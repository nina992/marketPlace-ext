(function(){"use strict";try{var o=document.createElement("style");o.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Roboto:wght@500&display=swap";body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}code{font-family:source-code-pro,Menlo,Monaco,Consolas,Courier New,monospace}nav,h1,p{padding:0;margin:0}')),document.head.appendChild(o)}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();


var extendStatics$1 = function(d2, b2) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics$1(d2, b2);
};
function __extends$1(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$1(d2, b2);
  function __2() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__2.prototype = b2.prototype, new __2());
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function __rest$G(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _24 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_24)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _24.label++;
            return { value: op[1], done: false };
          case 5:
            _24.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _24.ops.pop();
            _24.trys.pop();
            continue;
          default:
            if (!(t2 = _24.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _24 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _24.label = op[1];
              break;
            }
            if (op[0] === 6 && _24.label < t2[1]) {
              _24.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _24.label < t2[2]) {
              _24.label = t2[2];
              _24.ops.push(op);
              break;
            }
            if (t2[2])
              _24.ops.pop();
            _24.trys.pop();
            continue;
        }
        op = body.call(thisArg, _24);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to2, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar2; i < l2; i++) {
      if (ar2 || !(i in from2)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from2, 0, i);
        ar2[i] = from2[i];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from2));
}
var genericMessage = "Invariant Violation";
var _a$3 = Object.setPrototypeOf, setPrototypeOf = _a$3 === void 0 ? function(obj, proto) {
  obj.__proto__ = proto;
  return obj;
} : _a$3;
var InvariantError = function(_super) {
  __extends$1(InvariantError2, _super);
  function InvariantError2(message) {
    if (message === void 0) {
      message = genericMessage;
    }
    var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
    _this.framesToPop = 1;
    _this.name = genericMessage;
    setPrototypeOf(_this, InvariantError2.prototype);
    return _this;
  }
  return InvariantError2;
}(Error);
function invariant$1(condition, message) {
  if (!condition) {
    throw new InvariantError(message);
  }
}
var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
var verbosityLevel = verbosityLevels.indexOf("log");
function wrapConsoleMethod(name) {
  return function() {
    if (verbosityLevels.indexOf(name) >= verbosityLevel) {
      var method4 = console[name] || console.log;
      return method4.apply(console, arguments);
    }
  };
}
(function(invariant2) {
  invariant2.debug = wrapConsoleMethod("debug");
  invariant2.log = wrapConsoleMethod("log");
  invariant2.warn = wrapConsoleMethod("warn");
  invariant2.error = wrapConsoleMethod("error");
})(invariant$1 || (invariant$1 = {}));
function setVerbosity(level) {
  var old = verbosityLevels[verbosityLevel];
  verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
  return old;
}
function maybe$2(thunk) {
  try {
    return thunk();
  } catch (_a2) {
  }
}
var global$2 = maybe$2(function() {
  return globalThis;
}) || maybe$2(function() {
  return window;
}) || maybe$2(function() {
  return self;
}) || maybe$2(function() {
  return global;
}) || maybe$2(function() {
  return maybe$2.constructor("return this")();
});
var __ = "__";
var GLOBAL_KEY = [__, __].join("DEV");
function getDEV() {
  try {
    return Boolean(__DEV__);
  } catch (_a2) {
    Object.defineProperty(global$2, GLOBAL_KEY, {
      value: maybe$2(function() {
        return "production";
      }) !== "production",
      enumerable: false,
      configurable: true,
      writable: true
    });
    return global$2[GLOBAL_KEY];
  }
}
var DEV = getDEV();
function maybe$1(thunk) {
  try {
    return thunk();
  } catch (_24) {
  }
}
var safeGlobal = maybe$1(function() {
  return globalThis;
}) || maybe$1(function() {
  return window;
}) || maybe$1(function() {
  return self;
}) || maybe$1(function() {
  return global;
}) || maybe$1(function() {
  return maybe$1.constructor("return this")();
});
var needToRemove = false;
function install() {
  if (safeGlobal && !maybe$1(function() {
    return "production";
  }) && !maybe$1(function() {
    return process;
  })) {
    Object.defineProperty(safeGlobal, "process", {
      value: {
        env: {
          NODE_ENV: "production"
        }
      },
      configurable: true,
      enumerable: false,
      writable: true
    });
    needToRemove = true;
  }
}
install();
function remove() {
  if (needToRemove) {
    delete safeGlobal.process;
    needToRemove = false;
  }
}
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
function isObjectLike$5(value) {
  return typeof value == "object" && value !== null;
}
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}
const LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position2) {
  let lastLineStart = 0;
  let line2 = 1;
  for (const match2 of source.body.matchAll(LineRegExp)) {
    typeof match2.index === "number" || invariant(false);
    if (match2.index >= position2) {
      break;
    }
    lastLineStart = match2.index + match2[0].length;
    line2 += 1;
  }
  return {
    line: line2,
    column: position2 + 1 - lastLineStart
  };
}
function printLocation(location2) {
  return printSourceLocation(
    location2.source,
    getLocation(location2.source, location2.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_24, line2]) => line2 !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix2]) => prefix2.length));
  return existingLines.map(([prefix2, line2]) => prefix2.padStart(padLen) + (line2 ? " " + line2 : "")).join("\n");
}
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
class GraphQLError extends Error {
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref2;
    const { nodes, source, positions, path: path2, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path2 !== null && path2 !== void 0 ? path2 : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node2) => node2.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike$5(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref2 = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref2 !== void 0 ? _ref2 : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output2 = this.message;
    if (this.nodes) {
      for (const node2 of this.nodes) {
        if (node2.loc) {
          output2 += "\n\n" + printLocation(node2.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location2 of this.locations) {
        output2 += "\n\n" + printSourceLocation(this.source, location2);
      }
    }
    return output2;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
}
function undefinedIfEmpty(array4) {
  return array4 === void 0 || array4.length === 0 ? void 0 : array4;
}
function syntaxError(source, position2, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position2]
  });
}
class Location {
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class Token {
  constructor(kind, start, end, line2, column2, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line2;
    this.column = column2;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
const kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));
function isWhiteSpace(code2) {
  return code2 === 9 || code2 === 32;
}
function isDigit(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isLetter(code2) {
  return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
}
function isNameStart(code2) {
  return isLetter(code2) || code2 === 95;
}
function isNameContinue(code2) {
  return isLetter(code2) || isDigit(code2) || code2 === 95;
}
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0; i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line2 = lines[i];
    const indent2 = leadingWhitespace(line2);
    if (indent2 === line2.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line2, i) => i === 0 ? line2 : line2.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line2) => line2.length === 0 || isWhiteSpace(line2.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));
class Lexer {
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  advance() {
    this.lastToken = this.token;
    const token2 = this.token = this.lookahead();
    return token2;
  }
  lookahead() {
    let token2 = this.token;
    if (token2.kind !== TokenKind.EOF) {
      do {
        if (token2.next) {
          token2 = token2.next;
        } else {
          const nextToken = readNextToken(this, token2.end);
          token2.next = nextToken;
          nextToken.prev = token2;
          token2 = nextToken;
        }
      } while (token2.kind === TokenKind.COMMENT);
    }
    return token2;
  }
}
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code2) {
  return code2 >= 0 && code2 <= 55295 || code2 >= 57344 && code2 <= 1114111;
}
function isSupplementaryCodePoint(body, location2) {
  return isLeadingSurrogate(body.charCodeAt(location2)) && isTrailingSurrogate(body.charCodeAt(location2 + 1));
}
function isLeadingSurrogate(code2) {
  return code2 >= 55296 && code2 <= 56319;
}
function isTrailingSurrogate(code2) {
  return code2 >= 56320 && code2 <= 57343;
}
function printCodePointAt(lexer, location2) {
  const code2 = lexer.source.body.codePointAt(location2);
  if (code2 === void 0) {
    return TokenKind.EOF;
  } else if (code2 >= 32 && code2 <= 126) {
    const char2 = String.fromCodePoint(code2);
    return char2 === '"' ? `'"'` : `"${char2}"`;
  }
  return "U+" + code2.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line2 = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line2, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start;
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    switch (code2) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position2;
        continue;
      case 10:
        ++position2;
        ++lexer.line;
        lexer.lineStart = position2;
        continue;
      case 13:
        if (body.charCodeAt(position2 + 1) === 10) {
          position2 += 2;
        } else {
          ++position2;
        }
        ++lexer.line;
        lexer.lineStart = position2;
        continue;
      case 35:
        return readComment(lexer, position2);
      case 33:
        return createToken(lexer, TokenKind.BANG, position2, position2 + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position2, position2 + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position2, position2 + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position2, position2 + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position2, position2 + 1);
      case 46:
        if (body.charCodeAt(position2 + 1) === 46 && body.charCodeAt(position2 + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position2, position2 + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position2, position2 + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position2, position2 + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position2, position2 + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position2, position2 + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position2, position2 + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position2, position2 + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position2, position2 + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position2, position2 + 1);
      case 34:
        if (body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34) {
          return readBlockString(lexer, position2);
        }
        return readString(lexer, position2);
    }
    if (isDigit(code2) || code2 === 45) {
      return readNumber(lexer, position2, code2);
    }
    if (isNameStart(code2)) {
      return readName(lexer, position2);
    }
    throw syntaxError(
      lexer.source,
      position2,
      code2 === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code2) || isSupplementaryCodePoint(body, position2) ? `Unexpected character: ${printCodePointAt(lexer, position2)}.` : `Invalid character: ${printCodePointAt(lexer, position2)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start + 1;
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    if (code2 === 10 || code2 === 13) {
      break;
    }
    if (isUnicodeScalarValue(code2)) {
      ++position2;
    } else if (isSupplementaryCodePoint(body, position2)) {
      position2 += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position2,
    body.slice(start + 1, position2)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position2 = start;
  let code2 = firstCode;
  let isFloat = false;
  if (code2 === 45) {
    code2 = body.charCodeAt(++position2);
  }
  if (code2 === 48) {
    code2 = body.charCodeAt(++position2);
    if (isDigit(code2)) {
      throw syntaxError(
        lexer.source,
        position2,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position2
        )}.`
      );
    }
  } else {
    position2 = readDigits(lexer, position2, code2);
    code2 = body.charCodeAt(position2);
  }
  if (code2 === 46) {
    isFloat = true;
    code2 = body.charCodeAt(++position2);
    position2 = readDigits(lexer, position2, code2);
    code2 = body.charCodeAt(position2);
  }
  if (code2 === 69 || code2 === 101) {
    isFloat = true;
    code2 = body.charCodeAt(++position2);
    if (code2 === 43 || code2 === 45) {
      code2 = body.charCodeAt(++position2);
    }
    position2 = readDigits(lexer, position2, code2);
    code2 = body.charCodeAt(position2);
  }
  if (code2 === 46 || isNameStart(code2)) {
    throw syntaxError(
      lexer.source,
      position2,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position2
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position2,
    body.slice(start, position2)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position2 = start + 1;
  while (isDigit(body.charCodeAt(position2))) {
    ++position2;
  }
  return position2;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start + 1;
  let chunkStart = position2;
  let value = "";
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    if (code2 === 34) {
      value += body.slice(chunkStart, position2);
      return createToken(lexer, TokenKind.STRING, start, position2 + 1, value);
    }
    if (code2 === 92) {
      value += body.slice(chunkStart, position2);
      const escape2 = body.charCodeAt(position2 + 1) === 117 ? body.charCodeAt(position2 + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position2) : readEscapedUnicodeFixedWidth(lexer, position2) : readEscapedCharacter(lexer, position2);
      value += escape2.value;
      position2 += escape2.size;
      chunkStart = position2;
      continue;
    }
    if (code2 === 10 || code2 === 13) {
      break;
    }
    if (isUnicodeScalarValue(code2)) {
      ++position2;
    } else if (isSupplementaryCodePoint(body, position2)) {
      position2 += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position2,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position2
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position2, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position2) {
  const body = lexer.source.body;
  let point2 = 0;
  let size = 3;
  while (size < 12) {
    const code2 = body.charCodeAt(position2 + size++);
    if (code2 === 125) {
      if (size < 5 || !isUnicodeScalarValue(point2)) {
        break;
      }
      return {
        value: String.fromCodePoint(point2),
        size
      };
    }
    point2 = point2 << 4 | readHexDigit(code2);
    if (point2 < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position2,
    `Invalid Unicode escape sequence: "${body.slice(
      position2,
      position2 + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position2) {
  const body = lexer.source.body;
  const code2 = read16BitHexCode(body, position2 + 2);
  if (isUnicodeScalarValue(code2)) {
    return {
      value: String.fromCodePoint(code2),
      size: 6
    };
  }
  if (isLeadingSurrogate(code2)) {
    if (body.charCodeAt(position2 + 6) === 92 && body.charCodeAt(position2 + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position2 + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code2, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position2,
    `Invalid Unicode escape sequence: "${body.slice(position2, position2 + 6)}".`
  );
}
function read16BitHexCode(body, position2) {
  return readHexDigit(body.charCodeAt(position2)) << 12 | readHexDigit(body.charCodeAt(position2 + 1)) << 8 | readHexDigit(body.charCodeAt(position2 + 2)) << 4 | readHexDigit(body.charCodeAt(position2 + 3));
}
function readHexDigit(code2) {
  return code2 >= 48 && code2 <= 57 ? code2 - 48 : code2 >= 65 && code2 <= 70 ? code2 - 55 : code2 >= 97 && code2 <= 102 ? code2 - 87 : -1;
}
function readEscapedCharacter(lexer, position2) {
  const body = lexer.source.body;
  const code2 = body.charCodeAt(position2 + 1);
  switch (code2) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position2,
    `Invalid character escape sequence: "${body.slice(
      position2,
      position2 + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position2 = start + 3;
  let chunkStart = position2;
  let currentLine = "";
  const blockLines = [];
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    if (code2 === 34 && body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34) {
      currentLine += body.slice(chunkStart, position2);
      blockLines.push(currentLine);
      const token2 = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position2 + 3,
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token2;
    }
    if (code2 === 92 && body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34 && body.charCodeAt(position2 + 3) === 34) {
      currentLine += body.slice(chunkStart, position2);
      chunkStart = position2 + 1;
      position2 += 4;
      continue;
    }
    if (code2 === 10 || code2 === 13) {
      currentLine += body.slice(chunkStart, position2);
      blockLines.push(currentLine);
      if (code2 === 13 && body.charCodeAt(position2 + 1) === 10) {
        position2 += 2;
      } else {
        ++position2;
      }
      currentLine = "";
      chunkStart = position2;
      lineStart = position2;
      continue;
    }
    if (isUnicodeScalarValue(code2)) {
      ++position2;
    } else if (isSupplementaryCodePoint(body, position2)) {
      position2 += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position2,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position2
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position2, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start + 1;
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    if (isNameContinue(code2)) {
      ++position2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position2,
    body.slice(start, position2)
  );
}
const MAX_ARRAY_LENGTH = 10;
const MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object4, seenValues) {
  const entries = Object.entries(object4);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object4) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array4, seenValues) {
  if (array4.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array4.length);
  const remaining = array4.length - len;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array4[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object4) {
  const tag = Object.prototype.toString.call(object4).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object4.constructor === "function") {
    const name = object4.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
const instanceOf = function instanceOf2(value, constructor) {
  return value instanceof constructor;
};
class Source$2 {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function isSource(source) {
  return instanceOf(source, Source$2);
}
function parse$4(source, options) {
  const parser2 = new Parser(source, options);
  return parser2.parseDocument();
}
class Parser {
  constructor(source, options = {}) {
    const sourceObj = isSource(source) ? source : new Source$2(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  parseName() {
    const token2 = this.expectToken(TokenKind.NAME);
    return this.node(token2, {
      kind: Kind.NAME,
      value: token2.value
    });
  }
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias2;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias2 = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias: alias2,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  parseValueLiteral(isConst) {
    const token2 = this._lexer.token;
    switch (token2.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token2, {
          kind: Kind.INT,
          value: token2.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token2, {
          kind: Kind.FLOAT,
          value: token2.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token2.value) {
          case "true":
            return this.node(token2, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token2, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token2, {
              kind: Kind.NULL
            });
          default:
            return this.node(token2, {
              kind: Kind.ENUM,
              value: token2.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token2.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token2);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token2 = this._lexer.token;
    this.advanceLexer();
    return this.node(token2, {
      kind: Kind.STRING,
      value: token2.value,
      block: token2.kind === TokenKind.BLOCK_STRING
    });
  }
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  parseTypeReference() {
    const start = this._lexer.token;
    let type4;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type4 = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type4 = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type: type4
      });
    }
    return type4;
  }
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type4 = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type: type4
    });
  }
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type4 = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type: type4,
      directives
    });
  }
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type4 = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type: type4,
      defaultValue,
      directives
    });
  }
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types2 = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types: types2
    });
  }
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types2 = this.parseUnionMemberTypes();
    if (directives.length === 0 && types2.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types: types2
    });
  }
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  node(startToken, node2) {
    if (this._options.noLocation !== true) {
      node2.loc = new Location(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node2;
  }
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  expectToken(kind) {
    const token2 = this._lexer.token;
    if (token2.kind === kind) {
      this.advanceLexer();
      return token2;
    }
    throw syntaxError(
      this._lexer.source,
      token2.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token2)}.`
    );
  }
  expectOptionalToken(kind) {
    const token2 = this._lexer.token;
    if (token2.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  expectKeyword(value) {
    const token2 = this._lexer.token;
    if (token2.kind === TokenKind.NAME && token2.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token2.start,
        `Expected "${value}", found ${getTokenDesc(token2)}.`
      );
    }
  }
  expectOptionalKeyword(value) {
    const token2 = this._lexer.token;
    if (token2.kind === TokenKind.NAME && token2.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  unexpected(atToken) {
    const token2 = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token2.start,
      `Unexpected ${getTokenDesc(token2)}.`
    );
  }
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token2 = this._lexer.advance();
    if (maxTokens !== void 0 && token2.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token2.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
}
function getTokenDesc(token2) {
  const value = token2.value;
  return getTokenKindDesc(token2.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
const escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
const escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];
const BREAK = Object.freeze({});
function visit$2(root2, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root2);
  let keys2 = [root2];
  let index2 = -1;
  let edits = [];
  let node2 = root2;
  let key = void 0;
  let parent = void 0;
  const path2 = [];
  const ancestors = [];
  do {
    index2++;
    const isLeaving = index2 === keys2.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path2[path2.length - 1];
      node2 = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node2 = node2.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node2.splice(arrayKey, 1);
              editOffset++;
            } else {
              node2[arrayKey] = editValue;
            }
          }
        } else {
          node2 = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node2)
          );
          for (const [editKey, editValue] of edits) {
            node2[editKey] = editValue;
          }
        }
      }
      index2 = stack.index;
      keys2 = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index2 : keys2[index2];
      node2 = parent[key];
      if (node2 === null || node2 === void 0) {
        continue;
      }
      path2.push(key);
    }
    let result;
    if (!Array.isArray(node2)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node2) || devAssert(false, `Invalid AST Node: ${inspect(node2)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node2, key, parent, path2, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path2.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node2 = result;
          } else {
            path2.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node2]);
    }
    if (isLeaving) {
      path2.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index: index2,
        keys: keys2,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node2);
      keys2 = inArray ? node2 : (_node$kind = visitorKeys[node2.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index2 = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node2;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root2;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
function print(ast) {
  return visit$2(ast, printDocASTReducer);
}
const MAX_LINE_LENGTH = 80;
const printDocASTReducer = {
  Name: {
    leave: (node2) => node2.value
  },
  Variable: {
    leave: (node2) => "$" + node2.name
  },
  Document: {
    leave: (node2) => join$2(node2.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node2) {
      const varDefs = wrap$3("(", join$2(node2.variableDefinitions, ", "), ")");
      const prefix2 = join$2(
        [
          node2.operation,
          join$2([node2.name, varDefs]),
          join$2(node2.directives, " ")
        ],
        " "
      );
      return (prefix2 === "query" ? "" : prefix2 + " ") + node2.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type4, defaultValue, directives }) => variable + ": " + type4 + wrap$3(" = ", defaultValue) + wrap$3(" ", join$2(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias: alias2, name, arguments: args, directives, selectionSet }) {
      const prefix2 = wrap$3("", alias2, ": ") + name;
      let argsLine = prefix2 + wrap$3("(", join$2(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix2 + wrap$3("(\n", indent$1(join$2(args, "\n")), "\n)");
      }
      return join$2([argsLine, join$2(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap$3(" ", join$2(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join$2(
      [
        "...",
        wrap$3("on ", typeCondition),
        join$2(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap$3("(", join$2(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap$3("", join$2(directives, " "), " ")}` + selectionSet
  },
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join$2(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join$2(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap$3("(", join$2(args, ", "), ")")
  },
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type: type4 }) => "[" + type4 + "]"
  },
  NonNullType: {
    leave: ({ type: type4 }) => type4 + "!"
  },
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap$3("", description, "\n") + join$2(["schema", join$2(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type4 }) => operation + ": " + type4
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap$3("", description, "\n") + join$2(["scalar", name, join$2(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap$3("", description, "\n") + join$2(
      [
        "type",
        name,
        wrap$3("implements ", join$2(interfaces, " & ")),
        join$2(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type: type4, directives }) => wrap$3("", description, "\n") + name + (hasMultilineItems(args) ? wrap$3("(\n", indent$1(join$2(args, "\n")), "\n)") : wrap$3("(", join$2(args, ", "), ")")) + ": " + type4 + wrap$3(" ", join$2(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type: type4, defaultValue, directives }) => wrap$3("", description, "\n") + join$2(
      [name + ": " + type4, wrap$3("= ", defaultValue), join$2(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap$3("", description, "\n") + join$2(
      [
        "interface",
        name,
        wrap$3("implements ", join$2(interfaces, " & ")),
        join$2(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types: types2 }) => wrap$3("", description, "\n") + join$2(
      ["union", name, join$2(directives, " "), wrap$3("= ", join$2(types2, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap$3("", description, "\n") + join$2(["enum", name, join$2(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap$3("", description, "\n") + join$2([name, join$2(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap$3("", description, "\n") + join$2(["input", name, join$2(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap$3("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap$3("(\n", indent$1(join$2(args, "\n")), "\n)") : wrap$3("(", join$2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join$2(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join$2(
      ["extend schema", join$2(directives, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join$2(["extend scalar", name, join$2(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join$2(
      [
        "extend type",
        name,
        wrap$3("implements ", join$2(interfaces, " & ")),
        join$2(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join$2(
      [
        "extend interface",
        name,
        wrap$3("implements ", join$2(interfaces, " & ")),
        join$2(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types: types2 }) => join$2(
      [
        "extend union",
        name,
        join$2(directives, " "),
        wrap$3("= ", join$2(types2, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join$2(["extend enum", name, join$2(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join$2(["extend input", name, join$2(directives, " "), block(fields)], " ")
  }
};
function join$2(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x2) => x2).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array4) {
  return wrap$3("{\n", indent$1(join$2(array4, "\n")), "\n}");
}
function wrap$3(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent$1(str) {
  return wrap$3("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
function removeTemporaryGlobals() {
  return typeof Source$2 === "function" ? remove() : remove();
}
function checkDEV() {
  __DEV__ ? invariant$1("boolean" === typeof DEV, DEV) : invariant$1("boolean" === typeof DEV, 38);
}
removeTemporaryGlobals();
checkDEV();
function shouldInclude(_a2, variables) {
  var directives = _a2.directives;
  if (!directives || !directives.length) {
    return true;
  }
  return getInclusionDirectives(directives).every(function(_a3) {
    var directive = _a3.directive, ifArgument = _a3.ifArgument;
    var evaledValue = false;
    if (ifArgument.value.kind === "Variable") {
      evaledValue = variables && variables[ifArgument.value.name.value];
      __DEV__ ? invariant$1(evaledValue !== void 0, "Invalid variable referenced in @".concat(directive.name.value, " directive.")) : invariant$1(evaledValue !== void 0, 39);
    } else {
      evaledValue = ifArgument.value.value;
    }
    return directive.name.value === "skip" ? !evaledValue : evaledValue;
  });
}
function hasDirectives(names2, root2, all2) {
  var nameSet = new Set(names2);
  var uniqueCount = nameSet.size;
  visit$2(root2, {
    Directive: function(node2) {
      if (nameSet.delete(node2.name.value) && (!all2 || !nameSet.size)) {
        return BREAK;
      }
    }
  });
  return all2 ? !nameSet.size : nameSet.size < uniqueCount;
}
function hasClientExports(document2) {
  return document2 && hasDirectives(["client", "export"], document2, true);
}
function isInclusionDirective(_a2) {
  var value = _a2.name.value;
  return value === "skip" || value === "include";
}
function getInclusionDirectives(directives) {
  var result = [];
  if (directives && directives.length) {
    directives.forEach(function(directive) {
      if (!isInclusionDirective(directive))
        return;
      var directiveArguments = directive.arguments;
      var directiveName = directive.name.value;
      __DEV__ ? invariant$1(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @".concat(directiveName, " directive.")) : invariant$1(directiveArguments && directiveArguments.length === 1, 40);
      var ifArgument = directiveArguments[0];
      __DEV__ ? invariant$1(ifArgument.name && ifArgument.name.value === "if", "Invalid argument for the @".concat(directiveName, " directive.")) : invariant$1(ifArgument.name && ifArgument.name.value === "if", 41);
      var ifValue = ifArgument.value;
      __DEV__ ? invariant$1(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), "Argument for the @".concat(directiveName, " directive must be a variable or a boolean value.")) : invariant$1(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 42);
      result.push({ directive, ifArgument });
    });
  }
  return result;
}
function getFragmentQueryDocument(document2, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document2.definitions.forEach(function(definition2) {
    if (definition2.kind === "OperationDefinition") {
      throw __DEV__ ? new InvariantError("Found a ".concat(definition2.operation, " operation").concat(definition2.name ? " named '".concat(definition2.name.value, "'") : "", ". ") + "No operations are allowed when using a fragment as a query. Only fragments are allowed.") : new InvariantError(43);
    }
    if (definition2.kind === "FragmentDefinition") {
      fragments.push(definition2);
    }
  });
  if (typeof actualFragmentName === "undefined") {
    __DEV__ ? invariant$1(fragments.length === 1, "Found ".concat(fragments.length, " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.")) : invariant$1(fragments.length === 1, 44);
    actualFragmentName = fragments[0].name.value;
  }
  var query = __assign$1(__assign$1({}, document2), { definitions: __spreadArray([
    {
      kind: "OperationDefinition",
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: actualFragmentName
            }
          }
        ]
      }
    }
  ], document2.definitions, true) });
  return query;
}
function createFragmentMap(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }
  var symTable = {};
  fragments.forEach(function(fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}
function getFragmentFromSelection(selection, fragmentMap) {
  switch (selection.kind) {
    case "InlineFragment":
      return selection;
    case "FragmentSpread": {
      var fragmentName = selection.name.value;
      if (typeof fragmentMap === "function") {
        return fragmentMap(fragmentName);
      }
      var fragment = fragmentMap && fragmentMap[fragmentName];
      __DEV__ ? invariant$1(fragment, "No fragment named ".concat(fragmentName)) : invariant$1(fragment, 45);
      return fragment || null;
    }
    default:
      return null;
  }
}
function isNonNullObject(obj) {
  return obj !== null && typeof obj === "object";
}
function makeReference(id) {
  return { __ref: String(id) };
}
function isReference(obj) {
  return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
}
function isDocumentNode(value) {
  return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
}
function isStringValue(value) {
  return value.kind === "StringValue";
}
function isBooleanValue(value) {
  return value.kind === "BooleanValue";
}
function isIntValue(value) {
  return value.kind === "IntValue";
}
function isFloatValue(value) {
  return value.kind === "FloatValue";
}
function isVariable(value) {
  return value.kind === "Variable";
}
function isObjectValue(value) {
  return value.kind === "ObjectValue";
}
function isListValue(value) {
  return value.kind === "ListValue";
}
function isEnumValue(value) {
  return value.kind === "EnumValue";
}
function isNullValue(value) {
  return value.kind === "NullValue";
}
function valueToObjectRepresentation(argObj, name, value, variables) {
  if (isIntValue(value) || isFloatValue(value)) {
    argObj[name.value] = Number(value.value);
  } else if (isBooleanValue(value) || isStringValue(value)) {
    argObj[name.value] = value.value;
  } else if (isObjectValue(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function(obj) {
      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name.value] = nestedArgObj_1;
  } else if (isVariable(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name.value] = variableValue;
  } else if (isListValue(value)) {
    argObj[name.value] = value.values.map(function(listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
      return nestedArgArrayObj[name.value];
    });
  } else if (isEnumValue(value)) {
    argObj[name.value] = value.value;
  } else if (isNullValue(value)) {
    argObj[name.value] = null;
  } else {
    throw __DEV__ ? new InvariantError('The inline argument "'.concat(name.value, '" of kind "').concat(value.kind, '"') + "is not supported. Use variables instead of inline arguments to overcome this limitation.") : new InvariantError(54);
  }
}
function storeKeyNameFromField(field, variables) {
  var directivesObj = null;
  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function(directive) {
      directivesObj[directive.name.value] = {};
      if (directive.arguments) {
        directive.arguments.forEach(function(_a2) {
          var name = _a2.name, value = _a2.value;
          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
        });
      }
    });
  }
  var argObj = null;
  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function(_a2) {
      var name = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj, name, value, variables);
    });
  }
  return getStoreKeyName(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export"
];
var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
  if (args && directives && directives["connection"] && directives["connection"]["key"]) {
    if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
      var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
      filterKeys.sort();
      var filteredArgs_1 = {};
      filterKeys.forEach(function(key) {
        filteredArgs_1[key] = args[key];
      });
      return "".concat(directives["connection"]["key"], "(").concat(stringify$6(filteredArgs_1), ")");
    } else {
      return directives["connection"]["key"];
    }
  }
  var completeFieldName = fieldName;
  if (args) {
    var stringifiedArgs = stringify$6(args);
    completeFieldName += "(".concat(stringifiedArgs, ")");
  }
  if (directives) {
    Object.keys(directives).forEach(function(key) {
      if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
        return;
      if (directives[key] && Object.keys(directives[key]).length) {
        completeFieldName += "@".concat(key, "(").concat(stringify$6(directives[key]), ")");
      } else {
        completeFieldName += "@".concat(key);
      }
    });
  }
  return completeFieldName;
}, {
  setStringify: function(s2) {
    var previous2 = stringify$6;
    stringify$6 = s2;
    return previous2;
  }
});
var stringify$6 = function defaultStringify(value) {
  return JSON.stringify(value, stringifyReplacer);
};
function stringifyReplacer(_key, value) {
  if (isNonNullObject(value) && !Array.isArray(value)) {
    value = Object.keys(value).sort().reduce(function(copy2, key) {
      copy2[key] = value[key];
      return copy2;
    }, {});
  }
  return value;
}
function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function(_a2) {
      var name = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj_1, name, value, variables);
    });
    return argObj_1;
  }
  return null;
}
function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}
function getTypenameFromResult(result, selectionSet, fragmentMap) {
  if (typeof result.__typename === "string") {
    return result.__typename;
  }
  for (var _i2 = 0, _a2 = selectionSet.selections; _i2 < _a2.length; _i2++) {
    var selection = _a2[_i2];
    if (isField(selection)) {
      if (selection.name.value === "__typename") {
        return result[resultKeyNameFromField(selection)];
      }
    } else {
      var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
      if (typeof typename === "string") {
        return typename;
      }
    }
  }
}
function isField(selection) {
  return selection.kind === "Field";
}
function isInlineFragment(selection) {
  return selection.kind === "InlineFragment";
}
function checkDocument(doc) {
  __DEV__ ? invariant$1(doc && doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : invariant$1(doc && doc.kind === "Document", 46);
  var operations = doc.definitions.filter(function(d2) {
    return d2.kind !== "FragmentDefinition";
  }).map(function(definition2) {
    if (definition2.kind !== "OperationDefinition") {
      throw __DEV__ ? new InvariantError('Schema type definitions not allowed in queries. Found: "'.concat(definition2.kind, '"')) : new InvariantError(47);
    }
    return definition2;
  });
  __DEV__ ? invariant$1(operations.length <= 1, "Ambiguous GraphQL document: contains ".concat(operations.length, " operations")) : invariant$1(operations.length <= 1, 48);
  return doc;
}
function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter(function(definition2) {
    return definition2.kind === "OperationDefinition";
  })[0];
}
function getOperationName(doc) {
  return doc.definitions.filter(function(definition2) {
    return definition2.kind === "OperationDefinition" && definition2.name;
  }).map(function(x2) {
    return x2.name.value;
  })[0] || null;
}
function getFragmentDefinitions(doc) {
  return doc.definitions.filter(function(definition2) {
    return definition2.kind === "FragmentDefinition";
  });
}
function getQueryDefinition(doc) {
  var queryDef = getOperationDefinition(doc);
  __DEV__ ? invariant$1(queryDef && queryDef.operation === "query", "Must contain a query definition.") : invariant$1(queryDef && queryDef.operation === "query", 49);
  return queryDef;
}
function getFragmentDefinition(doc) {
  __DEV__ ? invariant$1(doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : invariant$1(doc.kind === "Document", 50);
  __DEV__ ? invariant$1(doc.definitions.length <= 1, "Fragment must have exactly one definition.") : invariant$1(doc.definitions.length <= 1, 51);
  var fragmentDef = doc.definitions[0];
  __DEV__ ? invariant$1(fragmentDef.kind === "FragmentDefinition", "Must be a fragment definition.") : invariant$1(fragmentDef.kind === "FragmentDefinition", 52);
  return fragmentDef;
}
function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  var fragmentDefinition;
  for (var _i2 = 0, _a2 = queryDoc.definitions; _i2 < _a2.length; _i2++) {
    var definition2 = _a2[_i2];
    if (definition2.kind === "OperationDefinition") {
      var operation = definition2.operation;
      if (operation === "query" || operation === "mutation" || operation === "subscription") {
        return definition2;
      }
    }
    if (definition2.kind === "FragmentDefinition" && !fragmentDefinition) {
      fragmentDefinition = definition2;
    }
  }
  if (fragmentDefinition) {
    return fragmentDefinition;
  }
  throw __DEV__ ? new InvariantError("Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.") : new InvariantError(53);
}
function getDefaultValues(definition2) {
  var defaultValues = /* @__PURE__ */ Object.create(null);
  var defs = definition2 && definition2.variableDefinitions;
  if (defs && defs.length) {
    defs.forEach(function(def) {
      if (def.defaultValue) {
        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
      }
    });
  }
  return defaultValues;
}
function filterInPlace(array4, test, context2) {
  var target = 0;
  array4.forEach(function(elem, i) {
    if (test.call(this, elem, i, array4)) {
      array4[target++] = elem;
    }
  }, context2);
  array4.length = target;
  return array4;
}
var TYPENAME_FIELD = {
  kind: "Field",
  name: {
    kind: "Name",
    value: "__typename"
  }
};
function isEmpty(op, fragmentMap) {
  return !op || op.selectionSet.selections.every(function(selection) {
    return selection.kind === "FragmentSpread" && isEmpty(fragmentMap[selection.name.value], fragmentMap);
  });
}
function nullIfDocIsEmpty(doc) {
  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
}
function getDirectiveMatcher(directives) {
  return function directiveMatcher(directive) {
    return directives.some(function(dir) {
      return dir.name && dir.name === directive.name.value || dir.test && dir.test(directive);
    });
  };
}
function removeDirectivesFromDocument(directives, doc) {
  var variablesInUse = /* @__PURE__ */ Object.create(null);
  var variablesToRemove = [];
  var fragmentSpreadsInUse = /* @__PURE__ */ Object.create(null);
  var fragmentSpreadsToRemove = [];
  var modifiedDoc = nullIfDocIsEmpty(visit$2(doc, {
    Variable: {
      enter: function(node2, _key, parent) {
        if (parent.kind !== "VariableDefinition") {
          variablesInUse[node2.name.value] = true;
        }
      }
    },
    Field: {
      enter: function(node2) {
        if (directives && node2.directives) {
          var shouldRemoveField = directives.some(function(directive) {
            return directive.remove;
          });
          if (shouldRemoveField && node2.directives && node2.directives.some(getDirectiveMatcher(directives))) {
            if (node2.arguments) {
              node2.arguments.forEach(function(arg) {
                if (arg.value.kind === "Variable") {
                  variablesToRemove.push({
                    name: arg.value.name.value
                  });
                }
              });
            }
            if (node2.selectionSet) {
              getAllFragmentSpreadsFromSelectionSet(node2.selectionSet).forEach(function(frag) {
                fragmentSpreadsToRemove.push({
                  name: frag.name.value
                });
              });
            }
            return null;
          }
        }
      }
    },
    FragmentSpread: {
      enter: function(node2) {
        fragmentSpreadsInUse[node2.name.value] = true;
      }
    },
    Directive: {
      enter: function(node2) {
        if (getDirectiveMatcher(directives)(node2)) {
          return null;
        }
      }
    }
  }));
  if (modifiedDoc && filterInPlace(variablesToRemove, function(v2) {
    return !!v2.name && !variablesInUse[v2.name];
  }).length) {
    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
  }
  if (modifiedDoc && filterInPlace(fragmentSpreadsToRemove, function(fs) {
    return !!fs.name && !fragmentSpreadsInUse[fs.name];
  }).length) {
    modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
  }
  return modifiedDoc;
}
var addTypenameToDocument = Object.assign(function(doc) {
  return visit$2(doc, {
    SelectionSet: {
      enter: function(node2, _key, parent) {
        if (parent && parent.kind === "OperationDefinition") {
          return;
        }
        var selections = node2.selections;
        if (!selections) {
          return;
        }
        var skip = selections.some(function(selection) {
          return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
        });
        if (skip) {
          return;
        }
        var field = parent;
        if (isField(field) && field.directives && field.directives.some(function(d2) {
          return d2.name.value === "export";
        })) {
          return;
        }
        return __assign$1(__assign$1({}, node2), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });
      }
    }
  });
}, {
  added: function(field) {
    return field === TYPENAME_FIELD;
  }
});
var connectionRemoveConfig = {
  test: function(directive) {
    var willRemove = directive.name.value === "connection";
    if (willRemove) {
      if (!directive.arguments || !directive.arguments.some(function(arg) {
        return arg.name.value === "key";
      })) {
        __DEV__ && invariant$1.warn("Removing an @connection directive even though it does not have a key. You may want to use the key parameter to specify a store key.");
      }
    }
    return willRemove;
  }
};
function removeConnectionDirectiveFromDocument(doc) {
  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
}
function getArgumentMatcher(config) {
  return function argumentMatcher(argument) {
    return config.some(function(aConfig) {
      return argument.value && argument.value.kind === "Variable" && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
    });
  };
}
function removeArgumentsFromDocument(config, doc) {
  var argMatcher = getArgumentMatcher(config);
  return nullIfDocIsEmpty(visit$2(doc, {
    OperationDefinition: {
      enter: function(node2) {
        return __assign$1(__assign$1({}, node2), { variableDefinitions: node2.variableDefinitions ? node2.variableDefinitions.filter(function(varDef) {
          return !config.some(function(arg) {
            return arg.name === varDef.variable.name.value;
          });
        }) : [] });
      }
    },
    Field: {
      enter: function(node2) {
        var shouldRemoveField = config.some(function(argConfig) {
          return argConfig.remove;
        });
        if (shouldRemoveField) {
          var argMatchCount_1 = 0;
          if (node2.arguments) {
            node2.arguments.forEach(function(arg) {
              if (argMatcher(arg)) {
                argMatchCount_1 += 1;
              }
            });
          }
          if (argMatchCount_1 === 1) {
            return null;
          }
        }
      }
    },
    Argument: {
      enter: function(node2) {
        if (argMatcher(node2)) {
          return null;
        }
      }
    }
  }));
}
function removeFragmentSpreadFromDocument(config, doc) {
  function enter(node2) {
    if (config.some(function(def) {
      return def.name === node2.name.value;
    })) {
      return null;
    }
  }
  return nullIfDocIsEmpty(visit$2(doc, {
    FragmentSpread: { enter },
    FragmentDefinition: { enter }
  }));
}
function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
  var allFragments = [];
  selectionSet.selections.forEach(function(selection) {
    if ((isField(selection) || isInlineFragment(selection)) && selection.selectionSet) {
      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function(frag) {
        return allFragments.push(frag);
      });
    } else if (selection.kind === "FragmentSpread") {
      allFragments.push(selection);
    }
  });
  return allFragments;
}
function buildQueryFromSelectionSet(document2) {
  var definition2 = getMainDefinition(document2);
  var definitionOperation = definition2.operation;
  if (definitionOperation === "query") {
    return document2;
  }
  var modifiedDoc = visit$2(document2, {
    OperationDefinition: {
      enter: function(node2) {
        return __assign$1(__assign$1({}, node2), { operation: "query" });
      }
    }
  });
  return modifiedDoc;
}
function removeClientSetsFromDocument(document2) {
  checkDocument(document2);
  var modifiedDoc = removeDirectivesFromDocument([
    {
      test: function(directive) {
        return directive.name.value === "client";
      },
      remove: true
    }
  ], document2);
  if (modifiedDoc) {
    modifiedDoc = visit$2(modifiedDoc, {
      FragmentDefinition: {
        enter: function(node2) {
          if (node2.selectionSet) {
            var isTypenameOnly = node2.selectionSet.selections.every(function(selection) {
              return isField(selection) && selection.name.value === "__typename";
            });
            if (isTypenameOnly) {
              return null;
            }
          }
        }
      }
    });
  }
  return modifiedDoc;
}
var hasOwnProperty$g = Object.prototype.hasOwnProperty;
function mergeDeep() {
  var sources = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    sources[_i2] = arguments[_i2];
  }
  return mergeDeepArray(sources);
}
function mergeDeepArray(sources) {
  var target = sources[0] || {};
  var count = sources.length;
  if (count > 1) {
    var merger = new DeepMerger();
    for (var i = 1; i < count; ++i) {
      target = merger.merge(target, sources[i]);
    }
  }
  return target;
}
var defaultReconciler = function(target, source, property) {
  return this.merge(target[property], source[property]);
};
var DeepMerger = function() {
  function DeepMerger2(reconciler) {
    if (reconciler === void 0) {
      reconciler = defaultReconciler;
    }
    this.reconciler = reconciler;
    this.isObject = isNonNullObject;
    this.pastCopies = /* @__PURE__ */ new Set();
  }
  DeepMerger2.prototype.merge = function(target, source) {
    var _this = this;
    var context2 = [];
    for (var _i2 = 2; _i2 < arguments.length; _i2++) {
      context2[_i2 - 2] = arguments[_i2];
    }
    if (isNonNullObject(source) && isNonNullObject(target)) {
      Object.keys(source).forEach(function(sourceKey) {
        if (hasOwnProperty$g.call(target, sourceKey)) {
          var targetValue = target[sourceKey];
          if (source[sourceKey] !== targetValue) {
            var result = _this.reconciler.apply(_this, __spreadArray([target, source, sourceKey], context2, false));
            if (result !== targetValue) {
              target = _this.shallowCopyForMerge(target);
              target[sourceKey] = result;
            }
          }
        } else {
          target = _this.shallowCopyForMerge(target);
          target[sourceKey] = source[sourceKey];
        }
      });
      return target;
    }
    return source;
  };
  DeepMerger2.prototype.shallowCopyForMerge = function(value) {
    if (isNonNullObject(value)) {
      if (!this.pastCopies.has(value)) {
        if (Array.isArray(value)) {
          value = value.slice(0);
        } else {
          value = __assign$1({ __proto__: Object.getPrototypeOf(value) }, value);
        }
        this.pastCopies.add(value);
      }
    }
    return value;
  };
  return DeepMerger2;
}();
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it2)
    return (it2 = it2.call(o)).next.bind(it2);
  if (Array.isArray(o) || (it2 = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it2)
      o = it2;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$3(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr2, len) {
  if (len == null || len > arr2.length)
    len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++) {
    arr22[i] = arr2[i];
  }
  return arr22;
}
function _defineProperties$4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var hasSymbols = function() {
  return typeof Symbol === "function";
};
var hasSymbol = function(name) {
  return hasSymbols() && Boolean(Symbol[name]);
};
var getSymbol = function(name) {
  return hasSymbol(name) ? Symbol[name] : "@@" + name;
};
if (hasSymbols() && !hasSymbol("observable")) {
  Symbol.observable = Symbol("observable");
}
var SymbolIterator = getSymbol("iterator");
var SymbolObservable = getSymbol("observable");
var SymbolSpecies = getSymbol("species");
function getMethod(obj, key) {
  var value = obj[key];
  if (value == null)
    return void 0;
  if (typeof value !== "function")
    throw new TypeError(value + " is not a function");
  return value;
}
function getSpecies(obj) {
  var ctor = obj.constructor;
  if (ctor !== void 0) {
    ctor = ctor[SymbolSpecies];
    if (ctor === null) {
      ctor = void 0;
    }
  }
  return ctor !== void 0 ? ctor : Observable$1;
}
function isObservable(x2) {
  return x2 instanceof Observable$1;
}
function hostReportError(e2) {
  if (hostReportError.log) {
    hostReportError.log(e2);
  } else {
    setTimeout(function() {
      throw e2;
    });
  }
}
function enqueue(fn2) {
  Promise.resolve().then(function() {
    try {
      fn2();
    } catch (e2) {
      hostReportError(e2);
    }
  });
}
function cleanupSubscription(subscription) {
  var cleanup2 = subscription._cleanup;
  if (cleanup2 === void 0)
    return;
  subscription._cleanup = void 0;
  if (!cleanup2) {
    return;
  }
  try {
    if (typeof cleanup2 === "function") {
      cleanup2();
    } else {
      var unsubscribe = getMethod(cleanup2, "unsubscribe");
      if (unsubscribe) {
        unsubscribe.call(cleanup2);
      }
    }
  } catch (e2) {
    hostReportError(e2);
  }
}
function closeSubscription(subscription) {
  subscription._observer = void 0;
  subscription._queue = void 0;
  subscription._state = "closed";
}
function flushSubscription(subscription) {
  var queue = subscription._queue;
  if (!queue) {
    return;
  }
  subscription._queue = void 0;
  subscription._state = "ready";
  for (var i = 0; i < queue.length; ++i) {
    notifySubscription(subscription, queue[i].type, queue[i].value);
    if (subscription._state === "closed")
      break;
  }
}
function notifySubscription(subscription, type4, value) {
  subscription._state = "running";
  var observer = subscription._observer;
  try {
    var m2 = getMethod(observer, type4);
    switch (type4) {
      case "next":
        if (m2)
          m2.call(observer, value);
        break;
      case "error":
        closeSubscription(subscription);
        if (m2)
          m2.call(observer, value);
        else
          throw value;
        break;
      case "complete":
        closeSubscription(subscription);
        if (m2)
          m2.call(observer);
        break;
    }
  } catch (e2) {
    hostReportError(e2);
  }
  if (subscription._state === "closed")
    cleanupSubscription(subscription);
  else if (subscription._state === "running")
    subscription._state = "ready";
}
function onNotify(subscription, type4, value) {
  if (subscription._state === "closed")
    return;
  if (subscription._state === "buffering") {
    subscription._queue.push({
      type: type4,
      value
    });
    return;
  }
  if (subscription._state !== "ready") {
    subscription._state = "buffering";
    subscription._queue = [{
      type: type4,
      value
    }];
    enqueue(function() {
      return flushSubscription(subscription);
    });
    return;
  }
  notifySubscription(subscription, type4, value);
}
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(observer, subscriber) {
    this._cleanup = void 0;
    this._observer = observer;
    this._queue = void 0;
    this._state = "initializing";
    var subscriptionObserver = new SubscriptionObserver(this);
    try {
      this._cleanup = subscriber.call(void 0, subscriptionObserver);
    } catch (e2) {
      subscriptionObserver.error(e2);
    }
    if (this._state === "initializing")
      this._state = "ready";
  }
  var _proto = Subscription2.prototype;
  _proto.unsubscribe = function unsubscribe() {
    if (this._state !== "closed") {
      closeSubscription(this);
      cleanupSubscription(this);
    }
  };
  _createClass$4(Subscription2, [{
    key: "closed",
    get: function() {
      return this._state === "closed";
    }
  }]);
  return Subscription2;
}();
var SubscriptionObserver = /* @__PURE__ */ function() {
  function SubscriptionObserver2(subscription) {
    this._subscription = subscription;
  }
  var _proto2 = SubscriptionObserver2.prototype;
  _proto2.next = function next2(value) {
    onNotify(this._subscription, "next", value);
  };
  _proto2.error = function error3(value) {
    onNotify(this._subscription, "error", value);
  };
  _proto2.complete = function complete() {
    onNotify(this._subscription, "complete");
  };
  _createClass$4(SubscriptionObserver2, [{
    key: "closed",
    get: function() {
      return this._subscription._state === "closed";
    }
  }]);
  return SubscriptionObserver2;
}();
var Observable$1 = /* @__PURE__ */ function() {
  function Observable2(subscriber) {
    if (!(this instanceof Observable2))
      throw new TypeError("Observable cannot be called as a function");
    if (typeof subscriber !== "function")
      throw new TypeError("Observable initializer must be a function");
    this._subscriber = subscriber;
  }
  var _proto3 = Observable2.prototype;
  _proto3.subscribe = function subscribe(observer) {
    if (typeof observer !== "object" || observer === null) {
      observer = {
        next: observer,
        error: arguments[1],
        complete: arguments[2]
      };
    }
    return new Subscription(observer, this._subscriber);
  };
  _proto3.forEach = function forEach2(fn2) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      if (typeof fn2 !== "function") {
        reject(new TypeError(fn2 + " is not a function"));
        return;
      }
      function done() {
        subscription.unsubscribe();
        resolve();
      }
      var subscription = _this.subscribe({
        next: function(value) {
          try {
            fn2(value, done);
          } catch (e2) {
            reject(e2);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  };
  _proto3.map = function map(fn2) {
    var _this2 = this;
    if (typeof fn2 !== "function")
      throw new TypeError(fn2 + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      return _this2.subscribe({
        next: function(value) {
          try {
            value = fn2(value);
          } catch (e2) {
            return observer.error(e2);
          }
          observer.next(value);
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.filter = function filter2(fn2) {
    var _this3 = this;
    if (typeof fn2 !== "function")
      throw new TypeError(fn2 + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      return _this3.subscribe({
        next: function(value) {
          try {
            if (!fn2(value))
              return;
          } catch (e2) {
            return observer.error(e2);
          }
          observer.next(value);
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.reduce = function reduce(fn2) {
    var _this4 = this;
    if (typeof fn2 !== "function")
      throw new TypeError(fn2 + " is not a function");
    var C2 = getSpecies(this);
    var hasSeed = arguments.length > 1;
    var hasValue2 = false;
    var seed2 = arguments[1];
    var acc = seed2;
    return new C2(function(observer) {
      return _this4.subscribe({
        next: function(value) {
          var first = !hasValue2;
          hasValue2 = true;
          if (!first || hasSeed) {
            try {
              acc = fn2(acc, value);
            } catch (e2) {
              return observer.error(e2);
            }
          } else {
            acc = value;
          }
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          if (!hasValue2 && !hasSeed)
            return observer.error(new TypeError("Cannot reduce an empty sequence"));
          observer.next(acc);
          observer.complete();
        }
      });
    });
  };
  _proto3.concat = function concat2() {
    var _this5 = this;
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      var subscription;
      var index2 = 0;
      function startNext(next2) {
        subscription = next2.subscribe({
          next: function(v2) {
            observer.next(v2);
          },
          error: function(e2) {
            observer.error(e2);
          },
          complete: function() {
            if (index2 === sources.length) {
              subscription = void 0;
              observer.complete();
            } else {
              startNext(C2.from(sources[index2++]));
            }
          }
        });
      }
      startNext(_this5);
      return function() {
        if (subscription) {
          subscription.unsubscribe();
          subscription = void 0;
        }
      };
    });
  };
  _proto3.flatMap = function flatMap(fn2) {
    var _this6 = this;
    if (typeof fn2 !== "function")
      throw new TypeError(fn2 + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      var subscriptions = [];
      var outer = _this6.subscribe({
        next: function(value) {
          if (fn2) {
            try {
              value = fn2(value);
            } catch (e2) {
              return observer.error(e2);
            }
          }
          var inner = C2.from(value).subscribe({
            next: function(value2) {
              observer.next(value2);
            },
            error: function(e2) {
              observer.error(e2);
            },
            complete: function() {
              var i = subscriptions.indexOf(inner);
              if (i >= 0)
                subscriptions.splice(i, 1);
              completeIfDone();
            }
          });
          subscriptions.push(inner);
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          completeIfDone();
        }
      });
      function completeIfDone() {
        if (outer.closed && subscriptions.length === 0)
          observer.complete();
      }
      return function() {
        subscriptions.forEach(function(s2) {
          return s2.unsubscribe();
        });
        outer.unsubscribe();
      };
    });
  };
  _proto3[SymbolObservable] = function() {
    return this;
  };
  Observable2.from = function from2(x2) {
    var C2 = typeof this === "function" ? this : Observable2;
    if (x2 == null)
      throw new TypeError(x2 + " is not an object");
    var method4 = getMethod(x2, SymbolObservable);
    if (method4) {
      var observable = method4.call(x2);
      if (Object(observable) !== observable)
        throw new TypeError(observable + " is not an object");
      if (isObservable(observable) && observable.constructor === C2)
        return observable;
      return new C2(function(observer) {
        return observable.subscribe(observer);
      });
    }
    if (hasSymbol("iterator")) {
      method4 = getMethod(x2, SymbolIterator);
      if (method4) {
        return new C2(function(observer) {
          enqueue(function() {
            if (observer.closed)
              return;
            for (var _iterator = _createForOfIteratorHelperLoose(method4.call(x2)), _step; !(_step = _iterator()).done; ) {
              var item = _step.value;
              observer.next(item);
              if (observer.closed)
                return;
            }
            observer.complete();
          });
        });
      }
    }
    if (Array.isArray(x2)) {
      return new C2(function(observer) {
        enqueue(function() {
          if (observer.closed)
            return;
          for (var i = 0; i < x2.length; ++i) {
            observer.next(x2[i]);
            if (observer.closed)
              return;
          }
          observer.complete();
        });
      });
    }
    throw new TypeError(x2 + " is not observable");
  };
  Observable2.of = function of() {
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    var C2 = typeof this === "function" ? this : Observable2;
    return new C2(function(observer) {
      enqueue(function() {
        if (observer.closed)
          return;
        for (var i = 0; i < items.length; ++i) {
          observer.next(items[i]);
          if (observer.closed)
            return;
        }
        observer.complete();
      });
    });
  };
  _createClass$4(Observable2, null, [{
    key: SymbolSpecies,
    get: function() {
      return this;
    }
  }]);
  return Observable2;
}();
if (hasSymbols()) {
  Object.defineProperty(Observable$1, Symbol("extensions"), {
    value: {
      symbol: SymbolObservable,
      hostReportError
    },
    configurable: true
  });
}
function symbolObservablePonyfill(root2) {
  var result;
  var Symbol2 = root2.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result = Symbol2.observable;
    } else {
      if (typeof Symbol2.for === "function") {
        result = Symbol2.for("https://github.com/benlesh/symbol-observable");
      } else {
        result = Symbol2("https://github.com/benlesh/symbol-observable");
      }
      try {
        Symbol2.observable = result;
      } catch (err) {
      }
    }
  } else {
    result = "@@observable";
  }
  return result;
}
var root$a;
if (typeof self !== "undefined") {
  root$a = self;
} else if (typeof window !== "undefined") {
  root$a = window;
} else if (typeof global !== "undefined") {
  root$a = global;
} else if (typeof module !== "undefined") {
  root$a = module;
} else {
  root$a = Function("return this")();
}
symbolObservablePonyfill(root$a);
var prototype = Observable$1.prototype;
var fakeObsSymbol = "@@observable";
if (!prototype[fakeObsSymbol]) {
  prototype[fakeObsSymbol] = function() {
    return this;
  };
}
var toString$2 = Object.prototype.toString;
function cloneDeep$3(value) {
  return cloneDeepHelper(value);
}
function cloneDeepHelper(val, seen) {
  switch (toString$2.call(val)) {
    case "[object Array]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_1 = val.slice(0);
      seen.set(val, copy_1);
      copy_1.forEach(function(child, i) {
        copy_1[i] = cloneDeepHelper(child, seen);
      });
      return copy_1;
    }
    case "[object Object]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_2 = Object.create(Object.getPrototypeOf(val));
      seen.set(val, copy_2);
      Object.keys(val).forEach(function(key) {
        copy_2[key] = cloneDeepHelper(val[key], seen);
      });
      return copy_2;
    }
    default:
      return val;
  }
}
function deepFreeze(value) {
  var workSet = /* @__PURE__ */ new Set([value]);
  workSet.forEach(function(obj) {
    if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        if (isNonNullObject(obj[name]))
          workSet.add(obj[name]);
      });
    }
  });
  return value;
}
function shallowFreeze(obj) {
  if (__DEV__ && !Object.isFrozen(obj)) {
    try {
      Object.freeze(obj);
    } catch (e2) {
      if (e2 instanceof TypeError)
        return null;
      throw e2;
    }
  }
  return obj;
}
function maybeDeepFreeze(obj) {
  if (__DEV__) {
    deepFreeze(obj);
  }
  return obj;
}
function iterateObserversSafely(observers2, method4, argument) {
  var observersWithMethod = [];
  observers2.forEach(function(obs) {
    return obs[method4] && observersWithMethod.push(obs);
  });
  observersWithMethod.forEach(function(obs) {
    return obs[method4](argument);
  });
}
function asyncMap$1(observable, mapFn, catchFn) {
  return new Observable$1(function(observer) {
    var next2 = observer.next, error3 = observer.error, complete = observer.complete;
    var activeCallbackCount = 0;
    var completed = false;
    var promiseQueue = {
      then: function(callback) {
        return new Promise(function(resolve) {
          return resolve(callback());
        });
      }
    };
    function makeCallback(examiner, delegate) {
      if (examiner) {
        return function(arg) {
          ++activeCallbackCount;
          var both = function() {
            return examiner(arg);
          };
          promiseQueue = promiseQueue.then(both, both).then(function(result) {
            --activeCallbackCount;
            next2 && next2.call(observer, result);
            if (completed) {
              handler.complete();
            }
          }, function(error4) {
            --activeCallbackCount;
            throw error4;
          }).catch(function(caught) {
            error3 && error3.call(observer, caught);
          });
        };
      } else {
        return function(arg) {
          return delegate && delegate.call(observer, arg);
        };
      }
    }
    var handler = {
      next: makeCallback(mapFn, next2),
      error: makeCallback(catchFn, error3),
      complete: function() {
        completed = true;
        if (!activeCallbackCount) {
          complete && complete.call(observer);
        }
      }
    };
    var sub = observable.subscribe(handler);
    return function() {
      return sub.unsubscribe();
    };
  });
}
var canUseWeakMap = typeof WeakMap === "function" && maybe$2(function() {
  return navigator.product;
}) !== "ReactNative";
var canUseWeakSet = typeof WeakSet === "function";
var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
var canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;
var canUseDOM$1 = typeof maybe$2(function() {
  return window.document.createElement;
}) === "function";
var usingJSDOM = maybe$2(function() {
  return navigator.userAgent.indexOf("jsdom") >= 0;
}) || false;
var canUseLayoutEffect = canUseDOM$1 && !usingJSDOM;
function fixObservableSubclass(subclass) {
  function set2(key) {
    Object.defineProperty(subclass, key, { value: Observable$1 });
  }
  if (canUseSymbol && Symbol.species) {
    set2(Symbol.species);
  }
  set2("@@species");
  return subclass;
}
function isPromiseLike(value) {
  return value && typeof value.then === "function";
}
var Concast = function(_super) {
  __extends$1(Concast2, _super);
  function Concast2(sources) {
    var _this = _super.call(this, function(observer) {
      _this.addObserver(observer);
      return function() {
        return _this.removeObserver(observer);
      };
    }) || this;
    _this.observers = /* @__PURE__ */ new Set();
    _this.promise = new Promise(function(resolve, reject) {
      _this.resolve = resolve;
      _this.reject = reject;
    });
    _this.handlers = {
      next: function(result) {
        if (_this.sub !== null) {
          _this.latest = ["next", result];
          _this.notify("next", result);
          iterateObserversSafely(_this.observers, "next", result);
        }
      },
      error: function(error3) {
        var sub = _this.sub;
        if (sub !== null) {
          if (sub)
            setTimeout(function() {
              return sub.unsubscribe();
            });
          _this.sub = null;
          _this.latest = ["error", error3];
          _this.reject(error3);
          _this.notify("error", error3);
          iterateObserversSafely(_this.observers, "error", error3);
        }
      },
      complete: function() {
        var sub = _this.sub;
        if (sub !== null) {
          var value = _this.sources.shift();
          if (!value) {
            if (sub)
              setTimeout(function() {
                return sub.unsubscribe();
              });
            _this.sub = null;
            if (_this.latest && _this.latest[0] === "next") {
              _this.resolve(_this.latest[1]);
            } else {
              _this.resolve();
            }
            _this.notify("complete");
            iterateObserversSafely(_this.observers, "complete");
          } else if (isPromiseLike(value)) {
            value.then(function(obs) {
              return _this.sub = obs.subscribe(_this.handlers);
            });
          } else {
            _this.sub = value.subscribe(_this.handlers);
          }
        }
      }
    };
    _this.nextResultListeners = /* @__PURE__ */ new Set();
    _this.cancel = function(reason) {
      _this.reject(reason);
      _this.sources = [];
      _this.handlers.complete();
    };
    _this.promise.catch(function(_24) {
    });
    if (typeof sources === "function") {
      sources = [new Observable$1(sources)];
    }
    if (isPromiseLike(sources)) {
      sources.then(function(iterable) {
        return _this.start(iterable);
      }, _this.handlers.error);
    } else {
      _this.start(sources);
    }
    return _this;
  }
  Concast2.prototype.start = function(sources) {
    if (this.sub !== void 0)
      return;
    this.sources = Array.from(sources);
    this.handlers.complete();
  };
  Concast2.prototype.deliverLastMessage = function(observer) {
    if (this.latest) {
      var nextOrError = this.latest[0];
      var method4 = observer[nextOrError];
      if (method4) {
        method4.call(observer, this.latest[1]);
      }
      if (this.sub === null && nextOrError === "next" && observer.complete) {
        observer.complete();
      }
    }
  };
  Concast2.prototype.addObserver = function(observer) {
    if (!this.observers.has(observer)) {
      this.deliverLastMessage(observer);
      this.observers.add(observer);
    }
  };
  Concast2.prototype.removeObserver = function(observer) {
    if (this.observers.delete(observer) && this.observers.size < 1) {
      this.handlers.complete();
    }
  };
  Concast2.prototype.notify = function(method4, arg) {
    var nextResultListeners = this.nextResultListeners;
    if (nextResultListeners.size) {
      this.nextResultListeners = /* @__PURE__ */ new Set();
      nextResultListeners.forEach(function(listener) {
        return listener(method4, arg);
      });
    }
  };
  Concast2.prototype.beforeNext = function(callback) {
    var called = false;
    this.nextResultListeners.add(function(method4, arg) {
      if (!called) {
        called = true;
        callback(method4, arg);
      }
    });
  };
  return Concast2;
}(Observable$1);
fixObservableSubclass(Concast);
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}
function graphQLResultHasError(result) {
  return result.errors && result.errors.length > 0 || false;
}
function compact$1() {
  var objects = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    objects[_i2] = arguments[_i2];
  }
  var result = /* @__PURE__ */ Object.create(null);
  objects.forEach(function(obj) {
    if (!obj)
      return;
    Object.keys(obj).forEach(function(key) {
      var value = obj[key];
      if (value !== void 0) {
        result[key] = value;
      }
    });
  });
  return result;
}
var prefixCounts = /* @__PURE__ */ new Map();
function makeUniqueId(prefix2) {
  var count = prefixCounts.get(prefix2) || 1;
  prefixCounts.set(prefix2, count + 1);
  return "".concat(prefix2, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
}
function stringifyForDisplay(value) {
  var undefId = makeUniqueId("stringifyForDisplay");
  return JSON.stringify(value, function(key, value2) {
    return value2 === void 0 ? undefId : value2;
  }).split(JSON.stringify(undefId)).join("<undefined>");
}
function mergeOptions(defaults2, options) {
  return compact$1(defaults2, options, options.variables && {
    variables: __assign$1(__assign$1({}, defaults2 && defaults2.variables), options.variables)
  });
}
function fromError(errorValue) {
  return new Observable$1(function(observer) {
    observer.error(errorValue);
  });
}
function toPromise(observable) {
  var completed = false;
  return new Promise(function(resolve, reject) {
    observable.subscribe({
      next: function(data2) {
        if (completed) {
          __DEV__ && invariant$1.warn("Promise Wrapper does not support multiple results from Observable");
        } else {
          completed = true;
          resolve(data2);
        }
      },
      error: reject
    });
  });
}
function fromPromise(promise) {
  return new Observable$1(function(observer) {
    promise.then(function(value) {
      observer.next(value);
      observer.complete();
    }).catch(observer.error.bind(observer));
  });
}
var throwServerError = function(response, result, message) {
  var error3 = new Error(message);
  error3.name = "ServerError";
  error3.response = response;
  error3.statusCode = response.status;
  error3.result = result;
  throw error3;
};
function validateOperation(operation) {
  var OPERATION_FIELDS = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ];
  for (var _i2 = 0, _a2 = Object.keys(operation); _i2 < _a2.length; _i2++) {
    var key = _a2[_i2];
    if (OPERATION_FIELDS.indexOf(key) < 0) {
      throw __DEV__ ? new InvariantError("illegal argument: ".concat(key)) : new InvariantError(26);
    }
  }
  return operation;
}
function createOperation(starting, operation) {
  var context2 = __assign$1({}, starting);
  var setContext2 = function(next2) {
    if (typeof next2 === "function") {
      context2 = __assign$1(__assign$1({}, context2), next2(context2));
    } else {
      context2 = __assign$1(__assign$1({}, context2), next2);
    }
  };
  var getContext = function() {
    return __assign$1({}, context2);
  };
  Object.defineProperty(operation, "setContext", {
    enumerable: false,
    value: setContext2
  });
  Object.defineProperty(operation, "getContext", {
    enumerable: false,
    value: getContext
  });
  return operation;
}
function transformOperation(operation) {
  var transformedOperation = {
    variables: operation.variables || {},
    extensions: operation.extensions || {},
    operationName: operation.operationName,
    query: operation.query
  };
  if (!transformedOperation.operationName) {
    transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) || void 0 : "";
  }
  return transformedOperation;
}
function passthrough(op, forward) {
  return forward ? forward(op) : Observable$1.of();
}
function toLink(handler) {
  return typeof handler === "function" ? new ApolloLink$1(handler) : handler;
}
function isTerminating(link2) {
  return link2.request.length <= 1;
}
var LinkError = function(_super) {
  __extends$1(LinkError2, _super);
  function LinkError2(message, link2) {
    var _this = _super.call(this, message) || this;
    _this.link = link2;
    return _this;
  }
  return LinkError2;
}(Error);
var ApolloLink$1 = function() {
  function ApolloLink2(request) {
    if (request)
      this.request = request;
  }
  ApolloLink2.empty = function() {
    return new ApolloLink2(function() {
      return Observable$1.of();
    });
  };
  ApolloLink2.from = function(links) {
    if (links.length === 0)
      return ApolloLink2.empty();
    return links.map(toLink).reduce(function(x2, y2) {
      return x2.concat(y2);
    });
  };
  ApolloLink2.split = function(test, left, right) {
    var leftLink = toLink(left);
    var rightLink = toLink(right || new ApolloLink2(passthrough));
    if (isTerminating(leftLink) && isTerminating(rightLink)) {
      return new ApolloLink2(function(operation) {
        return test(operation) ? leftLink.request(operation) || Observable$1.of() : rightLink.request(operation) || Observable$1.of();
      });
    } else {
      return new ApolloLink2(function(operation, forward) {
        return test(operation) ? leftLink.request(operation, forward) || Observable$1.of() : rightLink.request(operation, forward) || Observable$1.of();
      });
    }
  };
  ApolloLink2.execute = function(link2, operation) {
    return link2.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable$1.of();
  };
  ApolloLink2.concat = function(first, second) {
    var firstLink = toLink(first);
    if (isTerminating(firstLink)) {
      __DEV__ && invariant$1.warn(new LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
      return firstLink;
    }
    var nextLink = toLink(second);
    if (isTerminating(nextLink)) {
      return new ApolloLink2(function(operation) {
        return firstLink.request(operation, function(op) {
          return nextLink.request(op) || Observable$1.of();
        }) || Observable$1.of();
      });
    } else {
      return new ApolloLink2(function(operation, forward) {
        return firstLink.request(operation, function(op) {
          return nextLink.request(op, forward) || Observable$1.of();
        }) || Observable$1.of();
      });
    }
  };
  ApolloLink2.prototype.split = function(test, left, right) {
    return this.concat(ApolloLink2.split(test, left, right || new ApolloLink2(passthrough)));
  };
  ApolloLink2.prototype.concat = function(next2) {
    return ApolloLink2.concat(this, next2);
  };
  ApolloLink2.prototype.request = function(operation, forward) {
    throw __DEV__ ? new InvariantError("request is not implemented") : new InvariantError(21);
  };
  ApolloLink2.prototype.onError = function(error3, observer) {
    if (observer && observer.error) {
      observer.error(error3);
      return false;
    }
    throw error3;
  };
  ApolloLink2.prototype.setOnError = function(fn2) {
    this.onError = fn2;
    return this;
  };
  return ApolloLink2;
}();
var empty = ApolloLink$1.empty;
var from$2 = ApolloLink$1.from;
var split = ApolloLink$1.split;
var concat = ApolloLink$1.concat;
var execute = ApolloLink$1.execute;
var version$5 = "3.7.1";
function isNodeResponse(value) {
  return !!value.body;
}
function isReadableStream(value) {
  return !!value.getReader;
}
function isAsyncIterableIterator(value) {
  return !!(canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
}
function isStreamableBlob(value) {
  return !!value.stream;
}
function isBlob(value) {
  return !!value.arrayBuffer;
}
function isNodeReadableStream(value) {
  return !!value.pipe;
}
function asyncIterator(source) {
  var _a2;
  var iterator = source[Symbol.asyncIterator]();
  return _a2 = {
    next: function() {
      return iterator.next();
    }
  }, _a2[Symbol.asyncIterator] = function() {
    return this;
  }, _a2;
}
function nodeStreamIterator(stream) {
  var cleanup2 = null;
  var error3 = null;
  var done = false;
  var data2 = [];
  var waiting = [];
  function onData(chunk) {
    if (error3)
      return;
    if (waiting.length) {
      var shiftedArr = waiting.shift();
      if (Array.isArray(shiftedArr) && shiftedArr[0]) {
        return shiftedArr[0]({ value: chunk, done: false });
      }
    }
    data2.push(chunk);
  }
  function onError2(err) {
    error3 = err;
    var all2 = waiting.slice();
    all2.forEach(function(pair) {
      pair[1](err);
    });
    !cleanup2 || cleanup2();
  }
  function onEnd() {
    done = true;
    var all2 = waiting.slice();
    all2.forEach(function(pair) {
      pair[0]({ value: void 0, done: true });
    });
    !cleanup2 || cleanup2();
  }
  cleanup2 = function() {
    cleanup2 = null;
    stream.removeListener("data", onData);
    stream.removeListener("error", onError2);
    stream.removeListener("end", onEnd);
    stream.removeListener("finish", onEnd);
    stream.removeListener("close", onEnd);
  };
  stream.on("data", onData);
  stream.on("error", onError2);
  stream.on("end", onEnd);
  stream.on("finish", onEnd);
  stream.on("close", onEnd);
  function getNext() {
    return new Promise(function(resolve, reject) {
      if (error3)
        return reject(error3);
      if (data2.length)
        return resolve({ value: data2.shift(), done: false });
      if (done)
        return resolve({ value: void 0, done: true });
      waiting.push([resolve, reject]);
    });
  }
  var iterator = {
    next: function() {
      return getNext();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function promiseIterator(promise) {
  var resolved = false;
  var iterator = {
    next: function() {
      if (resolved)
        return Promise.resolve({
          value: void 0,
          done: true
        });
      resolved = true;
      return new Promise(function(resolve, reject) {
        promise.then(function(value) {
          resolve({ value, done: false });
        }).catch(reject);
      });
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function readerIterator(reader) {
  var iterator = {
    next: function() {
      return reader.read();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function responseIterator(response) {
  var body = response;
  if (isNodeResponse(response))
    body = response.body;
  if (isAsyncIterableIterator(body))
    return asyncIterator(body);
  if (isReadableStream(body))
    return readerIterator(body.getReader());
  if (isStreamableBlob(body)) {
    return readerIterator(body.stream().getReader());
  }
  if (isBlob(body))
    return promiseIterator(body.arrayBuffer());
  if (isNodeReadableStream(body))
    return nodeStreamIterator(body);
  throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
}
var hasOwnProperty$f = Object.prototype.hasOwnProperty;
function readMultipartBody(response, observer) {
  var _a2, _b, _c;
  return __awaiter(this, void 0, void 0, function() {
    var decoder, contentType, delimiter2, boundaryVal, boundary, buffer, iterator, running, _d, value, done, chunk, bi2, message, i, headers, contentType_1, body, result;
    var _e2;
    return __generator(this, function(_f) {
      switch (_f.label) {
        case 0:
          if (TextDecoder === void 0) {
            throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
          }
          decoder = new TextDecoder("utf-8");
          contentType = (_a2 = response.headers) === null || _a2 === void 0 ? void 0 : _a2.get("content-type");
          delimiter2 = "boundary=";
          boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter2)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter2)) + delimiter2.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
          boundary = "--".concat(boundaryVal);
          buffer = "";
          iterator = responseIterator(response);
          running = true;
          _f.label = 1;
        case 1:
          if (!running)
            return [3, 3];
          return [4, iterator.next()];
        case 2:
          _d = _f.sent(), value = _d.value, done = _d.done;
          chunk = typeof value === "string" ? value : decoder.decode(value);
          running = !done;
          buffer += chunk;
          bi2 = buffer.indexOf(boundary);
          while (bi2 > -1) {
            message = void 0;
            _e2 = [
              buffer.slice(0, bi2),
              buffer.slice(bi2 + boundary.length)
            ], message = _e2[0], buffer = _e2[1];
            if (message.trim()) {
              i = message.indexOf("\r\n\r\n");
              headers = parseHeaders(message.slice(0, i));
              contentType_1 = headers["content-type"];
              if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
                throw new Error("Unsupported patch content type: application/json is required.");
              }
              body = message.slice(i);
              try {
                result = parseJsonBody(response, body.replace("\r\n", ""));
                if (Object.keys(result).length > 1 || "data" in result || "incremental" in result || "errors" in result) {
                  (_b = observer.next) === null || _b === void 0 ? void 0 : _b.call(observer, result);
                }
              } catch (err) {
                handleError(err, observer);
              }
            }
            bi2 = buffer.indexOf(boundary);
          }
          return [3, 1];
        case 3:
          (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
          return [2];
      }
    });
  });
}
function parseHeaders(headerText) {
  var headersInit = {};
  headerText.split("\n").forEach(function(line2) {
    var i = line2.indexOf(":");
    if (i > -1) {
      var name_1 = line2.slice(0, i).trim().toLowerCase();
      var value = line2.slice(i + 1).trim();
      headersInit[name_1] = value;
    }
  });
  return headersInit;
}
function parseJsonBody(response, bodyText) {
  if (response.status >= 300) {
    var getResult = function() {
      try {
        return JSON.parse(bodyText);
      } catch (err) {
        return bodyText;
      }
    };
    throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
  }
  try {
    return JSON.parse(bodyText);
  } catch (err) {
    var parseError = err;
    parseError.name = "ServerParseError";
    parseError.response = response;
    parseError.statusCode = response.status;
    parseError.bodyText = bodyText;
    throw parseError;
  }
}
function handleError(err, observer) {
  var _a2, _b;
  if (err.name === "AbortError")
    return;
  if (err.result && err.result.errors && err.result.data) {
    (_a2 = observer.next) === null || _a2 === void 0 ? void 0 : _a2.call(observer, err.result);
  }
  (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, err);
}
function readJsonBody(response, operation, observer) {
  parseAndCheckHttpResponse$1(operation)(response).then(function(result) {
    var _a2, _b;
    (_a2 = observer.next) === null || _a2 === void 0 ? void 0 : _a2.call(observer, result);
    (_b = observer.complete) === null || _b === void 0 ? void 0 : _b.call(observer);
  }).catch(function(err) {
    return handleError(err, observer);
  });
}
function parseAndCheckHttpResponse$1(operations) {
  return function(response) {
    return response.text().then(function(bodyText) {
      return parseJsonBody(response, bodyText);
    }).then(function(result) {
      if (response.status >= 300) {
        throwServerError(response, result, "Response not successful: Received status code ".concat(response.status));
      }
      if (!Array.isArray(result) && !hasOwnProperty$f.call(result, "data") && !hasOwnProperty$f.call(result, "errors")) {
        throwServerError(response, result, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
          return op.operationName;
        }) : operations.operationName, "'."));
      }
      return result;
    });
  };
}
var serializeFetchParameter$1 = function(p2, label) {
  var serialized;
  try {
    serialized = JSON.stringify(p2);
  } catch (e2) {
    var parseError = __DEV__ ? new InvariantError("Network request failed. ".concat(label, " is not serializable: ").concat(e2.message)) : new InvariantError(23);
    parseError.parseError = e2;
    throw parseError;
  }
  return serialized;
};
var defaultHttpOptions = {
  includeQuery: true,
  includeExtensions: false,
  preserveHeaderCase: false
};
var defaultHeaders = {
  accept: "*/*",
  "content-type": "application/json"
};
var defaultOptions$2 = {
  method: "POST"
};
var fallbackHttpConfig$1 = {
  http: defaultHttpOptions,
  headers: defaultHeaders,
  options: defaultOptions$2
};
var defaultPrinter = function(ast, printer) {
  return printer(ast);
};
function selectHttpOptionsAndBody$1(operation, fallbackConfig) {
  var configs = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    configs[_i2 - 2] = arguments[_i2];
  }
  configs.unshift(fallbackConfig);
  return selectHttpOptionsAndBodyInternal.apply(void 0, __spreadArray([
    operation,
    defaultPrinter
  ], configs, false));
}
function selectHttpOptionsAndBodyInternal(operation, printer) {
  var configs = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    configs[_i2 - 2] = arguments[_i2];
  }
  var options = {};
  var http2 = {};
  configs.forEach(function(config) {
    options = __assign$1(__assign$1(__assign$1({}, options), config.options), { headers: __assign$1(__assign$1({}, options.headers), config.headers) });
    if (config.credentials) {
      options.credentials = config.credentials;
    }
    http2 = __assign$1(__assign$1({}, http2), config.http);
  });
  options.headers = removeDuplicateHeaders(options.headers, http2.preserveHeaderCase);
  var operationName2 = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
  var body = { operationName: operationName2, variables };
  if (http2.includeExtensions)
    body.extensions = extensions;
  if (http2.includeQuery)
    body.query = printer(query, print);
  return {
    options,
    body
  };
}
function removeDuplicateHeaders(headers, preserveHeaderCase) {
  if (!preserveHeaderCase) {
    var normalizedHeaders_1 = /* @__PURE__ */ Object.create(null);
    Object.keys(Object(headers)).forEach(function(name) {
      normalizedHeaders_1[name.toLowerCase()] = headers[name];
    });
    return normalizedHeaders_1;
  }
  var headerData = /* @__PURE__ */ Object.create(null);
  Object.keys(Object(headers)).forEach(function(name) {
    headerData[name.toLowerCase()] = { originalName: name, value: headers[name] };
  });
  var normalizedHeaders = /* @__PURE__ */ Object.create(null);
  Object.keys(headerData).forEach(function(name) {
    normalizedHeaders[headerData[name].originalName] = headerData[name].value;
  });
  return normalizedHeaders;
}
var checkFetcher = function(fetcher) {
  if (!fetcher && typeof fetch === "undefined") {
    throw __DEV__ ? new InvariantError(`
"fetch" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:

import fetch from 'cross-fetch';
import { ApolloClient, HttpLink } from '@apollo/client';
const client = new ApolloClient({
  link: new HttpLink({ uri: '/graphql', fetch })
});
    `) : new InvariantError(22);
  }
};
var createSignalIfSupported$1 = function() {
  if (typeof AbortController === "undefined")
    return { controller: false, signal: false };
  var controller = new AbortController();
  var signal = controller.signal;
  return { controller, signal };
};
var selectURI$1 = function(operation, fallbackURI) {
  var context2 = operation.getContext();
  var contextURI = context2.uri;
  if (contextURI) {
    return contextURI;
  } else if (typeof fallbackURI === "function") {
    return fallbackURI(operation);
  } else {
    return fallbackURI || "/graphql";
  }
};
function rewriteURIForGET$1(chosenURI, body) {
  var queryParams = [];
  var addQueryParam = function(key, value) {
    queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
  };
  if ("query" in body) {
    addQueryParam("query", body.query);
  }
  if (body.operationName) {
    addQueryParam("operationName", body.operationName);
  }
  if (body.variables) {
    var serializedVariables = void 0;
    try {
      serializedVariables = serializeFetchParameter$1(body.variables, "Variables map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("variables", serializedVariables);
  }
  if (body.extensions) {
    var serializedExtensions = void 0;
    try {
      serializedExtensions = serializeFetchParameter$1(body.extensions, "Extensions map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("extensions", serializedExtensions);
  }
  var fragment = "", preFragment = chosenURI;
  var fragmentStart = chosenURI.indexOf("#");
  if (fragmentStart !== -1) {
    fragment = chosenURI.substr(fragmentStart);
    preFragment = chosenURI.substr(0, fragmentStart);
  }
  var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
  var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
  return { newURI };
}
var backupFetch = maybe$2(function() {
  return fetch;
});
var createHttpLink = function(linkOptions) {
  if (linkOptions === void 0) {
    linkOptions = {};
  }
  var _a2 = linkOptions.uri, uri = _a2 === void 0 ? "/graphql" : _a2, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print2 = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest$G(linkOptions, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
  if (__DEV__) {
    checkFetcher(preferredFetch || backupFetch);
  }
  var linkConfig = {
    http: { includeExtensions, preserveHeaderCase },
    options: requestOptions.fetchOptions,
    credentials: requestOptions.credentials,
    headers: requestOptions.headers
  };
  return new ApolloLink$1(function(operation) {
    var chosenURI = selectURI$1(operation, uri);
    var context2 = operation.getContext();
    var clientAwarenessHeaders = {};
    if (context2.clientAwareness) {
      var _a3 = context2.clientAwareness, name_1 = _a3.name, version2 = _a3.version;
      if (name_1) {
        clientAwarenessHeaders["apollographql-client-name"] = name_1;
      }
      if (version2) {
        clientAwarenessHeaders["apollographql-client-version"] = version2;
      }
    }
    var contextHeaders = __assign$1(__assign$1({}, clientAwarenessHeaders), context2.headers);
    var contextConfig = {
      http: context2.http,
      options: context2.fetchOptions,
      credentials: context2.credentials,
      headers: contextHeaders
    };
    var _b2 = selectHttpOptionsAndBodyInternal(operation, print2, fallbackHttpConfig$1, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
    if (body.variables && !includeUnusedVariables) {
      var unusedNames_1 = new Set(Object.keys(body.variables));
      visit$2(operation.query, {
        Variable: function(node2, _key, parent) {
          if (parent && parent.kind !== "VariableDefinition") {
            unusedNames_1.delete(node2.name.value);
          }
        }
      });
      if (unusedNames_1.size) {
        body.variables = __assign$1({}, body.variables);
        unusedNames_1.forEach(function(name) {
          delete body.variables[name];
        });
      }
    }
    var controller;
    if (!options.signal) {
      var _c2 = createSignalIfSupported$1(), _controller = _c2.controller, signal = _c2.signal;
      controller = _controller;
      if (controller)
        options.signal = signal;
    }
    var definitionIsMutation = function(d2) {
      return d2.kind === "OperationDefinition" && d2.operation === "mutation";
    };
    if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
      options.method = "GET";
    }
    if (hasDirectives(["defer"], operation.query)) {
      options.headers.accept = "multipart/mixed; deferSpec=20220824, application/json";
    }
    if (options.method === "GET") {
      var _d = rewriteURIForGET$1(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
      if (parseError) {
        return fromError(parseError);
      }
      chosenURI = newURI;
    } else {
      try {
        options.body = serializeFetchParameter$1(body, "Payload");
      } catch (parseError2) {
        return fromError(parseError2);
      }
    }
    return new Observable$1(function(observer) {
      var currentFetch = preferredFetch || maybe$2(function() {
        return fetch;
      }) || backupFetch;
      currentFetch(chosenURI, options).then(function(response) {
        var _a4;
        operation.setContext({ response });
        var ctype = (_a4 = response.headers) === null || _a4 === void 0 ? void 0 : _a4.get("content-type");
        if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
          return readMultipartBody(response, observer);
        } else {
          return readJsonBody(response, operation, observer);
        }
      }).catch(function(err) {
        return handleError(err, observer);
      });
      return function() {
        if (controller)
          controller.abort();
      };
    });
  });
};
var HttpLink = function(_super) {
  __extends$1(HttpLink2, _super);
  function HttpLink2(options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this, createHttpLink(options).request) || this;
    _this.options = options;
    return _this;
  }
  return HttpLink2;
}(ApolloLink$1);
var http = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseAndCheckHttpResponse: parseAndCheckHttpResponse$1,
  serializeFetchParameter: serializeFetchParameter$1,
  fallbackHttpConfig: fallbackHttpConfig$1,
  defaultPrinter,
  selectHttpOptionsAndBody: selectHttpOptionsAndBody$1,
  selectHttpOptionsAndBodyInternal,
  checkFetcher,
  createSignalIfSupported: createSignalIfSupported$1,
  selectURI: selectURI$1,
  createHttpLink,
  HttpLink,
  rewriteURIForGET: rewriteURIForGET$1
}, Symbol.toStringTag, { value: "Module" }));
var _a$2 = Object.prototype, toString$1 = _a$2.toString, hasOwnProperty$e = _a$2.hasOwnProperty;
var fnToStr = Function.prototype.toString;
var previousComparisons = /* @__PURE__ */ new Map();
function equal(a, b2) {
  try {
    return check(a, b2);
  } finally {
    previousComparisons.clear();
  }
}
function check(a, b2) {
  if (a === b2) {
    return true;
  }
  var aTag = toString$1.call(a);
  var bTag = toString$1.call(b2);
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case "[object Array]":
      if (a.length !== b2.length)
        return false;
    case "[object Object]": {
      if (previouslyCompared(a, b2))
        return true;
      var aKeys = definedKeys(a);
      var bKeys = definedKeys(b2);
      var keyCount2 = aKeys.length;
      if (keyCount2 !== bKeys.length)
        return false;
      for (var k2 = 0; k2 < keyCount2; ++k2) {
        if (!hasOwnProperty$e.call(b2, aKeys[k2])) {
          return false;
        }
      }
      for (var k2 = 0; k2 < keyCount2; ++k2) {
        var key = aKeys[k2];
        if (!check(a[key], b2[key])) {
          return false;
        }
      }
      return true;
    }
    case "[object Error]":
      return a.name === b2.name && a.message === b2.message;
    case "[object Number]":
      if (a !== a)
        return b2 !== b2;
    case "[object Boolean]":
    case "[object Date]":
      return +a === +b2;
    case "[object RegExp]":
    case "[object String]":
      return a == "".concat(b2);
    case "[object Map]":
    case "[object Set]": {
      if (a.size !== b2.size)
        return false;
      if (previouslyCompared(a, b2))
        return true;
      var aIterator = a.entries();
      var isMap = aTag === "[object Map]";
      while (true) {
        var info = aIterator.next();
        if (info.done)
          break;
        var _a2 = info.value, aKey = _a2[0], aValue = _a2[1];
        if (!b2.has(aKey)) {
          return false;
        }
        if (isMap && !check(aValue, b2.get(aKey))) {
          return false;
        }
      }
      return true;
    }
    case "[object Uint16Array]":
    case "[object Uint8Array]":
    case "[object Uint32Array]":
    case "[object Int32Array]":
    case "[object Int8Array]":
    case "[object Int16Array]":
    case "[object ArrayBuffer]":
      a = new Uint8Array(a);
      b2 = new Uint8Array(b2);
    case "[object DataView]": {
      var len = a.byteLength;
      if (len === b2.byteLength) {
        while (len-- && a[len] === b2[len]) {
        }
      }
      return len === -1;
    }
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
    case "[object Function]": {
      var aCode = fnToStr.call(a);
      if (aCode !== fnToStr.call(b2)) {
        return false;
      }
      return !endsWith(aCode, nativeCodeSuffix);
    }
  }
  return false;
}
function definedKeys(obj) {
  return Object.keys(obj).filter(isDefinedKey, obj);
}
function isDefinedKey(key) {
  return this[key] !== void 0;
}
var nativeCodeSuffix = "{ [native code] }";
function endsWith(full, suffix) {
  var fromIndex = full.length - suffix.length;
  return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
}
function previouslyCompared(a, b2) {
  var bSet = previousComparisons.get(a);
  if (bSet) {
    if (bSet.has(b2))
      return true;
  } else {
    previousComparisons.set(a, bSet = /* @__PURE__ */ new Set());
  }
  bSet.add(b2);
  return false;
}
function isExecutionPatchIncrementalResult(value) {
  return !!value.incremental;
}
var defaultMakeData = function() {
  return /* @__PURE__ */ Object.create(null);
};
var _a$1 = Array.prototype, forEach = _a$1.forEach, slice$3 = _a$1.slice;
var Trie = function() {
  function Trie2(weakness, makeData) {
    if (weakness === void 0) {
      weakness = true;
    }
    if (makeData === void 0) {
      makeData = defaultMakeData;
    }
    this.weakness = weakness;
    this.makeData = makeData;
  }
  Trie2.prototype.lookup = function() {
    var array4 = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      array4[_i2] = arguments[_i2];
    }
    return this.lookupArray(array4);
  };
  Trie2.prototype.lookupArray = function(array4) {
    var node2 = this;
    forEach.call(array4, function(key) {
      return node2 = node2.getChildTrie(key);
    });
    return node2.data || (node2.data = this.makeData(slice$3.call(array4)));
  };
  Trie2.prototype.getChildTrie = function(key) {
    var map = this.weakness && isObjRef(key) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
    var child = map.get(key);
    if (!child)
      map.set(key, child = new Trie2(this.weakness, this.makeData));
    return child;
  };
  return Trie2;
}();
function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}
var currentContext$1 = null;
var MISSING_VALUE$1 = {};
var idCounter$1 = 1;
var makeSlotClass$1 = function() {
  return function() {
    function Slot2() {
      this.id = [
        "slot",
        idCounter$1++,
        Date.now(),
        Math.random().toString(36).slice(2)
      ].join(":");
    }
    Slot2.prototype.hasValue = function() {
      for (var context_1 = currentContext$1; context_1; context_1 = context_1.parent) {
        if (this.id in context_1.slots) {
          var value = context_1.slots[this.id];
          if (value === MISSING_VALUE$1)
            break;
          if (context_1 !== currentContext$1) {
            currentContext$1.slots[this.id] = value;
          }
          return true;
        }
      }
      if (currentContext$1) {
        currentContext$1.slots[this.id] = MISSING_VALUE$1;
      }
      return false;
    };
    Slot2.prototype.getValue = function() {
      if (this.hasValue()) {
        return currentContext$1.slots[this.id];
      }
    };
    Slot2.prototype.withValue = function(value, callback, args, thisArg) {
      var _a2;
      var slots = (_a2 = {
        __proto__: null
      }, _a2[this.id] = value, _a2);
      var parent = currentContext$1;
      currentContext$1 = { parent, slots };
      try {
        return callback.apply(thisArg, args);
      } finally {
        currentContext$1 = parent;
      }
    };
    Slot2.bind = function(callback) {
      var context2 = currentContext$1;
      return function() {
        var saved = currentContext$1;
        try {
          currentContext$1 = context2;
          return callback.apply(this, arguments);
        } finally {
          currentContext$1 = saved;
        }
      };
    };
    Slot2.noContext = function(callback, args, thisArg) {
      if (currentContext$1) {
        var saved = currentContext$1;
        try {
          currentContext$1 = null;
          return callback.apply(thisArg, args);
        } finally {
          currentContext$1 = saved;
        }
      } else {
        return callback.apply(thisArg, args);
      }
    };
    return Slot2;
  }();
};
var globalKey$1 = "@wry/context:Slot";
var host$1 = Array;
var Slot$1 = host$1[globalKey$1] || function() {
  var Slot2 = makeSlotClass$1();
  try {
    Object.defineProperty(host$1, globalKey$1, {
      value: host$1[globalKey$1] = Slot2,
      enumerable: false,
      writable: false,
      configurable: false
    });
  } finally {
    return Slot2;
  }
}();
Slot$1.bind;
Slot$1.noContext;
function defaultDispose() {
}
var Cache$1 = function() {
  function Cache2(max, dispose) {
    if (max === void 0) {
      max = Infinity;
    }
    if (dispose === void 0) {
      dispose = defaultDispose;
    }
    this.max = max;
    this.dispose = dispose;
    this.map = /* @__PURE__ */ new Map();
    this.newest = null;
    this.oldest = null;
  }
  Cache2.prototype.has = function(key) {
    return this.map.has(key);
  };
  Cache2.prototype.get = function(key) {
    var node2 = this.getNode(key);
    return node2 && node2.value;
  };
  Cache2.prototype.getNode = function(key) {
    var node2 = this.map.get(key);
    if (node2 && node2 !== this.newest) {
      var older = node2.older, newer = node2.newer;
      if (newer) {
        newer.older = older;
      }
      if (older) {
        older.newer = newer;
      }
      node2.older = this.newest;
      node2.older.newer = node2;
      node2.newer = null;
      this.newest = node2;
      if (node2 === this.oldest) {
        this.oldest = newer;
      }
    }
    return node2;
  };
  Cache2.prototype.set = function(key, value) {
    var node2 = this.getNode(key);
    if (node2) {
      return node2.value = value;
    }
    node2 = {
      key,
      value,
      newer: null,
      older: this.newest
    };
    if (this.newest) {
      this.newest.newer = node2;
    }
    this.newest = node2;
    this.oldest = this.oldest || node2;
    this.map.set(key, node2);
    return node2.value;
  };
  Cache2.prototype.clean = function() {
    while (this.oldest && this.map.size > this.max) {
      this.delete(this.oldest.key);
    }
  };
  Cache2.prototype.delete = function(key) {
    var node2 = this.map.get(key);
    if (node2) {
      if (node2 === this.newest) {
        this.newest = node2.older;
      }
      if (node2 === this.oldest) {
        this.oldest = node2.newer;
      }
      if (node2.newer) {
        node2.newer.older = node2.older;
      }
      if (node2.older) {
        node2.older.newer = node2.newer;
      }
      this.map.delete(key);
      this.dispose(node2.value, key);
      return true;
    }
    return false;
  };
  return Cache2;
}();
var parentEntrySlot = new Slot$1();
var _a;
var hasOwnProperty$d = Object.prototype.hasOwnProperty;
var toArray$c = (_a = Array.from, _a === void 0 ? function(collection) {
  var array4 = [];
  collection.forEach(function(item) {
    return array4.push(item);
  });
  return array4;
} : _a);
function maybeUnsubscribe(entryOrDep) {
  var unsubscribe = entryOrDep.unsubscribe;
  if (typeof unsubscribe === "function") {
    entryOrDep.unsubscribe = void 0;
    unsubscribe();
  }
}
var emptySetPool = [];
var POOL_TARGET_SIZE = 100;
function assert(condition, optionalMessage) {
  if (!condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}
function valueIs(a, b2) {
  var len = a.length;
  return len > 0 && len === b2.length && a[len - 1] === b2[len - 1];
}
function valueGet(value) {
  switch (value.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return value[0];
    case 2:
      throw value[1];
  }
}
function valueCopy(value) {
  return value.slice(0);
}
var Entry = function() {
  function Entry2(fn2) {
    this.fn = fn2;
    this.parents = /* @__PURE__ */ new Set();
    this.childValues = /* @__PURE__ */ new Map();
    this.dirtyChildren = null;
    this.dirty = true;
    this.recomputing = false;
    this.value = [];
    this.deps = null;
    ++Entry2.count;
  }
  Entry2.prototype.peek = function() {
    if (this.value.length === 1 && !mightBeDirty(this)) {
      rememberParent(this);
      return this.value[0];
    }
  };
  Entry2.prototype.recompute = function(args) {
    assert(!this.recomputing, "already recomputing");
    rememberParent(this);
    return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
  };
  Entry2.prototype.setDirty = function() {
    if (this.dirty)
      return;
    this.dirty = true;
    this.value.length = 0;
    reportDirty(this);
    maybeUnsubscribe(this);
  };
  Entry2.prototype.dispose = function() {
    var _this = this;
    this.setDirty();
    forgetChildren(this);
    eachParent(this, function(parent, child) {
      parent.setDirty();
      forgetChild(parent, _this);
    });
  };
  Entry2.prototype.forget = function() {
    this.dispose();
  };
  Entry2.prototype.dependOn = function(dep2) {
    dep2.add(this);
    if (!this.deps) {
      this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
    }
    this.deps.add(dep2);
  };
  Entry2.prototype.forgetDeps = function() {
    var _this = this;
    if (this.deps) {
      toArray$c(this.deps).forEach(function(dep2) {
        return dep2.delete(_this);
      });
      this.deps.clear();
      emptySetPool.push(this.deps);
      this.deps = null;
    }
  };
  Entry2.count = 0;
  return Entry2;
}();
function rememberParent(child) {
  var parent = parentEntrySlot.getValue();
  if (parent) {
    child.parents.add(parent);
    if (!parent.childValues.has(child)) {
      parent.childValues.set(child, []);
    }
    if (mightBeDirty(child)) {
      reportDirtyChild(parent, child);
    } else {
      reportCleanChild(parent, child);
    }
    return parent;
  }
}
function reallyRecompute(entry, args) {
  forgetChildren(entry);
  parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
  if (maybeSubscribe(entry, args)) {
    setClean(entry);
  }
  return valueGet(entry.value);
}
function recomputeNewValue(entry, args) {
  entry.recomputing = true;
  entry.value.length = 0;
  try {
    entry.value[0] = entry.fn.apply(null, args);
  } catch (e2) {
    entry.value[1] = e2;
  }
  entry.recomputing = false;
}
function mightBeDirty(entry) {
  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
  entry.dirty = false;
  if (mightBeDirty(entry)) {
    return;
  }
  reportClean(entry);
}
function reportDirty(child) {
  eachParent(child, reportDirtyChild);
}
function reportClean(child) {
  eachParent(child, reportCleanChild);
}
function eachParent(child, callback) {
  var parentCount = child.parents.size;
  if (parentCount) {
    var parents = toArray$c(child.parents);
    for (var i = 0; i < parentCount; ++i) {
      callback(parents[i], child);
    }
  }
}
function reportDirtyChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(mightBeDirty(child));
  var parentWasClean = !mightBeDirty(parent);
  if (!parent.dirtyChildren) {
    parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
  } else if (parent.dirtyChildren.has(child)) {
    return;
  }
  parent.dirtyChildren.add(child);
  if (parentWasClean) {
    reportDirty(parent);
  }
}
function reportCleanChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(!mightBeDirty(child));
  var childValue = parent.childValues.get(child);
  if (childValue.length === 0) {
    parent.childValues.set(child, valueCopy(child.value));
  } else if (!valueIs(childValue, child.value)) {
    parent.setDirty();
  }
  removeDirtyChild(parent, child);
  if (mightBeDirty(parent)) {
    return;
  }
  reportClean(parent);
}
function removeDirtyChild(parent, child) {
  var dc = parent.dirtyChildren;
  if (dc) {
    dc.delete(child);
    if (dc.size === 0) {
      if (emptySetPool.length < POOL_TARGET_SIZE) {
        emptySetPool.push(dc);
      }
      parent.dirtyChildren = null;
    }
  }
}
function forgetChildren(parent) {
  if (parent.childValues.size > 0) {
    parent.childValues.forEach(function(_value, child) {
      forgetChild(parent, child);
    });
  }
  parent.forgetDeps();
  assert(parent.dirtyChildren === null);
}
function forgetChild(parent, child) {
  child.parents.delete(parent);
  parent.childValues.delete(child);
  removeDirtyChild(parent, child);
}
function maybeSubscribe(entry, args) {
  if (typeof entry.subscribe === "function") {
    try {
      maybeUnsubscribe(entry);
      entry.unsubscribe = entry.subscribe.apply(null, args);
    } catch (e2) {
      entry.setDirty();
      return false;
    }
  }
  return true;
}
var EntryMethods = {
  setDirty: true,
  dispose: true,
  forget: true
};
function dep(options) {
  var depsByKey = /* @__PURE__ */ new Map();
  var subscribe = options && options.subscribe;
  function depend(key) {
    var parent = parentEntrySlot.getValue();
    if (parent) {
      var dep_1 = depsByKey.get(key);
      if (!dep_1) {
        depsByKey.set(key, dep_1 = /* @__PURE__ */ new Set());
      }
      parent.dependOn(dep_1);
      if (typeof subscribe === "function") {
        maybeUnsubscribe(dep_1);
        dep_1.unsubscribe = subscribe(key);
      }
    }
  }
  depend.dirty = function dirty(key, entryMethodName) {
    var dep2 = depsByKey.get(key);
    if (dep2) {
      var m_1 = entryMethodName && hasOwnProperty$d.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
      toArray$c(dep2).forEach(function(entry) {
        return entry[m_1]();
      });
      depsByKey.delete(key);
      maybeUnsubscribe(dep2);
    }
  };
  return depend;
}
function makeDefaultMakeCacheKeyFunction() {
  var keyTrie = new Trie(typeof WeakMap === "function");
  return function() {
    return keyTrie.lookupArray(arguments);
  };
}
makeDefaultMakeCacheKeyFunction();
var caches = /* @__PURE__ */ new Set();
function wrap$2(originalFunction, options) {
  if (options === void 0) {
    options = /* @__PURE__ */ Object.create(null);
  }
  var cache2 = new Cache$1(options.max || Math.pow(2, 16), function(entry) {
    return entry.dispose();
  });
  var keyArgs = options.keyArgs;
  var makeCacheKey = options.makeCacheKey || makeDefaultMakeCacheKeyFunction();
  var optimistic = function() {
    var key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
    if (key === void 0) {
      return originalFunction.apply(null, arguments);
    }
    var entry = cache2.get(key);
    if (!entry) {
      cache2.set(key, entry = new Entry(originalFunction));
      entry.subscribe = options.subscribe;
      entry.forget = function() {
        return cache2.delete(key);
      };
    }
    var value = entry.recompute(Array.prototype.slice.call(arguments));
    cache2.set(key, entry);
    caches.add(cache2);
    if (!parentEntrySlot.hasValue()) {
      caches.forEach(function(cache3) {
        return cache3.clean();
      });
      caches.clear();
    }
    return value;
  };
  Object.defineProperty(optimistic, "size", {
    get: function() {
      return cache2["map"].size;
    },
    configurable: false,
    enumerable: false
  });
  function dirtyKey(key) {
    var entry = cache2.get(key);
    if (entry) {
      entry.setDirty();
    }
  }
  optimistic.dirtyKey = dirtyKey;
  optimistic.dirty = function dirty() {
    dirtyKey(makeCacheKey.apply(null, arguments));
  };
  function peekKey(key) {
    var entry = cache2.get(key);
    if (entry) {
      return entry.peek();
    }
  }
  optimistic.peekKey = peekKey;
  optimistic.peek = function peek2() {
    return peekKey(makeCacheKey.apply(null, arguments));
  };
  function forgetKey(key) {
    return cache2.delete(key);
  }
  optimistic.forgetKey = forgetKey;
  optimistic.forget = function forget() {
    return forgetKey(makeCacheKey.apply(null, arguments));
  };
  optimistic.makeCacheKey = makeCacheKey;
  optimistic.getKey = keyArgs ? function getKey3() {
    return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
  } : makeCacheKey;
  return Object.freeze(optimistic);
}
var ApolloCache = function() {
  function ApolloCache2() {
    this.getFragmentDoc = wrap$2(getFragmentQueryDocument);
  }
  ApolloCache2.prototype.batch = function(options) {
    var _this = this;
    var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
    var updateResult;
    this.performTransaction(function() {
      return updateResult = options.update(_this);
    }, optimisticId);
    return updateResult;
  };
  ApolloCache2.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
    this.performTransaction(transaction, optimisticId);
  };
  ApolloCache2.prototype.transformDocument = function(document2) {
    return document2;
  };
  ApolloCache2.prototype.transformForLink = function(document2) {
    return document2;
  };
  ApolloCache2.prototype.identify = function(object4) {
    return;
  };
  ApolloCache2.prototype.gc = function() {
    return [];
  };
  ApolloCache2.prototype.modify = function(options) {
    return false;
  };
  ApolloCache2.prototype.readQuery = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = !!options.optimistic;
    }
    return this.read(__assign$1(__assign$1({}, options), { rootId: options.id || "ROOT_QUERY", optimistic }));
  };
  ApolloCache2.prototype.readFragment = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = !!options.optimistic;
    }
    return this.read(__assign$1(__assign$1({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic }));
  };
  ApolloCache2.prototype.writeQuery = function(_a2) {
    var id = _a2.id, data2 = _a2.data, options = __rest$G(_a2, ["id", "data"]);
    return this.write(Object.assign(options, {
      dataId: id || "ROOT_QUERY",
      result: data2
    }));
  };
  ApolloCache2.prototype.writeFragment = function(_a2) {
    var id = _a2.id, data2 = _a2.data, fragment = _a2.fragment, fragmentName = _a2.fragmentName, options = __rest$G(_a2, ["id", "data", "fragment", "fragmentName"]);
    return this.write(Object.assign(options, {
      query: this.getFragmentDoc(fragment, fragmentName),
      dataId: id,
      result: data2
    }));
  };
  ApolloCache2.prototype.updateQuery = function(options, update) {
    return this.batch({
      update: function(cache2) {
        var value = cache2.readQuery(options);
        var data2 = update(value);
        if (data2 === void 0 || data2 === null)
          return value;
        cache2.writeQuery(__assign$1(__assign$1({}, options), { data: data2 }));
        return data2;
      }
    });
  };
  ApolloCache2.prototype.updateFragment = function(options, update) {
    return this.batch({
      update: function(cache2) {
        var value = cache2.readFragment(options);
        var data2 = update(value);
        if (data2 === void 0 || data2 === null)
          return value;
        cache2.writeFragment(__assign$1(__assign$1({}, options), { data: data2 }));
        return data2;
      }
    });
  };
  return ApolloCache2;
}();
var Cache;
(function(Cache2) {
})(Cache || (Cache = {}));
var MissingFieldError = function(_super) {
  __extends$1(MissingFieldError2, _super);
  function MissingFieldError2(message, path2, query, variables) {
    var _a2;
    var _this = _super.call(this, message) || this;
    _this.message = message;
    _this.path = path2;
    _this.query = query;
    _this.variables = variables;
    if (Array.isArray(_this.path)) {
      _this.missing = _this.message;
      for (var i = _this.path.length - 1; i >= 0; --i) {
        _this.missing = (_a2 = {}, _a2[_this.path[i]] = _this.missing, _a2);
      }
    } else {
      _this.missing = _this.path;
    }
    _this.__proto__ = MissingFieldError2.prototype;
    return _this;
  }
  return MissingFieldError2;
}(Error);
var hasOwn$1 = Object.prototype.hasOwnProperty;
function isNullish(value) {
  return value === null || value === void 0;
}
var isArray$5 = Array.isArray;
function defaultDataIdFromObject(_a2, context2) {
  var __typename = _a2.__typename, id = _a2.id, _id = _a2._id;
  if (typeof __typename === "string") {
    if (context2) {
      context2.keyObject = !isNullish(id) ? { id } : !isNullish(_id) ? { _id } : void 0;
    }
    if (isNullish(id) && !isNullish(_id)) {
      id = _id;
    }
    if (!isNullish(id)) {
      return "".concat(__typename, ":").concat(typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id));
    }
  }
}
var defaultConfig$2 = {
  dataIdFromObject: defaultDataIdFromObject,
  addTypename: true,
  resultCaching: true,
  canonizeResults: false
};
function normalizeConfig(config) {
  return compact$1(defaultConfig$2, config);
}
function shouldCanonizeResults(config) {
  var value = config.canonizeResults;
  return value === void 0 ? defaultConfig$2.canonizeResults : value;
}
function getTypenameFromStoreObject(store, objectOrReference) {
  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
}
var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
function fieldNameFromStoreName(storeFieldName) {
  var match2 = storeFieldName.match(TypeOrFieldNameRegExp);
  return match2 ? match2[0] : storeFieldName;
}
function selectionSetMatchesResult(selectionSet, result, variables) {
  if (isNonNullObject(result)) {
    return isArray$5(result) ? result.every(function(item) {
      return selectionSetMatchesResult(selectionSet, item, variables);
    }) : selectionSet.selections.every(function(field) {
      if (isField(field) && shouldInclude(field, variables)) {
        var key = resultKeyNameFromField(field);
        return hasOwn$1.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));
      }
      return true;
    });
  }
  return false;
}
function storeValueIsStoreObject(value) {
  return isNonNullObject(value) && !isReference(value) && !isArray$5(value);
}
function makeProcessedFieldsMerger() {
  return new DeepMerger();
}
function extractFragmentContext(document2, fragments) {
  var fragmentMap = createFragmentMap(getFragmentDefinitions(document2));
  return {
    fragmentMap,
    lookupFragment: function(name) {
      var def = fragmentMap[name];
      if (!def && fragments) {
        def = fragments.lookup(name);
      }
      return def || null;
    }
  };
}
var DELETE = /* @__PURE__ */ Object.create(null);
var delModifier = function() {
  return DELETE;
};
var INVALIDATE$3 = /* @__PURE__ */ Object.create(null);
var EntityStore = function() {
  function EntityStore2(policies, group2) {
    var _this = this;
    this.policies = policies;
    this.group = group2;
    this.data = /* @__PURE__ */ Object.create(null);
    this.rootIds = /* @__PURE__ */ Object.create(null);
    this.refs = /* @__PURE__ */ Object.create(null);
    this.getFieldValue = function(objectOrReference, storeFieldName) {
      return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
    };
    this.canRead = function(objOrRef) {
      return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
    };
    this.toReference = function(objOrIdOrRef, mergeIntoStore) {
      if (typeof objOrIdOrRef === "string") {
        return makeReference(objOrIdOrRef);
      }
      if (isReference(objOrIdOrRef)) {
        return objOrIdOrRef;
      }
      var id = _this.policies.identify(objOrIdOrRef)[0];
      if (id) {
        var ref2 = makeReference(id);
        if (mergeIntoStore) {
          _this.merge(id, objOrIdOrRef);
        }
        return ref2;
      }
    };
  }
  EntityStore2.prototype.toObject = function() {
    return __assign$1({}, this.data);
  };
  EntityStore2.prototype.has = function(dataId) {
    return this.lookup(dataId, true) !== void 0;
  };
  EntityStore2.prototype.get = function(dataId, fieldName) {
    this.group.depend(dataId, fieldName);
    if (hasOwn$1.call(this.data, dataId)) {
      var storeObject = this.data[dataId];
      if (storeObject && hasOwn$1.call(storeObject, fieldName)) {
        return storeObject[fieldName];
      }
    }
    if (fieldName === "__typename" && hasOwn$1.call(this.policies.rootTypenamesById, dataId)) {
      return this.policies.rootTypenamesById[dataId];
    }
    if (this instanceof Layer) {
      return this.parent.get(dataId, fieldName);
    }
  };
  EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
    if (dependOnExistence)
      this.group.depend(dataId, "__exists");
    if (hasOwn$1.call(this.data, dataId)) {
      return this.data[dataId];
    }
    if (this instanceof Layer) {
      return this.parent.lookup(dataId, dependOnExistence);
    }
    if (this.policies.rootTypenamesById[dataId]) {
      return /* @__PURE__ */ Object.create(null);
    }
  };
  EntityStore2.prototype.merge = function(older, newer) {
    var _this = this;
    var dataId;
    if (isReference(older))
      older = older.__ref;
    if (isReference(newer))
      newer = newer.__ref;
    var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
    var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
    if (!incoming)
      return;
    __DEV__ ? invariant$1(typeof dataId === "string", "store.merge expects a string ID") : invariant$1(typeof dataId === "string", 1);
    var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
    this.data[dataId] = merged;
    if (merged !== existing) {
      delete this.refs[dataId];
      if (this.group.caching) {
        var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
        if (!existing)
          fieldsToDirty_1.__exists = 1;
        Object.keys(incoming).forEach(function(storeFieldName) {
          if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
            fieldsToDirty_1[storeFieldName] = 1;
            var fieldName = fieldNameFromStoreName(storeFieldName);
            if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
              fieldsToDirty_1[fieldName] = 1;
            }
            if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
              delete merged[storeFieldName];
            }
          }
        });
        if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && this.policies.rootTypenamesById[dataId] === merged.__typename) {
          delete fieldsToDirty_1.__typename;
        }
        Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
          return _this.group.dirty(dataId, fieldName);
        });
      }
    }
  };
  EntityStore2.prototype.modify = function(dataId, fields) {
    var _this = this;
    var storeObject = this.lookup(dataId);
    if (storeObject) {
      var changedFields_1 = /* @__PURE__ */ Object.create(null);
      var needToMerge_1 = false;
      var allDeleted_1 = true;
      var sharedDetails_1 = {
        DELETE,
        INVALIDATE: INVALIDATE$3,
        isReference,
        toReference: this.toReference,
        canRead: this.canRead,
        readField: function(fieldNameOrOptions, from2) {
          return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
            fieldName: fieldNameOrOptions,
            from: from2 || makeReference(dataId)
          } : fieldNameOrOptions, { store: _this });
        }
      };
      Object.keys(storeObject).forEach(function(storeFieldName) {
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var fieldValue = storeObject[storeFieldName];
        if (fieldValue === void 0)
          return;
        var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
        if (modify) {
          var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign$1(__assign$1({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
          if (newValue === INVALIDATE$3) {
            _this.group.dirty(dataId, storeFieldName);
          } else {
            if (newValue === DELETE)
              newValue = void 0;
            if (newValue !== fieldValue) {
              changedFields_1[storeFieldName] = newValue;
              needToMerge_1 = true;
              fieldValue = newValue;
            }
          }
        }
        if (fieldValue !== void 0) {
          allDeleted_1 = false;
        }
      });
      if (needToMerge_1) {
        this.merge(dataId, changedFields_1);
        if (allDeleted_1) {
          if (this instanceof Layer) {
            this.data[dataId] = void 0;
          } else {
            delete this.data[dataId];
          }
          this.group.dirty(dataId, "__exists");
        }
        return true;
      }
    }
    return false;
  };
  EntityStore2.prototype.delete = function(dataId, fieldName, args) {
    var _a2;
    var storeObject = this.lookup(dataId);
    if (storeObject) {
      var typename = this.getFieldValue(storeObject, "__typename");
      var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
      return this.modify(dataId, storeFieldName ? (_a2 = {}, _a2[storeFieldName] = delModifier, _a2) : delModifier);
    }
    return false;
  };
  EntityStore2.prototype.evict = function(options, limit) {
    var evicted = false;
    if (options.id) {
      if (hasOwn$1.call(this.data, options.id)) {
        evicted = this.delete(options.id, options.fieldName, options.args);
      }
      if (this instanceof Layer && this !== limit) {
        evicted = this.parent.evict(options, limit) || evicted;
      }
      if (options.fieldName || evicted) {
        this.group.dirty(options.id, options.fieldName || "__exists");
      }
    }
    return evicted;
  };
  EntityStore2.prototype.clear = function() {
    this.replace(null);
  };
  EntityStore2.prototype.extract = function() {
    var _this = this;
    var obj = this.toObject();
    var extraRootIds = [];
    this.getRootIdSet().forEach(function(id) {
      if (!hasOwn$1.call(_this.policies.rootTypenamesById, id)) {
        extraRootIds.push(id);
      }
    });
    if (extraRootIds.length) {
      obj.__META = { extraRootIds: extraRootIds.sort() };
    }
    return obj;
  };
  EntityStore2.prototype.replace = function(newData) {
    var _this = this;
    Object.keys(this.data).forEach(function(dataId) {
      if (!(newData && hasOwn$1.call(newData, dataId))) {
        _this.delete(dataId);
      }
    });
    if (newData) {
      var __META = newData.__META, rest_1 = __rest$G(newData, ["__META"]);
      Object.keys(rest_1).forEach(function(dataId) {
        _this.merge(dataId, rest_1[dataId]);
      });
      if (__META) {
        __META.extraRootIds.forEach(this.retain, this);
      }
    }
  };
  EntityStore2.prototype.retain = function(rootId) {
    return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
  };
  EntityStore2.prototype.release = function(rootId) {
    if (this.rootIds[rootId] > 0) {
      var count = --this.rootIds[rootId];
      if (!count)
        delete this.rootIds[rootId];
      return count;
    }
    return 0;
  };
  EntityStore2.prototype.getRootIdSet = function(ids) {
    if (ids === void 0) {
      ids = /* @__PURE__ */ new Set();
    }
    Object.keys(this.rootIds).forEach(ids.add, ids);
    if (this instanceof Layer) {
      this.parent.getRootIdSet(ids);
    } else {
      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
    }
    return ids;
  };
  EntityStore2.prototype.gc = function() {
    var _this = this;
    var ids = this.getRootIdSet();
    var snapshot = this.toObject();
    ids.forEach(function(id) {
      if (hasOwn$1.call(snapshot, id)) {
        Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
        delete snapshot[id];
      }
    });
    var idsToRemove = Object.keys(snapshot);
    if (idsToRemove.length) {
      var root_1 = this;
      while (root_1 instanceof Layer)
        root_1 = root_1.parent;
      idsToRemove.forEach(function(id) {
        return root_1.delete(id);
      });
    }
    return idsToRemove;
  };
  EntityStore2.prototype.findChildRefIds = function(dataId) {
    if (!hasOwn$1.call(this.refs, dataId)) {
      var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
      var root2 = this.data[dataId];
      if (!root2)
        return found_1;
      var workSet_1 = /* @__PURE__ */ new Set([root2]);
      workSet_1.forEach(function(obj) {
        if (isReference(obj)) {
          found_1[obj.__ref] = true;
        }
        if (isNonNullObject(obj)) {
          Object.keys(obj).forEach(function(key) {
            var child = obj[key];
            if (isNonNullObject(child)) {
              workSet_1.add(child);
            }
          });
        }
      });
    }
    return this.refs[dataId];
  };
  EntityStore2.prototype.makeCacheKey = function() {
    return this.group.keyMaker.lookupArray(arguments);
  };
  return EntityStore2;
}();
var CacheGroup = function() {
  function CacheGroup2(caching, parent) {
    if (parent === void 0) {
      parent = null;
    }
    this.caching = caching;
    this.parent = parent;
    this.d = null;
    this.resetCaching();
  }
  CacheGroup2.prototype.resetCaching = function() {
    this.d = this.caching ? dep() : null;
    this.keyMaker = new Trie(canUseWeakMap);
  };
  CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
    if (this.d) {
      this.d(makeDepKey(dataId, storeFieldName));
      var fieldName = fieldNameFromStoreName(storeFieldName);
      if (fieldName !== storeFieldName) {
        this.d(makeDepKey(dataId, fieldName));
      }
      if (this.parent) {
        this.parent.depend(dataId, storeFieldName);
      }
    }
  };
  CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
    if (this.d) {
      this.d.dirty(makeDepKey(dataId, storeFieldName), storeFieldName === "__exists" ? "forget" : "setDirty");
    }
  };
  return CacheGroup2;
}();
function makeDepKey(dataId, storeFieldName) {
  return storeFieldName + "#" + dataId;
}
function maybeDependOnExistenceOfEntity(store, entityId) {
  if (supportsResultCaching(store)) {
    store.group.depend(entityId, "__exists");
  }
}
(function(EntityStore2) {
  var Root = function(_super) {
    __extends$1(Root2, _super);
    function Root2(_a2) {
      var policies = _a2.policies, _b = _a2.resultCaching, resultCaching = _b === void 0 ? true : _b, seed2 = _a2.seed;
      var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
      _this.stump = new Stump(_this);
      _this.storageTrie = new Trie(canUseWeakMap);
      if (seed2)
        _this.replace(seed2);
      return _this;
    }
    Root2.prototype.addLayer = function(layerId, replay) {
      return this.stump.addLayer(layerId, replay);
    };
    Root2.prototype.removeLayer = function() {
      return this;
    };
    Root2.prototype.getStorage = function() {
      return this.storageTrie.lookupArray(arguments);
    };
    return Root2;
  }(EntityStore2);
  EntityStore2.Root = Root;
})(EntityStore || (EntityStore = {}));
var Layer = function(_super) {
  __extends$1(Layer2, _super);
  function Layer2(id, parent, replay, group2) {
    var _this = _super.call(this, parent.policies, group2) || this;
    _this.id = id;
    _this.parent = parent;
    _this.replay = replay;
    _this.group = group2;
    replay(_this);
    return _this;
  }
  Layer2.prototype.addLayer = function(layerId, replay) {
    return new Layer2(layerId, this, replay, this.group);
  };
  Layer2.prototype.removeLayer = function(layerId) {
    var _this = this;
    var parent = this.parent.removeLayer(layerId);
    if (layerId === this.id) {
      if (this.group.caching) {
        Object.keys(this.data).forEach(function(dataId) {
          var ownStoreObject = _this.data[dataId];
          var parentStoreObject = parent["lookup"](dataId);
          if (!parentStoreObject) {
            _this.delete(dataId);
          } else if (!ownStoreObject) {
            _this.group.dirty(dataId, "__exists");
            Object.keys(parentStoreObject).forEach(function(storeFieldName) {
              _this.group.dirty(dataId, storeFieldName);
            });
          } else if (ownStoreObject !== parentStoreObject) {
            Object.keys(ownStoreObject).forEach(function(storeFieldName) {
              if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                _this.group.dirty(dataId, storeFieldName);
              }
            });
          }
        });
      }
      return parent;
    }
    if (parent === this.parent)
      return this;
    return parent.addLayer(this.id, this.replay);
  };
  Layer2.prototype.toObject = function() {
    return __assign$1(__assign$1({}, this.parent.toObject()), this.data);
  };
  Layer2.prototype.findChildRefIds = function(dataId) {
    var fromParent = this.parent.findChildRefIds(dataId);
    return hasOwn$1.call(this.data, dataId) ? __assign$1(__assign$1({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
  };
  Layer2.prototype.getStorage = function() {
    var p2 = this.parent;
    while (p2.parent)
      p2 = p2.parent;
    return p2.getStorage.apply(p2, arguments);
  };
  return Layer2;
}(EntityStore);
var Stump = function(_super) {
  __extends$1(Stump2, _super);
  function Stump2(root2) {
    return _super.call(this, "EntityStore.Stump", root2, function() {
    }, new CacheGroup(root2.group.caching, root2.group)) || this;
  }
  Stump2.prototype.removeLayer = function() {
    return this;
  };
  Stump2.prototype.merge = function() {
    return this.parent.merge.apply(this.parent, arguments);
  };
  return Stump2;
}(Layer);
function storeObjectReconciler(existingObject, incomingObject, property) {
  var existingValue = existingObject[property];
  var incomingValue = incomingObject[property];
  return equal(existingValue, incomingValue) ? existingValue : incomingValue;
}
function supportsResultCaching(store) {
  return !!(store instanceof EntityStore && store.group.caching);
}
function shallowCopy(value) {
  if (isNonNullObject(value)) {
    return isArray$5(value) ? value.slice(0) : __assign$1({ __proto__: Object.getPrototypeOf(value) }, value);
  }
  return value;
}
var ObjectCanon = function() {
  function ObjectCanon2() {
    this.known = new (canUseWeakSet ? WeakSet : Set)();
    this.pool = new Trie(canUseWeakMap);
    this.passes = /* @__PURE__ */ new WeakMap();
    this.keysByJSON = /* @__PURE__ */ new Map();
    this.empty = this.admit({});
  }
  ObjectCanon2.prototype.isKnown = function(value) {
    return isNonNullObject(value) && this.known.has(value);
  };
  ObjectCanon2.prototype.pass = function(value) {
    if (isNonNullObject(value)) {
      var copy2 = shallowCopy(value);
      this.passes.set(copy2, value);
      return copy2;
    }
    return value;
  };
  ObjectCanon2.prototype.admit = function(value) {
    var _this = this;
    if (isNonNullObject(value)) {
      var original = this.passes.get(value);
      if (original)
        return original;
      var proto = Object.getPrototypeOf(value);
      switch (proto) {
        case Array.prototype: {
          if (this.known.has(value))
            return value;
          var array4 = value.map(this.admit, this);
          var node2 = this.pool.lookupArray(array4);
          if (!node2.array) {
            this.known.add(node2.array = array4);
            if (__DEV__) {
              Object.freeze(array4);
            }
          }
          return node2.array;
        }
        case null:
        case Object.prototype: {
          if (this.known.has(value))
            return value;
          var proto_1 = Object.getPrototypeOf(value);
          var array_1 = [proto_1];
          var keys2 = this.sortedKeys(value);
          array_1.push(keys2.json);
          var firstValueIndex_1 = array_1.length;
          keys2.sorted.forEach(function(key) {
            array_1.push(_this.admit(value[key]));
          });
          var node2 = this.pool.lookupArray(array_1);
          if (!node2.object) {
            var obj_1 = node2.object = Object.create(proto_1);
            this.known.add(obj_1);
            keys2.sorted.forEach(function(key, i) {
              obj_1[key] = array_1[firstValueIndex_1 + i];
            });
            if (__DEV__) {
              Object.freeze(obj_1);
            }
          }
          return node2.object;
        }
      }
    }
    return value;
  };
  ObjectCanon2.prototype.sortedKeys = function(obj) {
    var keys2 = Object.keys(obj);
    var node2 = this.pool.lookupArray(keys2);
    if (!node2.keys) {
      keys2.sort();
      var json = JSON.stringify(keys2);
      if (!(node2.keys = this.keysByJSON.get(json))) {
        this.keysByJSON.set(json, node2.keys = { sorted: keys2, json });
      }
    }
    return node2.keys;
  };
  return ObjectCanon2;
}();
var canonicalStringify = Object.assign(function(value) {
  if (isNonNullObject(value)) {
    if (stringifyCanon === void 0) {
      resetCanonicalStringify();
    }
    var canonical = stringifyCanon.admit(value);
    var json = stringifyCache.get(canonical);
    if (json === void 0) {
      stringifyCache.set(canonical, json = JSON.stringify(canonical));
    }
    return json;
  }
  return JSON.stringify(value);
}, {
  reset: resetCanonicalStringify
});
var stringifyCanon;
var stringifyCache;
function resetCanonicalStringify() {
  stringifyCanon = new ObjectCanon();
  stringifyCache = new (canUseWeakMap ? WeakMap : Map)();
}
function execSelectionSetKeyArgs(options) {
  return [
    options.selectionSet,
    options.objectOrReference,
    options.context,
    options.context.canonizeResults
  ];
}
var StoreReader = function() {
  function StoreReader2(config) {
    var _this = this;
    this.knownResults = new (canUseWeakMap ? WeakMap : Map)();
    this.config = compact$1(config, {
      addTypename: config.addTypename !== false,
      canonizeResults: shouldCanonizeResults(config)
    });
    this.canon = config.canon || new ObjectCanon();
    this.executeSelectionSet = wrap$2(function(options) {
      var _a2;
      var canonizeResults = options.context.canonizeResults;
      var peekArgs = execSelectionSetKeyArgs(options);
      peekArgs[3] = !canonizeResults;
      var other = (_a2 = _this.executeSelectionSet).peek.apply(_a2, peekArgs);
      if (other) {
        if (canonizeResults) {
          return __assign$1(__assign$1({}, other), { result: _this.canon.admit(other.result) });
        }
        return other;
      }
      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
      return _this.execSelectionSetImpl(options);
    }, {
      max: this.config.resultCacheMaxSize,
      keyArgs: execSelectionSetKeyArgs,
      makeCacheKey: function(selectionSet, parent, context2, canonizeResults) {
        if (supportsResultCaching(context2.store)) {
          return context2.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context2.varString, canonizeResults);
        }
      }
    });
    this.executeSubSelectedArray = wrap$2(function(options) {
      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
      return _this.execSubSelectedArrayImpl(options);
    }, {
      max: this.config.resultCacheMaxSize,
      makeCacheKey: function(_a2) {
        var field = _a2.field, array4 = _a2.array, context2 = _a2.context;
        if (supportsResultCaching(context2.store)) {
          return context2.store.makeCacheKey(field, array4, context2.varString);
        }
      }
    });
  }
  StoreReader2.prototype.resetCanon = function() {
    this.canon = new ObjectCanon();
  };
  StoreReader2.prototype.diffQueryAgainstStore = function(_a2) {
    var store = _a2.store, query = _a2.query, _b = _a2.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a2.variables, _c = _a2.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a2.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
    var policies = this.config.cache.policies;
    variables = __assign$1(__assign$1({}, getDefaultValues(getQueryDefinition(query))), variables);
    var rootRef = makeReference(rootId);
    var execResult = this.executeSelectionSet({
      selectionSet: getMainDefinition(query).selectionSet,
      objectOrReference: rootRef,
      enclosingRef: rootRef,
      context: __assign$1({ store, query, policies, variables, varString: canonicalStringify(variables), canonizeResults }, extractFragmentContext(query, this.config.fragments))
    });
    var missing;
    if (execResult.missing) {
      missing = [new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)];
      if (!returnPartialData) {
        throw missing[0];
      }
    }
    return {
      result: execResult.result,
      complete: !missing,
      missing
    };
  };
  StoreReader2.prototype.isFresh = function(result, parent, selectionSet, context2) {
    if (supportsResultCaching(context2.store) && this.knownResults.get(result) === selectionSet) {
      var latest = this.executeSelectionSet.peek(selectionSet, parent, context2, this.canon.isKnown(result));
      if (latest && result === latest.result) {
        return true;
      }
    }
    return false;
  };
  StoreReader2.prototype.execSelectionSetImpl = function(_a2) {
    var _this = this;
    var selectionSet = _a2.selectionSet, objectOrReference = _a2.objectOrReference, enclosingRef = _a2.enclosingRef, context2 = _a2.context;
    if (isReference(objectOrReference) && !context2.policies.rootTypenamesById[objectOrReference.__ref] && !context2.store.has(objectOrReference.__ref)) {
      return {
        result: this.canon.empty,
        missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
      };
    }
    var variables = context2.variables, policies = context2.policies, store = context2.store;
    var typename = store.getFieldValue(objectOrReference, "__typename");
    var objectsToMerge = [];
    var missing;
    var missingMerger = new DeepMerger();
    if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
      objectsToMerge.push({ __typename: typename });
    }
    function handleMissing(result2, resultName) {
      var _a3;
      if (result2.missing) {
        missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = result2.missing, _a3));
      }
      return result2.result;
    }
    var workSet = new Set(selectionSet.selections);
    workSet.forEach(function(selection) {
      var _a3, _b;
      if (!shouldInclude(selection, variables))
        return;
      if (isField(selection)) {
        var fieldValue = policies.readField({
          fieldName: selection.name.value,
          field: selection,
          variables: context2.variables,
          from: objectOrReference
        }, context2);
        var resultName = resultKeyNameFromField(selection);
        if (fieldValue === void 0) {
          if (!addTypenameToDocument.added(selection)) {
            missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a3));
          }
        } else if (isArray$5(fieldValue)) {
          fieldValue = handleMissing(_this.executeSubSelectedArray({
            field: selection,
            array: fieldValue,
            enclosingRef,
            context: context2
          }), resultName);
        } else if (!selection.selectionSet) {
          if (context2.canonizeResults) {
            fieldValue = _this.canon.pass(fieldValue);
          }
        } else if (fieldValue != null) {
          fieldValue = handleMissing(_this.executeSelectionSet({
            selectionSet: selection.selectionSet,
            objectOrReference: fieldValue,
            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,
            context: context2
          }), resultName);
        }
        if (fieldValue !== void 0) {
          objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
        }
      } else {
        var fragment = getFragmentFromSelection(selection, context2.lookupFragment);
        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
          throw __DEV__ ? new InvariantError("No fragment named ".concat(selection.name.value)) : new InvariantError(5);
        }
        if (fragment && policies.fragmentMatches(fragment, typename)) {
          fragment.selectionSet.selections.forEach(workSet.add, workSet);
        }
      }
    });
    var result = mergeDeepArray(objectsToMerge);
    var finalResult = { result, missing };
    var frozen = context2.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze(finalResult);
    if (frozen.result) {
      this.knownResults.set(frozen.result, selectionSet);
    }
    return frozen;
  };
  StoreReader2.prototype.execSubSelectedArrayImpl = function(_a2) {
    var _this = this;
    var field = _a2.field, array4 = _a2.array, enclosingRef = _a2.enclosingRef, context2 = _a2.context;
    var missing;
    var missingMerger = new DeepMerger();
    function handleMissing(childResult, i) {
      var _a3;
      if (childResult.missing) {
        missing = missingMerger.merge(missing, (_a3 = {}, _a3[i] = childResult.missing, _a3));
      }
      return childResult.result;
    }
    if (field.selectionSet) {
      array4 = array4.filter(context2.store.canRead);
    }
    array4 = array4.map(function(item, i) {
      if (item === null) {
        return null;
      }
      if (isArray$5(item)) {
        return handleMissing(_this.executeSubSelectedArray({
          field,
          array: item,
          enclosingRef,
          context: context2
        }), i);
      }
      if (field.selectionSet) {
        return handleMissing(_this.executeSelectionSet({
          selectionSet: field.selectionSet,
          objectOrReference: item,
          enclosingRef: isReference(item) ? item : enclosingRef,
          context: context2
        }), i);
      }
      if (__DEV__) {
        assertSelectionSetForIdValue(context2.store, field, item);
      }
      return item;
    });
    return {
      result: context2.canonizeResults ? this.canon.admit(array4) : array4,
      missing
    };
  };
  return StoreReader2;
}();
function firstMissing(tree) {
  try {
    JSON.stringify(tree, function(_24, value) {
      if (typeof value === "string")
        throw value;
      return value;
    });
  } catch (result) {
    return result;
  }
}
function assertSelectionSetForIdValue(store, field, fieldValue) {
  if (!field.selectionSet) {
    var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
    workSet_1.forEach(function(value) {
      if (isNonNullObject(value)) {
        __DEV__ ? invariant$1(!isReference(value), "Missing selection set for object of type ".concat(getTypenameFromStoreObject(store, value), " returned for query field ").concat(field.name.value)) : invariant$1(!isReference(value), 6);
        Object.values(value).forEach(workSet_1.add, workSet_1);
      }
    });
  }
}
var currentContext = null;
var MISSING_VALUE = {};
var idCounter = 1;
var makeSlotClass = function() {
  return function() {
    function Slot2() {
      this.id = [
        "slot",
        idCounter++,
        Date.now(),
        Math.random().toString(36).slice(2)
      ].join(":");
    }
    Slot2.prototype.hasValue = function() {
      for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
        if (this.id in context_1.slots) {
          var value = context_1.slots[this.id];
          if (value === MISSING_VALUE)
            break;
          if (context_1 !== currentContext) {
            currentContext.slots[this.id] = value;
          }
          return true;
        }
      }
      if (currentContext) {
        currentContext.slots[this.id] = MISSING_VALUE;
      }
      return false;
    };
    Slot2.prototype.getValue = function() {
      if (this.hasValue()) {
        return currentContext.slots[this.id];
      }
    };
    Slot2.prototype.withValue = function(value, callback, args, thisArg) {
      var _a2;
      var slots = (_a2 = {
        __proto__: null
      }, _a2[this.id] = value, _a2);
      var parent = currentContext;
      currentContext = { parent, slots };
      try {
        return callback.apply(thisArg, args);
      } finally {
        currentContext = parent;
      }
    };
    Slot2.bind = function(callback) {
      var context2 = currentContext;
      return function() {
        var saved = currentContext;
        try {
          currentContext = context2;
          return callback.apply(this, arguments);
        } finally {
          currentContext = saved;
        }
      };
    };
    Slot2.noContext = function(callback, args, thisArg) {
      if (currentContext) {
        var saved = currentContext;
        try {
          currentContext = null;
          return callback.apply(thisArg, args);
        } finally {
          currentContext = saved;
        }
      } else {
        return callback.apply(thisArg, args);
      }
    };
    return Slot2;
  }();
};
function maybe(fn2) {
  try {
    return fn2();
  } catch (ignored) {
  }
}
var globalKey = "@wry/context:Slot";
var host = maybe(function() {
  return globalThis;
}) || maybe(function() {
  return global;
}) || /* @__PURE__ */ Object.create(null);
var globalHost = host;
var Slot = globalHost[globalKey] || Array[globalKey] || function(Slot2) {
  try {
    Object.defineProperty(globalHost, globalKey, {
      value: Slot2,
      enumerable: false,
      writable: false,
      configurable: true
    });
  } finally {
    return Slot2;
  }
}(makeSlotClass());
Slot.bind;
Slot.noContext;
var cacheSlot = new Slot();
var cacheInfoMap = /* @__PURE__ */ new WeakMap();
function getCacheInfo(cache2) {
  var info = cacheInfoMap.get(cache2);
  if (!info) {
    cacheInfoMap.set(cache2, info = {
      vars: /* @__PURE__ */ new Set(),
      dep: dep()
    });
  }
  return info;
}
function forgetCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.forgetCache(cache2);
  });
}
function recallCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.attachCache(cache2);
  });
}
function makeVar(value) {
  var caches2 = /* @__PURE__ */ new Set();
  var listeners = /* @__PURE__ */ new Set();
  var rv = function(newValue) {
    if (arguments.length > 0) {
      if (value !== newValue) {
        value = newValue;
        caches2.forEach(function(cache3) {
          getCacheInfo(cache3).dep.dirty(rv);
          broadcast(cache3);
        });
        var oldListeners = Array.from(listeners);
        listeners.clear();
        oldListeners.forEach(function(listener) {
          return listener(value);
        });
      }
    } else {
      var cache2 = cacheSlot.getValue();
      if (cache2) {
        attach(cache2);
        getCacheInfo(cache2).dep(rv);
      }
    }
    return value;
  };
  rv.onNextChange = function(listener) {
    listeners.add(listener);
    return function() {
      listeners.delete(listener);
    };
  };
  var attach = rv.attachCache = function(cache2) {
    caches2.add(cache2);
    getCacheInfo(cache2).vars.add(rv);
    return rv;
  };
  rv.forgetCache = function(cache2) {
    return caches2.delete(cache2);
  };
  return rv;
}
function broadcast(cache2) {
  if (cache2.broadcastWatches) {
    cache2.broadcastWatches();
  }
}
var specifierInfoCache = /* @__PURE__ */ Object.create(null);
function lookupSpecifierInfo(spec) {
  var cacheKey = JSON.stringify(spec);
  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = /* @__PURE__ */ Object.create(null));
}
function keyFieldsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyFieldsFn || (info.keyFieldsFn = function(object4, context2) {
    var extract = function(from2, key) {
      return context2.readField(key, from2);
    };
    var keyObject = context2.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {
      var extracted = extractKeyPath(context2.storeObject, schemaKeyPath, extract);
      if (extracted === void 0 && object4 !== context2.storeObject && hasOwn$1.call(object4, schemaKeyPath[0])) {
        extracted = extractKeyPath(object4, schemaKeyPath, extractKey);
      }
      __DEV__ ? invariant$1(extracted !== void 0, "Missing field '".concat(schemaKeyPath.join("."), "' while extracting keyFields from ").concat(JSON.stringify(object4))) : invariant$1(extracted !== void 0, 2);
      return extracted;
    });
    return "".concat(context2.typename, ":").concat(JSON.stringify(keyObject));
  });
}
function keyArgsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyArgsFn || (info.keyArgsFn = function(args, _a2) {
    var field = _a2.field, variables = _a2.variables, fieldName = _a2.fieldName;
    var collected = collectSpecifierPaths(specifier, function(keyPath) {
      var firstKey = keyPath[0];
      var firstChar = firstKey.charAt(0);
      if (firstChar === "@") {
        if (field && isNonEmptyArray(field.directives)) {
          var directiveName_1 = firstKey.slice(1);
          var d2 = field.directives.find(function(d3) {
            return d3.name.value === directiveName_1;
          });
          var directiveArgs = d2 && argumentsObjectFromField(d2, variables);
          return directiveArgs && extractKeyPath(directiveArgs, keyPath.slice(1));
        }
        return;
      }
      if (firstChar === "$") {
        var variableName = firstKey.slice(1);
        if (variables && hasOwn$1.call(variables, variableName)) {
          var varKeyPath = keyPath.slice(0);
          varKeyPath[0] = variableName;
          return extractKeyPath(variables, varKeyPath);
        }
        return;
      }
      if (args) {
        return extractKeyPath(args, keyPath);
      }
    });
    var suffix = JSON.stringify(collected);
    if (args || suffix !== "{}") {
      fieldName += ":" + suffix;
    }
    return fieldName;
  });
}
function collectSpecifierPaths(specifier, extractor) {
  var merger = new DeepMerger();
  return getSpecifierPaths(specifier).reduce(function(collected, path2) {
    var _a2;
    var toMerge = extractor(path2);
    if (toMerge !== void 0) {
      for (var i = path2.length - 1; i >= 0; --i) {
        toMerge = (_a2 = {}, _a2[path2[i]] = toMerge, _a2);
      }
      collected = merger.merge(collected, toMerge);
    }
    return collected;
  }, /* @__PURE__ */ Object.create(null));
}
function getSpecifierPaths(spec) {
  var info = lookupSpecifierInfo(spec);
  if (!info.paths) {
    var paths_1 = info.paths = [];
    var currentPath_1 = [];
    spec.forEach(function(s2, i) {
      if (isArray$5(s2)) {
        getSpecifierPaths(s2).forEach(function(p2) {
          return paths_1.push(currentPath_1.concat(p2));
        });
        currentPath_1.length = 0;
      } else {
        currentPath_1.push(s2);
        if (!isArray$5(spec[i + 1])) {
          paths_1.push(currentPath_1.slice(0));
          currentPath_1.length = 0;
        }
      }
    });
  }
  return info.paths;
}
function extractKey(object4, key) {
  return object4[key];
}
function extractKeyPath(object4, path2, extract) {
  extract = extract || extractKey;
  return normalize$5(path2.reduce(function reducer(obj, key) {
    return isArray$5(obj) ? obj.map(function(child) {
      return reducer(child, key);
    }) : obj && extract(obj, key);
  }, object4));
}
function normalize$5(value) {
  if (isNonNullObject(value)) {
    if (isArray$5(value)) {
      return value.map(normalize$5);
    }
    return collectSpecifierPaths(Object.keys(value).sort(), function(path2) {
      return extractKeyPath(value, path2);
    });
  }
  return value;
}
getStoreKeyName.setStringify(canonicalStringify);
function argsFromFieldSpecifier(spec) {
  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;
}
var nullKeyFieldsFn = function() {
  return void 0;
};
var simpleKeyArgsFn = function(_args, context2) {
  return context2.fieldName;
};
var mergeTrueFn = function(existing, incoming, _a2) {
  var mergeObjects = _a2.mergeObjects;
  return mergeObjects(existing, incoming);
};
var mergeFalseFn = function(_24, incoming) {
  return incoming;
};
var Policies = function() {
  function Policies2(config) {
    this.config = config;
    this.typePolicies = /* @__PURE__ */ Object.create(null);
    this.toBeAdded = /* @__PURE__ */ Object.create(null);
    this.supertypeMap = /* @__PURE__ */ new Map();
    this.fuzzySubtypes = /* @__PURE__ */ new Map();
    this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
    this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
    this.usingPossibleTypes = false;
    this.config = __assign$1({ dataIdFromObject: defaultDataIdFromObject }, config);
    this.cache = this.config.cache;
    this.setRootTypename("Query");
    this.setRootTypename("Mutation");
    this.setRootTypename("Subscription");
    if (config.possibleTypes) {
      this.addPossibleTypes(config.possibleTypes);
    }
    if (config.typePolicies) {
      this.addTypePolicies(config.typePolicies);
    }
  }
  Policies2.prototype.identify = function(object4, partialContext) {
    var _a2;
    var policies = this;
    var typename = partialContext && (partialContext.typename || ((_a2 = partialContext.storeObject) === null || _a2 === void 0 ? void 0 : _a2.__typename)) || object4.__typename;
    if (typename === this.rootTypenamesById.ROOT_QUERY) {
      return ["ROOT_QUERY"];
    }
    var storeObject = partialContext && partialContext.storeObject || object4;
    var context2 = __assign$1(__assign$1({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
      var options = normalizeReadFieldOptions(arguments, storeObject);
      return policies.readField(options, {
        store: policies.cache["data"],
        variables: options.variables
      });
    } });
    var id;
    var policy = typename && this.getTypePolicy(typename);
    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
    while (keyFn) {
      var specifierOrId = keyFn(object4, context2);
      if (isArray$5(specifierOrId)) {
        keyFn = keyFieldsFnFromSpecifier(specifierOrId);
      } else {
        id = specifierOrId;
        break;
      }
    }
    id = id ? String(id) : void 0;
    return context2.keyObject ? [id, context2.keyObject] : [id];
  };
  Policies2.prototype.addTypePolicies = function(typePolicies) {
    var _this = this;
    Object.keys(typePolicies).forEach(function(typename) {
      var _a2 = typePolicies[typename], queryType = _a2.queryType, mutationType = _a2.mutationType, subscriptionType = _a2.subscriptionType, incoming = __rest$G(_a2, ["queryType", "mutationType", "subscriptionType"]);
      if (queryType)
        _this.setRootTypename("Query", typename);
      if (mutationType)
        _this.setRootTypename("Mutation", typename);
      if (subscriptionType)
        _this.setRootTypename("Subscription", typename);
      if (hasOwn$1.call(_this.toBeAdded, typename)) {
        _this.toBeAdded[typename].push(incoming);
      } else {
        _this.toBeAdded[typename] = [incoming];
      }
    });
  };
  Policies2.prototype.updateTypePolicy = function(typename, incoming) {
    var _this = this;
    var existing = this.getTypePolicy(typename);
    var keyFields = incoming.keyFields, fields = incoming.fields;
    function setMerge(existing2, merge3) {
      existing2.merge = typeof merge3 === "function" ? merge3 : merge3 === true ? mergeTrueFn : merge3 === false ? mergeFalseFn : existing2.merge;
    }
    setMerge(existing, incoming.merge);
    existing.keyFn = keyFields === false ? nullKeyFieldsFn : isArray$5(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
    if (fields) {
      Object.keys(fields).forEach(function(fieldName) {
        var existing2 = _this.getFieldPolicy(typename, fieldName, true);
        var incoming2 = fields[fieldName];
        if (typeof incoming2 === "function") {
          existing2.read = incoming2;
        } else {
          var keyArgs = incoming2.keyArgs, read2 = incoming2.read, merge3 = incoming2.merge;
          existing2.keyFn = keyArgs === false ? simpleKeyArgsFn : isArray$5(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
          if (typeof read2 === "function") {
            existing2.read = read2;
          }
          setMerge(existing2, merge3);
        }
        if (existing2.read && existing2.merge) {
          existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
        }
      });
    }
  };
  Policies2.prototype.setRootTypename = function(which, typename) {
    if (typename === void 0) {
      typename = which;
    }
    var rootId = "ROOT_" + which.toUpperCase();
    var old = this.rootTypenamesById[rootId];
    if (typename !== old) {
      __DEV__ ? invariant$1(!old || old === which, "Cannot change root ".concat(which, " __typename more than once")) : invariant$1(!old || old === which, 3);
      if (old)
        delete this.rootIdsByTypename[old];
      this.rootIdsByTypename[typename] = rootId;
      this.rootTypenamesById[rootId] = typename;
    }
  };
  Policies2.prototype.addPossibleTypes = function(possibleTypes) {
    var _this = this;
    this.usingPossibleTypes = true;
    Object.keys(possibleTypes).forEach(function(supertype) {
      _this.getSupertypeSet(supertype, true);
      possibleTypes[supertype].forEach(function(subtype) {
        _this.getSupertypeSet(subtype, true).add(supertype);
        var match2 = subtype.match(TypeOrFieldNameRegExp);
        if (!match2 || match2[0] !== subtype) {
          _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
        }
      });
    });
  };
  Policies2.prototype.getTypePolicy = function(typename) {
    var _this = this;
    if (!hasOwn$1.call(this.typePolicies, typename)) {
      var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
      policy_1.fields = /* @__PURE__ */ Object.create(null);
      var supertypes = this.supertypeMap.get(typename);
      if (supertypes && supertypes.size) {
        supertypes.forEach(function(supertype) {
          var _a2 = _this.getTypePolicy(supertype), fields = _a2.fields, rest = __rest$G(_a2, ["fields"]);
          Object.assign(policy_1, rest);
          Object.assign(policy_1.fields, fields);
        });
      }
    }
    var inbox = this.toBeAdded[typename];
    if (inbox && inbox.length) {
      inbox.splice(0).forEach(function(policy) {
        _this.updateTypePolicy(typename, policy);
      });
    }
    return this.typePolicies[typename];
  };
  Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
    if (typename) {
      var fieldPolicies = this.getTypePolicy(typename).fields;
      return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
    }
  };
  Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
    var supertypeSet = this.supertypeMap.get(subtype);
    if (!supertypeSet && createIfMissing) {
      this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
    }
    return supertypeSet;
  };
  Policies2.prototype.fragmentMatches = function(fragment, typename, result, variables) {
    var _this = this;
    if (!fragment.typeCondition)
      return true;
    if (!typename)
      return false;
    var supertype = fragment.typeCondition.name.value;
    if (typename === supertype)
      return true;
    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
      var typenameSupertypeSet = this.getSupertypeSet(typename, true);
      var workQueue_1 = [typenameSupertypeSet];
      var maybeEnqueue_1 = function(subtype) {
        var supertypeSet2 = _this.getSupertypeSet(subtype, false);
        if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
          workQueue_1.push(supertypeSet2);
        }
      };
      var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
      var checkingFuzzySubtypes = false;
      for (var i = 0; i < workQueue_1.length; ++i) {
        var supertypeSet = workQueue_1[i];
        if (supertypeSet.has(supertype)) {
          if (!typenameSupertypeSet.has(supertype)) {
            if (checkingFuzzySubtypes) {
              __DEV__ && invariant$1.warn("Inferring subtype ".concat(typename, " of supertype ").concat(supertype));
            }
            typenameSupertypeSet.add(supertype);
          }
          return true;
        }
        supertypeSet.forEach(maybeEnqueue_1);
        if (needToCheckFuzzySubtypes && i === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
          needToCheckFuzzySubtypes = false;
          checkingFuzzySubtypes = true;
          this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
            var match2 = typename.match(regExp);
            if (match2 && match2[0] === typename) {
              maybeEnqueue_1(fuzzyString);
            }
          });
        }
      }
    }
    return false;
  };
  Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
    var policy = this.getFieldPolicy(typename, fieldName, false);
    return !!(policy && policy.keyFn);
  };
  Policies2.prototype.getStoreFieldName = function(fieldSpec) {
    var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
    var policy = this.getFieldPolicy(typename, fieldName, false);
    var storeFieldName;
    var keyFn = policy && policy.keyFn;
    if (keyFn && typename) {
      var context2 = {
        typename,
        fieldName,
        field: fieldSpec.field || null,
        variables: fieldSpec.variables
      };
      var args = argsFromFieldSpecifier(fieldSpec);
      while (keyFn) {
        var specifierOrString = keyFn(args, context2);
        if (isArray$5(specifierOrString)) {
          keyFn = keyArgsFnFromSpecifier(specifierOrString);
        } else {
          storeFieldName = specifierOrString || fieldName;
          break;
        }
      }
    }
    if (storeFieldName === void 0) {
      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
    }
    if (storeFieldName === false) {
      return fieldName;
    }
    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
  };
  Policies2.prototype.readField = function(options, context2) {
    var objectOrReference = options.from;
    if (!objectOrReference)
      return;
    var nameOrField = options.field || options.fieldName;
    if (!nameOrField)
      return;
    if (options.typename === void 0) {
      var typename = context2.store.getFieldValue(objectOrReference, "__typename");
      if (typename)
        options.typename = typename;
    }
    var storeFieldName = this.getStoreFieldName(options);
    var fieldName = fieldNameFromStoreName(storeFieldName);
    var existing = context2.store.getFieldValue(objectOrReference, storeFieldName);
    var policy = this.getFieldPolicy(options.typename, fieldName, false);
    var read2 = policy && policy.read;
    if (read2) {
      var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context2, context2.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
      return cacheSlot.withValue(this.cache, read2, [existing, readOptions]);
    }
    return existing;
  };
  Policies2.prototype.getReadFunction = function(typename, fieldName) {
    var policy = this.getFieldPolicy(typename, fieldName, false);
    return policy && policy.read;
  };
  Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
    var policy = this.getFieldPolicy(parentTypename, fieldName, false);
    var merge3 = policy && policy.merge;
    if (!merge3 && childTypename) {
      policy = this.getTypePolicy(childTypename);
      merge3 = policy && policy.merge;
    }
    return merge3;
  };
  Policies2.prototype.runMergeFunction = function(existing, incoming, _a2, context2, storage) {
    var field = _a2.field, typename = _a2.typename, merge3 = _a2.merge;
    if (merge3 === mergeTrueFn) {
      return makeMergeObjectsFunction(context2.store)(existing, incoming);
    }
    if (merge3 === mergeFalseFn) {
      return incoming;
    }
    if (context2.overwrite) {
      existing = void 0;
    }
    return merge3(existing, incoming, makeFieldFunctionOptions(this, void 0, { typename, fieldName: field.name.value, field, variables: context2.variables }, context2, storage || /* @__PURE__ */ Object.create(null)));
  };
  return Policies2;
}();
function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context2, storage) {
  var storeFieldName = policies.getStoreFieldName(fieldSpec);
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var variables = fieldSpec.variables || context2.variables;
  var _a2 = context2.store, toReference = _a2.toReference, canRead = _a2.canRead;
  return {
    args: argsFromFieldSpecifier(fieldSpec),
    field: fieldSpec.field || null,
    fieldName,
    storeFieldName,
    variables,
    isReference,
    toReference,
    storage,
    cache: policies.cache,
    canRead,
    readField: function() {
      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context2);
    },
    mergeObjects: makeMergeObjectsFunction(context2.store)
  };
}
function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
  var fieldNameOrOptions = readFieldArgs[0], from2 = readFieldArgs[1], argc = readFieldArgs.length;
  var options;
  if (typeof fieldNameOrOptions === "string") {
    options = {
      fieldName: fieldNameOrOptions,
      from: argc > 1 ? from2 : objectOrReference
    };
  } else {
    options = __assign$1({}, fieldNameOrOptions);
    if (!hasOwn$1.call(options, "from")) {
      options.from = objectOrReference;
    }
  }
  if (__DEV__ && options.from === void 0) {
    __DEV__ && invariant$1.warn("Undefined 'from' passed to readField with arguments ".concat(stringifyForDisplay(Array.from(readFieldArgs))));
  }
  if (void 0 === options.variables) {
    options.variables = variables;
  }
  return options;
}
function makeMergeObjectsFunction(store) {
  return function mergeObjects(existing, incoming) {
    if (isArray$5(existing) || isArray$5(incoming)) {
      throw __DEV__ ? new InvariantError("Cannot automatically merge arrays") : new InvariantError(4);
    }
    if (isNonNullObject(existing) && isNonNullObject(incoming)) {
      var eType = store.getFieldValue(existing, "__typename");
      var iType = store.getFieldValue(incoming, "__typename");
      var typesDiffer = eType && iType && eType !== iType;
      if (typesDiffer) {
        return incoming;
      }
      if (isReference(existing) && storeValueIsStoreObject(incoming)) {
        store.merge(existing.__ref, incoming);
        return existing;
      }
      if (storeValueIsStoreObject(existing) && isReference(incoming)) {
        store.merge(existing, incoming.__ref);
        return incoming;
      }
      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
        return __assign$1(__assign$1({}, existing), incoming);
      }
    }
    return incoming;
  };
}
function getContextFlavor(context2, clientOnly, deferred) {
  var key = "".concat(clientOnly).concat(deferred);
  var flavored = context2.flavors.get(key);
  if (!flavored) {
    context2.flavors.set(key, flavored = context2.clientOnly === clientOnly && context2.deferred === deferred ? context2 : __assign$1(__assign$1({}, context2), { clientOnly, deferred }));
  }
  return flavored;
}
var StoreWriter = function() {
  function StoreWriter2(cache2, reader, fragments) {
    this.cache = cache2;
    this.reader = reader;
    this.fragments = fragments;
  }
  StoreWriter2.prototype.writeToStore = function(store, _a2) {
    var _this = this;
    var query = _a2.query, result = _a2.result, dataId = _a2.dataId, variables = _a2.variables, overwrite = _a2.overwrite;
    var operationDefinition = getOperationDefinition(query);
    var merger = makeProcessedFieldsMerger();
    variables = __assign$1(__assign$1({}, getDefaultValues(operationDefinition)), variables);
    var context2 = __assign$1(__assign$1({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
      return merger.merge(existing, incoming);
    }, variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
    var ref2 = this.processSelectionSet({
      result: result || /* @__PURE__ */ Object.create(null),
      dataId,
      selectionSet: operationDefinition.selectionSet,
      mergeTree: { map: /* @__PURE__ */ new Map() },
      context: context2
    });
    if (!isReference(ref2)) {
      throw __DEV__ ? new InvariantError("Could not identify object ".concat(JSON.stringify(result))) : new InvariantError(7);
    }
    context2.incomingById.forEach(function(_a3, dataId2) {
      var storeObject = _a3.storeObject, mergeTree = _a3.mergeTree, fieldNodeSet = _a3.fieldNodeSet;
      var entityRef = makeReference(dataId2);
      if (mergeTree && mergeTree.map.size) {
        var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context2);
        if (isReference(applied)) {
          return;
        }
        storeObject = applied;
      }
      if (__DEV__ && !context2.overwrite) {
        var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
        fieldNodeSet.forEach(function(field) {
          if (field.selectionSet) {
            fieldsWithSelectionSets_1[field.name.value] = true;
          }
        });
        var hasSelectionSet_1 = function(storeFieldName) {
          return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
        };
        var hasMergeFunction_1 = function(storeFieldName) {
          var childTree = mergeTree && mergeTree.map.get(storeFieldName);
          return Boolean(childTree && childTree.info && childTree.info.merge);
        };
        Object.keys(storeObject).forEach(function(storeFieldName) {
          if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
            warnAboutDataLoss(entityRef, storeObject, storeFieldName, context2.store);
          }
        });
      }
      store.merge(dataId2, storeObject);
    });
    store.retain(ref2.__ref);
    return ref2;
  };
  StoreWriter2.prototype.processSelectionSet = function(_a2) {
    var _this = this;
    var dataId = _a2.dataId, result = _a2.result, selectionSet = _a2.selectionSet, context2 = _a2.context, mergeTree = _a2.mergeTree;
    var policies = this.cache.policies;
    var incoming = /* @__PURE__ */ Object.create(null);
    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context2.fragmentMap) || dataId && context2.store.get(dataId, "__typename");
    if ("string" === typeof typename) {
      incoming.__typename = typename;
    }
    var readField = function() {
      var options = normalizeReadFieldOptions(arguments, incoming, context2.variables);
      if (isReference(options.from)) {
        var info = context2.incomingById.get(options.from.__ref);
        if (info) {
          var result_1 = policies.readField(__assign$1(__assign$1({}, options), { from: info.storeObject }), context2);
          if (result_1 !== void 0) {
            return result_1;
          }
        }
      }
      return policies.readField(options, context2);
    };
    var fieldNodeSet = /* @__PURE__ */ new Set();
    this.flattenFields(selectionSet, result, context2, typename).forEach(function(context3, field) {
      var _a3;
      var resultFieldKey = resultKeyNameFromField(field);
      var value = result[resultFieldKey];
      fieldNodeSet.add(field);
      if (value !== void 0) {
        var storeFieldName = policies.getStoreFieldName({
          typename,
          fieldName: field.name.value,
          field,
          variables: context3.variables
        });
        var childTree = getChildMergeTree(mergeTree, storeFieldName);
        var incomingValue = _this.processFieldValue(value, field, field.selectionSet ? getContextFlavor(context3, false, false) : context3, childTree);
        var childTypename = void 0;
        if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {
          childTypename = readField("__typename", incomingValue);
        }
        var merge3 = policies.getMergeFunction(typename, field.name.value, childTypename);
        if (merge3) {
          childTree.info = {
            field,
            typename,
            merge: merge3
          };
        } else {
          maybeRecycleChildMergeTree(mergeTree, storeFieldName);
        }
        incoming = context3.merge(incoming, (_a3 = {}, _a3[storeFieldName] = incomingValue, _a3));
      } else if (__DEV__ && !context3.clientOnly && !context3.deferred && !addTypenameToDocument.added(field) && !policies.getReadFunction(typename, field.name.value)) {
        __DEV__ && invariant$1.error("Missing field '".concat(resultKeyNameFromField(field), "' while writing result ").concat(JSON.stringify(result, null, 2)).substring(0, 1e3));
      }
    });
    try {
      var _b = policies.identify(result, {
        typename,
        selectionSet,
        fragmentMap: context2.fragmentMap,
        storeObject: incoming,
        readField
      }), id = _b[0], keyObject = _b[1];
      dataId = dataId || id;
      if (keyObject) {
        incoming = context2.merge(incoming, keyObject);
      }
    } catch (e2) {
      if (!dataId)
        throw e2;
    }
    if ("string" === typeof dataId) {
      var dataRef = makeReference(dataId);
      var sets2 = context2.written[dataId] || (context2.written[dataId] = []);
      if (sets2.indexOf(selectionSet) >= 0)
        return dataRef;
      sets2.push(selectionSet);
      if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context2)) {
        return dataRef;
      }
      var previous_1 = context2.incomingById.get(dataId);
      if (previous_1) {
        previous_1.storeObject = context2.merge(previous_1.storeObject, incoming);
        previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
        fieldNodeSet.forEach(function(field) {
          return previous_1.fieldNodeSet.add(field);
        });
      } else {
        context2.incomingById.set(dataId, {
          storeObject: incoming,
          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
          fieldNodeSet
        });
      }
      return dataRef;
    }
    return incoming;
  };
  StoreWriter2.prototype.processFieldValue = function(value, field, context2, mergeTree) {
    var _this = this;
    if (!field.selectionSet || value === null) {
      return __DEV__ ? cloneDeep$3(value) : value;
    }
    if (isArray$5(value)) {
      return value.map(function(item, i) {
        var value2 = _this.processFieldValue(item, field, context2, getChildMergeTree(mergeTree, i));
        maybeRecycleChildMergeTree(mergeTree, i);
        return value2;
      });
    }
    return this.processSelectionSet({
      result: value,
      selectionSet: field.selectionSet,
      context: context2,
      mergeTree
    });
  };
  StoreWriter2.prototype.flattenFields = function(selectionSet, result, context2, typename) {
    if (typename === void 0) {
      typename = getTypenameFromResult(result, selectionSet, context2.fragmentMap);
    }
    var fieldMap = /* @__PURE__ */ new Map();
    var policies = this.cache.policies;
    var limitingTrie = new Trie(false);
    (function flatten(selectionSet2, inheritedContext) {
      var visitedNode = limitingTrie.lookup(selectionSet2, inheritedContext.clientOnly, inheritedContext.deferred);
      if (visitedNode.visited)
        return;
      visitedNode.visited = true;
      selectionSet2.selections.forEach(function(selection) {
        if (!shouldInclude(selection, context2.variables))
          return;
        var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
        if (!(clientOnly && deferred) && isNonEmptyArray(selection.directives)) {
          selection.directives.forEach(function(dir) {
            var name = dir.name.value;
            if (name === "client")
              clientOnly = true;
            if (name === "defer") {
              var args = argumentsObjectFromField(dir, context2.variables);
              if (!args || args.if !== false) {
                deferred = true;
              }
            }
          });
        }
        if (isField(selection)) {
          var existing = fieldMap.get(selection);
          if (existing) {
            clientOnly = clientOnly && existing.clientOnly;
            deferred = deferred && existing.deferred;
          }
          fieldMap.set(selection, getContextFlavor(context2, clientOnly, deferred));
        } else {
          var fragment = getFragmentFromSelection(selection, context2.lookupFragment);
          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
            throw __DEV__ ? new InvariantError("No fragment named ".concat(selection.name.value)) : new InvariantError(8);
          }
          if (fragment && policies.fragmentMatches(fragment, typename, result, context2.variables)) {
            flatten(fragment.selectionSet, getContextFlavor(context2, clientOnly, deferred));
          }
        }
      });
    })(selectionSet, context2);
    return fieldMap;
  };
  StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context2, getStorageArgs) {
    var _a2;
    var _this = this;
    if (mergeTree.map.size && !isReference(incoming)) {
      var e_1 = !isArray$5(incoming) && (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;
      var i_1 = incoming;
      if (e_1 && !getStorageArgs) {
        getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];
      }
      var changedFields_1;
      var getValue_1 = function(from2, name) {
        return isArray$5(from2) ? typeof name === "number" ? from2[name] : void 0 : context2.store.getFieldValue(from2, String(name));
      };
      mergeTree.map.forEach(function(childTree, storeFieldName) {
        var eVal = getValue_1(e_1, storeFieldName);
        var iVal = getValue_1(i_1, storeFieldName);
        if (void 0 === iVal)
          return;
        if (getStorageArgs) {
          getStorageArgs.push(storeFieldName);
        }
        var aVal = _this.applyMerges(childTree, eVal, iVal, context2, getStorageArgs);
        if (aVal !== iVal) {
          changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
          changedFields_1.set(storeFieldName, aVal);
        }
        if (getStorageArgs) {
          invariant$1(getStorageArgs.pop() === storeFieldName);
        }
      });
      if (changedFields_1) {
        incoming = isArray$5(i_1) ? i_1.slice(0) : __assign$1({}, i_1);
        changedFields_1.forEach(function(value, name) {
          incoming[name] = value;
        });
      }
    }
    if (mergeTree.info) {
      return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context2, getStorageArgs && (_a2 = context2.store).getStorage.apply(_a2, getStorageArgs));
    }
    return incoming;
  };
  return StoreWriter2;
}();
var emptyMergeTreePool = [];
function getChildMergeTree(_a2, name) {
  var map = _a2.map;
  if (!map.has(name)) {
    map.set(name, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
  }
  return map.get(name);
}
function mergeMergeTrees(left, right) {
  if (left === right || !right || mergeTreeIsEmpty(right))
    return left;
  if (!left || mergeTreeIsEmpty(left))
    return right;
  var info = left.info && right.info ? __assign$1(__assign$1({}, left.info), right.info) : left.info || right.info;
  var needToMergeMaps = left.map.size && right.map.size;
  var map = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
  var merged = { info, map };
  if (needToMergeMaps) {
    var remainingRightKeys_1 = new Set(right.map.keys());
    left.map.forEach(function(leftTree, key) {
      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
      remainingRightKeys_1.delete(key);
    });
    remainingRightKeys_1.forEach(function(key) {
      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
    });
  }
  return merged;
}
function mergeTreeIsEmpty(tree) {
  return !tree || !(tree.info || tree.map.size);
}
function maybeRecycleChildMergeTree(_a2, name) {
  var map = _a2.map;
  var childTree = map.get(name);
  if (childTree && mergeTreeIsEmpty(childTree)) {
    emptyMergeTreePool.push(childTree);
    map.delete(name);
  }
}
var warnings = /* @__PURE__ */ new Set();
function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
  var getChild = function(objOrRef) {
    var child = store.getFieldValue(objOrRef, storeFieldName);
    return typeof child === "object" && child;
  };
  var existing = getChild(existingRef);
  if (!existing)
    return;
  var incoming = getChild(incomingObj);
  if (!incoming)
    return;
  if (isReference(existing))
    return;
  if (equal(existing, incoming))
    return;
  if (Object.keys(existing).every(function(key) {
    return store.getFieldValue(incoming, key) !== void 0;
  })) {
    return;
  }
  var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var typeDotName = "".concat(parentType, ".").concat(fieldName);
  if (warnings.has(typeDotName))
    return;
  warnings.add(typeDotName);
  var childTypenames = [];
  if (!isArray$5(existing) && !isArray$5(incoming)) {
    [existing, incoming].forEach(function(child) {
      var typename = store.getFieldValue(child, "__typename");
      if (typeof typename === "string" && !childTypenames.includes(typename)) {
        childTypenames.push(typename);
      }
    });
  }
  __DEV__ && invariant$1.warn("Cache data may be lost when replacing the ".concat(fieldName, " field of a ").concat(parentType, " object.\n\nTo address this problem (which is not a bug in Apollo Client), ").concat(childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", "define a custom merge function for the ").concat(typeDotName, " field, so InMemoryCache can safely merge these objects:\n\n  existing: ").concat(JSON.stringify(existing).slice(0, 1e3), "\n  incoming: ").concat(JSON.stringify(incoming).slice(0, 1e3), "\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n"));
}
var InMemoryCache = function(_super) {
  __extends$1(InMemoryCache2, _super);
  function InMemoryCache2(config) {
    if (config === void 0) {
      config = {};
    }
    var _this = _super.call(this) || this;
    _this.watches = /* @__PURE__ */ new Set();
    _this.typenameDocumentCache = /* @__PURE__ */ new Map();
    _this.makeVar = makeVar;
    _this.txCount = 0;
    _this.config = normalizeConfig(config);
    _this.addTypename = !!_this.config.addTypename;
    _this.policies = new Policies({
      cache: _this,
      dataIdFromObject: _this.config.dataIdFromObject,
      possibleTypes: _this.config.possibleTypes,
      typePolicies: _this.config.typePolicies
    });
    _this.init();
    return _this;
  }
  InMemoryCache2.prototype.init = function() {
    var rootStore = this.data = new EntityStore.Root({
      policies: this.policies,
      resultCaching: this.config.resultCaching
    });
    this.optimisticData = rootStore.stump;
    this.resetResultCache();
  };
  InMemoryCache2.prototype.resetResultCache = function(resetResultIdentities) {
    var _this = this;
    var previousReader = this.storeReader;
    var fragments = this.config.fragments;
    this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
      cache: this,
      addTypename: this.addTypename,
      resultCacheMaxSize: this.config.resultCacheMaxSize,
      canonizeResults: shouldCanonizeResults(this.config),
      canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
      fragments
    }), fragments);
    this.maybeBroadcastWatch = wrap$2(function(c2, options) {
      return _this.broadcastWatch(c2, options);
    }, {
      max: this.config.resultCacheMaxSize,
      makeCacheKey: function(c2) {
        var store = c2.optimistic ? _this.optimisticData : _this.data;
        if (supportsResultCaching(store)) {
          var optimistic = c2.optimistic, id = c2.id, variables = c2.variables;
          return store.makeCacheKey(c2.query, c2.callback, canonicalStringify({ optimistic, id, variables }));
        }
      }
    });
    (/* @__PURE__ */ new Set([
      this.data.group,
      this.optimisticData.group
    ])).forEach(function(group2) {
      return group2.resetCaching();
    });
  };
  InMemoryCache2.prototype.restore = function(data2) {
    this.init();
    if (data2)
      this.data.replace(data2);
    return this;
  };
  InMemoryCache2.prototype.extract = function(optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return (optimistic ? this.optimisticData : this.data).extract();
  };
  InMemoryCache2.prototype.read = function(options) {
    var _a2 = options.returnPartialData, returnPartialData = _a2 === void 0 ? false : _a2;
    try {
      return this.storeReader.diffQueryAgainstStore(__assign$1(__assign$1({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
    } catch (e2) {
      if (e2 instanceof MissingFieldError) {
        return null;
      }
      throw e2;
    }
  };
  InMemoryCache2.prototype.write = function(options) {
    try {
      ++this.txCount;
      return this.storeWriter.writeToStore(this.data, options);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  };
  InMemoryCache2.prototype.modify = function(options) {
    if (hasOwn$1.call(options, "id") && !options.id) {
      return false;
    }
    var store = options.optimistic ? this.optimisticData : this.data;
    try {
      ++this.txCount;
      return store.modify(options.id || "ROOT_QUERY", options.fields);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  };
  InMemoryCache2.prototype.diff = function(options) {
    return this.storeReader.diffQueryAgainstStore(__assign$1(__assign$1({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
  };
  InMemoryCache2.prototype.watch = function(watch) {
    var _this = this;
    if (!this.watches.size) {
      recallCache(this);
    }
    this.watches.add(watch);
    if (watch.immediate) {
      this.maybeBroadcastWatch(watch);
    }
    return function() {
      if (_this.watches.delete(watch) && !_this.watches.size) {
        forgetCache(_this);
      }
      _this.maybeBroadcastWatch.forget(watch);
    };
  };
  InMemoryCache2.prototype.gc = function(options) {
    canonicalStringify.reset();
    var ids = this.optimisticData.gc();
    if (options && !this.txCount) {
      if (options.resetResultCache) {
        this.resetResultCache(options.resetResultIdentities);
      } else if (options.resetResultIdentities) {
        this.storeReader.resetCanon();
      }
    }
    return ids;
  };
  InMemoryCache2.prototype.retain = function(rootId, optimistic) {
    return (optimistic ? this.optimisticData : this.data).retain(rootId);
  };
  InMemoryCache2.prototype.release = function(rootId, optimistic) {
    return (optimistic ? this.optimisticData : this.data).release(rootId);
  };
  InMemoryCache2.prototype.identify = function(object4) {
    if (isReference(object4))
      return object4.__ref;
    try {
      return this.policies.identify(object4)[0];
    } catch (e2) {
      __DEV__ && invariant$1.warn(e2);
    }
  };
  InMemoryCache2.prototype.evict = function(options) {
    if (!options.id) {
      if (hasOwn$1.call(options, "id")) {
        return false;
      }
      options = __assign$1(__assign$1({}, options), { id: "ROOT_QUERY" });
    }
    try {
      ++this.txCount;
      return this.optimisticData.evict(options, this.data);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  };
  InMemoryCache2.prototype.reset = function(options) {
    var _this = this;
    this.init();
    canonicalStringify.reset();
    if (options && options.discardWatches) {
      this.watches.forEach(function(watch) {
        return _this.maybeBroadcastWatch.forget(watch);
      });
      this.watches.clear();
      forgetCache(this);
    } else {
      this.broadcastWatches();
    }
    return Promise.resolve();
  };
  InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
    var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
    if (newOptimisticData !== this.optimisticData) {
      this.optimisticData = newOptimisticData;
      this.broadcastWatches();
    }
  };
  InMemoryCache2.prototype.batch = function(options) {
    var _this = this;
    var update = options.update, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
    var updateResult;
    var perform = function(layer) {
      var _a3 = _this, data2 = _a3.data, optimisticData = _a3.optimisticData;
      ++_this.txCount;
      if (layer) {
        _this.data = _this.optimisticData = layer;
      }
      try {
        return updateResult = update(_this);
      } finally {
        --_this.txCount;
        _this.data = data2;
        _this.optimisticData = optimisticData;
      }
    };
    var alreadyDirty = /* @__PURE__ */ new Set();
    if (onWatchUpdated && !this.txCount) {
      this.broadcastWatches(__assign$1(__assign$1({}, options), { onWatchUpdated: function(watch) {
        alreadyDirty.add(watch);
        return false;
      } }));
    }
    if (typeof optimistic === "string") {
      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
    } else if (optimistic === false) {
      perform(this.data);
    } else {
      perform();
    }
    if (typeof removeOptimistic === "string") {
      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
    }
    if (onWatchUpdated && alreadyDirty.size) {
      this.broadcastWatches(__assign$1(__assign$1({}, options), { onWatchUpdated: function(watch, diff) {
        var result = onWatchUpdated.call(this, watch, diff);
        if (result !== false) {
          alreadyDirty.delete(watch);
        }
        return result;
      } }));
      if (alreadyDirty.size) {
        alreadyDirty.forEach(function(watch) {
          return _this.maybeBroadcastWatch.dirty(watch);
        });
      }
    } else {
      this.broadcastWatches(options);
    }
    return updateResult;
  };
  InMemoryCache2.prototype.performTransaction = function(update, optimisticId) {
    return this.batch({
      update,
      optimistic: optimisticId || optimisticId !== null
    });
  };
  InMemoryCache2.prototype.transformDocument = function(document2) {
    if (this.addTypename) {
      var result = this.typenameDocumentCache.get(document2);
      if (!result) {
        result = addTypenameToDocument(document2);
        this.typenameDocumentCache.set(document2, result);
        this.typenameDocumentCache.set(result, result);
      }
      return result;
    }
    return document2;
  };
  InMemoryCache2.prototype.transformForLink = function(document2) {
    var fragments = this.config.fragments;
    return fragments ? fragments.transform(document2) : document2;
  };
  InMemoryCache2.prototype.broadcastWatches = function(options) {
    var _this = this;
    if (!this.txCount) {
      this.watches.forEach(function(c2) {
        return _this.maybeBroadcastWatch(c2, options);
      });
    }
  };
  InMemoryCache2.prototype.broadcastWatch = function(c2, options) {
    var lastDiff = c2.lastDiff;
    var diff = this.diff(c2);
    if (options) {
      if (c2.optimistic && typeof options.optimistic === "string") {
        diff.fromOptimisticTransaction = true;
      }
      if (options.onWatchUpdated && options.onWatchUpdated.call(this, c2, diff, lastDiff) === false) {
        return;
      }
    }
    if (!lastDiff || !equal(lastDiff.result, diff.result)) {
      c2.callback(c2.lastDiff = diff, lastDiff);
    }
  };
  return InMemoryCache2;
}(ApolloCache);
function isApolloError(err) {
  return err.hasOwnProperty("graphQLErrors");
}
var generateErrorMessage = function(err) {
  var message = "";
  if (isNonEmptyArray(err.graphQLErrors) || isNonEmptyArray(err.clientErrors)) {
    var errors = (err.graphQLErrors || []).concat(err.clientErrors || []);
    errors.forEach(function(error3) {
      var errorMessage = error3 ? error3.message : "Error message not found.";
      message += "".concat(errorMessage, "\n");
    });
  }
  if (err.networkError) {
    message += "".concat(err.networkError.message, "\n");
  }
  message = message.replace(/\n$/, "");
  return message;
};
var ApolloError = function(_super) {
  __extends$1(ApolloError2, _super);
  function ApolloError2(_a2) {
    var graphQLErrors = _a2.graphQLErrors, clientErrors = _a2.clientErrors, networkError = _a2.networkError, errorMessage = _a2.errorMessage, extraInfo = _a2.extraInfo;
    var _this = _super.call(this, errorMessage) || this;
    _this.graphQLErrors = graphQLErrors || [];
    _this.clientErrors = clientErrors || [];
    _this.networkError = networkError || null;
    _this.message = errorMessage || generateErrorMessage(_this);
    _this.extraInfo = extraInfo;
    _this.__proto__ = ApolloError2.prototype;
    return _this;
  }
  return ApolloError2;
}(Error);
var NetworkStatus;
(function(NetworkStatus2) {
  NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
  NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
  NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
  NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
  NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
  NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
  NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
  return networkStatus ? networkStatus < 7 : false;
}
var assign$1 = Object.assign, hasOwnProperty$c = Object.hasOwnProperty;
var ObservableQuery = function(_super) {
  __extends$1(ObservableQuery2, _super);
  function ObservableQuery2(_a2) {
    var queryManager = _a2.queryManager, queryInfo = _a2.queryInfo, options = _a2.options;
    var _this = _super.call(this, function(observer) {
      try {
        var subObserver = observer._subscription._observer;
        if (subObserver && !subObserver.error) {
          subObserver.error = defaultSubscriptionObserverErrorCallback;
        }
      } catch (_a3) {
      }
      var first = !_this.observers.size;
      _this.observers.add(observer);
      var last = _this.last;
      if (last && last.error) {
        observer.error && observer.error(last.error);
      } else if (last && last.result) {
        observer.next && observer.next(last.result);
      }
      if (first) {
        _this.reobserve().catch(function() {
        });
      }
      return function() {
        if (_this.observers.delete(observer) && !_this.observers.size) {
          _this.tearDownQuery();
        }
      };
    }) || this;
    _this.observers = /* @__PURE__ */ new Set();
    _this.subscriptions = /* @__PURE__ */ new Set();
    _this.queryInfo = queryInfo;
    _this.queryManager = queryManager;
    _this.isTornDown = false;
    var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
    var _e2 = options.fetchPolicy, fetchPolicy = _e2 === void 0 ? defaultFetchPolicy : _e2, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
    _this.options = __assign$1(__assign$1({}, options), { initialFetchPolicy, fetchPolicy });
    _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
    var opDef = getOperationDefinition(_this.query);
    _this.queryName = opDef && opDef.name && opDef.name.value;
    return _this;
  }
  Object.defineProperty(ObservableQuery2.prototype, "query", {
    get: function() {
      return this.queryManager.transform(this.options.query).document;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ObservableQuery2.prototype, "variables", {
    get: function() {
      return this.options.variables;
    },
    enumerable: false,
    configurable: true
  });
  ObservableQuery2.prototype.result = function() {
    var _this = this;
    return new Promise(function(resolve, reject) {
      var observer = {
        next: function(result) {
          resolve(result);
          _this.observers.delete(observer);
          if (!_this.observers.size) {
            _this.queryManager.removeQuery(_this.queryId);
          }
          setTimeout(function() {
            subscription.unsubscribe();
          }, 0);
        },
        error: reject
      };
      var subscription = _this.subscribe(observer);
    });
  };
  ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
    if (saveAsLastResult === void 0) {
      saveAsLastResult = true;
    }
    var lastResult = this.getLastResult(true);
    var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;
    var result = __assign$1(__assign$1({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
    var _a2 = this.options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2;
    if (fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby" || this.queryManager.transform(this.options.query).hasForcedResolvers)
      ;
    else {
      var diff = this.queryInfo.getDiff();
      if (diff.complete || this.options.returnPartialData) {
        result.data = diff.result;
      }
      if (equal(result.data, {})) {
        result.data = void 0;
      }
      if (diff.complete) {
        delete result.partial;
        if (diff.complete && result.networkStatus === NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
          result.networkStatus = NetworkStatus.ready;
          result.loading = false;
        }
      } else {
        result.partial = true;
      }
      if (__DEV__ && !diff.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {
        logMissingFieldErrors(diff.missing);
      }
    }
    if (saveAsLastResult) {
      this.updateLastResult(result);
    }
    return result;
  };
  ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult, variables) {
    return !this.last || !equal(this.last.result, newResult) || variables && !equal(this.last.variables, variables);
  };
  ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {
    var last = this.last;
    if (last && last[key] && (!variablesMustMatch || equal(last.variables, this.variables))) {
      return last[key];
    }
  };
  ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
    return this.getLast("result", variablesMustMatch);
  };
  ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
    return this.getLast("error", variablesMustMatch);
  };
  ObservableQuery2.prototype.resetLastResults = function() {
    delete this.last;
    this.isTornDown = false;
  };
  ObservableQuery2.prototype.resetQueryStoreErrors = function() {
    this.queryManager.resetErrors(this.queryId);
  };
  ObservableQuery2.prototype.refetch = function(variables) {
    var _a2;
    var reobserveOptions = {
      pollInterval: 0
    };
    var fetchPolicy = this.options.fetchPolicy;
    if (fetchPolicy === "cache-and-network") {
      reobserveOptions.fetchPolicy = fetchPolicy;
    } else if (fetchPolicy === "no-cache") {
      reobserveOptions.fetchPolicy = "no-cache";
    } else {
      reobserveOptions.fetchPolicy = "network-only";
    }
    if (__DEV__ && variables && hasOwnProperty$c.call(variables, "variables")) {
      var queryDef = getQueryDefinition(this.query);
      var vars = queryDef.variableDefinitions;
      if (!vars || !vars.some(function(v2) {
        return v2.variable.name.value === "variables";
      })) {
        __DEV__ && invariant$1.warn("Called refetch(".concat(JSON.stringify(variables), ") for query ").concat(((_a2 = queryDef.name) === null || _a2 === void 0 ? void 0 : _a2.value) || JSON.stringify(queryDef), ", which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?"));
      }
    }
    if (variables && !equal(this.options.variables, variables)) {
      reobserveOptions.variables = this.options.variables = __assign$1(__assign$1({}, this.options.variables), variables);
    }
    this.queryInfo.resetLastWrite();
    return this.reobserve(reobserveOptions, NetworkStatus.refetch);
  };
  ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
    var _this = this;
    var combinedOptions = __assign$1(__assign$1({}, fetchMoreOptions.query ? fetchMoreOptions : __assign$1(__assign$1(__assign$1(__assign$1({}, this.options), { query: this.query }), fetchMoreOptions), { variables: __assign$1(__assign$1({}, this.options.variables), fetchMoreOptions.variables) })), { fetchPolicy: "no-cache" });
    var qid = this.queryManager.generateQueryId();
    var queryInfo = this.queryInfo;
    var originalNetworkStatus = queryInfo.networkStatus;
    queryInfo.networkStatus = NetworkStatus.fetchMore;
    if (combinedOptions.notifyOnNetworkStatusChange) {
      this.observe();
    }
    var updatedQuerySet = /* @__PURE__ */ new Set();
    return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {
      _this.queryManager.removeQuery(qid);
      if (queryInfo.networkStatus === NetworkStatus.fetchMore) {
        queryInfo.networkStatus = originalNetworkStatus;
      }
      _this.queryManager.cache.batch({
        update: function(cache2) {
          var updateQuery = fetchMoreOptions.updateQuery;
          if (updateQuery) {
            cache2.updateQuery({
              query: _this.query,
              variables: _this.variables,
              returnPartialData: true,
              optimistic: false
            }, function(previous2) {
              return updateQuery(previous2, {
                fetchMoreResult: fetchMoreResult.data,
                variables: combinedOptions.variables
              });
            });
          } else {
            cache2.writeQuery({
              query: combinedOptions.query,
              variables: combinedOptions.variables,
              data: fetchMoreResult.data
            });
          }
        },
        onWatchUpdated: function(watch) {
          updatedQuerySet.add(watch.query);
        }
      });
      return fetchMoreResult;
    }).finally(function() {
      if (!updatedQuerySet.has(_this.query)) {
        reobserveCacheFirst(_this);
      }
    });
  };
  ObservableQuery2.prototype.subscribeToMore = function(options) {
    var _this = this;
    var subscription = this.queryManager.startGraphQLSubscription({
      query: options.document,
      variables: options.variables,
      context: options.context
    }).subscribe({
      next: function(subscriptionData) {
        var updateQuery = options.updateQuery;
        if (updateQuery) {
          _this.updateQuery(function(previous2, _a2) {
            var variables = _a2.variables;
            return updateQuery(previous2, {
              subscriptionData,
              variables
            });
          });
        }
      },
      error: function(err) {
        if (options.onError) {
          options.onError(err);
          return;
        }
        __DEV__ && invariant$1.error("Unhandled GraphQL subscription error", err);
      }
    });
    this.subscriptions.add(subscription);
    return function() {
      if (_this.subscriptions.delete(subscription)) {
        subscription.unsubscribe();
      }
    };
  };
  ObservableQuery2.prototype.setOptions = function(newOptions) {
    return this.reobserve(newOptions);
  };
  ObservableQuery2.prototype.setVariables = function(variables) {
    if (equal(this.variables, variables)) {
      return this.observers.size ? this.result() : Promise.resolve();
    }
    this.options.variables = variables;
    if (!this.observers.size) {
      return Promise.resolve();
    }
    return this.reobserve({
      fetchPolicy: this.options.initialFetchPolicy,
      variables
    }, NetworkStatus.setVariables);
  };
  ObservableQuery2.prototype.updateQuery = function(mapFn) {
    var queryManager = this.queryManager;
    var result = queryManager.cache.diff({
      query: this.options.query,
      variables: this.variables,
      returnPartialData: true,
      optimistic: false
    }).result;
    var newResult = mapFn(result, {
      variables: this.variables
    });
    if (newResult) {
      queryManager.cache.writeQuery({
        query: this.options.query,
        data: newResult,
        variables: this.variables
      });
      queryManager.broadcastQueries();
    }
  };
  ObservableQuery2.prototype.startPolling = function(pollInterval) {
    this.options.pollInterval = pollInterval;
    this.updatePolling();
  };
  ObservableQuery2.prototype.stopPolling = function() {
    this.options.pollInterval = 0;
    this.updatePolling();
  };
  ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options) {
    if (options.nextFetchPolicy) {
      var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
      if (fetchPolicy === "standby")
        ;
      else if (typeof options.nextFetchPolicy === "function") {
        options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
          reason,
          options,
          observable: this,
          initialFetchPolicy
        });
      } else if (reason === "variables-changed") {
        options.fetchPolicy = initialFetchPolicy;
      } else {
        options.fetchPolicy = options.nextFetchPolicy;
      }
    }
    return options.fetchPolicy;
  };
  ObservableQuery2.prototype.fetch = function(options, newNetworkStatus) {
    this.queryManager.setObservableQuery(this);
    return this.queryManager.fetchQueryObservable(this.queryId, options, newNetworkStatus);
  };
  ObservableQuery2.prototype.updatePolling = function() {
    var _this = this;
    if (this.queryManager.ssrMode) {
      return;
    }
    var _a2 = this, pollingInfo = _a2.pollingInfo, pollInterval = _a2.options.pollInterval;
    if (!pollInterval) {
      if (pollingInfo) {
        clearTimeout(pollingInfo.timeout);
        delete this.pollingInfo;
      }
      return;
    }
    if (pollingInfo && pollingInfo.interval === pollInterval) {
      return;
    }
    __DEV__ ? invariant$1(pollInterval, "Attempted to start a polling query without a polling interval.") : invariant$1(pollInterval, 12);
    var info = pollingInfo || (this.pollingInfo = {});
    info.interval = pollInterval;
    var maybeFetch = function() {
      if (_this.pollingInfo) {
        if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus)) {
          _this.reobserve({
            fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
          }, NetworkStatus.poll).then(poll, poll);
        } else {
          poll();
        }
      }
    };
    var poll = function() {
      var info2 = _this.pollingInfo;
      if (info2) {
        clearTimeout(info2.timeout);
        info2.timeout = setTimeout(maybeFetch, info2.interval);
      }
    };
    poll();
  };
  ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
    if (variables === void 0) {
      variables = this.variables;
    }
    this.last = __assign$1(__assign$1({}, this.last), { result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep$3(newResult), variables });
    if (!isNonEmptyArray(newResult.errors)) {
      delete this.last.error;
    }
    return this.last;
  };
  ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
    var _this = this;
    this.isTornDown = false;
    var useDisposableConcast = newNetworkStatus === NetworkStatus.refetch || newNetworkStatus === NetworkStatus.fetchMore || newNetworkStatus === NetworkStatus.poll;
    var oldVariables = this.options.variables;
    var oldFetchPolicy = this.options.fetchPolicy;
    var mergedOptions = compact$1(this.options, newOptions || {});
    var options = useDisposableConcast ? mergedOptions : assign$1(this.options, mergedOptions);
    if (!useDisposableConcast) {
      this.updatePolling();
      if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) && options.fetchPolicy !== "standby" && options.fetchPolicy === oldFetchPolicy) {
        this.applyNextFetchPolicy("variables-changed", options);
        if (newNetworkStatus === void 0) {
          newNetworkStatus = NetworkStatus.setVariables;
        }
      }
    }
    var variables = options.variables && __assign$1({}, options.variables);
    var concast = this.fetch(options, newNetworkStatus);
    var observer = {
      next: function(result) {
        _this.reportResult(result, variables);
      },
      error: function(error3) {
        _this.reportError(error3, variables);
      }
    };
    if (!useDisposableConcast) {
      if (this.concast && this.observer) {
        this.concast.removeObserver(this.observer);
      }
      this.concast = concast;
      this.observer = observer;
    }
    concast.addObserver(observer);
    return concast.promise;
  };
  ObservableQuery2.prototype.observe = function() {
    this.reportResult(this.getCurrentResult(false), this.variables);
  };
  ObservableQuery2.prototype.reportResult = function(result, variables) {
    var lastError = this.getLastError();
    if (lastError || this.isDifferentFromLastResult(result, variables)) {
      if (lastError || !result.partial || this.options.returnPartialData) {
        this.updateLastResult(result, variables);
      }
      iterateObserversSafely(this.observers, "next", result);
    }
  };
  ObservableQuery2.prototype.reportError = function(error3, variables) {
    var errorResult = __assign$1(__assign$1({}, this.getLastResult()), { error: error3, errors: error3.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });
    this.updateLastResult(errorResult, variables);
    iterateObserversSafely(this.observers, "error", this.last.error = error3);
  };
  ObservableQuery2.prototype.hasObservers = function() {
    return this.observers.size > 0;
  };
  ObservableQuery2.prototype.tearDownQuery = function() {
    if (this.isTornDown)
      return;
    if (this.concast && this.observer) {
      this.concast.removeObserver(this.observer);
      delete this.concast;
      delete this.observer;
    }
    this.stopPolling();
    this.subscriptions.forEach(function(sub) {
      return sub.unsubscribe();
    });
    this.subscriptions.clear();
    this.queryManager.stopQuery(this.queryId);
    this.observers.clear();
    this.isTornDown = true;
  };
  return ObservableQuery2;
}(Observable$1);
fixObservableSubclass(ObservableQuery);
function reobserveCacheFirst(obsQuery) {
  var _a2 = obsQuery.options, fetchPolicy = _a2.fetchPolicy, nextFetchPolicy = _a2.nextFetchPolicy;
  if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
    return obsQuery.reobserve({
      fetchPolicy: "cache-first",
      nextFetchPolicy: function() {
        this.nextFetchPolicy = nextFetchPolicy;
        if (typeof nextFetchPolicy === "function") {
          return nextFetchPolicy.apply(this, arguments);
        }
        return fetchPolicy;
      }
    });
  }
  return obsQuery.reobserve();
}
function defaultSubscriptionObserverErrorCallback(error3) {
  __DEV__ && invariant$1.error("Unhandled error", error3.message, error3.stack);
}
function logMissingFieldErrors(missing) {
  if (__DEV__ && missing) {
    __DEV__ && invariant$1.debug("Missing cache result fields: ".concat(JSON.stringify(missing)), missing);
  }
}
var LocalState = function() {
  function LocalState2(_a2) {
    var cache2 = _a2.cache, client = _a2.client, resolvers2 = _a2.resolvers, fragmentMatcher = _a2.fragmentMatcher;
    this.cache = cache2;
    if (client) {
      this.client = client;
    }
    if (resolvers2) {
      this.addResolvers(resolvers2);
    }
    if (fragmentMatcher) {
      this.setFragmentMatcher(fragmentMatcher);
    }
  }
  LocalState2.prototype.addResolvers = function(resolvers2) {
    var _this = this;
    this.resolvers = this.resolvers || {};
    if (Array.isArray(resolvers2)) {
      resolvers2.forEach(function(resolverGroup) {
        _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
      });
    } else {
      this.resolvers = mergeDeep(this.resolvers, resolvers2);
    }
  };
  LocalState2.prototype.setResolvers = function(resolvers2) {
    this.resolvers = {};
    this.addResolvers(resolvers2);
  };
  LocalState2.prototype.getResolvers = function() {
    return this.resolvers || {};
  };
  LocalState2.prototype.runResolvers = function(_a2) {
    var document2 = _a2.document, remoteResult = _a2.remoteResult, context2 = _a2.context, variables = _a2.variables, _b = _a2.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_c) {
        if (document2) {
          return [2, this.resolveDocument(document2, remoteResult.data, context2, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
            return __assign$1(__assign$1({}, remoteResult), { data: localResult.result });
          })];
        }
        return [2, remoteResult];
      });
    });
  };
  LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
    this.fragmentMatcher = fragmentMatcher;
  };
  LocalState2.prototype.getFragmentMatcher = function() {
    return this.fragmentMatcher;
  };
  LocalState2.prototype.clientQuery = function(document2) {
    if (hasDirectives(["client"], document2)) {
      if (this.resolvers) {
        return document2;
      }
    }
    return null;
  };
  LocalState2.prototype.serverQuery = function(document2) {
    return removeClientSetsFromDocument(document2);
  };
  LocalState2.prototype.prepareContext = function(context2) {
    var cache2 = this.cache;
    return __assign$1(__assign$1({}, context2), { cache: cache2, getCacheKey: function(obj) {
      return cache2.identify(obj);
    } });
  };
  LocalState2.prototype.addExportedVariables = function(document2, variables, context2) {
    if (variables === void 0) {
      variables = {};
    }
    if (context2 === void 0) {
      context2 = {};
    }
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        if (document2) {
          return [2, this.resolveDocument(document2, this.buildRootValueFromCache(document2, variables) || {}, this.prepareContext(context2), variables).then(function(data2) {
            return __assign$1(__assign$1({}, variables), data2.exportedVariables);
          })];
        }
        return [2, __assign$1({}, variables)];
      });
    });
  };
  LocalState2.prototype.shouldForceResolvers = function(document2) {
    var forceResolvers = false;
    visit$2(document2, {
      Directive: {
        enter: function(node2) {
          if (node2.name.value === "client" && node2.arguments) {
            forceResolvers = node2.arguments.some(function(arg) {
              return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
            });
            if (forceResolvers) {
              return BREAK;
            }
          }
        }
      }
    });
    return forceResolvers;
  };
  LocalState2.prototype.buildRootValueFromCache = function(document2, variables) {
    return this.cache.diff({
      query: buildQueryFromSelectionSet(document2),
      variables,
      returnPartialData: true,
      optimistic: false
    }).result;
  };
  LocalState2.prototype.resolveDocument = function(document2, rootValue, context2, variables, fragmentMatcher, onlyRunForcedResolvers) {
    if (context2 === void 0) {
      context2 = {};
    }
    if (variables === void 0) {
      variables = {};
    }
    if (fragmentMatcher === void 0) {
      fragmentMatcher = function() {
        return true;
      };
    }
    if (onlyRunForcedResolvers === void 0) {
      onlyRunForcedResolvers = false;
    }
    return __awaiter(this, void 0, void 0, function() {
      var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a2, cache2, client, execContext;
      return __generator(this, function(_b) {
        mainDefinition = getMainDefinition(document2);
        fragments = getFragmentDefinitions(document2);
        fragmentMap = createFragmentMap(fragments);
        definitionOperation = mainDefinition.operation;
        defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
        _a2 = this, cache2 = _a2.cache, client = _a2.client;
        execContext = {
          fragmentMap,
          context: __assign$1(__assign$1({}, context2), { cache: cache2, client }),
          variables,
          fragmentMatcher,
          defaultOperationType,
          exportedVariables: {},
          onlyRunForcedResolvers
        };
        return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function(result) {
          return {
            result,
            exportedVariables: execContext.exportedVariables
          };
        })];
      });
    });
  };
  LocalState2.prototype.resolveSelectionSet = function(selectionSet, rootValue, execContext) {
    return __awaiter(this, void 0, void 0, function() {
      var fragmentMap, context2, variables, resultsToMerge, execute2;
      var _this = this;
      return __generator(this, function(_a2) {
        fragmentMap = execContext.fragmentMap, context2 = execContext.context, variables = execContext.variables;
        resultsToMerge = [rootValue];
        execute2 = function(selection) {
          return __awaiter(_this, void 0, void 0, function() {
            var fragment, typeCondition;
            return __generator(this, function(_a3) {
              if (!shouldInclude(selection, variables)) {
                return [2];
              }
              if (isField(selection)) {
                return [2, this.resolveField(selection, rootValue, execContext).then(function(fieldResult) {
                  var _a4;
                  if (typeof fieldResult !== "undefined") {
                    resultsToMerge.push((_a4 = {}, _a4[resultKeyNameFromField(selection)] = fieldResult, _a4));
                  }
                })];
              }
              if (isInlineFragment(selection)) {
                fragment = selection;
              } else {
                fragment = fragmentMap[selection.name.value];
                __DEV__ ? invariant$1(fragment, "No fragment named ".concat(selection.name.value)) : invariant$1(fragment, 11);
              }
              if (fragment && fragment.typeCondition) {
                typeCondition = fragment.typeCondition.name.value;
                if (execContext.fragmentMatcher(rootValue, typeCondition, context2)) {
                  return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function(fragmentResult) {
                    resultsToMerge.push(fragmentResult);
                  })];
                }
              }
              return [2];
            });
          });
        };
        return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
          return mergeDeepArray(resultsToMerge);
        })];
      });
    });
  };
  LocalState2.prototype.resolveField = function(field, rootValue, execContext) {
    return __awaiter(this, void 0, void 0, function() {
      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
      var _this = this;
      return __generator(this, function(_a2) {
        variables = execContext.variables;
        fieldName = field.name.value;
        aliasedFieldName = resultKeyNameFromField(field);
        aliasUsed = fieldName !== aliasedFieldName;
        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
        resultPromise = Promise.resolve(defaultResult);
        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
          resolverType = rootValue.__typename || execContext.defaultOperationType;
          resolverMap = this.resolvers && this.resolvers[resolverType];
          if (resolverMap) {
            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
            if (resolve) {
              resultPromise = Promise.resolve(cacheSlot.withValue(this.cache, resolve, [
                rootValue,
                argumentsObjectFromField(field, variables),
                execContext.context,
                { field, fragmentMap: execContext.fragmentMap }
              ]));
            }
          }
        }
        return [2, resultPromise.then(function(result) {
          if (result === void 0) {
            result = defaultResult;
          }
          if (field.directives) {
            field.directives.forEach(function(directive) {
              if (directive.name.value === "export" && directive.arguments) {
                directive.arguments.forEach(function(arg) {
                  if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                    execContext.exportedVariables[arg.value.value] = result;
                  }
                });
              }
            });
          }
          if (!field.selectionSet) {
            return result;
          }
          if (result == null) {
            return result;
          }
          if (Array.isArray(result)) {
            return _this.resolveSubSelectedArray(field, result, execContext);
          }
          if (field.selectionSet) {
            return _this.resolveSelectionSet(field.selectionSet, result, execContext);
          }
        })];
      });
    });
  };
  LocalState2.prototype.resolveSubSelectedArray = function(field, result, execContext) {
    var _this = this;
    return Promise.all(result.map(function(item) {
      if (item === null) {
        return null;
      }
      if (Array.isArray(item)) {
        return _this.resolveSubSelectedArray(field, item, execContext);
      }
      if (field.selectionSet) {
        return _this.resolveSelectionSet(field.selectionSet, item, execContext);
      }
    }));
  };
  return LocalState2;
}();
var destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();
function wrapDestructiveCacheMethod(cache2, methodName) {
  var original = cache2[methodName];
  if (typeof original === "function") {
    cache2[methodName] = function() {
      destructiveMethodCounts.set(cache2, (destructiveMethodCounts.get(cache2) + 1) % 1e15);
      return original.apply(this, arguments);
    };
  }
}
function cancelNotifyTimeout(info) {
  if (info["notifyTimeout"]) {
    clearTimeout(info["notifyTimeout"]);
    info["notifyTimeout"] = void 0;
  }
}
var QueryInfo = function() {
  function QueryInfo2(queryManager, queryId) {
    if (queryId === void 0) {
      queryId = queryManager.generateQueryId();
    }
    this.queryId = queryId;
    this.listeners = /* @__PURE__ */ new Set();
    this.document = null;
    this.lastRequestId = 1;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.stopped = false;
    this.dirty = false;
    this.observableQuery = null;
    var cache2 = this.cache = queryManager.cache;
    if (!destructiveMethodCounts.has(cache2)) {
      destructiveMethodCounts.set(cache2, 0);
      wrapDestructiveCacheMethod(cache2, "evict");
      wrapDestructiveCacheMethod(cache2, "modify");
      wrapDestructiveCacheMethod(cache2, "reset");
    }
  }
  QueryInfo2.prototype.init = function(query) {
    var networkStatus = query.networkStatus || NetworkStatus.loading;
    if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal(this.variables, query.variables)) {
      networkStatus = NetworkStatus.setVariables;
    }
    if (!equal(query.variables, this.variables)) {
      this.lastDiff = void 0;
    }
    Object.assign(this, {
      document: query.document,
      variables: query.variables,
      networkError: null,
      graphQLErrors: this.graphQLErrors || [],
      networkStatus
    });
    if (query.observableQuery) {
      this.setObservableQuery(query.observableQuery);
    }
    if (query.lastRequestId) {
      this.lastRequestId = query.lastRequestId;
    }
    return this;
  };
  QueryInfo2.prototype.reset = function() {
    cancelNotifyTimeout(this);
    this.dirty = false;
  };
  QueryInfo2.prototype.getDiff = function(variables) {
    if (variables === void 0) {
      variables = this.variables;
    }
    var options = this.getDiffOptions(variables);
    if (this.lastDiff && equal(options, this.lastDiff.options)) {
      return this.lastDiff.diff;
    }
    this.updateWatch(this.variables = variables);
    var oq = this.observableQuery;
    if (oq && oq.options.fetchPolicy === "no-cache") {
      return { complete: false };
    }
    var diff = this.cache.diff(options);
    this.updateLastDiff(diff, options);
    return diff;
  };
  QueryInfo2.prototype.updateLastDiff = function(diff, options) {
    this.lastDiff = diff ? {
      diff,
      options: options || this.getDiffOptions()
    } : void 0;
  };
  QueryInfo2.prototype.getDiffOptions = function(variables) {
    var _a2;
    if (variables === void 0) {
      variables = this.variables;
    }
    return {
      query: this.document,
      variables,
      returnPartialData: true,
      optimistic: true,
      canonizeResults: (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.options.canonizeResults
    };
  };
  QueryInfo2.prototype.setDiff = function(diff) {
    var _this = this;
    var oldDiff = this.lastDiff && this.lastDiff.diff;
    this.updateLastDiff(diff);
    if (!this.dirty && !equal(oldDiff && oldDiff.result, diff && diff.result)) {
      this.dirty = true;
      if (!this.notifyTimeout) {
        this.notifyTimeout = setTimeout(function() {
          return _this.notify();
        }, 0);
      }
    }
  };
  QueryInfo2.prototype.setObservableQuery = function(oq) {
    var _this = this;
    if (oq === this.observableQuery)
      return;
    if (this.oqListener) {
      this.listeners.delete(this.oqListener);
    }
    this.observableQuery = oq;
    if (oq) {
      oq["queryInfo"] = this;
      this.listeners.add(this.oqListener = function() {
        var diff = _this.getDiff();
        if (diff.fromOptimisticTransaction) {
          oq["observe"]();
        } else {
          reobserveCacheFirst(oq);
        }
      });
    } else {
      delete this.oqListener;
    }
  };
  QueryInfo2.prototype.notify = function() {
    var _this = this;
    cancelNotifyTimeout(this);
    if (this.shouldNotify()) {
      this.listeners.forEach(function(listener) {
        return listener(_this);
      });
    }
    this.dirty = false;
  };
  QueryInfo2.prototype.shouldNotify = function() {
    if (!this.dirty || !this.listeners.size) {
      return false;
    }
    if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
      var fetchPolicy = this.observableQuery.options.fetchPolicy;
      if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
        return false;
      }
    }
    return true;
  };
  QueryInfo2.prototype.stop = function() {
    if (!this.stopped) {
      this.stopped = true;
      this.reset();
      this.cancel();
      this.cancel = QueryInfo2.prototype.cancel;
      this.subscriptions.forEach(function(sub) {
        return sub.unsubscribe();
      });
      var oq = this.observableQuery;
      if (oq)
        oq.stopPolling();
    }
  };
  QueryInfo2.prototype.cancel = function() {
  };
  QueryInfo2.prototype.updateWatch = function(variables) {
    var _this = this;
    if (variables === void 0) {
      variables = this.variables;
    }
    var oq = this.observableQuery;
    if (oq && oq.options.fetchPolicy === "no-cache") {
      return;
    }
    var watchOptions = __assign$1(__assign$1({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff) {
      return _this.setDiff(diff);
    } });
    if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {
      this.cancel();
      this.cancel = this.cache.watch(this.lastWatch = watchOptions);
    }
  };
  QueryInfo2.prototype.resetLastWrite = function() {
    this.lastWrite = void 0;
  };
  QueryInfo2.prototype.shouldWrite = function(result, variables) {
    var lastWrite = this.lastWrite;
    return !(lastWrite && lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result.data, lastWrite.result.data));
  };
  QueryInfo2.prototype.markResult = function(result, document2, options, cacheWriteBehavior) {
    var _this = this;
    var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
    this.reset();
    if ("incremental" in result && isNonEmptyArray(result.incremental)) {
      var mergedData_1 = this.getDiff().result;
      var merger_1 = new DeepMerger();
      result.incremental.forEach(function(_a2) {
        var data2 = _a2.data, path2 = _a2.path, errors = _a2.errors;
        for (var i = path2.length - 1; i >= 0; --i) {
          var key = path2[i];
          var isNumericKey = !isNaN(+key);
          var parent_1 = isNumericKey ? [] : {};
          parent_1[key] = data2;
          data2 = parent_1;
        }
        if (errors) {
          graphQLErrors.push.apply(graphQLErrors, errors);
        }
        mergedData_1 = merger_1.merge(mergedData_1, data2);
      });
      result.data = mergedData_1;
    }
    this.graphQLErrors = graphQLErrors;
    if (options.fetchPolicy === "no-cache") {
      this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options.variables));
    } else if (cacheWriteBehavior !== 0) {
      if (shouldWriteResult(result, options.errorPolicy)) {
        this.cache.performTransaction(function(cache2) {
          if (_this.shouldWrite(result, options.variables)) {
            cache2.writeQuery({
              query: document2,
              data: result.data,
              variables: options.variables,
              overwrite: cacheWriteBehavior === 1
            });
            _this.lastWrite = {
              result,
              variables: options.variables,
              dmCount: destructiveMethodCounts.get(_this.cache)
            };
          } else {
            if (_this.lastDiff && _this.lastDiff.diff.complete) {
              result.data = _this.lastDiff.diff.result;
              return;
            }
          }
          var diffOptions = _this.getDiffOptions(options.variables);
          var diff = cache2.diff(diffOptions);
          if (!_this.stopped) {
            _this.updateWatch(options.variables);
          }
          _this.updateLastDiff(diff, diffOptions);
          if (diff.complete) {
            result.data = diff.result;
          }
        });
      } else {
        this.lastWrite = void 0;
      }
    }
  };
  QueryInfo2.prototype.markReady = function() {
    this.networkError = null;
    return this.networkStatus = NetworkStatus.ready;
  };
  QueryInfo2.prototype.markError = function(error3) {
    this.networkStatus = NetworkStatus.error;
    this.lastWrite = void 0;
    this.reset();
    if (error3.graphQLErrors) {
      this.graphQLErrors = error3.graphQLErrors;
    }
    if (error3.networkError) {
      this.networkError = error3.networkError;
    }
    return error3;
  };
  return QueryInfo2;
}();
function shouldWriteResult(result, errorPolicy) {
  if (errorPolicy === void 0) {
    errorPolicy = "none";
  }
  var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
  var writeWithErrors = !graphQLResultHasError(result);
  if (!writeWithErrors && ignoreErrors && result.data) {
    writeWithErrors = true;
  }
  return writeWithErrors;
}
var hasOwnProperty$b = Object.prototype.hasOwnProperty;
var QueryManager = function() {
  function QueryManager2(_a2) {
    var cache2 = _a2.cache, link2 = _a2.link, defaultOptions2 = _a2.defaultOptions, _b = _a2.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a2.onBroadcast, _c = _a2.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a2.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a2.localState, assumeImmutableResults = _a2.assumeImmutableResults;
    this.clientAwareness = {};
    this.queries = /* @__PURE__ */ new Map();
    this.fetchCancelFns = /* @__PURE__ */ new Map();
    this.transformCache = new (canUseWeakMap ? WeakMap : Map)();
    this.queryIdCounter = 1;
    this.requestIdCounter = 1;
    this.mutationIdCounter = 1;
    this.inFlightLinkObservables = /* @__PURE__ */ new Map();
    this.cache = cache2;
    this.link = link2;
    this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
    this.queryDeduplication = queryDeduplication;
    this.clientAwareness = clientAwareness;
    this.localState = localState || new LocalState({ cache: cache2 });
    this.ssrMode = ssrMode;
    this.assumeImmutableResults = !!assumeImmutableResults;
    if (this.onBroadcast = onBroadcast) {
      this.mutationStore = /* @__PURE__ */ Object.create(null);
    }
  }
  QueryManager2.prototype.stop = function() {
    var _this = this;
    this.queries.forEach(function(_info, queryId) {
      _this.stopQueryNoBroadcast(queryId);
    });
    this.cancelPendingFetches(__DEV__ ? new InvariantError("QueryManager stopped while query was in flight") : new InvariantError(13));
  };
  QueryManager2.prototype.cancelPendingFetches = function(error3) {
    this.fetchCancelFns.forEach(function(cancel) {
      return cancel(error3);
    });
    this.fetchCancelFns.clear();
  };
  QueryManager2.prototype.mutate = function(_a2) {
    var _b, _c;
    var mutation = _a2.mutation, variables = _a2.variables, optimisticResponse = _a2.optimisticResponse, updateQueries = _a2.updateQueries, _d = _a2.refetchQueries, refetchQueries = _d === void 0 ? [] : _d, _e2 = _a2.awaitRefetchQueries, awaitRefetchQueries = _e2 === void 0 ? false : _e2, updateWithProxyFn = _a2.update, onQueryUpdated = _a2.onQueryUpdated, _f = _a2.fetchPolicy, fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || "network-only" : _f, _g = _a2.errorPolicy, errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || "none" : _g, keepRootFields = _a2.keepRootFields, context2 = _a2.context;
    return __awaiter(this, void 0, void 0, function() {
      var mutationId, _h, document2, hasClientExports2, mutationStoreValue, self2;
      return __generator(this, function(_j) {
        switch (_j.label) {
          case 0:
            __DEV__ ? invariant$1(mutation, "mutation option is required. You must specify your GraphQL document in the mutation option.") : invariant$1(mutation, 14);
            __DEV__ ? invariant$1(fetchPolicy === "network-only" || fetchPolicy === "no-cache", "Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.") : invariant$1(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 15);
            mutationId = this.generateMutationId();
            _h = this.transform(mutation), document2 = _h.document, hasClientExports2 = _h.hasClientExports;
            mutation = this.cache.transformForLink(document2);
            variables = this.getVariables(mutation, variables);
            if (!hasClientExports2)
              return [3, 2];
            return [4, this.localState.addExportedVariables(mutation, variables, context2)];
          case 1:
            variables = _j.sent();
            _j.label = 2;
          case 2:
            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
              mutation,
              variables,
              loading: true,
              error: null
            });
            if (optimisticResponse) {
              this.markMutationOptimistic(optimisticResponse, {
                mutationId,
                document: mutation,
                variables,
                fetchPolicy,
                errorPolicy,
                context: context2,
                updateQueries,
                update: updateWithProxyFn,
                keepRootFields
              });
            }
            this.broadcastQueries();
            self2 = this;
            return [2, new Promise(function(resolve, reject) {
              return asyncMap$1(self2.getObservableFromLink(mutation, __assign$1(__assign$1({}, context2), { optimisticResponse }), variables, false), function(result) {
                if (graphQLResultHasError(result) && errorPolicy === "none") {
                  throw new ApolloError({
                    graphQLErrors: result.errors
                  });
                }
                if (mutationStoreValue) {
                  mutationStoreValue.loading = false;
                  mutationStoreValue.error = null;
                }
                var storeResult = __assign$1({}, result);
                if (typeof refetchQueries === "function") {
                  refetchQueries = refetchQueries(storeResult);
                }
                if (errorPolicy === "ignore" && graphQLResultHasError(storeResult)) {
                  delete storeResult.errors;
                }
                return self2.markMutationResult({
                  mutationId,
                  result: storeResult,
                  document: mutation,
                  variables,
                  fetchPolicy,
                  errorPolicy,
                  context: context2,
                  update: updateWithProxyFn,
                  updateQueries,
                  awaitRefetchQueries,
                  refetchQueries,
                  removeOptimistic: optimisticResponse ? mutationId : void 0,
                  onQueryUpdated,
                  keepRootFields
                });
              }).subscribe({
                next: function(storeResult) {
                  self2.broadcastQueries();
                  resolve(storeResult);
                },
                error: function(err) {
                  if (mutationStoreValue) {
                    mutationStoreValue.loading = false;
                    mutationStoreValue.error = err;
                  }
                  if (optimisticResponse) {
                    self2.cache.removeOptimistic(mutationId);
                  }
                  self2.broadcastQueries();
                  reject(err instanceof ApolloError ? err : new ApolloError({
                    networkError: err
                  }));
                }
              });
            })];
        }
      });
    });
  };
  QueryManager2.prototype.markMutationResult = function(mutation, cache2) {
    var _this = this;
    if (cache2 === void 0) {
      cache2 = this.cache;
    }
    var result = mutation.result;
    var cacheWrites = [];
    var skipCache = mutation.fetchPolicy === "no-cache";
    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
      cacheWrites.push({
        result: result.data,
        dataId: "ROOT_MUTATION",
        query: mutation.document,
        variables: mutation.variables
      });
      var updateQueries_1 = mutation.updateQueries;
      if (updateQueries_1) {
        this.queries.forEach(function(_a2, queryId) {
          var observableQuery = _a2.observableQuery;
          var queryName = observableQuery && observableQuery.queryName;
          if (!queryName || !hasOwnProperty$b.call(updateQueries_1, queryName)) {
            return;
          }
          var updater = updateQueries_1[queryName];
          var _b = _this.queries.get(queryId), document2 = _b.document, variables = _b.variables;
          var _c = cache2.diff({
            query: document2,
            variables,
            returnPartialData: true,
            optimistic: false
          }), currentQueryResult = _c.result, complete = _c.complete;
          if (complete && currentQueryResult) {
            var nextQueryResult = updater(currentQueryResult, {
              mutationResult: result,
              queryName: document2 && getOperationName(document2) || void 0,
              queryVariables: variables
            });
            if (nextQueryResult) {
              cacheWrites.push({
                result: nextQueryResult,
                dataId: "ROOT_QUERY",
                query: document2,
                variables
              });
            }
          }
        });
      }
    }
    if (cacheWrites.length > 0 || mutation.refetchQueries || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
      var results_1 = [];
      this.refetchQueries({
        updateCache: function(cache3) {
          if (!skipCache) {
            cacheWrites.forEach(function(write) {
              return cache3.write(write);
            });
          }
          var update = mutation.update;
          if (update) {
            if (!skipCache) {
              var diff = cache3.diff({
                id: "ROOT_MUTATION",
                query: _this.transform(mutation.document).asQuery,
                variables: mutation.variables,
                optimistic: false,
                returnPartialData: true
              });
              if (diff.complete && !isExecutionPatchIncrementalResult(result)) {
                result = __assign$1(__assign$1({}, result), { data: diff.result });
              }
            }
            update(cache3, result, {
              context: mutation.context,
              variables: mutation.variables
            });
          }
          if (!skipCache && !mutation.keepRootFields) {
            cache3.modify({
              id: "ROOT_MUTATION",
              fields: function(value, _a2) {
                var fieldName = _a2.fieldName, DELETE2 = _a2.DELETE;
                return fieldName === "__typename" ? value : DELETE2;
              }
            });
          }
        },
        include: mutation.refetchQueries,
        optimistic: false,
        removeOptimistic: mutation.removeOptimistic,
        onQueryUpdated: mutation.onQueryUpdated || null
      }).forEach(function(result2) {
        return results_1.push(result2);
      });
      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
        return Promise.all(results_1).then(function() {
          return result;
        });
      }
    }
    return Promise.resolve(result);
  };
  QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
    var _this = this;
    var data2 = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables) : optimisticResponse;
    return this.cache.recordOptimisticTransaction(function(cache2) {
      try {
        _this.markMutationResult(__assign$1(__assign$1({}, mutation), { result: { data: data2 } }), cache2);
      } catch (error3) {
        __DEV__ && invariant$1.error(error3);
      }
    }, mutation.mutationId);
  };
  QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {
    return this.fetchQueryObservable(queryId, options, networkStatus).promise;
  };
  QueryManager2.prototype.getQueryStore = function() {
    var store = /* @__PURE__ */ Object.create(null);
    this.queries.forEach(function(info, queryId) {
      store[queryId] = {
        variables: info.variables,
        networkStatus: info.networkStatus,
        networkError: info.networkError,
        graphQLErrors: info.graphQLErrors
      };
    });
    return store;
  };
  QueryManager2.prototype.resetErrors = function(queryId) {
    var queryInfo = this.queries.get(queryId);
    if (queryInfo) {
      queryInfo.networkError = void 0;
      queryInfo.graphQLErrors = [];
    }
  };
  QueryManager2.prototype.transform = function(document2) {
    var transformCache = this.transformCache;
    if (!transformCache.has(document2)) {
      var transformed = this.cache.transformDocument(document2);
      var noConnection = removeConnectionDirectiveFromDocument(transformed);
      var clientQuery = this.localState.clientQuery(transformed);
      var serverQuery = noConnection && this.localState.serverQuery(noConnection);
      var cacheEntry_1 = {
        document: transformed,
        hasClientExports: hasClientExports(transformed),
        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
        clientQuery,
        serverQuery,
        defaultVars: getDefaultValues(getOperationDefinition(transformed)),
        asQuery: __assign$1(__assign$1({}, transformed), { definitions: transformed.definitions.map(function(def) {
          if (def.kind === "OperationDefinition" && def.operation !== "query") {
            return __assign$1(__assign$1({}, def), { operation: "query" });
          }
          return def;
        }) })
      };
      var add = function(doc) {
        if (doc && !transformCache.has(doc)) {
          transformCache.set(doc, cacheEntry_1);
        }
      };
      add(document2);
      add(transformed);
      add(clientQuery);
      add(serverQuery);
    }
    return transformCache.get(document2);
  };
  QueryManager2.prototype.getVariables = function(document2, variables) {
    return __assign$1(__assign$1({}, this.transform(document2).defaultVars), variables);
  };
  QueryManager2.prototype.watchQuery = function(options) {
    options = __assign$1(__assign$1({}, options), { variables: this.getVariables(options.query, options.variables) });
    if (typeof options.notifyOnNetworkStatusChange === "undefined") {
      options.notifyOnNetworkStatusChange = false;
    }
    var queryInfo = new QueryInfo(this);
    var observable = new ObservableQuery({
      queryManager: this,
      queryInfo,
      options
    });
    this.queries.set(observable.queryId, queryInfo);
    queryInfo.init({
      document: observable.query,
      observableQuery: observable,
      variables: observable.variables
    });
    return observable;
  };
  QueryManager2.prototype.query = function(options, queryId) {
    var _this = this;
    if (queryId === void 0) {
      queryId = this.generateQueryId();
    }
    __DEV__ ? invariant$1(options.query, "query option is required. You must specify your GraphQL document in the query option.") : invariant$1(options.query, 16);
    __DEV__ ? invariant$1(options.query.kind === "Document", 'You must wrap the query string in a "gql" tag.') : invariant$1(options.query.kind === "Document", 17);
    __DEV__ ? invariant$1(!options.returnPartialData, "returnPartialData option only supported on watchQuery.") : invariant$1(!options.returnPartialData, 18);
    __DEV__ ? invariant$1(!options.pollInterval, "pollInterval option only supported on watchQuery.") : invariant$1(!options.pollInterval, 19);
    return this.fetchQuery(queryId, options).finally(function() {
      return _this.stopQuery(queryId);
    });
  };
  QueryManager2.prototype.generateQueryId = function() {
    return String(this.queryIdCounter++);
  };
  QueryManager2.prototype.generateRequestId = function() {
    return this.requestIdCounter++;
  };
  QueryManager2.prototype.generateMutationId = function() {
    return String(this.mutationIdCounter++);
  };
  QueryManager2.prototype.stopQueryInStore = function(queryId) {
    this.stopQueryInStoreNoBroadcast(queryId);
    this.broadcastQueries();
  };
  QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
    var queryInfo = this.queries.get(queryId);
    if (queryInfo)
      queryInfo.stop();
  };
  QueryManager2.prototype.clearStore = function(options) {
    if (options === void 0) {
      options = {
        discardWatches: true
      };
    }
    this.cancelPendingFetches(__DEV__ ? new InvariantError("Store reset while query was in flight (not completed in link chain)") : new InvariantError(20));
    this.queries.forEach(function(queryInfo) {
      if (queryInfo.observableQuery) {
        queryInfo.networkStatus = NetworkStatus.loading;
      } else {
        queryInfo.stop();
      }
    });
    if (this.mutationStore) {
      this.mutationStore = /* @__PURE__ */ Object.create(null);
    }
    return this.cache.reset(options);
  };
  QueryManager2.prototype.getObservableQueries = function(include) {
    var _this = this;
    if (include === void 0) {
      include = "active";
    }
    var queries = /* @__PURE__ */ new Map();
    var queryNamesAndDocs = /* @__PURE__ */ new Map();
    var legacyQueryOptions = /* @__PURE__ */ new Set();
    if (Array.isArray(include)) {
      include.forEach(function(desc) {
        if (typeof desc === "string") {
          queryNamesAndDocs.set(desc, false);
        } else if (isDocumentNode(desc)) {
          queryNamesAndDocs.set(_this.transform(desc).document, false);
        } else if (isNonNullObject(desc) && desc.query) {
          legacyQueryOptions.add(desc);
        }
      });
    }
    this.queries.forEach(function(_a2, queryId) {
      var oq = _a2.observableQuery, document2 = _a2.document;
      if (oq) {
        if (include === "all") {
          queries.set(queryId, oq);
          return;
        }
        var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
        if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
          return;
        }
        if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document2 && queryNamesAndDocs.has(document2)) {
          queries.set(queryId, oq);
          if (queryName)
            queryNamesAndDocs.set(queryName, true);
          if (document2)
            queryNamesAndDocs.set(document2, true);
        }
      }
    });
    if (legacyQueryOptions.size) {
      legacyQueryOptions.forEach(function(options) {
        var queryId = makeUniqueId("legacyOneTimeQuery");
        var queryInfo = _this.getQuery(queryId).init({
          document: options.query,
          variables: options.variables
        });
        var oq = new ObservableQuery({
          queryManager: _this,
          queryInfo,
          options: __assign$1(__assign$1({}, options), { fetchPolicy: "network-only" })
        });
        invariant$1(oq.queryId === queryId);
        queryInfo.setObservableQuery(oq);
        queries.set(queryId, oq);
      });
    }
    if (__DEV__ && queryNamesAndDocs.size) {
      queryNamesAndDocs.forEach(function(included, nameOrDoc) {
        if (!included) {
          __DEV__ && invariant$1.warn("Unknown query ".concat(typeof nameOrDoc === "string" ? "named " : "").concat(JSON.stringify(nameOrDoc, null, 2), " requested in refetchQueries options.include array"));
        }
      });
    }
    return queries;
  };
  QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
    var _this = this;
    if (includeStandby === void 0) {
      includeStandby = false;
    }
    var observableQueryPromises = [];
    this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
      var fetchPolicy = observableQuery.options.fetchPolicy;
      observableQuery.resetLastResults();
      if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
        observableQueryPromises.push(observableQuery.refetch());
      }
      _this.getQuery(queryId).setDiff(null);
    });
    this.broadcastQueries();
    return Promise.all(observableQueryPromises);
  };
  QueryManager2.prototype.setObservableQuery = function(observableQuery) {
    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
  };
  QueryManager2.prototype.startGraphQLSubscription = function(_a2) {
    var _this = this;
    var query = _a2.query, fetchPolicy = _a2.fetchPolicy, errorPolicy = _a2.errorPolicy, variables = _a2.variables, _b = _a2.context, context2 = _b === void 0 ? {} : _b;
    query = this.transform(query).document;
    variables = this.getVariables(query, variables);
    var makeObservable = function(variables2) {
      return _this.getObservableFromLink(query, context2, variables2).map(function(result) {
        if (fetchPolicy !== "no-cache") {
          if (shouldWriteResult(result, errorPolicy)) {
            _this.cache.write({
              query,
              result: result.data,
              dataId: "ROOT_SUBSCRIPTION",
              variables: variables2
            });
          }
          _this.broadcastQueries();
        }
        if (graphQLResultHasError(result)) {
          throw new ApolloError({
            graphQLErrors: result.errors
          });
        }
        return result;
      });
    };
    if (this.transform(query).hasClientExports) {
      var observablePromise_1 = this.localState.addExportedVariables(query, variables, context2).then(makeObservable);
      return new Observable$1(function(observer) {
        var sub = null;
        observablePromise_1.then(function(observable) {
          return sub = observable.subscribe(observer);
        }, observer.error);
        return function() {
          return sub && sub.unsubscribe();
        };
      });
    }
    return makeObservable(variables);
  };
  QueryManager2.prototype.stopQuery = function(queryId) {
    this.stopQueryNoBroadcast(queryId);
    this.broadcastQueries();
  };
  QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
    this.stopQueryInStoreNoBroadcast(queryId);
    this.removeQuery(queryId);
  };
  QueryManager2.prototype.removeQuery = function(queryId) {
    this.fetchCancelFns.delete(queryId);
    if (this.queries.has(queryId)) {
      this.getQuery(queryId).stop();
      this.queries.delete(queryId);
    }
  };
  QueryManager2.prototype.broadcastQueries = function() {
    if (this.onBroadcast)
      this.onBroadcast();
    this.queries.forEach(function(info) {
      return info.notify();
    });
  };
  QueryManager2.prototype.getLocalState = function() {
    return this.localState;
  };
  QueryManager2.prototype.getObservableFromLink = function(query, context2, variables, deduplication) {
    var _this = this;
    var _a2;
    if (deduplication === void 0) {
      deduplication = (_a2 = context2 === null || context2 === void 0 ? void 0 : context2.queryDeduplication) !== null && _a2 !== void 0 ? _a2 : this.queryDeduplication;
    }
    var observable;
    var serverQuery = this.transform(query).serverQuery;
    if (serverQuery) {
      var _b = this, inFlightLinkObservables_1 = _b.inFlightLinkObservables, link2 = _b.link;
      var operation = {
        query: serverQuery,
        variables,
        operationName: getOperationName(serverQuery) || void 0,
        context: this.prepareContext(__assign$1(__assign$1({}, context2), { forceFetch: !deduplication }))
      };
      context2 = operation.context;
      if (deduplication) {
        var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || /* @__PURE__ */ new Map();
        inFlightLinkObservables_1.set(serverQuery, byVariables_1);
        var varJson_1 = canonicalStringify(variables);
        observable = byVariables_1.get(varJson_1);
        if (!observable) {
          var concast = new Concast([
            execute(link2, operation)
          ]);
          byVariables_1.set(varJson_1, observable = concast);
          concast.beforeNext(function() {
            if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {
              inFlightLinkObservables_1.delete(serverQuery);
            }
          });
        }
      } else {
        observable = new Concast([
          execute(link2, operation)
        ]);
      }
    } else {
      observable = new Concast([
        Observable$1.of({ data: {} })
      ]);
      context2 = this.prepareContext(context2);
    }
    var clientQuery = this.transform(query).clientQuery;
    if (clientQuery) {
      observable = asyncMap$1(observable, function(result) {
        return _this.localState.runResolvers({
          document: clientQuery,
          remoteResult: result,
          context: context2,
          variables
        });
      });
    }
    return observable;
  };
  QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
    var requestId = queryInfo.lastRequestId = this.generateRequestId();
    options = cloneDeep$3(options);
    var linkDocument = this.cache.transformForLink(this.transform(queryInfo.document).document);
    return asyncMap$1(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result) {
      var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
      if ("incremental" in result && isNonEmptyArray(result.incremental)) {
        result.incremental.forEach(function(incrementalResult) {
          if (incrementalResult.errors) {
            graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
          }
        });
      }
      var hasErrors = isNonEmptyArray(graphQLErrors);
      if (requestId >= queryInfo.lastRequestId) {
        if (hasErrors && options.errorPolicy === "none") {
          throw queryInfo.markError(new ApolloError({
            graphQLErrors
          }));
        }
        queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);
        queryInfo.markReady();
      }
      var aqr = {
        data: result.data,
        loading: false,
        networkStatus: NetworkStatus.ready
      };
      if (hasErrors && options.errorPolicy !== "ignore") {
        aqr.errors = graphQLErrors;
        aqr.networkStatus = NetworkStatus.error;
      }
      return aqr;
    }, function(networkError) {
      var error3 = isApolloError(networkError) ? networkError : new ApolloError({ networkError });
      if (requestId >= queryInfo.lastRequestId) {
        queryInfo.markError(error3);
      }
      throw error3;
    });
  };
  QueryManager2.prototype.fetchQueryObservable = function(queryId, options, networkStatus) {
    var _this = this;
    if (networkStatus === void 0) {
      networkStatus = NetworkStatus.loading;
    }
    var query = this.transform(options.query).document;
    var variables = this.getVariables(query, options.variables);
    var queryInfo = this.getQuery(queryId);
    var defaults2 = this.defaultOptions.watchQuery;
    var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? defaults2 && defaults2.fetchPolicy || "cache-first" : _a2, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults2 && defaults2.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e2 = options.context, context2 = _e2 === void 0 ? {} : _e2;
    var normalized = Object.assign({}, options, {
      query,
      variables,
      fetchPolicy,
      errorPolicy,
      returnPartialData,
      notifyOnNetworkStatusChange,
      context: context2
    });
    var fromVariables = function(variables2) {
      normalized.variables = variables2;
      var concastSources = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
      if (normalized.fetchPolicy !== "standby" && concastSources.length > 0 && queryInfo.observableQuery) {
        queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
      }
      return concastSources;
    };
    var cleanupCancelFn = function() {
      return _this.fetchCancelFns.delete(queryId);
    };
    this.fetchCancelFns.set(queryId, function(reason) {
      cleanupCancelFn();
      setTimeout(function() {
        return concast.cancel(reason);
      });
    });
    var concast = new Concast(this.transform(normalized.query).hasClientExports ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables) : fromVariables(normalized.variables));
    concast.promise.then(cleanupCancelFn, cleanupCancelFn);
    return concast;
  };
  QueryManager2.prototype.refetchQueries = function(_a2) {
    var _this = this;
    var updateCache = _a2.updateCache, include = _a2.include, _b = _a2.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a2.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a2.onQueryUpdated;
    var includedQueriesById = /* @__PURE__ */ new Map();
    if (include) {
      this.getObservableQueries(include).forEach(function(oq, queryId) {
        includedQueriesById.set(queryId, {
          oq,
          lastDiff: _this.getQuery(queryId).getDiff()
        });
      });
    }
    var results = /* @__PURE__ */ new Map();
    if (updateCache) {
      this.cache.batch({
        update: updateCache,
        optimistic: optimistic && removeOptimistic || false,
        removeOptimistic,
        onWatchUpdated: function(watch, diff, lastDiff) {
          var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
          if (oq) {
            if (onQueryUpdated) {
              includedQueriesById.delete(oq.queryId);
              var result = onQueryUpdated(oq, diff, lastDiff);
              if (result === true) {
                result = oq.refetch();
              }
              if (result !== false) {
                results.set(oq, result);
              }
              return result;
            }
            if (onQueryUpdated !== null) {
              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });
            }
          }
        }
      });
    }
    if (includedQueriesById.size) {
      includedQueriesById.forEach(function(_a3, queryId) {
        var oq = _a3.oq, lastDiff = _a3.lastDiff, diff = _a3.diff;
        var result;
        if (onQueryUpdated) {
          if (!diff) {
            var info = oq["queryInfo"];
            info.reset();
            diff = info.getDiff();
          }
          result = onQueryUpdated(oq, diff, lastDiff);
        }
        if (!onQueryUpdated || result === true) {
          result = oq.refetch();
        }
        if (result !== false) {
          results.set(oq, result);
        }
        if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
          _this.stopQueryNoBroadcast(queryId);
        }
      });
    }
    if (removeOptimistic) {
      this.cache.removeOptimistic(removeOptimistic);
    }
    return results;
  };
  QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a2, networkStatus) {
    var _this = this;
    var query = _a2.query, variables = _a2.variables, fetchPolicy = _a2.fetchPolicy, refetchWritePolicy = _a2.refetchWritePolicy, errorPolicy = _a2.errorPolicy, returnPartialData = _a2.returnPartialData, context2 = _a2.context, notifyOnNetworkStatusChange = _a2.notifyOnNetworkStatusChange;
    var oldNetworkStatus = queryInfo.networkStatus;
    queryInfo.init({
      document: this.transform(query).document,
      variables,
      networkStatus
    });
    var readCache = function() {
      return queryInfo.getDiff(variables);
    };
    var resultsFromCache = function(diff2, networkStatus2) {
      if (networkStatus2 === void 0) {
        networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;
      }
      var data2 = diff2.result;
      if (__DEV__ && !returnPartialData && !equal(data2, {})) {
        logMissingFieldErrors(diff2.missing);
      }
      var fromData = function(data3) {
        return Observable$1.of(__assign$1({ data: data3, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff2.complete ? null : { partial: true }));
      };
      if (data2 && _this.transform(query).hasForcedResolvers) {
        return _this.localState.runResolvers({
          document: query,
          remoteResult: { data: data2 },
          context: context2,
          variables,
          onlyRunForcedResolvers: true
        }).then(function(resolved) {
          return fromData(resolved.data || void 0);
        });
      }
      return fromData(data2);
    };
    var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
    var resultsFromLink = function() {
      return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
        variables,
        context: context2,
        fetchPolicy,
        errorPolicy
      });
    };
    var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
    switch (fetchPolicy) {
      default:
      case "cache-first": {
        var diff = readCache();
        if (diff.complete) {
          return [
            resultsFromCache(diff, queryInfo.markReady())
          ];
        }
        if (returnPartialData || shouldNotify) {
          return [
            resultsFromCache(diff),
            resultsFromLink()
          ];
        }
        return [
          resultsFromLink()
        ];
      }
      case "cache-and-network": {
        var diff = readCache();
        if (diff.complete || returnPartialData || shouldNotify) {
          return [
            resultsFromCache(diff),
            resultsFromLink()
          ];
        }
        return [
          resultsFromLink()
        ];
      }
      case "cache-only":
        return [
          resultsFromCache(readCache(), queryInfo.markReady())
        ];
      case "network-only":
        if (shouldNotify) {
          return [
            resultsFromCache(readCache()),
            resultsFromLink()
          ];
        }
        return [resultsFromLink()];
      case "no-cache":
        if (shouldNotify) {
          return [
            resultsFromCache(queryInfo.getDiff()),
            resultsFromLink()
          ];
        }
        return [resultsFromLink()];
      case "standby":
        return [];
    }
  };
  QueryManager2.prototype.getQuery = function(queryId) {
    if (queryId && !this.queries.has(queryId)) {
      this.queries.set(queryId, new QueryInfo(this, queryId));
    }
    return this.queries.get(queryId);
  };
  QueryManager2.prototype.prepareContext = function(context2) {
    if (context2 === void 0) {
      context2 = {};
    }
    var newContext = this.localState.prepareContext(context2);
    return __assign$1(__assign$1({}, newContext), { clientAwareness: this.clientAwareness });
  };
  return QueryManager2;
}();
var hasSuggestedDevtools = false;
var ApolloClient = function() {
  function ApolloClient2(options) {
    var _this = this;
    this.resetStoreCallbacks = [];
    this.clearStoreCallbacks = [];
    var uri = options.uri, credentials = options.credentials, headers = options.headers, cache2 = options.cache, _a2 = options.ssrMode, ssrMode = _a2 === void 0 ? false : _a2, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, _c = options.connectToDevTools, connectToDevTools = _c === void 0 ? typeof window === "object" && !window.__APOLLO_CLIENT__ && __DEV__ : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions2 = options.defaultOptions, _e2 = options.assumeImmutableResults, assumeImmutableResults = _e2 === void 0 ? false : _e2, resolvers2 = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
    var link2 = options.link;
    if (!link2) {
      link2 = uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink$1.empty();
    }
    if (!cache2) {
      throw __DEV__ ? new InvariantError("To initialize Apollo Client, you must specify a 'cache' property in the options object. \nFor more information, please visit: https://go.apollo.dev/c/docs") : new InvariantError(9);
    }
    this.link = link2;
    this.cache = cache2;
    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
    this.queryDeduplication = queryDeduplication;
    this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
    this.typeDefs = typeDefs;
    if (ssrForceFetchDelay) {
      setTimeout(function() {
        return _this.disableNetworkFetches = false;
      }, ssrForceFetchDelay);
    }
    this.watchQuery = this.watchQuery.bind(this);
    this.query = this.query.bind(this);
    this.mutate = this.mutate.bind(this);
    this.resetStore = this.resetStore.bind(this);
    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
    if (connectToDevTools && typeof window === "object") {
      window.__APOLLO_CLIENT__ = this;
    }
    if (!hasSuggestedDevtools && __DEV__) {
      hasSuggestedDevtools = true;
      if (typeof window !== "undefined" && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
        var nav = window.navigator;
        var ua2 = nav && nav.userAgent;
        var url2 = void 0;
        if (typeof ua2 === "string") {
          if (ua2.indexOf("Chrome/") > -1) {
            url2 = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
          } else if (ua2.indexOf("Firefox/") > -1) {
            url2 = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
          }
        }
        if (url2) {
          __DEV__ && invariant$1.log("Download the Apollo DevTools for a better development experience: " + url2);
        }
      }
    }
    this.version = version$5;
    this.localState = new LocalState({
      cache: cache2,
      client: this,
      resolvers: resolvers2,
      fragmentMatcher
    });
    this.queryManager = new QueryManager({
      cache: this.cache,
      link: this.link,
      defaultOptions: this.defaultOptions,
      queryDeduplication,
      ssrMode,
      clientAwareness: {
        name: clientAwarenessName,
        version: clientAwarenessVersion
      },
      localState: this.localState,
      assumeImmutableResults,
      onBroadcast: connectToDevTools ? function() {
        if (_this.devToolsHookCb) {
          _this.devToolsHookCb({
            action: {},
            state: {
              queries: _this.queryManager.getQueryStore(),
              mutations: _this.queryManager.mutationStore || {}
            },
            dataWithOptimisticResults: _this.cache.extract(true)
          });
        }
      } : void 0
    });
  }
  ApolloClient2.prototype.stop = function() {
    this.queryManager.stop();
  };
  ApolloClient2.prototype.watchQuery = function(options) {
    if (this.defaultOptions.watchQuery) {
      options = mergeOptions(this.defaultOptions.watchQuery, options);
    }
    if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
      options = __assign$1(__assign$1({}, options), { fetchPolicy: "cache-first" });
    }
    return this.queryManager.watchQuery(options);
  };
  ApolloClient2.prototype.query = function(options) {
    if (this.defaultOptions.query) {
      options = mergeOptions(this.defaultOptions.query, options);
    }
    __DEV__ ? invariant$1(options.fetchPolicy !== "cache-and-network", "The cache-and-network fetchPolicy does not work with client.query, because client.query can only return a single result. Please use client.watchQuery to receive multiple results from the cache and the network, or consider using a different fetchPolicy, such as cache-first or network-only.") : invariant$1(options.fetchPolicy !== "cache-and-network", 10);
    if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
      options = __assign$1(__assign$1({}, options), { fetchPolicy: "cache-first" });
    }
    return this.queryManager.query(options);
  };
  ApolloClient2.prototype.mutate = function(options) {
    if (this.defaultOptions.mutate) {
      options = mergeOptions(this.defaultOptions.mutate, options);
    }
    return this.queryManager.mutate(options);
  };
  ApolloClient2.prototype.subscribe = function(options) {
    return this.queryManager.startGraphQLSubscription(options);
  };
  ApolloClient2.prototype.readQuery = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return this.cache.readQuery(options, optimistic);
  };
  ApolloClient2.prototype.readFragment = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return this.cache.readFragment(options, optimistic);
  };
  ApolloClient2.prototype.writeQuery = function(options) {
    this.cache.writeQuery(options);
    this.queryManager.broadcastQueries();
  };
  ApolloClient2.prototype.writeFragment = function(options) {
    this.cache.writeFragment(options);
    this.queryManager.broadcastQueries();
  };
  ApolloClient2.prototype.__actionHookForDevTools = function(cb) {
    this.devToolsHookCb = cb;
  };
  ApolloClient2.prototype.__requestRaw = function(payload) {
    return execute(this.link, payload);
  };
  ApolloClient2.prototype.resetStore = function() {
    var _this = this;
    return Promise.resolve().then(function() {
      return _this.queryManager.clearStore({
        discardWatches: false
      });
    }).then(function() {
      return Promise.all(_this.resetStoreCallbacks.map(function(fn2) {
        return fn2();
      }));
    }).then(function() {
      return _this.reFetchObservableQueries();
    });
  };
  ApolloClient2.prototype.clearStore = function() {
    var _this = this;
    return Promise.resolve().then(function() {
      return _this.queryManager.clearStore({
        discardWatches: true
      });
    }).then(function() {
      return Promise.all(_this.clearStoreCallbacks.map(function(fn2) {
        return fn2();
      }));
    });
  };
  ApolloClient2.prototype.onResetStore = function(cb) {
    var _this = this;
    this.resetStoreCallbacks.push(cb);
    return function() {
      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c2) {
        return c2 !== cb;
      });
    };
  };
  ApolloClient2.prototype.onClearStore = function(cb) {
    var _this = this;
    this.clearStoreCallbacks.push(cb);
    return function() {
      _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c2) {
        return c2 !== cb;
      });
    };
  };
  ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
    return this.queryManager.reFetchObservableQueries(includeStandby);
  };
  ApolloClient2.prototype.refetchQueries = function(options) {
    var map = this.queryManager.refetchQueries(options);
    var queries = [];
    var results = [];
    map.forEach(function(result2, obsQuery) {
      queries.push(obsQuery);
      results.push(result2);
    });
    var result = Promise.all(results);
    result.queries = queries;
    result.results = results;
    result.catch(function(error3) {
      __DEV__ && invariant$1.debug("In client.refetchQueries, Promise.all promise rejected with error ".concat(error3));
    });
    return result;
  };
  ApolloClient2.prototype.getObservableQueries = function(include) {
    if (include === void 0) {
      include = "active";
    }
    return this.queryManager.getObservableQueries(include);
  };
  ApolloClient2.prototype.extract = function(optimistic) {
    return this.cache.extract(optimistic);
  };
  ApolloClient2.prototype.restore = function(serializedState) {
    return this.cache.restore(serializedState);
  };
  ApolloClient2.prototype.addResolvers = function(resolvers2) {
    this.localState.addResolvers(resolvers2);
  };
  ApolloClient2.prototype.setResolvers = function(resolvers2) {
    this.localState.setResolvers(resolvers2);
  };
  ApolloClient2.prototype.getResolvers = function() {
    return this.localState.getResolvers();
  };
  ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
    this.localState.setFragmentMatcher(fragmentMatcher);
  };
  ApolloClient2.prototype.setLink = function(newLink) {
    this.link = this.queryManager.link = newLink;
  };
  return ApolloClient2;
}();
var docCache = /* @__PURE__ */ new Map();
var fragmentSourceMap = /* @__PURE__ */ new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize$4(string3) {
  return string3.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize$4(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions2 = [];
  ast.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions2.push(fragmentDefinition);
      }
    } else {
      definitions2.push(fragmentDefinition);
    }
  });
  return __assign$1(__assign$1({}, ast), { definitions: definitions2 });
}
function stripLoc(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node2) {
    if (node2.loc)
      delete node2.loc;
    Object.keys(node2).forEach(function(key) {
      var value = node2[key];
      if (value && typeof value === "object") {
        workSet.add(value);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
}
function parseDocument(source) {
  var cacheKey = normalize$4(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse$4(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    args[_i2 - 1] = arguments[_i2];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args.forEach(function(arg, i) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;
setVerbosity(DEV ? "log" : "silent");
var core = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  setLogVerbosity: setVerbosity,
  ApolloClient,
  mergeOptions,
  ObservableQuery,
  get NetworkStatus() {
    return NetworkStatus;
  },
  isApolloError,
  ApolloError,
  get Cache() {
    return Cache;
  },
  ApolloCache,
  InMemoryCache,
  MissingFieldError,
  defaultDataIdFromObject,
  makeVar,
  fromError,
  toPromise,
  fromPromise,
  throwServerError,
  Observable: Observable$1,
  isReference,
  makeReference,
  get gql() {
    return gql;
  },
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables,
  empty,
  from: from$2,
  split,
  concat,
  execute,
  ApolloLink: ApolloLink$1,
  parseAndCheckHttpResponse: parseAndCheckHttpResponse$1,
  serializeFetchParameter: serializeFetchParameter$1,
  fallbackHttpConfig: fallbackHttpConfig$1,
  defaultPrinter,
  selectHttpOptionsAndBody: selectHttpOptionsAndBody$1,
  selectHttpOptionsAndBodyInternal,
  checkFetcher,
  createSignalIfSupported: createSignalIfSupported$1,
  selectURI: selectURI$1,
  createHttpLink,
  HttpLink,
  rewriteURIForGET: rewriteURIForGET$1
}, Symbol.toStringTag, { value: "Module" }));
var contextKey = canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
function getApolloContext() {
  var context2 = React.createContext[contextKey];
  if (!context2) {
    Object.defineProperty(React.createContext, contextKey, {
      value: context2 = React.createContext({}),
      enumerable: false,
      writable: false,
      configurable: true
    });
    context2.displayName = "ApolloContext";
  }
  return context2;
}
var ApolloProvider = function(_a2) {
  var client = _a2.client, children = _a2.children;
  var ApolloContext = getApolloContext();
  return React.createElement(ApolloContext.Consumer, null, function(context2) {
    if (context2 === void 0) {
      context2 = {};
    }
    if (client && context2.client !== client) {
      context2 = Object.assign({}, context2, { client });
    }
    __DEV__ ? invariant$1(context2.client, 'ApolloProvider was not passed a client instance. Make sure you pass in your client via the "client" prop.') : invariant$1(context2.client, 28);
    return React.createElement(ApolloContext.Provider, { value: context2 }, children);
  });
};
function useApolloClient(override) {
  var context2 = React.useContext(getApolloContext());
  var client = override || context2.client;
  __DEV__ ? invariant$1(!!client, 'Could not find "client" in the context or passed in as an option. Wrap the root component in an <ApolloProvider>, or pass an ApolloClient instance in via options.') : invariant$1(!!client, 31);
  return client;
}
var didWarnUncachedGetSnapshot = false;
var uSESKey = "useSyncExternalStore";
var realHook = React[uSESKey];
var useSyncExternalStore = realHook || function(subscribe, getSnapshot, getServerSnapshot) {
  var value = getSnapshot();
  if (__DEV__ && !didWarnUncachedGetSnapshot && value !== getSnapshot()) {
    didWarnUncachedGetSnapshot = true;
    __DEV__ && invariant$1.error("The result of getSnapshot should be cached to avoid an infinite loop");
  }
  var _a2 = React.useState({ inst: { value, getSnapshot } }), inst = _a2[0].inst, forceUpdate = _a2[1];
  if (canUseLayoutEffect) {
    React.useLayoutEffect(function() {
      Object.assign(inst, { value, getSnapshot });
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({ inst });
      }
    }, [subscribe, value, getSnapshot]);
  } else {
    Object.assign(inst, { value, getSnapshot });
  }
  React.useEffect(function() {
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({ inst });
    }
    return subscribe(function handleStoreChange() {
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({ inst });
      }
    });
  }, [subscribe]);
  return value;
};
function checkIfSnapshotChanged(_a2) {
  var value = _a2.value, getSnapshot = _a2.getSnapshot;
  try {
    return value !== getSnapshot();
  } catch (_b) {
    return true;
  }
}
var DocumentType;
(function(DocumentType2) {
  DocumentType2[DocumentType2["Query"] = 0] = "Query";
  DocumentType2[DocumentType2["Mutation"] = 1] = "Mutation";
  DocumentType2[DocumentType2["Subscription"] = 2] = "Subscription";
})(DocumentType || (DocumentType = {}));
var cache = /* @__PURE__ */ new Map();
function operationName(type4) {
  var name;
  switch (type4) {
    case DocumentType.Query:
      name = "Query";
      break;
    case DocumentType.Mutation:
      name = "Mutation";
      break;
    case DocumentType.Subscription:
      name = "Subscription";
      break;
  }
  return name;
}
function parser(document2) {
  var cached2 = cache.get(document2);
  if (cached2)
    return cached2;
  var variables, type4, name;
  __DEV__ ? invariant$1(!!document2 && !!document2.kind, "Argument of ".concat(document2, " passed to parser was not a valid GraphQL ") + "DocumentNode. You may need to use 'graphql-tag' or another method to convert your operation into a document") : invariant$1(!!document2 && !!document2.kind, 32);
  var fragments = [];
  var queries = [];
  var mutations = [];
  var subscriptions = [];
  for (var _i2 = 0, _a2 = document2.definitions; _i2 < _a2.length; _i2++) {
    var x2 = _a2[_i2];
    if (x2.kind === "FragmentDefinition") {
      fragments.push(x2);
      continue;
    }
    if (x2.kind === "OperationDefinition") {
      switch (x2.operation) {
        case "query":
          queries.push(x2);
          break;
        case "mutation":
          mutations.push(x2);
          break;
        case "subscription":
          subscriptions.push(x2);
          break;
      }
    }
  }
  __DEV__ ? invariant$1(!fragments.length || (queries.length || mutations.length || subscriptions.length), "Passing only a fragment to 'graphql' is not yet supported. You must include a query, subscription or mutation as well") : invariant$1(!fragments.length || (queries.length || mutations.length || subscriptions.length), 33);
  __DEV__ ? invariant$1(queries.length + mutations.length + subscriptions.length <= 1, "react-apollo only supports a query, subscription, or a mutation per HOC. " + "".concat(document2, " had ").concat(queries.length, " queries, ").concat(subscriptions.length, " ") + "subscriptions and ".concat(mutations.length, " mutations. ") + "You can use 'compose' to join multiple operation types to a component") : invariant$1(queries.length + mutations.length + subscriptions.length <= 1, 34);
  type4 = queries.length ? DocumentType.Query : DocumentType.Mutation;
  if (!queries.length && !mutations.length)
    type4 = DocumentType.Subscription;
  var definitions2 = queries.length ? queries : mutations.length ? mutations : subscriptions;
  __DEV__ ? invariant$1(definitions2.length === 1, "react-apollo only supports one definition per HOC. ".concat(document2, " had ") + "".concat(definitions2.length, " definitions. ") + "You can use 'compose' to join multiple operation types to a component") : invariant$1(definitions2.length === 1, 35);
  var definition2 = definitions2[0];
  variables = definition2.variableDefinitions || [];
  if (definition2.name && definition2.name.kind === "Name") {
    name = definition2.name.value;
  } else {
    name = "data";
  }
  var payload = { name, type: type4, variables };
  cache.set(document2, payload);
  return payload;
}
function verifyDocumentType(document2, type4) {
  var operation = parser(document2);
  var requiredOperationName = operationName(type4);
  var usedOperationName = operationName(operation.type);
  __DEV__ ? invariant$1(operation.type === type4, "Running a ".concat(requiredOperationName, " requires a graphql ") + "".concat(requiredOperationName, ", but a ").concat(usedOperationName, " was used instead.")) : invariant$1(operation.type === type4, 36);
}
var hasOwnProperty$a = Object.prototype.hasOwnProperty;
function useQuery(query, options) {
  if (options === void 0) {
    options = /* @__PURE__ */ Object.create(null);
  }
  return useInternalState(useApolloClient(options.client), query).useQuery(options);
}
function useInternalState(client, query) {
  var stateRef = React.useRef();
  if (!stateRef.current || client !== stateRef.current.client || query !== stateRef.current.query) {
    stateRef.current = new InternalState(client, query, stateRef.current);
  }
  var state = stateRef.current;
  var _a2 = React.useState(0);
  _a2[0];
  var setTick = _a2[1];
  state.forceUpdate = function() {
    setTick(function(tick) {
      return tick + 1;
    });
  };
  return state;
}
var InternalState = function() {
  function InternalState2(client, query, previous2) {
    this.client = client;
    this.query = query;
    this.asyncResolveFns = /* @__PURE__ */ new Set();
    this.optionsToIgnoreOnce = new (canUseWeakSet ? WeakSet : Set)();
    this.ssrDisabledResult = maybeDeepFreeze({
      loading: true,
      data: void 0,
      error: void 0,
      networkStatus: NetworkStatus.loading
    });
    this.skipStandbyResult = maybeDeepFreeze({
      loading: false,
      data: void 0,
      error: void 0,
      networkStatus: NetworkStatus.ready
    });
    this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();
    verifyDocumentType(query, DocumentType.Query);
    var previousResult = previous2 && previous2.result;
    var previousData = previousResult && previousResult.data;
    if (previousData) {
      this.previousData = previousData;
    }
  }
  InternalState2.prototype.forceUpdate = function() {
    __DEV__ && invariant$1.warn("Calling default no-op implementation of InternalState#forceUpdate");
  };
  InternalState2.prototype.asyncUpdate = function() {
    var _this = this;
    return new Promise(function(resolve) {
      _this.asyncResolveFns.add(resolve);
      _this.optionsToIgnoreOnce.add(_this.watchQueryOptions);
      _this.forceUpdate();
    });
  };
  InternalState2.prototype.useQuery = function(options) {
    var _this = this;
    this.renderPromises = React.useContext(getApolloContext()).renderPromises;
    this.useOptions(options);
    var obsQuery = this.useObservableQuery();
    var result = useSyncExternalStore(React.useCallback(function() {
      if (_this.renderPromises) {
        return function() {
        };
      }
      var onNext = function() {
        var previousResult = _this.result;
        var result2 = obsQuery.getCurrentResult();
        if (previousResult && previousResult.loading === result2.loading && previousResult.networkStatus === result2.networkStatus && equal(previousResult.data, result2.data)) {
          return;
        }
        _this.setResult(result2);
      };
      var onError2 = function(error3) {
        var last = obsQuery["last"];
        subscription.unsubscribe();
        try {
          obsQuery.resetLastResults();
          subscription = obsQuery.subscribe(onNext, onError2);
        } finally {
          obsQuery["last"] = last;
        }
        if (!hasOwnProperty$a.call(error3, "graphQLErrors")) {
          throw error3;
        }
        var previousResult = _this.result;
        if (!previousResult || previousResult && previousResult.loading || !equal(error3, previousResult.error)) {
          _this.setResult({
            data: previousResult && previousResult.data,
            error: error3,
            loading: false,
            networkStatus: NetworkStatus.error
          });
        }
      };
      var subscription = obsQuery.subscribe(onNext, onError2);
      return function() {
        return subscription.unsubscribe();
      };
    }, [
      obsQuery,
      this.renderPromises,
      this.client.disableNetworkFetches
    ]), function() {
      return _this.getCurrentResult();
    }, function() {
      return _this.getCurrentResult();
    });
    this.unsafeHandlePartialRefetch(result);
    var queryResult = this.toQueryResult(result);
    if (!queryResult.loading && this.asyncResolveFns.size) {
      this.asyncResolveFns.forEach(function(resolve) {
        return resolve(queryResult);
      });
      this.asyncResolveFns.clear();
    }
    return queryResult;
  };
  InternalState2.prototype.useOptions = function(options) {
    var _a2;
    var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);
    var currentWatchQueryOptions = this.watchQueryOptions;
    if (this.optionsToIgnoreOnce.has(currentWatchQueryOptions) || !equal(watchQueryOptions, currentWatchQueryOptions)) {
      this.watchQueryOptions = watchQueryOptions;
      if (currentWatchQueryOptions && this.observable) {
        this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);
        this.observable.reobserve(this.getObsQueryOptions());
        this.previousData = ((_a2 = this.result) === null || _a2 === void 0 ? void 0 : _a2.data) || this.previousData;
        this.result = void 0;
      }
    }
    this.onCompleted = options.onCompleted || InternalState2.prototype.onCompleted;
    this.onError = options.onError || InternalState2.prototype.onError;
    if ((this.renderPromises || this.client.disableNetworkFetches) && this.queryHookOptions.ssr === false && !this.queryHookOptions.skip) {
      this.result = this.ssrDisabledResult;
    } else if (this.queryHookOptions.skip || this.watchQueryOptions.fetchPolicy === "standby") {
      this.result = this.skipStandbyResult;
    } else if (this.result === this.ssrDisabledResult || this.result === this.skipStandbyResult) {
      this.result = void 0;
    }
  };
  InternalState2.prototype.getObsQueryOptions = function() {
    var toMerge = [];
    var globalDefaults = this.client.defaultOptions.watchQuery;
    if (globalDefaults)
      toMerge.push(globalDefaults);
    if (this.queryHookOptions.defaultOptions) {
      toMerge.push(this.queryHookOptions.defaultOptions);
    }
    toMerge.push(compact$1(this.observable && this.observable.options, this.watchQueryOptions));
    return toMerge.reduce(mergeOptions);
  };
  InternalState2.prototype.createWatchQueryOptions = function(_a2) {
    var _b;
    if (_a2 === void 0) {
      _a2 = {};
    }
    var skip = _a2.skip;
    _a2.ssr;
    _a2.onCompleted;
    _a2.onError;
    _a2.defaultOptions;
    var otherOptions = __rest$G(_a2, ["skip", "ssr", "onCompleted", "onError", "defaultOptions"]);
    var watchQueryOptions = Object.assign(otherOptions, { query: this.query });
    if (this.renderPromises && (watchQueryOptions.fetchPolicy === "network-only" || watchQueryOptions.fetchPolicy === "cache-and-network")) {
      watchQueryOptions.fetchPolicy = "cache-first";
    }
    if (!watchQueryOptions.variables) {
      watchQueryOptions.variables = {};
    }
    if (skip) {
      var _c = watchQueryOptions.fetchPolicy, fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c, _d = watchQueryOptions.initialFetchPolicy, initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;
      Object.assign(watchQueryOptions, {
        initialFetchPolicy,
        fetchPolicy: "standby"
      });
    } else if (!watchQueryOptions.fetchPolicy) {
      watchQueryOptions.fetchPolicy = ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) || this.getDefaultFetchPolicy();
    }
    return watchQueryOptions;
  };
  InternalState2.prototype.getDefaultFetchPolicy = function() {
    var _a2, _b;
    return ((_a2 = this.queryHookOptions.defaultOptions) === null || _a2 === void 0 ? void 0 : _a2.fetchPolicy) || ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || "cache-first";
  };
  InternalState2.prototype.onCompleted = function(data2) {
  };
  InternalState2.prototype.onError = function(error3) {
  };
  InternalState2.prototype.useObservableQuery = function() {
    var obsQuery = this.observable = this.renderPromises && this.renderPromises.getSSRObservable(this.watchQueryOptions) || this.observable || this.client.watchQuery(this.getObsQueryOptions());
    this.obsQueryFields = React.useMemo(function() {
      return {
        refetch: obsQuery.refetch.bind(obsQuery),
        reobserve: obsQuery.reobserve.bind(obsQuery),
        fetchMore: obsQuery.fetchMore.bind(obsQuery),
        updateQuery: obsQuery.updateQuery.bind(obsQuery),
        startPolling: obsQuery.startPolling.bind(obsQuery),
        stopPolling: obsQuery.stopPolling.bind(obsQuery),
        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)
      };
    }, [obsQuery]);
    var ssrAllowed = !(this.queryHookOptions.ssr === false || this.queryHookOptions.skip);
    if (this.renderPromises && ssrAllowed) {
      this.renderPromises.registerSSRObservable(obsQuery);
      if (obsQuery.getCurrentResult().loading) {
        this.renderPromises.addObservableQueryPromise(obsQuery);
      }
    }
    return obsQuery;
  };
  InternalState2.prototype.setResult = function(nextResult) {
    var previousResult = this.result;
    if (previousResult && previousResult.data) {
      this.previousData = previousResult.data;
    }
    this.result = nextResult;
    this.forceUpdate();
    this.handleErrorOrCompleted(nextResult);
  };
  InternalState2.prototype.handleErrorOrCompleted = function(result) {
    var _this = this;
    if (!result.loading) {
      Promise.resolve().then(function() {
        if (result.error) {
          _this.onError(result.error);
        } else if (result.data) {
          _this.onCompleted(result.data);
        }
      }).catch(function(error3) {
        __DEV__ && invariant$1.warn(error3);
      });
    }
  };
  InternalState2.prototype.getCurrentResult = function() {
    if (!this.result) {
      this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());
    }
    return this.result;
  };
  InternalState2.prototype.toQueryResult = function(result) {
    var queryResult = this.toQueryResultCache.get(result);
    if (queryResult)
      return queryResult;
    var data2 = result.data;
    result.partial;
    var resultWithoutPartial = __rest$G(result, ["data", "partial"]);
    this.toQueryResultCache.set(result, queryResult = __assign$1(__assign$1(__assign$1({ data: data2 }, resultWithoutPartial), this.obsQueryFields), { client: this.client, observable: this.observable, variables: this.observable.variables, called: !this.queryHookOptions.skip, previousData: this.previousData }));
    if (!queryResult.error && isNonEmptyArray(result.errors)) {
      queryResult.error = new ApolloError({ graphQLErrors: result.errors });
    }
    return queryResult;
  };
  InternalState2.prototype.unsafeHandlePartialRefetch = function(result) {
    if (result.partial && this.queryHookOptions.partialRefetch && !result.loading && (!result.data || Object.keys(result.data).length === 0) && this.observable.options.fetchPolicy !== "cache-only") {
      Object.assign(result, {
        loading: true,
        networkStatus: NetworkStatus.refetch
      });
      this.observable.refetch();
    }
  };
  return InternalState2;
}();
function useMutation(mutation, options) {
  var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);
  verifyDocumentType(mutation, DocumentType.Mutation);
  var _a2 = React.useState({
    called: false,
    loading: false,
    client
  }), result = _a2[0], setResult = _a2[1];
  var ref2 = React.useRef({
    result,
    mutationId: 0,
    isMounted: true,
    client,
    mutation,
    options
  });
  {
    Object.assign(ref2.current, { client, options, mutation });
  }
  var execute2 = React.useCallback(function(executeOptions) {
    if (executeOptions === void 0) {
      executeOptions = {};
    }
    var _a3 = ref2.current, client2 = _a3.client, options2 = _a3.options, mutation2 = _a3.mutation;
    var baseOptions = __assign$1(__assign$1({}, options2), { mutation: mutation2 });
    if (!ref2.current.result.loading && !baseOptions.ignoreResults && ref2.current.isMounted) {
      setResult(ref2.current.result = {
        loading: true,
        error: void 0,
        data: void 0,
        called: true,
        client: client2
      });
    }
    var mutationId = ++ref2.current.mutationId;
    var clientOptions = mergeOptions(baseOptions, executeOptions);
    return client2.mutate(clientOptions).then(function(response) {
      var _a4, _b, _c;
      var data2 = response.data, errors = response.errors;
      var error3 = errors && errors.length > 0 ? new ApolloError({ graphQLErrors: errors }) : void 0;
      if (mutationId === ref2.current.mutationId && !clientOptions.ignoreResults) {
        var result_1 = {
          called: true,
          loading: false,
          data: data2,
          error: error3,
          client: client2
        };
        if (ref2.current.isMounted && !equal(ref2.current.result, result_1)) {
          setResult(ref2.current.result = result_1);
        }
      }
      (_b = (_a4 = ref2.current.options) === null || _a4 === void 0 ? void 0 : _a4.onCompleted) === null || _b === void 0 ? void 0 : _b.call(_a4, response.data, clientOptions);
      (_c = executeOptions.onCompleted) === null || _c === void 0 ? void 0 : _c.call(executeOptions, response.data, clientOptions);
      return response;
    }).catch(function(error3) {
      var _a4, _b, _c, _d;
      if (mutationId === ref2.current.mutationId && ref2.current.isMounted) {
        var result_2 = {
          loading: false,
          error: error3,
          data: void 0,
          called: true,
          client: client2
        };
        if (!equal(ref2.current.result, result_2)) {
          setResult(ref2.current.result = result_2);
        }
      }
      if (((_a4 = ref2.current.options) === null || _a4 === void 0 ? void 0 : _a4.onError) || clientOptions.onError) {
        (_c = (_b = ref2.current.options) === null || _b === void 0 ? void 0 : _b.onError) === null || _c === void 0 ? void 0 : _c.call(_b, error3, clientOptions);
        (_d = executeOptions.onError) === null || _d === void 0 ? void 0 : _d.call(executeOptions, error3, clientOptions);
        return { data: void 0, errors: error3 };
      }
      throw error3;
    });
  }, []);
  var reset = React.useCallback(function() {
    if (ref2.current.isMounted) {
      setResult({ called: false, loading: false, client });
    }
  }, []);
  React.useEffect(function() {
    ref2.current.isMounted = true;
    return function() {
      ref2.current.isMounted = false;
    };
  }, []);
  return [execute2, __assign$1({ reset }, result)];
}
const defaultOptions$1 = {};
const PluginDocument = gql`
    query Plugin($id: ID!) {
  node(id: $id, type: PLUGIN) {
    id
    ... on Plugin {
      id
      images
      author
      publisher {
        id
        name
        displayName
      }
      like
      downloads
      name
      icon
      readme
      description
      liked
      updatedAt
      active
      latestVersion {
        version
      }
    }
  }
}
    `;
function usePluginQuery(baseOptions) {
  const options = { ...defaultOptions$1, ...baseOptions };
  return useQuery(PluginDocument, options);
}
const PluginsDocument = gql`
    query Plugins($ids: [ID!]!) {
  nodes(ids: $ids, type: PLUGIN) {
    id
    ... on Plugin {
      id
      images
      author
      publisher {
        id
        name
        displayName
      }
      like
      downloads
      name
      icon
      readme
      description
      liked
      updatedAt
      latestVersion {
        version
      }
    }
  }
}
    `;
function usePluginsQuery(baseOptions) {
  const options = { ...defaultOptions$1, ...baseOptions };
  return useQuery(PluginsDocument, options);
}
const SearchPluginDocument = gql`
    query SearchPlugin($first: Int!, $keyword: String, $liked: Boolean, $tags: [String!], $types: [PluginType!], $publisher: ID, $sort: PluginSort, $offset: Int) {
  plugins(
    input: {first: $first, keyword: $keyword, liked: $liked, tags: $tags, types: $types, publisher: $publisher, sort: $sort, offset: $offset}
  ) {
    nodes {
      id
      images
      author
      publisher {
        id
        name
        displayName
      }
      like
      liked
      downloads
      name
    }
    totalCount
  }
}
    `;
function useSearchPluginQuery(baseOptions) {
  const options = { ...defaultOptions$1, ...baseOptions };
  return useQuery(SearchPluginDocument, options);
}
const LikePluginDocument = gql`
    mutation LikePlugin($id: ID!) {
  likePlugin(input: {pluginId: $id}) {
    plugin {
      id
      like
      liked
    }
  }
}
    `;
function useLikePluginMutation(baseOptions) {
  const options = { ...defaultOptions$1, ...baseOptions };
  return useMutation(LikePluginDocument, options);
}
const UnlikePluginDocument = gql`
    mutation UnlikePlugin($id: ID!) {
  unlikePlugin(input: {pluginId: $id}) {
    plugin {
      id
      like
      liked
    }
  }
}
    `;
function useUnlikePluginMutation(baseOptions) {
  const options = { ...defaultOptions$1, ...baseOptions };
  return useMutation(UnlikePluginDocument, options);
}
gql`
    mutation UpdatePlugin($pluginId: ID!, $active: Boolean, $images: [Upload!], $newTags: [String!], $deletedTags: [String!]) {
  updatePlugin(
    input: {pluginId: $pluginId, active: $active, images: $images, newTags: $newTags, deletedTags: $deletedTags}
  ) {
    plugin {
      id
      active
      tags
      images
    }
  }
}
    `;
gql`
    mutation CreatePlugin($file: Upload, $repo: String, $publisher: ID) {
  createPlugin(input: {file: $file, repo: $repo, publisher: $publisher}) {
    plugin {
      id
      name
      description
      latestVersion {
        version
      }
      images
    }
  }
}
    `;
gql`
    mutation ParsePlugin($file: Upload, $repo: String) {
  parsePlugin(input: {file: $file, repo: $repo}) {
    plugin {
      id
      type
      name
      author
      publisher {
        id
        name
        displayName
      }
      description
      icon
      repository
      readme
      latestVersion {
        version
      }
    }
  }
}
    `;
gql`
    mutation UpdatePluginVersion($pluginId: ID!, $version: String!, $description: String, $active: Boolean) {
  updateVersion(
    input: {pluginId: $pluginId, version: $version, description: $description, active: $active}
  ) {
    plugin {
      id
      name
      author
      publisher {
        id
        name
        displayName
      }
      description
      icon
      repository
      publishedAt
      readme
      latestVersion {
        version
        description
        downloads
        active
        createdAt
        updatedAt
        publishedAt
      }
    }
  }
}
    `;
const GetMeDocument = gql`
    query GetMe($first: Int!, $offset: Int) {
  me {
    id
    name
    lang
    displayName
    description
    plugins(first: $first, offset: $offset) {
      nodes {
        id
        images
        author
        like
        liked
        downloads
        name
        readme
        icon
        latestVersion {
          version
        }
        active
        updatedAt
      }
      totalCount
    }
  }
}
    `;
function useGetMeQuery(baseOptions) {
  const options = { ...defaultOptions$1, ...baseOptions };
  return useQuery(GetMeDocument, options);
}
gql`
    mutation UpdateMe($name: String, $lang: Lang, $displayName: String, $description: String, $tel: String) {
  updateMe(
    input: {name: $name, lang: $lang, displayName: $displayName, description: $description, tel: $tel}
  ) {
    me {
      id
      name
      lang
      displayName
      description
      tel
    }
  }
}
    `;
function setContext(setter) {
  return new ApolloLink$1(function(operation, forward) {
    var request = __rest$G(operation, []);
    return new Observable$1(function(observer) {
      var handle2;
      var closed = false;
      Promise.resolve(request).then(function(req) {
        return setter(req, operation.getContext());
      }).then(operation.setContext).then(function() {
        if (closed)
          return;
        handle2 = forward(operation).subscribe({
          next: observer.next.bind(observer),
          error: observer.error.bind(observer),
          complete: observer.complete.bind(observer)
        });
      }).catch(observer.error.bind(observer));
      return function() {
        closed = true;
        if (handle2)
          handle2.unsubscribe();
      };
    });
  });
}
function onError(errorHandler) {
  return new ApolloLink$1(function(operation, forward) {
    return new Observable$1(function(observer) {
      var sub;
      var retriedSub;
      var retriedResult;
      try {
        sub = forward(operation).subscribe({
          next: function(result) {
            if (result.errors) {
              retriedResult = errorHandler({
                graphQLErrors: result.errors,
                response: result,
                operation,
                forward
              });
              if (retriedResult) {
                retriedSub = retriedResult.subscribe({
                  next: observer.next.bind(observer),
                  error: observer.error.bind(observer),
                  complete: observer.complete.bind(observer)
                });
                return;
              }
            }
            observer.next(result);
          },
          error: function(networkError) {
            retriedResult = errorHandler({
              operation,
              networkError,
              graphQLErrors: networkError && networkError.result && networkError.result.errors,
              forward
            });
            if (retriedResult) {
              retriedSub = retriedResult.subscribe({
                next: observer.next.bind(observer),
                error: observer.error.bind(observer),
                complete: observer.complete.bind(observer)
              });
              return;
            }
            observer.error(networkError);
          },
          complete: function() {
            if (!retriedResult) {
              observer.complete.bind(observer)();
            }
          }
        });
      } catch (e2) {
        errorHandler({ networkError: e2, operation, forward });
        observer.error(e2);
      }
      return function() {
        if (sub)
          sub.unsubscribe();
        if (retriedSub)
          sub.unsubscribe();
      };
    });
  });
}
(function(_super) {
  __extends$1(ErrorLink, _super);
  function ErrorLink(errorHandler) {
    var _this = _super.call(this) || this;
    _this.link = onError(errorHandler);
    return _this;
  }
  ErrorLink.prototype.request = function(operation, forward) {
    return this.link.request(operation, forward);
  };
  return ErrorLink;
})(ApolloLink$1);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(core);
var require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(http);
var ReactNativeFile_1 = class ReactNativeFile {
  constructor({ uri, name, type: type4 }) {
    this.uri = uri;
    this.name = name;
    this.type = type4;
  }
};
const ReactNativeFile2 = ReactNativeFile_1;
var isExtractableFile$2 = function isExtractableFile(value) {
  return typeof File !== "undefined" && value instanceof File || typeof Blob !== "undefined" && value instanceof Blob || value instanceof ReactNativeFile2;
};
const defaultIsExtractableFile = isExtractableFile$2;
var extractFiles$1 = function extractFiles(value, path2 = "", isExtractableFile3 = defaultIsExtractableFile) {
  const files = /* @__PURE__ */ new Map();
  const clones = /* @__PURE__ */ new Map();
  function recurse(value2, path3, recursed) {
    let clone2 = value2;
    if (isExtractableFile3(value2)) {
      clone2 = null;
      const filePaths = files.get(value2);
      filePaths ? filePaths.push(path3) : files.set(value2, [path3]);
    } else {
      const isList = Array.isArray(value2) || typeof FileList !== "undefined" && value2 instanceof FileList;
      const isObject2 = value2 && value2.constructor === Object;
      if (isList || isObject2) {
        const hasClone = clones.has(value2);
        if (hasClone)
          clone2 = clones.get(value2);
        else {
          clone2 = isList ? [] : {};
          clones.set(value2, clone2);
        }
        if (!recursed.has(value2)) {
          const pathPrefix = path3 ? `${path3}.` : "";
          const recursedDeeper = new Set(recursed).add(value2);
          if (isList) {
            let index2 = 0;
            for (const item of value2) {
              const itemClone = recurse(
                item,
                pathPrefix + index2++,
                recursedDeeper
              );
              if (!hasClone)
                clone2.push(itemClone);
            }
          } else
            for (const key in value2) {
              const propertyClone = recurse(
                value2[key],
                pathPrefix + key,
                recursedDeeper
              );
              if (!hasClone)
                clone2[key] = propertyClone;
            }
        }
      }
    }
    return clone2;
  }
  return {
    clone: recurse(value, path2, /* @__PURE__ */ new Set()),
    files
  };
};
var formDataAppendFile$1 = function formDataAppendFile(formData, fieldName, file) {
  formData.append(fieldName, file, file.name);
};
var isExtractableFile$1 = isExtractableFile$2;
const { ApolloLink, Observable } = require$$0$1;
const {
  createSignalIfSupported,
  fallbackHttpConfig,
  parseAndCheckHttpResponse,
  rewriteURIForGET,
  selectHttpOptionsAndBody,
  selectURI,
  serializeFetchParameter
} = require$$1$1;
const extractFiles2 = extractFiles$1;
const formDataAppendFile2 = formDataAppendFile$1;
const isExtractableFile2 = isExtractableFile$1;
var createUploadLink = function createUploadLink2({
  uri: fetchUri = "/graphql",
  useGETForQueries,
  isExtractableFile: customIsExtractableFile = isExtractableFile2,
  FormData: CustomFormData,
  formDataAppendFile: customFormDataAppendFile = formDataAppendFile2,
  fetch: customFetch,
  fetchOptions,
  credentials,
  headers,
  includeExtensions
} = {}) {
  const linkConfig = {
    http: { includeExtensions },
    options: fetchOptions,
    credentials,
    headers
  };
  return new ApolloLink((operation) => {
    const context2 = operation.getContext();
    const {
      clientAwareness: { name, version: version2 } = {},
      headers: headers2
    } = context2;
    const contextConfig = {
      http: context2.http,
      options: context2.fetchOptions,
      credentials: context2.credentials,
      headers: {
        ...name && { "apollographql-client-name": name },
        ...version2 && { "apollographql-client-version": version2 },
        ...headers2
      }
    };
    const { options, body } = selectHttpOptionsAndBody(
      operation,
      fallbackHttpConfig,
      linkConfig,
      contextConfig
    );
    const { clone: clone2, files } = extractFiles2(body, "", customIsExtractableFile);
    let uri = selectURI(operation, fetchUri);
    if (files.size) {
      delete options.headers["content-type"];
      const RuntimeFormData = CustomFormData || FormData;
      const form = new RuntimeFormData();
      form.append("operations", serializeFetchParameter(clone2, "Payload"));
      const map = {};
      let i = 0;
      files.forEach((paths) => {
        map[++i] = paths;
      });
      form.append("map", JSON.stringify(map));
      i = 0;
      files.forEach((paths, file) => {
        customFormDataAppendFile(form, ++i, file);
      });
      options.body = form;
    } else {
      if (useGETForQueries && !operation.query.definitions.some(
        (definition2) => definition2.kind === "OperationDefinition" && definition2.operation === "mutation"
      ))
        options.method = "GET";
      if (options.method === "GET") {
        const { newURI, parseError } = rewriteURIForGET(uri, body);
        if (parseError)
          return new Observable((observer) => {
            observer.error(parseError);
          });
        uri = newURI;
      } else
        options.body = serializeFetchParameter(clone2, "Payload");
    }
    const { controller } = createSignalIfSupported();
    if (controller) {
      if (options.signal)
        options.signal.aborted ? controller.abort() : options.signal.addEventListener(
          "abort",
          () => {
            controller.abort();
          },
          {
            once: true
          }
        );
      options.signal = controller.signal;
    }
    const runtimeFetch = customFetch || fetch;
    return new Observable((observer) => {
      let cleaningUp;
      runtimeFetch(uri, options).then((response) => {
        operation.setContext({ response });
        return response;
      }).then(parseAndCheckHttpResponse(operation)).then((result) => {
        observer.next(result);
        observer.complete();
      }).catch((error3) => {
        if (!cleaningUp) {
          if (error3.result && error3.result.errors && error3.result.data)
            observer.next(error3.result);
          observer.error(error3);
        }
      });
      return () => {
        cleaningUp = true;
        if (controller)
          controller.abort();
      };
    });
  });
};
var createUploadLink$1 = createUploadLink;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __2() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__2.prototype = b2.prototype, new __2());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var e$2 = function(t2, n2) {
  return e$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e2, t3) {
    e2.__proto__ = t3;
  } || function(e2, t3) {
    for (var n3 in t3)
      Object.prototype.hasOwnProperty.call(t3, n3) && (e2[n3] = t3[n3]);
  }, e$2(t2, n2);
};
function t$2(t2, n2) {
  if ("function" != typeof n2 && null !== n2)
    throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
  function r2() {
    this.constructor = t2;
  }
  e$2(t2, n2), t2.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
}
var s = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function u$2(e2) {
  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
function l$2(e2, t2) {
  return e2(t2 = { exports: {} }, t2.exports), t2.exports;
}
var f$2, d$2, h$2 = function(e2) {
  return e2 && e2.Math == Math && e2;
}, p$2 = h$2("object" == typeof globalThis && globalThis) || h$2("object" == typeof window && window) || h$2("object" == typeof self && self) || h$2("object" == typeof s && s) || function() {
  return this;
}() || Function("return this")(), y$1 = function(e2) {
  try {
    return !!e2();
  } catch (e3) {
    return true;
  }
}, v$2 = !y$1(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
}), m$2 = !y$1(function() {
  var e2 = function() {
  }.bind();
  return "function" != typeof e2 || e2.hasOwnProperty("prototype");
}), g$2 = Function.prototype.call, b$2 = m$2 ? g$2.bind(g$2) : function() {
  return g$2.apply(g$2, arguments);
}, w$1 = {}.propertyIsEnumerable, S = Object.getOwnPropertyDescriptor, _ = S && !w$1.call({ 1: 2 }, 1) ? function(e2) {
  var t2 = S(this, e2);
  return !!t2 && t2.enumerable;
} : w$1, k$2 = { f: _ }, I = function(e2, t2) {
  return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
}, T = Function.prototype, O = T.bind, E = T.call, x$1 = m$2 && O.bind(E, E), C = m$2 ? function(e2) {
  return e2 && x$1(e2);
} : function(e2) {
  return e2 && function() {
    return E.apply(e2, arguments);
  };
}, R = C({}.toString), j = C("".slice), A$1 = function(e2) {
  return j(R(e2), 8, -1);
}, U = p$2.Object, P = C("".split), K = y$1(function() {
  return !U("z").propertyIsEnumerable(0);
}) ? function(e2) {
  return "String" == A$1(e2) ? P(e2, "") : U(e2);
} : U, F = p$2.TypeError, W = function(e2) {
  if (null == e2)
    throw F("Can't call method on " + e2);
  return e2;
}, L = function(e2) {
  return K(W(e2));
}, Z = function(e2) {
  return "function" == typeof e2;
}, G = function(e2) {
  return "object" == typeof e2 ? null !== e2 : Z(e2);
}, X = function(e2) {
  return Z(e2) ? e2 : void 0;
}, V = function(e2, t2) {
  return arguments.length < 2 ? X(p$2[e2]) : p$2[e2] && p$2[e2][t2];
}, N = C({}.isPrototypeOf), D = V("navigator", "userAgent") || "", Y = p$2.process, M = p$2.Deno, z$1 = Y && Y.versions || M && M.version, B = z$1 && z$1.v8;
B && (d$2 = (f$2 = B.split("."))[0] > 0 && f$2[0] < 4 ? 1 : +(f$2[0] + f$2[1])), !d$2 && D && (!(f$2 = D.match(/Edge\/(\d+)/)) || f$2[1] >= 74) && (f$2 = D.match(/Chrome\/(\d+)/)) && (d$2 = +f$2[1]);
var J = d$2, H = !!Object.getOwnPropertySymbols && !y$1(function() {
  var e2 = Symbol();
  return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && J && J < 41;
}), q$2 = H && !Symbol.sham && "symbol" == typeof Symbol.iterator, Q = p$2.Object, $ = q$2 ? function(e2) {
  return "symbol" == typeof e2;
} : function(e2) {
  var t2 = V("Symbol");
  return Z(t2) && N(t2.prototype, Q(e2));
}, ee = p$2.String, te = function(e2) {
  try {
    return ee(e2);
  } catch (e3) {
    return "Object";
  }
}, ne = p$2.TypeError, re = function(e2) {
  if (Z(e2))
    return e2;
  throw ne(te(e2) + " is not a function");
}, oe = function(e2, t2) {
  var n2 = e2[t2];
  return null == n2 ? void 0 : re(n2);
}, ie = p$2.TypeError, ae = Object.defineProperty, ce = function(e2, t2) {
  try {
    ae(p$2, e2, { value: t2, configurable: true, writable: true });
  } catch (n2) {
    p$2[e2] = t2;
  }
  return t2;
}, se = p$2["__core-js_shared__"] || ce("__core-js_shared__", {}), ue = l$2(function(e2) {
  (e2.exports = function(e3, t2) {
    return se[e3] || (se[e3] = void 0 !== t2 ? t2 : {});
  })("versions", []).push({ version: "3.21.1", mode: "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE", source: "https://github.com/zloirock/core-js" });
}), le = p$2.Object, fe = function(e2) {
  return le(W(e2));
}, de = C({}.hasOwnProperty), he = Object.hasOwn || function(e2, t2) {
  return de(fe(e2), t2);
}, pe = 0, ye = Math.random(), ve = C(1 .toString), me = function(e2) {
  return "Symbol(" + (void 0 === e2 ? "" : e2) + ")_" + ve(++pe + ye, 36);
}, ge = ue("wks"), be = p$2.Symbol, we = be && be.for, Se = q$2 ? be : be && be.withoutSetter || me, _e = function(e2) {
  if (!he(ge, e2) || !H && "string" != typeof ge[e2]) {
    var t2 = "Symbol." + e2;
    H && he(be, e2) ? ge[e2] = be[e2] : ge[e2] = q$2 && we ? we(t2) : Se(t2);
  }
  return ge[e2];
}, ke = p$2.TypeError, Ie = _e("toPrimitive"), Te = function(e2, t2) {
  if (!G(e2) || $(e2))
    return e2;
  var n2, r2 = oe(e2, Ie);
  if (r2) {
    if (void 0 === t2 && (t2 = "default"), n2 = b$2(r2, e2, t2), !G(n2) || $(n2))
      return n2;
    throw ke("Can't convert object to primitive value");
  }
  return void 0 === t2 && (t2 = "number"), function(e3, t3) {
    var n3, r3;
    if ("string" === t3 && Z(n3 = e3.toString) && !G(r3 = b$2(n3, e3)))
      return r3;
    if (Z(n3 = e3.valueOf) && !G(r3 = b$2(n3, e3)))
      return r3;
    if ("string" !== t3 && Z(n3 = e3.toString) && !G(r3 = b$2(n3, e3)))
      return r3;
    throw ie("Can't convert object to primitive value");
  }(e2, t2);
}, Oe = function(e2) {
  var t2 = Te(e2, "string");
  return $(t2) ? t2 : t2 + "";
}, Ee = p$2.document, xe = G(Ee) && G(Ee.createElement), Ce = function(e2) {
  return xe ? Ee.createElement(e2) : {};
}, Re = !v$2 && !y$1(function() {
  return 7 != Object.defineProperty(Ce("div"), "a", { get: function() {
    return 7;
  } }).a;
}), je = Object.getOwnPropertyDescriptor, Ae = { f: v$2 ? je : function(e2, t2) {
  if (e2 = L(e2), t2 = Oe(t2), Re)
    try {
      return je(e2, t2);
    } catch (e3) {
    }
  if (he(e2, t2))
    return I(!b$2(k$2.f, e2, t2), e2[t2]);
} }, Ue = v$2 && y$1(function() {
  return 42 != Object.defineProperty(function() {
  }, "prototype", { value: 42, writable: false }).prototype;
}), Pe = p$2.String, Ke = p$2.TypeError, Fe = function(e2) {
  if (G(e2))
    return e2;
  throw Ke(Pe(e2) + " is not an object");
}, We = p$2.TypeError, Le = Object.defineProperty, Ze = Object.getOwnPropertyDescriptor, Ge = { f: v$2 ? Ue ? function(e2, t2, n2) {
  if (Fe(e2), t2 = Oe(t2), Fe(n2), "function" == typeof e2 && "prototype" === t2 && "value" in n2 && "writable" in n2 && !n2.writable) {
    var r2 = Ze(e2, t2);
    r2 && r2.writable && (e2[t2] = n2.value, n2 = { configurable: "configurable" in n2 ? n2.configurable : r2.configurable, enumerable: "enumerable" in n2 ? n2.enumerable : r2.enumerable, writable: false });
  }
  return Le(e2, t2, n2);
} : Le : function(e2, t2, n2) {
  if (Fe(e2), t2 = Oe(t2), Fe(n2), Re)
    try {
      return Le(e2, t2, n2);
    } catch (e3) {
    }
  if ("get" in n2 || "set" in n2)
    throw We("Accessors not supported");
  return "value" in n2 && (e2[t2] = n2.value), e2;
} }, Xe = v$2 ? function(e2, t2, n2) {
  return Ge.f(e2, t2, I(1, n2));
} : function(e2, t2, n2) {
  return e2[t2] = n2, e2;
}, Ve = C(Function.toString);
Z(se.inspectSource) || (se.inspectSource = function(e2) {
  return Ve(e2);
});
var Ne, De, Ye, Me = se.inspectSource, ze = p$2.WeakMap, Be = Z(ze) && /native code/.test(Me(ze)), Je = ue("keys"), He = function(e2) {
  return Je[e2] || (Je[e2] = me(e2));
}, qe = {}, Qe = p$2.TypeError, $e = p$2.WeakMap;
if (Be || se.state) {
  var et = se.state || (se.state = new $e()), tt = C(et.get), nt = C(et.has), rt = C(et.set);
  Ne = function(e2, t2) {
    if (nt(et, e2))
      throw new Qe("Object already initialized");
    return t2.facade = e2, rt(et, e2, t2), t2;
  }, De = function(e2) {
    return tt(et, e2) || {};
  }, Ye = function(e2) {
    return nt(et, e2);
  };
} else {
  var ot = He("state");
  qe[ot] = true, Ne = function(e2, t2) {
    if (he(e2, ot))
      throw new Qe("Object already initialized");
    return t2.facade = e2, Xe(e2, ot, t2), t2;
  }, De = function(e2) {
    return he(e2, ot) ? e2[ot] : {};
  }, Ye = function(e2) {
    return he(e2, ot);
  };
}
var it = { set: Ne, get: De, has: Ye, enforce: function(e2) {
  return Ye(e2) ? De(e2) : Ne(e2, {});
}, getterFor: function(e2) {
  return function(t2) {
    var n2;
    if (!G(t2) || (n2 = De(t2)).type !== e2)
      throw Qe("Incompatible receiver, " + e2 + " required");
    return n2;
  };
} }, at = Function.prototype, ct = v$2 && Object.getOwnPropertyDescriptor, st = he(at, "name"), ut = { EXISTS: st, PROPER: st && "something" === function() {
}.name, CONFIGURABLE: st && (!v$2 || v$2 && ct(at, "name").configurable) }, lt = l$2(function(e2) {
  var t2 = ut.CONFIGURABLE, n2 = it.get, r2 = it.enforce, o = String(String).split("String");
  (e2.exports = function(e3, n3, i, a) {
    var c2, s2 = !!a && !!a.unsafe, u2 = !!a && !!a.enumerable, l2 = !!a && !!a.noTargetGet, f2 = a && void 0 !== a.name ? a.name : n3;
    Z(i) && ("Symbol(" === String(f2).slice(0, 7) && (f2 = "[" + String(f2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!he(i, "name") || t2 && i.name !== f2) && Xe(i, "name", f2), (c2 = r2(i)).source || (c2.source = o.join("string" == typeof f2 ? f2 : ""))), e3 !== p$2 ? (s2 ? !l2 && e3[n3] && (u2 = true) : delete e3[n3], u2 ? e3[n3] = i : Xe(e3, n3, i)) : u2 ? e3[n3] = i : ce(n3, i);
  })(Function.prototype, "toString", function() {
    return Z(this) && n2(this).source || Me(this);
  });
}), ft = Math.ceil, dt = Math.floor, ht = function(e2) {
  var t2 = +e2;
  return t2 != t2 || 0 === t2 ? 0 : (t2 > 0 ? dt : ft)(t2);
}, pt = Math.max, yt = Math.min, vt = function(e2, t2) {
  var n2 = ht(e2);
  return n2 < 0 ? pt(n2 + t2, 0) : yt(n2, t2);
}, mt = Math.min, gt = function(e2) {
  return e2 > 0 ? mt(ht(e2), 9007199254740991) : 0;
}, bt = function(e2) {
  return gt(e2.length);
}, wt = function(e2) {
  return function(t2, n2, r2) {
    var o, i = L(t2), a = bt(i), c2 = vt(r2, a);
    if (e2 && n2 != n2) {
      for (; a > c2; )
        if ((o = i[c2++]) != o)
          return true;
    } else
      for (; a > c2; c2++)
        if ((e2 || c2 in i) && i[c2] === n2)
          return e2 || c2 || 0;
    return !e2 && -1;
  };
}, St = { includes: wt(true), indexOf: wt(false) }, _t = St.indexOf, kt = C([].push), It = function(e2, t2) {
  var n2, r2 = L(e2), o = 0, i = [];
  for (n2 in r2)
    !he(qe, n2) && he(r2, n2) && kt(i, n2);
  for (; t2.length > o; )
    he(r2, n2 = t2[o++]) && (~_t(i, n2) || kt(i, n2));
  return i;
}, Tt = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Ot = Tt.concat("length", "prototype"), Et = { f: Object.getOwnPropertyNames || function(e2) {
  return It(e2, Ot);
} }, xt = { f: Object.getOwnPropertySymbols }, Ct = C([].concat), Rt = V("Reflect", "ownKeys") || function(e2) {
  var t2 = Et.f(Fe(e2)), n2 = xt.f;
  return n2 ? Ct(t2, n2(e2)) : t2;
}, jt = function(e2, t2, n2) {
  for (var r2 = Rt(t2), o = Ge.f, i = Ae.f, a = 0; a < r2.length; a++) {
    var c2 = r2[a];
    he(e2, c2) || n2 && he(n2, c2) || o(e2, c2, i(t2, c2));
  }
}, At = /#|\.prototype\./, Ut = function(e2, t2) {
  var n2 = Kt[Pt(e2)];
  return n2 == Wt || n2 != Ft && (Z(t2) ? y$1(t2) : !!t2);
}, Pt = Ut.normalize = function(e2) {
  return String(e2).replace(At, ".").toLowerCase();
}, Kt = Ut.data = {}, Ft = Ut.NATIVE = "N", Wt = Ut.POLYFILL = "P", Lt = Ut, Zt = Ae.f, Gt = function(e2, t2) {
  var n2, r2, o, i, a, c2 = e2.target, s2 = e2.global, u2 = e2.stat;
  if (n2 = s2 ? p$2 : u2 ? p$2[c2] || ce(c2, {}) : (p$2[c2] || {}).prototype)
    for (r2 in t2) {
      if (i = t2[r2], o = e2.noTargetGet ? (a = Zt(n2, r2)) && a.value : n2[r2], !Lt(s2 ? r2 : c2 + (u2 ? "." : "#") + r2, e2.forced) && void 0 !== o) {
        if (typeof i == typeof o)
          continue;
        jt(i, o);
      }
      (e2.sham || o && o.sham) && Xe(i, "sham", true), lt(n2, r2, i, e2);
    }
}, Xt = {};
Xt[_e("toStringTag")] = "z";
var Vt, Nt = "[object z]" === String(Xt), Dt = _e("toStringTag"), Yt = p$2.Object, Mt = "Arguments" == A$1(function() {
  return arguments;
}()), zt = Nt ? A$1 : function(e2) {
  var t2, n2, r2;
  return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (n2 = function(e3, t3) {
    try {
      return e3[t3];
    } catch (e4) {
    }
  }(t2 = Yt(e2), Dt)) ? n2 : Mt ? A$1(t2) : "Object" == (r2 = A$1(t2)) && Z(t2.callee) ? "Arguments" : r2;
}, Bt = p$2.String, Jt = function(e2) {
  if ("Symbol" === zt(e2))
    throw TypeError("Cannot convert a Symbol value to a string");
  return Bt(e2);
}, Ht = _e("match"), qt = p$2.TypeError, Qt = function(e2) {
  if (function(e3) {
    var t2;
    return G(e3) && (void 0 !== (t2 = e3[Ht]) ? !!t2 : "RegExp" == A$1(e3));
  }(e2))
    throw qt("The method doesn't accept regular expressions");
  return e2;
}, $t = _e("match"), en = function(e2) {
  var t2 = /./;
  try {
    "/./"[e2](t2);
  } catch (n2) {
    try {
      return t2[$t] = false, "/./"[e2](t2);
    } catch (e3) {
    }
  }
  return false;
}, tn = Ae.f, nn = C("".startsWith), rn = C("".slice), on = Math.min, an = en("startsWith"), cn = !(an || (Vt = tn(String.prototype, "startsWith"), !Vt || Vt.writable));
Gt({ target: "String", proto: true, forced: !cn && !an }, { startsWith: function(e2) {
  var t2 = Jt(W(this));
  Qt(e2);
  var n2 = gt(on(arguments.length > 1 ? arguments[1] : void 0, t2.length)), r2 = Jt(e2);
  return nn ? nn(t2, r2, n2) : rn(t2, n2, n2 + r2.length) === r2;
} });
var sn = function(e2, t2) {
  return C(p$2[e2].prototype[t2]);
};
sn("String", "startsWith");
var un = Array.isArray || function(e2) {
  return "Array" == A$1(e2);
}, ln = function(e2, t2, n2) {
  var r2 = Oe(t2);
  r2 in e2 ? Ge.f(e2, r2, I(0, n2)) : e2[r2] = n2;
}, fn = function() {
}, dn = [], hn = V("Reflect", "construct"), pn = /^\s*(?:class|function)\b/, yn = C(pn.exec), vn = !pn.exec(fn), mn = function(e2) {
  if (!Z(e2))
    return false;
  try {
    return hn(fn, dn, e2), true;
  } catch (e3) {
    return false;
  }
}, gn = function(e2) {
  if (!Z(e2))
    return false;
  switch (zt(e2)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return vn || !!yn(pn, Me(e2));
  } catch (e3) {
    return true;
  }
};
gn.sham = true;
var bn, wn = !hn || y$1(function() {
  var e2;
  return mn(mn.call) || !mn(Object) || !mn(function() {
    e2 = true;
  }) || e2;
}) ? gn : mn, Sn = _e("species"), _n = p$2.Array, kn = function(e2, t2) {
  return new (function(e3) {
    var t3;
    return un(e3) && (t3 = e3.constructor, (wn(t3) && (t3 === _n || un(t3.prototype)) || G(t3) && null === (t3 = t3[Sn])) && (t3 = void 0)), void 0 === t3 ? _n : t3;
  }(e2))(0 === t2 ? 0 : t2);
}, In = _e("species"), Tn = _e("isConcatSpreadable"), On = p$2.TypeError, En = J >= 51 || !y$1(function() {
  var e2 = [];
  return e2[Tn] = false, e2.concat()[0] !== e2;
}), xn = (bn = "concat", J >= 51 || !y$1(function() {
  var e2 = [];
  return (e2.constructor = {})[In] = function() {
    return { foo: 1 };
  }, 1 !== e2[bn](Boolean).foo;
})), Cn = function(e2) {
  if (!G(e2))
    return false;
  var t2 = e2[Tn];
  return void 0 !== t2 ? !!t2 : un(e2);
};
Gt({ target: "Array", proto: true, forced: !En || !xn }, { concat: function(e2) {
  var t2, n2, r2, o, i, a = fe(this), c2 = kn(a, 0), s2 = 0;
  for (t2 = -1, r2 = arguments.length; t2 < r2; t2++)
    if (Cn(i = -1 === t2 ? a : arguments[t2])) {
      if (s2 + (o = bt(i)) > 9007199254740991)
        throw On("Maximum allowed index exceeded");
      for (n2 = 0; n2 < o; n2++, s2++)
        n2 in i && ln(c2, s2, i[n2]);
    } else {
      if (s2 >= 9007199254740991)
        throw On("Maximum allowed index exceeded");
      ln(c2, s2++, i);
    }
  return c2.length = s2, c2;
} });
var Rn = Nt ? {}.toString : function() {
  return "[object " + zt(this) + "]";
};
Nt || lt(Object.prototype, "toString", Rn, { unsafe: true });
var jn, An = Function.prototype, Un = An.apply, Pn = An.call, Kn = "object" == typeof Reflect && Reflect.apply || (m$2 ? Pn.bind(Un) : function() {
  return Pn.apply(Un, arguments);
}), Fn = Object.keys || function(e2) {
  return It(e2, Tt);
}, Wn = v$2 && !Ue ? Object.defineProperties : function(e2, t2) {
  Fe(e2);
  for (var n2, r2 = L(t2), o = Fn(t2), i = o.length, a = 0; i > a; )
    Ge.f(e2, n2 = o[a++], r2[n2]);
  return e2;
}, Ln = { f: Wn }, Zn = V("document", "documentElement"), Gn = He("IE_PROTO"), Xn = function() {
}, Vn = function(e2) {
  return "<script>" + e2 + "<\/script>";
}, Nn = function(e2) {
  e2.write(Vn("")), e2.close();
  var t2 = e2.parentWindow.Object;
  return e2 = null, t2;
}, Dn = function() {
  try {
    jn = new ActiveXObject("htmlfile");
  } catch (e3) {
  }
  var e2, t2;
  Dn = "undefined" != typeof document ? document.domain && jn ? Nn(jn) : ((t2 = Ce("iframe")).style.display = "none", Zn.appendChild(t2), t2.src = String("javascript:"), (e2 = t2.contentWindow.document).open(), e2.write(Vn("document.F=Object")), e2.close(), e2.F) : Nn(jn);
  for (var n2 = Tt.length; n2--; )
    delete Dn.prototype[Tt[n2]];
  return Dn();
};
qe[Gn] = true;
var Yn = Object.create || function(e2, t2) {
  var n2;
  return null !== e2 ? (Xn.prototype = Fe(e2), n2 = new Xn(), Xn.prototype = null, n2[Gn] = e2) : n2 = Dn(), void 0 === t2 ? n2 : Ln.f(n2, t2);
}, Mn = p$2.Array, zn = Math.max, Bn = Et.f, Jn = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], Hn = function(e2) {
  try {
    return Bn(e2);
  } catch (e3) {
    return function(e4, t2, n2) {
      for (var r2 = bt(e4), o = vt(t2, r2), i = vt(void 0 === n2 ? r2 : n2, r2), a = Mn(zn(i - o, 0)), c2 = 0; o < i; o++, c2++)
        ln(a, c2, e4[o]);
      return a.length = c2, a;
    }(Jn);
  }
}, qn = { f: function(e2) {
  return Jn && "Window" == A$1(e2) ? Hn(e2) : Bn(L(e2));
} }, Qn = C([].slice), $n = { f: _e }, er = p$2, tr = Ge.f, nr = function(e2) {
  var t2 = er.Symbol || (er.Symbol = {});
  he(t2, e2) || tr(t2, e2, { value: $n.f(e2) });
}, rr = Ge.f, or = _e("toStringTag"), ir = function(e2, t2, n2) {
  e2 && !n2 && (e2 = e2.prototype), e2 && !he(e2, or) && rr(e2, or, { configurable: true, value: t2 });
}, ar = C(C.bind), cr = function(e2, t2) {
  return re(e2), void 0 === t2 ? e2 : m$2 ? ar(e2, t2) : function() {
    return e2.apply(t2, arguments);
  };
}, sr = C([].push), ur = function(e2) {
  var t2 = 1 == e2, n2 = 2 == e2, r2 = 3 == e2, o = 4 == e2, i = 6 == e2, a = 7 == e2, c2 = 5 == e2 || i;
  return function(s2, u2, l2, f2) {
    for (var d2, h2, p2 = fe(s2), y2 = K(p2), v2 = cr(u2, l2), m2 = bt(y2), g2 = 0, b2 = f2 || kn, w2 = t2 ? b2(s2, m2) : n2 || a ? b2(s2, 0) : void 0; m2 > g2; g2++)
      if ((c2 || g2 in y2) && (h2 = v2(d2 = y2[g2], g2, p2), e2))
        if (t2)
          w2[g2] = h2;
        else if (h2)
          switch (e2) {
            case 3:
              return true;
            case 5:
              return d2;
            case 6:
              return g2;
            case 2:
              sr(w2, d2);
          }
        else
          switch (e2) {
            case 4:
              return false;
            case 7:
              sr(w2, d2);
          }
    return i ? -1 : r2 || o ? o : w2;
  };
}, lr = { forEach: ur(0), map: ur(1), filter: ur(2), some: ur(3), every: ur(4), find: ur(5), findIndex: ur(6), filterReject: ur(7) }.forEach, fr = He("hidden"), dr = _e("toPrimitive"), hr = it.set, pr = it.getterFor("Symbol"), yr = Object.prototype, vr = p$2.Symbol, mr = vr && vr.prototype, gr = p$2.TypeError, br = p$2.QObject, wr = V("JSON", "stringify"), Sr = Ae.f, _r$1 = Ge.f, kr = qn.f, Ir = k$2.f, Tr = C([].push), Or = ue("symbols"), Er = ue("op-symbols"), xr = ue("string-to-symbol-registry"), Cr = ue("symbol-to-string-registry"), Rr = ue("wks"), jr = !br || !br.prototype || !br.prototype.findChild, Ar = v$2 && y$1(function() {
  return 7 != Yn(_r$1({}, "a", { get: function() {
    return _r$1(this, "a", { value: 7 }).a;
  } })).a;
}) ? function(e2, t2, n2) {
  var r2 = Sr(yr, t2);
  r2 && delete yr[t2], _r$1(e2, t2, n2), r2 && e2 !== yr && _r$1(yr, t2, r2);
} : _r$1, Ur = function(e2, t2) {
  var n2 = Or[e2] = Yn(mr);
  return hr(n2, { type: "Symbol", tag: e2, description: t2 }), v$2 || (n2.description = t2), n2;
}, Pr = function(e2, t2, n2) {
  e2 === yr && Pr(Er, t2, n2), Fe(e2);
  var r2 = Oe(t2);
  return Fe(n2), he(Or, r2) ? (n2.enumerable ? (he(e2, fr) && e2[fr][r2] && (e2[fr][r2] = false), n2 = Yn(n2, { enumerable: I(0, false) })) : (he(e2, fr) || _r$1(e2, fr, I(1, {})), e2[fr][r2] = true), Ar(e2, r2, n2)) : _r$1(e2, r2, n2);
}, Kr = function(e2, t2) {
  Fe(e2);
  var n2 = L(t2), r2 = Fn(n2).concat(Zr(n2));
  return lr(r2, function(t3) {
    v$2 && !b$2(Fr, n2, t3) || Pr(e2, t3, n2[t3]);
  }), e2;
}, Fr = function(e2) {
  var t2 = Oe(e2), n2 = b$2(Ir, this, t2);
  return !(this === yr && he(Or, t2) && !he(Er, t2)) && (!(n2 || !he(this, t2) || !he(Or, t2) || he(this, fr) && this[fr][t2]) || n2);
}, Wr = function(e2, t2) {
  var n2 = L(e2), r2 = Oe(t2);
  if (n2 !== yr || !he(Or, r2) || he(Er, r2)) {
    var o = Sr(n2, r2);
    return !o || !he(Or, r2) || he(n2, fr) && n2[fr][r2] || (o.enumerable = true), o;
  }
}, Lr = function(e2) {
  var t2 = kr(L(e2)), n2 = [];
  return lr(t2, function(e3) {
    he(Or, e3) || he(qe, e3) || Tr(n2, e3);
  }), n2;
}, Zr = function(e2) {
  var t2 = e2 === yr, n2 = kr(t2 ? Er : L(e2)), r2 = [];
  return lr(n2, function(e3) {
    !he(Or, e3) || t2 && !he(yr, e3) || Tr(r2, Or[e3]);
  }), r2;
};
if (H || (mr = (vr = function() {
  if (N(mr, this))
    throw gr("Symbol is not a constructor");
  var e2 = arguments.length && void 0 !== arguments[0] ? Jt(arguments[0]) : void 0, t2 = me(e2), n2 = function(e3) {
    this === yr && b$2(n2, Er, e3), he(this, fr) && he(this[fr], t2) && (this[fr][t2] = false), Ar(this, t2, I(1, e3));
  };
  return v$2 && jr && Ar(yr, t2, { configurable: true, set: n2 }), Ur(t2, e2);
}).prototype, lt(mr, "toString", function() {
  return pr(this).tag;
}), lt(vr, "withoutSetter", function(e2) {
  return Ur(me(e2), e2);
}), k$2.f = Fr, Ge.f = Pr, Ln.f = Kr, Ae.f = Wr, Et.f = qn.f = Lr, xt.f = Zr, $n.f = function(e2) {
  return Ur(_e(e2), e2);
}, v$2 && (_r$1(mr, "description", { configurable: true, get: function() {
  return pr(this).description;
} }), lt(yr, "propertyIsEnumerable", Fr, { unsafe: true }))), Gt({ global: true, wrap: true, forced: !H, sham: !H }, { Symbol: vr }), lr(Fn(Rr), function(e2) {
  nr(e2);
}), Gt({ target: "Symbol", stat: true, forced: !H }, { for: function(e2) {
  var t2 = Jt(e2);
  if (he(xr, t2))
    return xr[t2];
  var n2 = vr(t2);
  return xr[t2] = n2, Cr[n2] = t2, n2;
}, keyFor: function(e2) {
  if (!$(e2))
    throw gr(e2 + " is not a symbol");
  if (he(Cr, e2))
    return Cr[e2];
}, useSetter: function() {
  jr = true;
}, useSimple: function() {
  jr = false;
} }), Gt({ target: "Object", stat: true, forced: !H, sham: !v$2 }, { create: function(e2, t2) {
  return void 0 === t2 ? Yn(e2) : Kr(Yn(e2), t2);
}, defineProperty: Pr, defineProperties: Kr, getOwnPropertyDescriptor: Wr }), Gt({ target: "Object", stat: true, forced: !H }, { getOwnPropertyNames: Lr, getOwnPropertySymbols: Zr }), Gt({ target: "Object", stat: true, forced: y$1(function() {
  xt.f(1);
}) }, { getOwnPropertySymbols: function(e2) {
  return xt.f(fe(e2));
} }), wr) {
  var Gr = !H || y$1(function() {
    var e2 = vr();
    return "[null]" != wr([e2]) || "{}" != wr({ a: e2 }) || "{}" != wr(Object(e2));
  });
  Gt({ target: "JSON", stat: true, forced: Gr }, { stringify: function(e2, t2, n2) {
    var r2 = Qn(arguments), o = t2;
    if ((G(t2) || void 0 !== e2) && !$(e2))
      return un(t2) || (t2 = function(e3, t3) {
        if (Z(o) && (t3 = b$2(o, this, e3, t3)), !$(t3))
          return t3;
      }), r2[1] = t2, Kn(wr, null, r2);
  } });
}
if (!mr[dr]) {
  var Xr = mr.valueOf;
  lt(mr, dr, function(e2) {
    return b$2(Xr, this);
  });
}
ir(vr, "Symbol"), qe[fr] = true, nr("asyncIterator");
var Vr = Ge.f, Nr = p$2.Symbol, Dr = Nr && Nr.prototype;
if (v$2 && Z(Nr) && (!("description" in Dr) || void 0 !== Nr().description)) {
  var Yr = {}, Mr = function() {
    var e2 = arguments.length < 1 || void 0 === arguments[0] ? void 0 : Jt(arguments[0]), t2 = N(Dr, this) ? new Nr(e2) : void 0 === e2 ? Nr() : Nr(e2);
    return "" === e2 && (Yr[t2] = true), t2;
  };
  jt(Mr, Nr), Mr.prototype = Dr, Dr.constructor = Mr;
  var zr = "Symbol(test)" == String(Nr("test")), Br = C(Dr.toString), Jr = C(Dr.valueOf), Hr = /^Symbol\((.*)\)[^)]+$/, qr = C("".replace), Qr = C("".slice);
  Vr(Dr, "description", { configurable: true, get: function() {
    var e2 = Jr(this), t2 = Br(e2);
    if (he(Yr, e2))
      return "";
    var n2 = zr ? Qr(t2, 7, -1) : qr(t2, Hr, "$1");
    return "" === n2 ? void 0 : n2;
  } }), Gt({ global: true, forced: true }, { Symbol: Mr });
}
nr("hasInstance"), nr("isConcatSpreadable"), nr("iterator"), nr("match"), nr("matchAll"), nr("replace"), nr("search"), nr("species"), nr("split"), nr("toPrimitive"), nr("toStringTag"), nr("unscopables"), ir(p$2.JSON, "JSON", true), ir(Math, "Math", true), Gt({ global: true }, { Reflect: {} }), ir(p$2.Reflect, "Reflect", true), er.Symbol;
var $r, eo, to, no = C("".charAt), ro = C("".charCodeAt), oo = C("".slice), io = function(e2) {
  return function(t2, n2) {
    var r2, o, i = Jt(W(t2)), a = ht(n2), c2 = i.length;
    return a < 0 || a >= c2 ? e2 ? "" : void 0 : (r2 = ro(i, a)) < 55296 || r2 > 56319 || a + 1 === c2 || (o = ro(i, a + 1)) < 56320 || o > 57343 ? e2 ? no(i, a) : r2 : e2 ? oo(i, a, a + 2) : o - 56320 + (r2 - 55296 << 10) + 65536;
  };
}, ao = { codeAt: io(false), charAt: io(true) }, co = !y$1(function() {
  function e2() {
  }
  return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
}), so = He("IE_PROTO"), uo = p$2.Object, lo = uo.prototype, fo = co ? uo.getPrototypeOf : function(e2) {
  var t2 = fe(e2);
  if (he(t2, so))
    return t2[so];
  var n2 = t2.constructor;
  return Z(n2) && t2 instanceof n2 ? n2.prototype : t2 instanceof uo ? lo : null;
}, ho = _e("iterator"), po = false;
[].keys && ("next" in (to = [].keys()) ? (eo = fo(fo(to))) !== Object.prototype && ($r = eo) : po = true);
var yo = null == $r || y$1(function() {
  var e2 = {};
  return $r[ho].call(e2) !== e2;
});
yo && ($r = {}), Z($r[ho]) || lt($r, ho, function() {
  return this;
});
var vo = { IteratorPrototype: $r, BUGGY_SAFARI_ITERATORS: po }, mo = {}, go = vo.IteratorPrototype, bo = function() {
  return this;
}, wo = p$2.String, So = p$2.TypeError, _o = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var e2, t2 = false, n2 = {};
  try {
    (e2 = C(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n2, []), t2 = n2 instanceof Array;
  } catch (e3) {
  }
  return function(n3, r2) {
    return Fe(n3), function(e3) {
      if ("object" == typeof e3 || Z(e3))
        return e3;
      throw So("Can't set " + wo(e3) + " as a prototype");
    }(r2), t2 ? e2(n3, r2) : n3.__proto__ = r2, n3;
  };
}() : void 0), ko = ut.PROPER, Io = ut.CONFIGURABLE, To = vo.IteratorPrototype, Oo = vo.BUGGY_SAFARI_ITERATORS, Eo = _e("iterator"), xo = function() {
  return this;
}, Co = function(e2, t2, n2, r2, o, i, a) {
  !function(e3, t3, n3, r3) {
    var o2 = t3 + " Iterator";
    e3.prototype = Yn(go, { next: I(+!r3, n3) }), ir(e3, o2, false), mo[o2] = bo;
  }(n2, t2, r2);
  var c2, s2, u2, l2 = function(e3) {
    if (e3 === o && y2)
      return y2;
    if (!Oo && e3 in h2)
      return h2[e3];
    switch (e3) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n2(this, e3);
        };
    }
    return function() {
      return new n2(this);
    };
  }, f2 = t2 + " Iterator", d2 = false, h2 = e2.prototype, p2 = h2[Eo] || h2["@@iterator"] || o && h2[o], y2 = !Oo && p2 || l2(o), v2 = "Array" == t2 && h2.entries || p2;
  if (v2 && (c2 = fo(v2.call(new e2()))) !== Object.prototype && c2.next && (fo(c2) !== To && (_o ? _o(c2, To) : Z(c2[Eo]) || lt(c2, Eo, xo)), ir(c2, f2, true)), ko && "values" == o && p2 && "values" !== p2.name && (Io ? Xe(h2, "name", "values") : (d2 = true, y2 = function() {
    return b$2(p2, this);
  })), o)
    if (s2 = { values: l2("values"), keys: i ? y2 : l2("keys"), entries: l2("entries") }, a)
      for (u2 in s2)
        (Oo || d2 || !(u2 in h2)) && lt(h2, u2, s2[u2]);
    else
      Gt({ target: t2, proto: true, forced: Oo || d2 }, s2);
  return h2[Eo] !== y2 && lt(h2, Eo, y2, { name: o }), mo[t2] = y2, s2;
}, Ro = ao.charAt, jo = it.set, Ao = it.getterFor("String Iterator");
Co(String, "String", function(e2) {
  jo(this, { type: "String Iterator", string: Jt(e2), index: 0 });
}, function() {
  var e2, t2 = Ao(this), n2 = t2.string, r2 = t2.index;
  return r2 >= n2.length ? { value: void 0, done: true } : (e2 = Ro(n2, r2), t2.index += e2.length, { value: e2, done: false });
});
var Uo = function(e2, t2, n2) {
  var r2, o;
  Fe(e2);
  try {
    if (!(r2 = oe(e2, "return"))) {
      if ("throw" === t2)
        throw n2;
      return n2;
    }
    r2 = b$2(r2, e2);
  } catch (e3) {
    o = true, r2 = e3;
  }
  if ("throw" === t2)
    throw n2;
  if (o)
    throw r2;
  return Fe(r2), n2;
}, Po = function(e2, t2, n2, r2) {
  try {
    return r2 ? t2(Fe(n2)[0], n2[1]) : t2(n2);
  } catch (t3) {
    Uo(e2, "throw", t3);
  }
}, Ko = _e("iterator"), Fo = Array.prototype, Wo = function(e2) {
  return void 0 !== e2 && (mo.Array === e2 || Fo[Ko] === e2);
}, Lo = _e("iterator"), Zo = function(e2) {
  if (null != e2)
    return oe(e2, Lo) || oe(e2, "@@iterator") || mo[zt(e2)];
}, Go = p$2.TypeError, Xo = function(e2, t2) {
  var n2 = arguments.length < 2 ? Zo(e2) : t2;
  if (re(n2))
    return Fe(b$2(n2, e2));
  throw Go(te(e2) + " is not iterable");
}, Vo = p$2.Array, No = _e("iterator"), Do = false;
try {
  var Yo = 0, Mo = { next: function() {
    return { done: !!Yo++ };
  }, return: function() {
    Do = true;
  } };
  Mo[No] = function() {
    return this;
  }, Array.from(Mo, function() {
    throw 2;
  });
} catch (e2) {
}
var zo = function(e2, t2) {
  if (!t2 && !Do)
    return false;
  var n2 = false;
  try {
    var r2 = {};
    r2[No] = function() {
      return { next: function() {
        return { done: n2 = true };
      } };
    }, e2(r2);
  } catch (e3) {
  }
  return n2;
}, Bo = !zo(function(e2) {
  Array.from(e2);
});
Gt({ target: "Array", stat: true, forced: Bo }, { from: function(e2) {
  var t2 = fe(e2), n2 = wn(this), r2 = arguments.length, o = r2 > 1 ? arguments[1] : void 0, i = void 0 !== o;
  i && (o = cr(o, r2 > 2 ? arguments[2] : void 0));
  var a, c2, s2, u2, l2, f2, d2 = Zo(t2), h2 = 0;
  if (!d2 || this == Vo && Wo(d2))
    for (a = bt(t2), c2 = n2 ? new this(a) : Vo(a); a > h2; h2++)
      f2 = i ? o(t2[h2], h2) : t2[h2], ln(c2, h2, f2);
  else
    for (l2 = (u2 = Xo(t2, d2)).next, c2 = n2 ? new this() : []; !(s2 = b$2(l2, u2)).done; h2++)
      f2 = i ? Po(u2, o, [s2.value, h2], true) : s2.value, ln(c2, h2, f2);
  return c2.length = h2, c2;
} }), er.Array.from;
var Jo, Ho, qo, Qo = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView, $o = Ge.f, ei = p$2.Int8Array, ti = ei && ei.prototype, ni = p$2.Uint8ClampedArray, ri = ni && ni.prototype, oi = ei && fo(ei), ii = ti && fo(ti), ai = Object.prototype, ci = p$2.TypeError, si = _e("toStringTag"), ui = me("TYPED_ARRAY_TAG"), li = me("TYPED_ARRAY_CONSTRUCTOR"), fi = Qo && !!_o && "Opera" !== zt(p$2.opera), di = false, hi = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, pi = { BigInt64Array: 8, BigUint64Array: 8 }, yi = function(e2) {
  if (!G(e2))
    return false;
  var t2 = zt(e2);
  return he(hi, t2) || he(pi, t2);
};
for (Jo in hi)
  (qo = (Ho = p$2[Jo]) && Ho.prototype) ? Xe(qo, li, Ho) : fi = false;
for (Jo in pi)
  (qo = (Ho = p$2[Jo]) && Ho.prototype) && Xe(qo, li, Ho);
if ((!fi || !Z(oi) || oi === Function.prototype) && (oi = function() {
  throw ci("Incorrect invocation");
}, fi))
  for (Jo in hi)
    p$2[Jo] && _o(p$2[Jo], oi);
if ((!fi || !ii || ii === ai) && (ii = oi.prototype, fi))
  for (Jo in hi)
    p$2[Jo] && _o(p$2[Jo].prototype, ii);
if (fi && fo(ri) !== ii && _o(ri, ii), v$2 && !he(ii, si))
  for (Jo in di = true, $o(ii, si, { get: function() {
    return G(this) ? this[ui] : void 0;
  } }), hi)
    p$2[Jo] && Xe(p$2[Jo], ui, Jo);
var vi = { NATIVE_ARRAY_BUFFER_VIEWS: fi, TYPED_ARRAY_CONSTRUCTOR: li, TYPED_ARRAY_TAG: di && ui, aTypedArray: function(e2) {
  if (yi(e2))
    return e2;
  throw ci("Target is not a typed array");
}, aTypedArrayConstructor: function(e2) {
  if (Z(e2) && (!_o || N(oi, e2)))
    return e2;
  throw ci(te(e2) + " is not a typed array constructor");
}, exportTypedArrayMethod: function(e2, t2, n2, r2) {
  if (v$2) {
    if (n2)
      for (var o in hi) {
        var i = p$2[o];
        if (i && he(i.prototype, e2))
          try {
            delete i.prototype[e2];
          } catch (n3) {
            try {
              i.prototype[e2] = t2;
            } catch (e3) {
            }
          }
      }
    ii[e2] && !n2 || lt(ii, e2, n2 ? t2 : fi && ti[e2] || t2, r2);
  }
}, exportTypedArrayStaticMethod: function(e2, t2, n2) {
  var r2, o;
  if (v$2) {
    if (_o) {
      if (n2) {
        for (r2 in hi)
          if ((o = p$2[r2]) && he(o, e2))
            try {
              delete o[e2];
            } catch (e3) {
            }
      }
      if (oi[e2] && !n2)
        return;
      try {
        return lt(oi, e2, n2 ? t2 : fi && oi[e2] || t2);
      } catch (e3) {
      }
    }
    for (r2 in hi)
      !(o = p$2[r2]) || o[e2] && !n2 || lt(o, e2, t2);
  }
}, isView: function(e2) {
  if (!G(e2))
    return false;
  var t2 = zt(e2);
  return "DataView" === t2 || he(hi, t2) || he(pi, t2);
}, isTypedArray: yi, TypedArray: oi, TypedArrayPrototype: ii }, mi = p$2.TypeError, gi = _e("species"), bi = function(e2, t2) {
  var n2, r2 = Fe(e2).constructor;
  return void 0 === r2 || null == (n2 = Fe(r2)[gi]) ? t2 : function(e3) {
    if (wn(e3))
      return e3;
    throw mi(te(e3) + " is not a constructor");
  }(n2);
}, wi = vi.TYPED_ARRAY_CONSTRUCTOR, Si = vi.aTypedArrayConstructor, _i = vi.aTypedArray;
(0, vi.exportTypedArrayMethod)("slice", function(e2, t2) {
  for (var n2, r2 = Qn(_i(this), e2, t2), o = Si(bi(n2 = this, n2[wi])), i = 0, a = r2.length, c2 = new o(a); a > i; )
    c2[i] = r2[i++];
  return c2;
}, y$1(function() {
  new Int8Array(1).slice();
}));
var ki = _e("unscopables"), Ii = Array.prototype;
null == Ii[ki] && Ge.f(Ii, ki, { configurable: true, value: Yn(null) });
var Ti = function(e2) {
  Ii[ki][e2] = true;
}, Oi = St.includes;
Gt({ target: "Array", proto: true }, { includes: function(e2) {
  return Oi(this, e2, arguments.length > 1 ? arguments[1] : void 0);
} }), Ti("includes"), sn("Array", "includes");
var Ei = C("".indexOf);
Gt({ target: "String", proto: true, forced: !en("includes") }, { includes: function(e2) {
  return !!~Ei(Jt(W(this)), Jt(Qt(e2)), arguments.length > 1 ? arguments[1] : void 0);
} }), sn("String", "includes");
var xi = Ge.f, Ci = it.set, Ri = it.getterFor("Array Iterator");
Co(Array, "Array", function(e2, t2) {
  Ci(this, { type: "Array Iterator", target: L(e2), index: 0, kind: t2 });
}, function() {
  var e2 = Ri(this), t2 = e2.target, n2 = e2.kind, r2 = e2.index++;
  return !t2 || r2 >= t2.length ? (e2.target = void 0, { value: void 0, done: true }) : "keys" == n2 ? { value: r2, done: false } : "values" == n2 ? { value: t2[r2], done: false } : { value: [r2, t2[r2]], done: false };
}, "values");
var ji = mo.Arguments = mo.Array;
if (Ti("keys"), Ti("values"), Ti("entries"), v$2 && "values" !== ji.name)
  try {
    xi(ji, "name", { value: "values" });
  } catch (e2) {
  }
var Ai = y$1(function() {
  if ("function" == typeof ArrayBuffer) {
    var e2 = new ArrayBuffer(8);
    Object.isExtensible(e2) && Object.defineProperty(e2, "a", { value: 8 });
  }
}), Ui = Object.isExtensible, Pi = y$1(function() {
  Ui(1);
}) || Ai ? function(e2) {
  return !!G(e2) && ((!Ai || "ArrayBuffer" != A$1(e2)) && (!Ui || Ui(e2)));
} : Ui, Ki = !y$1(function() {
  return Object.isExtensible(Object.preventExtensions({}));
}), Fi = l$2(function(e2) {
  var t2 = Ge.f, n2 = false, r2 = me("meta"), o = 0, i = function(e3) {
    t2(e3, r2, { value: { objectID: "O" + o++, weakData: {} } });
  }, a = e2.exports = { enable: function() {
    a.enable = function() {
    }, n2 = true;
    var e3 = Et.f, t3 = C([].splice), o2 = {};
    o2[r2] = 1, e3(o2).length && (Et.f = function(n3) {
      for (var o3 = e3(n3), i2 = 0, a2 = o3.length; i2 < a2; i2++)
        if (o3[i2] === r2) {
          t3(o3, i2, 1);
          break;
        }
      return o3;
    }, Gt({ target: "Object", stat: true, forced: true }, { getOwnPropertyNames: qn.f }));
  }, fastKey: function(e3, t3) {
    if (!G(e3))
      return "symbol" == typeof e3 ? e3 : ("string" == typeof e3 ? "S" : "P") + e3;
    if (!he(e3, r2)) {
      if (!Pi(e3))
        return "F";
      if (!t3)
        return "E";
      i(e3);
    }
    return e3[r2].objectID;
  }, getWeakData: function(e3, t3) {
    if (!he(e3, r2)) {
      if (!Pi(e3))
        return true;
      if (!t3)
        return false;
      i(e3);
    }
    return e3[r2].weakData;
  }, onFreeze: function(e3) {
    return Ki && n2 && Pi(e3) && !he(e3, r2) && i(e3), e3;
  } };
  qe[r2] = true;
});
Fi.enable, Fi.fastKey, Fi.getWeakData, Fi.onFreeze;
var Wi = p$2.TypeError, Li = function(e2, t2) {
  this.stopped = e2, this.result = t2;
}, Zi = Li.prototype, Gi = function(e2, t2, n2) {
  var r2, o, i, a, c2, s2, u2, l2 = n2 && n2.that, f2 = !(!n2 || !n2.AS_ENTRIES), d2 = !(!n2 || !n2.IS_ITERATOR), h2 = !(!n2 || !n2.INTERRUPTED), p2 = cr(t2, l2), y2 = function(e3) {
    return r2 && Uo(r2, "normal", e3), new Li(true, e3);
  }, v2 = function(e3) {
    return f2 ? (Fe(e3), h2 ? p2(e3[0], e3[1], y2) : p2(e3[0], e3[1])) : h2 ? p2(e3, y2) : p2(e3);
  };
  if (d2)
    r2 = e2;
  else {
    if (!(o = Zo(e2)))
      throw Wi(te(e2) + " is not iterable");
    if (Wo(o)) {
      for (i = 0, a = bt(e2); a > i; i++)
        if ((c2 = v2(e2[i])) && N(Zi, c2))
          return c2;
      return new Li(false);
    }
    r2 = Xo(e2, o);
  }
  for (s2 = r2.next; !(u2 = b$2(s2, r2)).done; ) {
    try {
      c2 = v2(u2.value);
    } catch (e3) {
      Uo(r2, "throw", e3);
    }
    if ("object" == typeof c2 && c2 && N(Zi, c2))
      return c2;
  }
  return new Li(false);
}, Xi = p$2.TypeError, Vi = function(e2, t2) {
  if (N(t2, e2))
    return e2;
  throw Xi("Incorrect invocation");
}, Ni = function(e2, t2, n2) {
  for (var r2 in t2)
    lt(e2, r2, t2[r2], n2);
  return e2;
}, Di = _e("species"), Yi = Ge.f, Mi = Fi.fastKey, zi = it.set, Bi = it.getterFor, Ji = { getConstructor: function(e2, t2, n2, r2) {
  var o = e2(function(e3, o2) {
    Vi(e3, i), zi(e3, { type: t2, index: Yn(null), first: void 0, last: void 0, size: 0 }), v$2 || (e3.size = 0), null != o2 && Gi(o2, e3[r2], { that: e3, AS_ENTRIES: n2 });
  }), i = o.prototype, a = Bi(t2), c2 = function(e3, t3, n3) {
    var r3, o2, i2 = a(e3), c3 = s2(e3, t3);
    return c3 ? c3.value = n3 : (i2.last = c3 = { index: o2 = Mi(t3, true), key: t3, value: n3, previous: r3 = i2.last, next: void 0, removed: false }, i2.first || (i2.first = c3), r3 && (r3.next = c3), v$2 ? i2.size++ : e3.size++, "F" !== o2 && (i2.index[o2] = c3)), e3;
  }, s2 = function(e3, t3) {
    var n3, r3 = a(e3), o2 = Mi(t3);
    if ("F" !== o2)
      return r3.index[o2];
    for (n3 = r3.first; n3; n3 = n3.next)
      if (n3.key == t3)
        return n3;
  };
  return Ni(i, { clear: function() {
    for (var e3 = a(this), t3 = e3.index, n3 = e3.first; n3; )
      n3.removed = true, n3.previous && (n3.previous = n3.previous.next = void 0), delete t3[n3.index], n3 = n3.next;
    e3.first = e3.last = void 0, v$2 ? e3.size = 0 : this.size = 0;
  }, delete: function(e3) {
    var t3 = this, n3 = a(t3), r3 = s2(t3, e3);
    if (r3) {
      var o2 = r3.next, i2 = r3.previous;
      delete n3.index[r3.index], r3.removed = true, i2 && (i2.next = o2), o2 && (o2.previous = i2), n3.first == r3 && (n3.first = o2), n3.last == r3 && (n3.last = i2), v$2 ? n3.size-- : t3.size--;
    }
    return !!r3;
  }, forEach: function(e3) {
    for (var t3, n3 = a(this), r3 = cr(e3, arguments.length > 1 ? arguments[1] : void 0); t3 = t3 ? t3.next : n3.first; )
      for (r3(t3.value, t3.key, this); t3 && t3.removed; )
        t3 = t3.previous;
  }, has: function(e3) {
    return !!s2(this, e3);
  } }), Ni(i, n2 ? { get: function(e3) {
    var t3 = s2(this, e3);
    return t3 && t3.value;
  }, set: function(e3, t3) {
    return c2(this, 0 === e3 ? 0 : e3, t3);
  } } : { add: function(e3) {
    return c2(this, e3 = 0 === e3 ? 0 : e3, e3);
  } }), v$2 && Yi(i, "size", { get: function() {
    return a(this).size;
  } }), o;
}, setStrong: function(e2, t2, n2) {
  var r2 = t2 + " Iterator", o = Bi(t2), i = Bi(r2);
  Co(e2, t2, function(e3, t3) {
    zi(this, { type: r2, target: e3, state: o(e3), kind: t3, last: void 0 });
  }, function() {
    for (var e3 = i(this), t3 = e3.kind, n3 = e3.last; n3 && n3.removed; )
      n3 = n3.previous;
    return e3.target && (e3.last = n3 = n3 ? n3.next : e3.state.first) ? "keys" == t3 ? { value: n3.key, done: false } : "values" == t3 ? { value: n3.value, done: false } : { value: [n3.key, n3.value], done: false } : (e3.target = void 0, { value: void 0, done: true });
  }, n2 ? "entries" : "values", !n2, true), function(e3) {
    var t3 = V(e3), n3 = Ge.f;
    v$2 && t3 && !t3[Di] && n3(t3, Di, { configurable: true, get: function() {
      return this;
    } });
  }(t2);
} };
function Hi(e2) {
  var t2 = this.constructor;
  return this.then(function(n2) {
    return t2.resolve(e2()).then(function() {
      return n2;
    });
  }, function(n2) {
    return t2.resolve(e2()).then(function() {
      return t2.reject(n2);
    });
  });
}
function qi(e2) {
  return new this(function(t2, n2) {
    if (!e2 || void 0 === e2.length)
      return n2(new TypeError(typeof e2 + " " + e2 + " is not iterable(cannot read property Symbol(Symbol.iterator))"));
    var r2 = Array.prototype.slice.call(e2);
    if (0 === r2.length)
      return t2([]);
    var o = r2.length;
    function i(e3, n3) {
      if (n3 && ("object" == typeof n3 || "function" == typeof n3)) {
        var a2 = n3.then;
        if ("function" == typeof a2)
          return void a2.call(n3, function(t3) {
            i(e3, t3);
          }, function(n4) {
            r2[e3] = { status: "rejected", reason: n4 }, 0 == --o && t2(r2);
          });
      }
      r2[e3] = { status: "fulfilled", value: n3 }, 0 == --o && t2(r2);
    }
    for (var a = 0; a < r2.length; a++)
      i(a, r2[a]);
  });
}
!function(e2, t2, n2) {
  var r2 = -1 !== e2.indexOf("Map"), o = -1 !== e2.indexOf("Weak"), i = r2 ? "set" : "add", a = p$2[e2], c2 = a && a.prototype, s2 = a, u2 = {}, l2 = function(e3) {
    var t3 = C(c2[e3]);
    lt(c2, e3, "add" == e3 ? function(e4) {
      return t3(this, 0 === e4 ? 0 : e4), this;
    } : "delete" == e3 ? function(e4) {
      return !(o && !G(e4)) && t3(this, 0 === e4 ? 0 : e4);
    } : "get" == e3 ? function(e4) {
      return o && !G(e4) ? void 0 : t3(this, 0 === e4 ? 0 : e4);
    } : "has" == e3 ? function(e4) {
      return !(o && !G(e4)) && t3(this, 0 === e4 ? 0 : e4);
    } : function(e4, n3) {
      return t3(this, 0 === e4 ? 0 : e4, n3), this;
    });
  };
  if (Lt(e2, !Z(a) || !(o || c2.forEach && !y$1(function() {
    new a().entries().next();
  }))))
    s2 = n2.getConstructor(t2, e2, r2, i), Fi.enable();
  else if (Lt(e2, true)) {
    var f2 = new s2(), d2 = f2[i](o ? {} : -0, 1) != f2, h2 = y$1(function() {
      f2.has(1);
    }), v2 = zo(function(e3) {
      new a(e3);
    }), m2 = !o && y$1(function() {
      for (var e3 = new a(), t3 = 5; t3--; )
        e3[i](t3, t3);
      return !e3.has(-0);
    });
    v2 || ((s2 = t2(function(e3, t3) {
      Vi(e3, c2);
      var n3 = function(e4, t4, n4) {
        var r3, o2;
        return _o && Z(r3 = t4.constructor) && r3 !== n4 && G(o2 = r3.prototype) && o2 !== n4.prototype && _o(e4, o2), e4;
      }(new a(), e3, s2);
      return null != t3 && Gi(t3, n3[i], { that: n3, AS_ENTRIES: r2 }), n3;
    })).prototype = c2, c2.constructor = s2), (h2 || m2) && (l2("delete"), l2("has"), r2 && l2("get")), (m2 || d2) && l2(i), o && c2.clear && delete c2.clear;
  }
  u2[e2] = s2, Gt({ global: true, forced: s2 != a }, u2), ir(s2, e2), o || n2.setStrong(s2, e2, r2);
}("Set", function(e2) {
  return function() {
    return e2(this, arguments.length ? arguments[0] : void 0);
  };
}, Ji), er.Set;
var Qi = setTimeout, $i = "undefined" != typeof setImmediate ? setImmediate : null;
function ea(e2) {
  return Boolean(e2 && void 0 !== e2.length);
}
function ta() {
}
function na(e2) {
  if (!(this instanceof na))
    throw new TypeError("Promises must be constructed via new");
  if ("function" != typeof e2)
    throw new TypeError("not a function");
  this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], sa(e2, this);
}
function ra(e2, t2) {
  for (; 3 === e2._state; )
    e2 = e2._value;
  0 !== e2._state ? (e2._handled = true, na._immediateFn(function() {
    var n2 = 1 === e2._state ? t2.onFulfilled : t2.onRejected;
    if (null !== n2) {
      var r2;
      try {
        r2 = n2(e2._value);
      } catch (e3) {
        return void ia(t2.promise, e3);
      }
      oa(t2.promise, r2);
    } else
      (1 === e2._state ? oa : ia)(t2.promise, e2._value);
  })) : e2._deferreds.push(t2);
}
function oa(e2, t2) {
  try {
    if (t2 === e2)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (t2 && ("object" == typeof t2 || "function" == typeof t2)) {
      var n2 = t2.then;
      if (t2 instanceof na)
        return e2._state = 3, e2._value = t2, void aa(e2);
      if ("function" == typeof n2)
        return void sa((r2 = n2, o = t2, function() {
          r2.apply(o, arguments);
        }), e2);
    }
    e2._state = 1, e2._value = t2, aa(e2);
  } catch (t3) {
    ia(e2, t3);
  }
  var r2, o;
}
function ia(e2, t2) {
  e2._state = 2, e2._value = t2, aa(e2);
}
function aa(e2) {
  2 === e2._state && 0 === e2._deferreds.length && na._immediateFn(function() {
    e2._handled || na._unhandledRejectionFn(e2._value);
  });
  for (var t2 = 0, n2 = e2._deferreds.length; t2 < n2; t2++)
    ra(e2, e2._deferreds[t2]);
  e2._deferreds = null;
}
function ca(e2, t2, n2) {
  this.onFulfilled = "function" == typeof e2 ? e2 : null, this.onRejected = "function" == typeof t2 ? t2 : null, this.promise = n2;
}
function sa(e2, t2) {
  var n2 = false;
  try {
    e2(function(e3) {
      n2 || (n2 = true, oa(t2, e3));
    }, function(e3) {
      n2 || (n2 = true, ia(t2, e3));
    });
  } catch (e3) {
    if (n2)
      return;
    n2 = true, ia(t2, e3);
  }
}
na.prototype.catch = function(e2) {
  return this.then(null, e2);
}, na.prototype.then = function(e2, t2) {
  var n2 = new this.constructor(ta);
  return ra(this, new ca(e2, t2, n2)), n2;
}, na.prototype.finally = Hi, na.all = function(e2) {
  return new na(function(t2, n2) {
    if (!ea(e2))
      return n2(new TypeError("Promise.all accepts an array"));
    var r2 = Array.prototype.slice.call(e2);
    if (0 === r2.length)
      return t2([]);
    var o = r2.length;
    function i(e3, a2) {
      try {
        if (a2 && ("object" == typeof a2 || "function" == typeof a2)) {
          var c2 = a2.then;
          if ("function" == typeof c2)
            return void c2.call(a2, function(t3) {
              i(e3, t3);
            }, n2);
        }
        r2[e3] = a2, 0 == --o && t2(r2);
      } catch (e4) {
        n2(e4);
      }
    }
    for (var a = 0; a < r2.length; a++)
      i(a, r2[a]);
  });
}, na.allSettled = qi, na.resolve = function(e2) {
  return e2 && "object" == typeof e2 && e2.constructor === na ? e2 : new na(function(t2) {
    t2(e2);
  });
}, na.reject = function(e2) {
  return new na(function(t2, n2) {
    n2(e2);
  });
}, na.race = function(e2) {
  return new na(function(t2, n2) {
    if (!ea(e2))
      return n2(new TypeError("Promise.race accepts an array"));
    for (var r2 = 0, o = e2.length; r2 < o; r2++)
      na.resolve(e2[r2]).then(t2, n2);
  });
}, na._immediateFn = "function" == typeof $i && function(e2) {
  $i(e2);
} || function(e2) {
  Qi(e2, 0);
}, na._unhandledRejectionFn = function(e2) {
  "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", e2);
};
var ua = function() {
  if ("undefined" != typeof self)
    return self;
  if ("undefined" != typeof window)
    return window;
  if ("undefined" != typeof global)
    return global;
  throw new Error("unable to locate global object");
}();
"function" != typeof ua.Promise ? ua.Promise = na : (ua.Promise.prototype.finally || (ua.Promise.prototype.finally = Hi), ua.Promise.allSettled || (ua.Promise.allSettled = qi)), function(e2) {
  function t2() {
  }
  function n2(e3, t3) {
    if (e3 = void 0 === e3 ? "utf-8" : e3, t3 = void 0 === t3 ? { fatal: false } : t3, -1 === o.indexOf(e3.toLowerCase()))
      throw new RangeError("Failed to construct 'TextDecoder': The encoding label provided ('" + e3 + "') is invalid.");
    if (t3.fatal)
      throw Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.");
  }
  function r2(e3) {
    for (var t3 = 0, n3 = Math.min(65536, e3.length + 1), r3 = new Uint16Array(n3), o2 = [], i2 = 0; ; ) {
      var a = t3 < e3.length;
      if (!a || i2 >= n3 - 1) {
        if (o2.push(String.fromCharCode.apply(null, r3.subarray(0, i2))), !a)
          return o2.join("");
        e3 = e3.subarray(t3), i2 = t3 = 0;
      }
      if (0 == (128 & (a = e3[t3++])))
        r3[i2++] = a;
      else if (192 == (224 & a)) {
        var c2 = 63 & e3[t3++];
        r3[i2++] = (31 & a) << 6 | c2;
      } else if (224 == (240 & a)) {
        c2 = 63 & e3[t3++];
        var s2 = 63 & e3[t3++];
        r3[i2++] = (31 & a) << 12 | c2 << 6 | s2;
      } else if (240 == (248 & a)) {
        65535 < (a = (7 & a) << 18 | (c2 = 63 & e3[t3++]) << 12 | (s2 = 63 & e3[t3++]) << 6 | 63 & e3[t3++]) && (a -= 65536, r3[i2++] = a >>> 10 & 1023 | 55296, a = 56320 | 1023 & a), r3[i2++] = a;
      }
    }
  }
  if (e2.TextEncoder && e2.TextDecoder)
    return false;
  var o = ["utf-8", "utf8", "unicode-1-1-utf-8"];
  Object.defineProperty(t2.prototype, "encoding", { value: "utf-8" }), t2.prototype.encode = function(e3, t3) {
    if ((t3 = void 0 === t3 ? { stream: false } : t3).stream)
      throw Error("Failed to encode: the 'stream' option is unsupported.");
    t3 = 0;
    for (var n3 = e3.length, r3 = 0, o2 = Math.max(32, n3 + (n3 >>> 1) + 7), i2 = new Uint8Array(o2 >>> 3 << 3); t3 < n3; ) {
      var a = e3.charCodeAt(t3++);
      if (55296 <= a && 56319 >= a) {
        if (t3 < n3) {
          var c2 = e3.charCodeAt(t3);
          56320 == (64512 & c2) && (++t3, a = ((1023 & a) << 10) + (1023 & c2) + 65536);
        }
        if (55296 <= a && 56319 >= a)
          continue;
      }
      if (r3 + 4 > i2.length && (o2 += 8, o2 = (o2 *= 1 + t3 / e3.length * 2) >>> 3 << 3, (c2 = new Uint8Array(o2)).set(i2), i2 = c2), 0 == (4294967168 & a))
        i2[r3++] = a;
      else {
        if (0 == (4294965248 & a))
          i2[r3++] = a >>> 6 & 31 | 192;
        else if (0 == (4294901760 & a))
          i2[r3++] = a >>> 12 & 15 | 224, i2[r3++] = a >>> 6 & 63 | 128;
        else {
          if (0 != (4292870144 & a))
            continue;
          i2[r3++] = a >>> 18 & 7 | 240, i2[r3++] = a >>> 12 & 63 | 128, i2[r3++] = a >>> 6 & 63 | 128;
        }
        i2[r3++] = 63 & a | 128;
      }
    }
    return i2.slice ? i2.slice(0, r3) : i2.subarray(0, r3);
  }, Object.defineProperty(n2.prototype, "encoding", { value: "utf-8" }), Object.defineProperty(n2.prototype, "fatal", { value: false }), Object.defineProperty(n2.prototype, "ignoreBOM", { value: false });
  var i = r2;
  "function" == typeof Buffer && Buffer.from ? i = function(e3) {
    return Buffer.from(e3.buffer, e3.byteOffset, e3.byteLength).toString("utf-8");
  } : "function" == typeof Blob && "function" == typeof URL && "function" == typeof URL.createObjectURL && (i = function(e3) {
    var t3 = URL.createObjectURL(new Blob([e3], { type: "text/plain;charset=UTF-8" }));
    try {
      var n3 = new XMLHttpRequest();
      return n3.open("GET", t3, false), n3.send(), n3.responseText;
    } catch (t4) {
      return r2(e3);
    } finally {
      URL.revokeObjectURL(t3);
    }
  }), n2.prototype.decode = function(e3, t3) {
    if ((t3 = void 0 === t3 ? { stream: false } : t3).stream)
      throw Error("Failed to decode: the 'stream' option is unsupported.");
    return e3 = e3 instanceof Uint8Array ? e3 : e3.buffer instanceof ArrayBuffer ? new Uint8Array(e3.buffer) : new Uint8Array(e3), i(e3);
  }, e2.TextEncoder = t2, e2.TextDecoder = n2;
}("undefined" != typeof window ? window : s), function() {
  function e2(e3, t3) {
    if (!(e3 instanceof t3))
      throw new TypeError("Cannot call a class as a function");
  }
  function t2(e3, t3) {
    for (var n3 = 0; n3 < t3.length; n3++) {
      var r3 = t3[n3];
      r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e3, r3.key, r3);
    }
  }
  function n2(e3, n3, r3) {
    return n3 && t2(e3.prototype, n3), r3 && t2(e3, r3), e3;
  }
  function r2(e3, t3) {
    if ("function" != typeof t3 && null !== t3)
      throw new TypeError("Super expression must either be null or a function");
    e3.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), t3 && i(e3, t3);
  }
  function o(e3) {
    return o = Object.setPrototypeOf ? Object.getPrototypeOf : function(e4) {
      return e4.__proto__ || Object.getPrototypeOf(e4);
    }, o(e3);
  }
  function i(e3, t3) {
    return i = Object.setPrototypeOf || function(e4, t4) {
      return e4.__proto__ = t4, e4;
    }, i(e3, t3);
  }
  function a() {
    if ("undefined" == typeof Reflect || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if ("function" == typeof Proxy)
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch (e3) {
      return false;
    }
  }
  function c2(e3) {
    if (void 0 === e3)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e3;
  }
  function u2(e3, t3) {
    return !t3 || "object" != typeof t3 && "function" != typeof t3 ? c2(e3) : t3;
  }
  function l2(e3) {
    var t3 = a();
    return function() {
      var n3, r3 = o(e3);
      if (t3) {
        var i2 = o(this).constructor;
        n3 = Reflect.construct(r3, arguments, i2);
      } else
        n3 = r3.apply(this, arguments);
      return u2(this, n3);
    };
  }
  function f2(e3, t3) {
    for (; !Object.prototype.hasOwnProperty.call(e3, t3) && null !== (e3 = o(e3)); )
      ;
    return e3;
  }
  function d2(e3, t3, n3) {
    return d2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e4, t4, n4) {
      var r3 = f2(e4, t4);
      if (r3) {
        var o2 = Object.getOwnPropertyDescriptor(r3, t4);
        return o2.get ? o2.get.call(n4) : o2.value;
      }
    }, d2(e3, t3, n3 || e3);
  }
  var h2 = function() {
    function t3() {
      e2(this, t3), Object.defineProperty(this, "listeners", { value: {}, writable: true, configurable: true });
    }
    return n2(t3, [{ key: "addEventListener", value: function(e3, t4, n3) {
      e3 in this.listeners || (this.listeners[e3] = []), this.listeners[e3].push({ callback: t4, options: n3 });
    } }, { key: "removeEventListener", value: function(e3, t4) {
      if (e3 in this.listeners) {
        for (var n3 = this.listeners[e3], r3 = 0, o2 = n3.length; r3 < o2; r3++)
          if (n3[r3].callback === t4)
            return void n3.splice(r3, 1);
      }
    } }, { key: "dispatchEvent", value: function(e3) {
      if (e3.type in this.listeners) {
        for (var t4 = this.listeners[e3.type].slice(), n3 = 0, r3 = t4.length; n3 < r3; n3++) {
          var o2 = t4[n3];
          try {
            o2.callback.call(this, e3);
          } catch (e4) {
            Promise.resolve().then(function() {
              throw e4;
            });
          }
          o2.options && o2.options.once && this.removeEventListener(e3.type, o2.callback);
        }
        return !e3.defaultPrevented;
      }
    } }]), t3;
  }(), p2 = function(t3) {
    r2(a2, t3);
    var i2 = l2(a2);
    function a2() {
      var t4;
      return e2(this, a2), (t4 = i2.call(this)).listeners || h2.call(c2(t4)), Object.defineProperty(c2(t4), "aborted", { value: false, writable: true, configurable: true }), Object.defineProperty(c2(t4), "onabort", { value: null, writable: true, configurable: true }), t4;
    }
    return n2(a2, [{ key: "toString", value: function() {
      return "[object AbortSignal]";
    } }, { key: "dispatchEvent", value: function(e3) {
      "abort" === e3.type && (this.aborted = true, "function" == typeof this.onabort && this.onabort.call(this, e3)), d2(o(a2.prototype), "dispatchEvent", this).call(this, e3);
    } }]), a2;
  }(h2), y2 = function() {
    function t3() {
      e2(this, t3), Object.defineProperty(this, "signal", { value: new p2(), writable: true, configurable: true });
    }
    return n2(t3, [{ key: "abort", value: function() {
      var e3;
      try {
        e3 = new Event("abort");
      } catch (t4) {
        "undefined" != typeof document ? document.createEvent ? (e3 = document.createEvent("Event")).initEvent("abort", false, false) : (e3 = document.createEventObject()).type = "abort" : e3 = { type: "abort", bubbles: false, cancelable: false };
      }
      this.signal.dispatchEvent(e3);
    } }, { key: "toString", value: function() {
      return "[object AbortController]";
    } }]), t3;
  }();
  function v2(e3) {
    return e3.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL ? (console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill"), true) : "function" == typeof e3.Request && !e3.Request.prototype.hasOwnProperty("signal") || !e3.AbortController;
  }
  "undefined" != typeof Symbol && Symbol.toStringTag && (y2.prototype[Symbol.toStringTag] = "AbortController", p2.prototype[Symbol.toStringTag] = "AbortSignal"), function(e3) {
    v2(e3) && (e3.AbortController = y2, e3.AbortSignal = p2);
  }("undefined" != typeof self ? self : s);
}();
var la = l$2(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true });
  var n2 = function() {
    function e3() {
      var e4 = this;
      this.locked = /* @__PURE__ */ new Map(), this.addToLocked = function(t3, n3) {
        var r2 = e4.locked.get(t3);
        void 0 === r2 ? void 0 === n3 ? e4.locked.set(t3, []) : e4.locked.set(t3, [n3]) : void 0 !== n3 && (r2.unshift(n3), e4.locked.set(t3, r2));
      }, this.isLocked = function(t3) {
        return e4.locked.has(t3);
      }, this.lock = function(t3) {
        return new Promise(function(n3, r2) {
          e4.isLocked(t3) ? e4.addToLocked(t3, n3) : (e4.addToLocked(t3), n3());
        });
      }, this.unlock = function(t3) {
        var n3 = e4.locked.get(t3);
        if (void 0 !== n3 && 0 !== n3.length) {
          var r2 = n3.pop();
          e4.locked.set(t3, n3), void 0 !== r2 && setTimeout(r2, 0);
        } else
          e4.locked.delete(t3);
      };
    }
    return e3.getInstance = function() {
      return void 0 === e3.instance && (e3.instance = new e3()), e3.instance;
    }, e3;
  }();
  t2.default = function() {
    return n2.getInstance();
  };
});
u$2(la);
var fa = l$2(function(e2, t2) {
  var n2 = s && s.__awaiter || function(e3, t3, n3, r3) {
    return new (n3 || (n3 = Promise))(function(o2, i2) {
      function a2(e4) {
        try {
          s2(r3.next(e4));
        } catch (e5) {
          i2(e5);
        }
      }
      function c3(e4) {
        try {
          s2(r3.throw(e4));
        } catch (e5) {
          i2(e5);
        }
      }
      function s2(e4) {
        e4.done ? o2(e4.value) : new n3(function(t4) {
          t4(e4.value);
        }).then(a2, c3);
      }
      s2((r3 = r3.apply(e3, t3 || [])).next());
    });
  }, r2 = s && s.__generator || function(e3, t3) {
    var n3, r3, o2, i2, a2 = { label: 0, sent: function() {
      if (1 & o2[0])
        throw o2[1];
      return o2[1];
    }, trys: [], ops: [] };
    return i2 = { next: c3(0), throw: c3(1), return: c3(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
      return this;
    }), i2;
    function c3(i3) {
      return function(c4) {
        return function(i4) {
          if (n3)
            throw new TypeError("Generator is already executing.");
          for (; a2; )
            try {
              if (n3 = 1, r3 && (o2 = 2 & i4[0] ? r3.return : i4[0] ? r3.throw || ((o2 = r3.return) && o2.call(r3), 0) : r3.next) && !(o2 = o2.call(r3, i4[1])).done)
                return o2;
              switch (r3 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
                case 0:
                case 1:
                  o2 = i4;
                  break;
                case 4:
                  return a2.label++, { value: i4[1], done: false };
                case 5:
                  a2.label++, r3 = i4[1], i4 = [0];
                  continue;
                case 7:
                  i4 = a2.ops.pop(), a2.trys.pop();
                  continue;
                default:
                  if (!(o2 = a2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                    a2 = 0;
                    continue;
                  }
                  if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                    a2.label = i4[1];
                    break;
                  }
                  if (6 === i4[0] && a2.label < o2[1]) {
                    a2.label = o2[1], o2 = i4;
                    break;
                  }
                  if (o2 && a2.label < o2[2]) {
                    a2.label = o2[2], a2.ops.push(i4);
                    break;
                  }
                  o2[2] && a2.ops.pop(), a2.trys.pop();
                  continue;
              }
              i4 = t3.call(e3, a2);
            } catch (e4) {
              i4 = [6, e4], r3 = 0;
            } finally {
              n3 = o2 = 0;
            }
          if (5 & i4[0])
            throw i4[1];
          return { value: i4[0] ? i4[1] : void 0, done: true };
        }([i3, c4]);
      };
    }
  };
  Object.defineProperty(t2, "__esModule", { value: true });
  var o = "browser-tabs-lock-key";
  function i(e3) {
    return new Promise(function(t3) {
      return setTimeout(t3, e3);
    });
  }
  function a(e3) {
    for (var t3 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", n3 = "", r3 = 0; r3 < e3; r3++) {
      n3 += t3[Math.floor(Math.random() * t3.length)];
    }
    return n3;
  }
  var c2 = function() {
    function e3() {
      this.acquiredIatSet = /* @__PURE__ */ new Set(), this.id = Date.now().toString() + a(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), void 0 === e3.waiters && (e3.waiters = []);
    }
    return e3.prototype.acquireLock = function(t3, c3) {
      return void 0 === c3 && (c3 = 5e3), n2(this, void 0, void 0, function() {
        var n3, s2, u2, l2, f2, d2;
        return r2(this, function(r3) {
          switch (r3.label) {
            case 0:
              n3 = Date.now() + a(4), s2 = Date.now() + c3, u2 = o + "-" + t3, l2 = window.localStorage, r3.label = 1;
            case 1:
              return Date.now() < s2 ? [4, i(30)] : [3, 8];
            case 2:
              return r3.sent(), null !== l2.getItem(u2) ? [3, 5] : (f2 = this.id + "-" + t3 + "-" + n3, [4, i(Math.floor(25 * Math.random()))]);
            case 3:
              return r3.sent(), l2.setItem(u2, JSON.stringify({ id: this.id, iat: n3, timeoutKey: f2, timeAcquired: Date.now(), timeRefreshed: Date.now() })), [4, i(30)];
            case 4:
              return r3.sent(), null !== (d2 = l2.getItem(u2)) && (d2 = JSON.parse(d2)).id === this.id && d2.iat === n3 ? (this.acquiredIatSet.add(n3), this.refreshLockWhileAcquired(u2, n3), [2, true]) : [3, 7];
            case 5:
              return e3.lockCorrector(), [4, this.waitForSomethingToChange(s2)];
            case 6:
              r3.sent(), r3.label = 7;
            case 7:
              return n3 = Date.now() + a(4), [3, 1];
            case 8:
              return [2, false];
          }
        });
      });
    }, e3.prototype.refreshLockWhileAcquired = function(e4, t3) {
      return n2(this, void 0, void 0, function() {
        var o2 = this;
        return r2(this, function(i2) {
          return setTimeout(function() {
            return n2(o2, void 0, void 0, function() {
              var n3, o3;
              return r2(this, function(r3) {
                switch (r3.label) {
                  case 0:
                    return [4, la.default().lock(t3)];
                  case 1:
                    return r3.sent(), this.acquiredIatSet.has(t3) ? (n3 = window.localStorage, null === (o3 = n3.getItem(e4)) ? (la.default().unlock(t3), [2]) : ((o3 = JSON.parse(o3)).timeRefreshed = Date.now(), n3.setItem(e4, JSON.stringify(o3)), la.default().unlock(t3), this.refreshLockWhileAcquired(e4, t3), [2])) : (la.default().unlock(t3), [2]);
                }
              });
            });
          }, 1e3), [2];
        });
      });
    }, e3.prototype.waitForSomethingToChange = function(t3) {
      return n2(this, void 0, void 0, function() {
        return r2(this, function(n3) {
          switch (n3.label) {
            case 0:
              return [4, new Promise(function(n4) {
                var r3 = false, o2 = Date.now(), i2 = false;
                function a2() {
                  if (i2 || (window.removeEventListener("storage", a2), e3.removeFromWaiting(a2), clearTimeout(c3), i2 = true), !r3) {
                    r3 = true;
                    var t4 = 50 - (Date.now() - o2);
                    t4 > 0 ? setTimeout(n4, t4) : n4();
                  }
                }
                window.addEventListener("storage", a2), e3.addToWaiting(a2);
                var c3 = setTimeout(a2, Math.max(0, t3 - Date.now()));
              })];
            case 1:
              return n3.sent(), [2];
          }
        });
      });
    }, e3.addToWaiting = function(t3) {
      this.removeFromWaiting(t3), void 0 !== e3.waiters && e3.waiters.push(t3);
    }, e3.removeFromWaiting = function(t3) {
      void 0 !== e3.waiters && (e3.waiters = e3.waiters.filter(function(e4) {
        return e4 !== t3;
      }));
    }, e3.notifyWaiters = function() {
      void 0 !== e3.waiters && e3.waiters.slice().forEach(function(e4) {
        return e4();
      });
    }, e3.prototype.releaseLock = function(e4) {
      return n2(this, void 0, void 0, function() {
        return r2(this, function(t3) {
          switch (t3.label) {
            case 0:
              return [4, this.releaseLock__private__(e4)];
            case 1:
              return [2, t3.sent()];
          }
        });
      });
    }, e3.prototype.releaseLock__private__ = function(t3) {
      return n2(this, void 0, void 0, function() {
        var n3, i2, a2;
        return r2(this, function(r3) {
          switch (r3.label) {
            case 0:
              return n3 = window.localStorage, i2 = o + "-" + t3, null === (a2 = n3.getItem(i2)) ? [2] : (a2 = JSON.parse(a2)).id !== this.id ? [3, 2] : [4, la.default().lock(a2.iat)];
            case 1:
              r3.sent(), this.acquiredIatSet.delete(a2.iat), n3.removeItem(i2), la.default().unlock(a2.iat), e3.notifyWaiters(), r3.label = 2;
            case 2:
              return [2];
          }
        });
      });
    }, e3.lockCorrector = function() {
      for (var t3 = Date.now() - 5e3, n3 = window.localStorage, r3 = Object.keys(n3), i2 = false, a2 = 0; a2 < r3.length; a2++) {
        var c3 = r3[a2];
        if (c3.includes(o)) {
          var s2 = n3.getItem(c3);
          null !== s2 && (void 0 === (s2 = JSON.parse(s2)).timeRefreshed && s2.timeAcquired < t3 || void 0 !== s2.timeRefreshed && s2.timeRefreshed < t3) && (n3.removeItem(c3), i2 = true);
        }
      }
      i2 && e3.notifyWaiters();
    }, e3.waiters = void 0, e3;
  }();
  t2.default = c2;
}), da = u$2(fa), ma = function(e2) {
  function n2(t2, r2) {
    var o = e2.call(this, r2) || this;
    return o.error = t2, o.error_description = r2, Object.setPrototypeOf(o, n2.prototype), o;
  }
  return t$2(n2, e2), n2.fromPayload = function(e3) {
    return new n2(e3.error, e3.error_description);
  }, n2;
}(Error);
(function(e2) {
  function n2(t2, r2, o, i) {
    void 0 === i && (i = null);
    var a = e2.call(this, t2, r2) || this;
    return a.state = o, a.appState = i, Object.setPrototypeOf(a, n2.prototype), a;
  }
  return t$2(n2, e2), n2;
})(ma);
var ba = function(e2) {
  function n2() {
    var t2 = e2.call(this, "timeout", "Timeout") || this;
    return Object.setPrototypeOf(t2, n2.prototype), t2;
  }
  return t$2(n2, e2), n2;
}(ma);
(function(e2) {
  function n2(t2) {
    var r2 = e2.call(this) || this;
    return r2.popup = t2, Object.setPrototypeOf(r2, n2.prototype), r2;
  }
  return t$2(n2, e2), n2;
})(ba);
(function(e2) {
  function n2(t2) {
    var r2 = e2.call(this, "cancelled", "Popup closed") || this;
    return r2.popup = t2, Object.setPrototypeOf(r2, n2.prototype), r2;
  }
  return t$2(n2, e2), n2;
})(ma);
(function(e2) {
  function n2(t2, r2, o) {
    var i = e2.call(this, t2, r2) || this;
    return i.mfa_token = o, Object.setPrototypeOf(i, n2.prototype), i;
  }
  return t$2(n2, e2), n2;
})(ma);
var Ba = l$2(function(e2, t2) {
  var n2 = s && s.__assign || function() {
    return n2 = Object.assign || function(e3) {
      for (var t3, n3 = 1, r3 = arguments.length; n3 < r3; n3++)
        for (var o2 in t3 = arguments[n3])
          Object.prototype.hasOwnProperty.call(t3, o2) && (e3[o2] = t3[o2]);
      return e3;
    }, n2.apply(this, arguments);
  };
  function r2(e3, t3) {
    if (!t3)
      return "";
    var n3 = "; " + e3;
    return true === t3 ? n3 : n3 + "=" + t3;
  }
  function o(e3, t3, n3) {
    return encodeURIComponent(e3).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\(/g, "%28").replace(/\)/g, "%29") + "=" + encodeURIComponent(t3).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function(e4) {
      if ("number" == typeof e4.expires) {
        var t4 = new Date();
        t4.setMilliseconds(t4.getMilliseconds() + 864e5 * e4.expires), e4.expires = t4;
      }
      return r2("Expires", e4.expires ? e4.expires.toUTCString() : "") + r2("Domain", e4.domain) + r2("Path", e4.path) + r2("Secure", e4.secure) + r2("SameSite", e4.sameSite);
    }(n3);
  }
  function i(e3) {
    for (var t3 = {}, n3 = e3 ? e3.split("; ") : [], r3 = /(%[\dA-F]{2})+/gi, o2 = 0; o2 < n3.length; o2++) {
      var i2 = n3[o2].split("="), a2 = i2.slice(1).join("=");
      '"' === a2.charAt(0) && (a2 = a2.slice(1, -1));
      try {
        t3[i2[0].replace(r3, decodeURIComponent)] = a2.replace(r3, decodeURIComponent);
      } catch (e4) {
      }
    }
    return t3;
  }
  function a() {
    return i(document.cookie);
  }
  function c2(e3, t3, r3) {
    document.cookie = o(e3, t3, n2({ path: "/" }, r3));
  }
  t2.__esModule = true, t2.encode = o, t2.parse = i, t2.getAll = a, t2.get = function(e3) {
    return a()[e3];
  }, t2.set = c2, t2.remove = function(e3, t3) {
    c2(e3, "", n2(n2({}, t3), { expires: -1 }));
  };
});
u$2(Ba), Ba.encode, Ba.parse, Ba.getAll;
Ba.get;
Ba.set;
Ba.remove;
new da();
var initialAuthState = {
  isAuthenticated: false,
  isLoading: true
};
var stub = function() {
  throw new Error("You forgot to wrap your component in <Auth0Provider>.");
};
var initialContext = __assign(__assign({}, initialAuthState), { buildAuthorizeUrl: stub, buildLogoutUrl: stub, getAccessTokenSilently: stub, getAccessTokenWithPopup: stub, getIdTokenClaims: stub, loginWithRedirect: stub, loginWithPopup: stub, logout: stub, handleRedirectCallback: stub });
var Auth0Context = React.createContext(initialContext);
(function(_super) {
  __extends(OAuthError, _super);
  function OAuthError(error3, error_description) {
    var _this = _super.call(this, error_description || error3) || this;
    _this.error = error3;
    _this.error_description = error_description;
    return _this;
  }
  return OAuthError;
})(Error);
var useAuth0 = function() {
  return React.useContext(Auth0Context);
};
const errorKey = "reeartherror";
function useAuth(accessToken) {
  const { isAuthenticated, error: error3, isLoading, loginWithRedirect, logout, getAccessTokenSilently } = useAuth0();
  return React.useMemo(
    () => ({
      isAuthenticated: !!accessToken || isAuthenticated && !error3,
      isLoading,
      error: error3 == null ? void 0 : error3.message,
      getAccessToken: () => accessToken || getAccessTokenSilently(),
      login: () => loginWithRedirect(),
      logout: () => logout({
        returnTo: error3 ? `${window.location.origin}?${errorKey}=${encodeURIComponent(error3 == null ? void 0 : error3.message)}` : window.location.origin
      })
    }),
    [
      accessToken,
      error3,
      getAccessTokenSilently,
      isAuthenticated,
      isLoading,
      loginWithRedirect,
      logout
    ]
  );
}
const defaultConfig$1 = {
  marketplaceApi: "https://api.marketplace.test.reearth.dev/api",
  authAudience: "https://api.test.reearth.dev",
  authDomain: "reearth-oss-test.eu.auth0.com",
  authClientId: "k6F1sgFikzVkkcW9Cpz7Ztvwq5cBRXlv",
  reearthApi: "https://api.test.reearth.dev/api",
  reearthWeb: {}.REEARTH_MARKETPLACE_REEARTH_WEB,
  reportUrl: {}.REEARTH_MARKETPLACE_REPORT_URL
};
async function loadConfig() {
  var _a2, _b, _c;
  if (window.REEARTH_MARKETPLACE_CONFIG)
    return;
  window.REEARTH_MARKETPLACE_CONFIG = defaultConfig$1;
  let config = {};
  try {
    const res = await fetch(
      `${(_c = (_b = (_a2 = window.REEARTH_CONFIG) == null ? void 0 : _a2.marketplaceUrl) == null ? void 0 : _b.replace(/\/$/, "")) != null ? _c : ""}/reearth_config.json`
    );
    if (res.status === 200)
      config = await res.json();
  } catch (err) {
    console.error("config load error", err);
  }
  window.REEARTH_MARKETPLACE_CONFIG = {
    ...defaultConfig$1,
    ...config
  };
}
function getConfig() {
  return window.REEARTH_MARKETPLACE_CONFIG;
}
let resolvers = [];
let rejecters = [];
async function getOrLoadConfig() {
  let config = getConfig();
  if (config)
    return config;
  const first = resolvers.length === 0;
  const promise = new Promise((resolve, reject) => {
    resolvers.push(resolve);
    rejecters.push(reject);
  });
  if (!first)
    return promise;
  try {
    await loadConfig();
    config = getConfig();
    for (const r2 of resolvers) {
      r2(config);
    }
  } catch (err) {
    for (const r2 of rejecters) {
      r2(err);
    }
  } finally {
    resolvers = [];
    rejecters = [];
  }
  return config;
}
function useConfig$3() {
  const [config, setConfig] = React.useState();
  React.useEffect(() => {
    (async () => {
      setConfig(await getOrLoadConfig());
    })();
  }, []);
  return config;
}
const SUSPENSE_PROMISE = Symbol();
const isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];
const isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;
const cancelSuspensePromise = (suspensePromise) => {
  var _a2, _b;
  (_b = (_a2 = suspensePromise[SUSPENSE_PROMISE]).c) == null ? void 0 : _b.call(_a2);
};
const isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {
  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;
  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;
  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);
};
const createSuspensePromise = (promise) => {
  const objectToAttach = {
    o: promise,
    c: null
  };
  const suspensePromise = new Promise((resolve) => {
    objectToAttach.c = () => {
      objectToAttach.c = null;
      resolve();
    };
    promise.then(objectToAttach.c, objectToAttach.c);
  });
  suspensePromise[SUSPENSE_PROMISE] = objectToAttach;
  return suspensePromise;
};
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps = (a, b2) => __defProps(a, __getOwnPropDescs(b2));
const hasInitialValue = (atom2) => "init" in atom2;
const READ_ATOM = "r";
const WRITE_ATOM = "w";
const COMMIT_ATOM = "c";
const SUBSCRIBE_ATOM = "s";
const RESTORE_ATOMS = "h";
const DEV_SUBSCRIBE_STATE = "n";
const DEV_GET_MOUNTED_ATOMS = "l";
const DEV_GET_ATOM_STATE = "a";
const DEV_GET_MOUNTED = "m";
const createStore = (initialValues) => {
  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();
  const mountedMap = /* @__PURE__ */ new WeakMap();
  const pendingMap = /* @__PURE__ */ new Map();
  let stateListeners;
  let mountedAtoms;
  if (({ "REEARTH_MARKETPLACE_REEARTH_API": "https://api.test.reearth.dev/api", "REEARTH_MARKETPLACE_API": "https://api.marketplace.test.reearth.dev/api", "REEARTH_MARKETPLACE_AUTH_DOMAIN": "reearth-oss-test.eu.auth0.com", "REEARTH_MARKETPLACE_AUTH_AUDIENCE": "https://api.test.reearth.dev", "REEARTH_MARKETPLACE_AUTH_CLIENT_ID": "k6F1sgFikzVkkcW9Cpz7Ztvwq5cBRXlv", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
    stateListeners = /* @__PURE__ */ new Set();
    mountedAtoms = /* @__PURE__ */ new Set();
  }
  if (initialValues) {
    for (const [atom2, value] of initialValues) {
      const atomState = { v: value, r: 0, d: /* @__PURE__ */ new Map() };
      if (({ "REEARTH_MARKETPLACE_REEARTH_API": "https://api.test.reearth.dev/api", "REEARTH_MARKETPLACE_API": "https://api.marketplace.test.reearth.dev/api", "REEARTH_MARKETPLACE_AUTH_DOMAIN": "reearth-oss-test.eu.auth0.com", "REEARTH_MARKETPLACE_AUTH_AUDIENCE": "https://api.test.reearth.dev", "REEARTH_MARKETPLACE_AUTH_CLIENT_ID": "k6F1sgFikzVkkcW9Cpz7Ztvwq5cBRXlv", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
        Object.freeze(atomState);
        if (!hasInitialValue(atom2)) {
          console.warn("Found initial value for derived atom which can cause unexpected behavior", atom2);
        }
      }
      committedAtomStateMap.set(atom2, atomState);
    }
  }
  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();
  const addSuspensePromiseToCache = (version2, atom2, suspensePromise) => {
    let cache2 = suspensePromiseCacheMap.get(atom2);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new Map();
      suspensePromiseCacheMap.set(atom2, cache2);
    }
    suspensePromise.then(() => {
      if (cache2.get(version2) === suspensePromise) {
        cache2.delete(version2);
        if (!cache2.size) {
          suspensePromiseCacheMap.delete(atom2);
        }
      }
    });
    cache2.set(version2, suspensePromise);
  };
  const cancelAllSuspensePromiseInCache = (atom2) => {
    const versionSet = /* @__PURE__ */ new Set();
    const cache2 = suspensePromiseCacheMap.get(atom2);
    if (cache2) {
      suspensePromiseCacheMap.delete(atom2);
      cache2.forEach((suspensePromise, version2) => {
        cancelSuspensePromise(suspensePromise);
        versionSet.add(version2);
      });
    }
    return versionSet;
  };
  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();
  const getVersionedAtomStateMap = (version2) => {
    let versionedAtomStateMap = versionedAtomStateMapMap.get(version2);
    if (!versionedAtomStateMap) {
      versionedAtomStateMap = /* @__PURE__ */ new Map();
      versionedAtomStateMapMap.set(version2, versionedAtomStateMap);
    }
    return versionedAtomStateMap;
  };
  const getAtomState = (version2, atom2) => {
    if (version2) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version2);
      let atomState = versionedAtomStateMap.get(atom2);
      if (!atomState) {
        atomState = getAtomState(version2.p, atom2);
        if (atomState) {
          if ("p" in atomState) {
            atomState.p.then(() => versionedAtomStateMap.delete(atom2));
          }
          versionedAtomStateMap.set(atom2, atomState);
        }
      }
      return atomState;
    }
    return committedAtomStateMap.get(atom2);
  };
  const setAtomState = (version2, atom2, atomState) => {
    if (({ "REEARTH_MARKETPLACE_REEARTH_API": "https://api.test.reearth.dev/api", "REEARTH_MARKETPLACE_API": "https://api.marketplace.test.reearth.dev/api", "REEARTH_MARKETPLACE_AUTH_DOMAIN": "reearth-oss-test.eu.auth0.com", "REEARTH_MARKETPLACE_AUTH_AUDIENCE": "https://api.test.reearth.dev", "REEARTH_MARKETPLACE_AUTH_CLIENT_ID": "k6F1sgFikzVkkcW9Cpz7Ztvwq5cBRXlv", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
      Object.freeze(atomState);
    }
    if (version2) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version2);
      versionedAtomStateMap.set(atom2, atomState);
    } else {
      const prevAtomState = committedAtomStateMap.get(atom2);
      committedAtomStateMap.set(atom2, atomState);
      if (!pendingMap.has(atom2)) {
        pendingMap.set(atom2, prevAtomState);
      }
    }
  };
  const createReadDependencies = (version2, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {
    if (!dependencies) {
      return prevReadDependencies;
    }
    const readDependencies = /* @__PURE__ */ new Map();
    let changed = false;
    dependencies.forEach((atom2) => {
      var _a2;
      const revision = ((_a2 = getAtomState(version2, atom2)) == null ? void 0 : _a2.r) || 0;
      readDependencies.set(atom2, revision);
      if (prevReadDependencies.get(atom2) !== revision) {
        changed = true;
      }
    });
    if (prevReadDependencies.size === readDependencies.size && !changed) {
      return prevReadDependencies;
    }
    return readDependencies;
  };
  const setAtomValue = (version2, atom2, value, dependencies, suspensePromise) => {
    const atomState = getAtomState(version2, atom2);
    if (atomState) {
      if (suspensePromise && (!("p" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {
        return atomState;
      }
      if ("p" in atomState) {
        cancelSuspensePromise(atomState.p);
      }
    }
    const nextAtomState = {
      v: value,
      r: (atomState == null ? void 0 : atomState.r) || 0,
      d: createReadDependencies(version2, atomState == null ? void 0 : atomState.d, dependencies)
    };
    let changed = false;
    if (!atomState || !("v" in atomState) || !Object.is(atomState.v, value)) {
      changed = true;
      ++nextAtomState.r;
      if (nextAtomState.d.has(atom2)) {
        nextAtomState.d = new Map(nextAtomState.d).set(atom2, nextAtomState.r);
      }
    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {
      changed = true;
      Promise.resolve().then(() => {
        flushPending(version2);
      });
    }
    if (atomState && !changed) {
      return atomState;
    }
    setAtomState(version2, atom2, nextAtomState);
    return nextAtomState;
  };
  const setAtomReadError = (version2, atom2, error3, dependencies, suspensePromise) => {
    const atomState = getAtomState(version2, atom2);
    if (atomState) {
      if (suspensePromise && (!("p" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {
        return atomState;
      }
      if ("p" in atomState) {
        cancelSuspensePromise(atomState.p);
      }
    }
    const nextAtomState = {
      e: error3,
      r: (atomState == null ? void 0 : atomState.r) || 0,
      d: createReadDependencies(version2, atomState == null ? void 0 : atomState.d, dependencies)
    };
    setAtomState(version2, atom2, nextAtomState);
    return nextAtomState;
  };
  const setAtomSuspensePromise = (version2, atom2, suspensePromise, dependencies) => {
    const atomState = getAtomState(version2, atom2);
    if (atomState && "p" in atomState) {
      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {
        return atomState;
      }
      cancelSuspensePromise(atomState.p);
    }
    addSuspensePromiseToCache(version2, atom2, suspensePromise);
    const nextAtomState = {
      p: suspensePromise,
      r: (atomState == null ? void 0 : atomState.r) || 0,
      d: createReadDependencies(version2, atomState == null ? void 0 : atomState.d, dependencies)
    };
    setAtomState(version2, atom2, nextAtomState);
    return nextAtomState;
  };
  const setAtomPromiseOrValue = (version2, atom2, promiseOrValue, dependencies) => {
    if (promiseOrValue instanceof Promise) {
      const suspensePromise = createSuspensePromise(promiseOrValue.then((value) => {
        setAtomValue(version2, atom2, value, dependencies, suspensePromise);
      }).catch((e2) => {
        if (e2 instanceof Promise) {
          if (isSuspensePromise(e2)) {
            return e2.then(() => {
              readAtomState(version2, atom2, true);
            });
          }
          return e2;
        }
        setAtomReadError(version2, atom2, e2, dependencies, suspensePromise);
      }));
      return setAtomSuspensePromise(version2, atom2, suspensePromise, dependencies);
    }
    return setAtomValue(version2, atom2, promiseOrValue, dependencies);
  };
  const setAtomInvalidated = (version2, atom2) => {
    const atomState = getAtomState(version2, atom2);
    if (atomState) {
      const nextAtomState = __spreadProps(__spreadValues({}, atomState), {
        i: atomState.r
      });
      setAtomState(version2, atom2, nextAtomState);
    } else if (({ "REEARTH_MARKETPLACE_REEARTH_API": "https://api.test.reearth.dev/api", "REEARTH_MARKETPLACE_API": "https://api.marketplace.test.reearth.dev/api", "REEARTH_MARKETPLACE_AUTH_DOMAIN": "reearth-oss-test.eu.auth0.com", "REEARTH_MARKETPLACE_AUTH_AUDIENCE": "https://api.test.reearth.dev", "REEARTH_MARKETPLACE_AUTH_CLIENT_ID": "k6F1sgFikzVkkcW9Cpz7Ztvwq5cBRXlv", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
      console.warn("[Bug] could not invalidate non existing atom", atom2);
    }
  };
  const readAtomState = (version2, atom2, force) => {
    if (!force) {
      const atomState = getAtomState(version2, atom2);
      if (atomState) {
        if (atomState.r !== atomState.i && "p" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {
          return atomState;
        }
        atomState.d.forEach((_24, a) => {
          if (a !== atom2) {
            if (!mountedMap.has(a)) {
              readAtomState(version2, a);
            } else {
              const aState = getAtomState(version2, a);
              if (aState && aState.r === aState.i) {
                readAtomState(version2, a);
              }
            }
          }
        });
        if (Array.from(atomState.d).every(([a, r2]) => {
          const aState = getAtomState(version2, a);
          return aState && "v" in aState && aState.r === r2;
        })) {
          return atomState;
        }
      }
    }
    const dependencies = /* @__PURE__ */ new Set();
    try {
      const promiseOrValue = atom2.read((a) => {
        dependencies.add(a);
        const aState = a === atom2 ? getAtomState(version2, a) : readAtomState(version2, a);
        if (aState) {
          if ("e" in aState) {
            throw aState.e;
          }
          if ("p" in aState) {
            throw aState.p;
          }
          return aState.v;
        }
        if (hasInitialValue(a)) {
          return a.init;
        }
        throw new Error("no atom init");
      });
      return setAtomPromiseOrValue(version2, atom2, promiseOrValue, dependencies);
    } catch (errorOrPromise) {
      if (errorOrPromise instanceof Promise) {
        const suspensePromise = createSuspensePromise(errorOrPromise);
        return setAtomSuspensePromise(version2, atom2, suspensePromise, dependencies);
      }
      return setAtomReadError(version2, atom2, errorOrPromise, dependencies);
    }
  };
  const readAtom = (readingAtom, version2) => {
    const atomState = readAtomState(version2, readingAtom);
    return atomState;
  };
  const addAtom = (addingAtom) => {
    let mounted = mountedMap.get(addingAtom);
    if (!mounted) {
      mounted = mountAtom(addingAtom);
    }
    return mounted;
  };
  const canUnmountAtom = (atom2, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom2));
  const delAtom = (deletingAtom) => {
    const mounted = mountedMap.get(deletingAtom);
    if (mounted && canUnmountAtom(deletingAtom, mounted)) {
      unmountAtom(deletingAtom);
    }
  };
  const invalidateDependents = (version2, atom2) => {
    const mounted = mountedMap.get(atom2);
    mounted == null ? void 0 : mounted.t.forEach((dependent) => {
      if (dependent !== atom2) {
        setAtomInvalidated(version2, dependent);
        invalidateDependents(version2, dependent);
      }
    });
  };
  const writeAtomState = (version2, atom2, update) => {
    let isSync = true;
    const writeGetter = (a, options) => {
      const aState = readAtomState(version2, a);
      if ("e" in aState) {
        throw aState.e;
      }
      if ("p" in aState) {
        if (options == null ? void 0 : options.unstable_promise) {
          return aState.p.then(() => writeGetter(a, options));
        }
        if (({ "REEARTH_MARKETPLACE_REEARTH_API": "https://api.test.reearth.dev/api", "REEARTH_MARKETPLACE_API": "https://api.marketplace.test.reearth.dev/api", "REEARTH_MARKETPLACE_AUTH_DOMAIN": "reearth-oss-test.eu.auth0.com", "REEARTH_MARKETPLACE_AUTH_AUDIENCE": "https://api.test.reearth.dev", "REEARTH_MARKETPLACE_AUTH_CLIENT_ID": "k6F1sgFikzVkkcW9Cpz7Ztvwq5cBRXlv", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
          console.info("Reading pending atom state in write operation. We throw a promise for now.", a);
        }
        throw aState.p;
      }
      if ("v" in aState) {
        return aState.v;
      }
      if (({ "REEARTH_MARKETPLACE_REEARTH_API": "https://api.test.reearth.dev/api", "REEARTH_MARKETPLACE_API": "https://api.marketplace.test.reearth.dev/api", "REEARTH_MARKETPLACE_AUTH_DOMAIN": "reearth-oss-test.eu.auth0.com", "REEARTH_MARKETPLACE_AUTH_AUDIENCE": "https://api.test.reearth.dev", "REEARTH_MARKETPLACE_AUTH_CLIENT_ID": "k6F1sgFikzVkkcW9Cpz7Ztvwq5cBRXlv", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
        console.warn("[Bug] no value found while reading atom in write operation. This is probably a bug.", a);
      }
      throw new Error("no value found");
    };
    const setter = (a, v2) => {
      let promiseOrVoid2;
      if (a === atom2) {
        if (!hasInitialValue(a)) {
          throw new Error("atom not writable");
        }
        const versionSet = cancelAllSuspensePromiseInCache(a);
        versionSet.forEach((cancelledVersion) => {
          if (cancelledVersion !== version2) {
            setAtomPromiseOrValue(cancelledVersion, a, v2);
          }
        });
        const prevAtomState = getAtomState(version2, a);
        const nextAtomState = setAtomPromiseOrValue(version2, a, v2);
        if (prevAtomState !== nextAtomState) {
          invalidateDependents(version2, a);
        }
      } else {
        promiseOrVoid2 = writeAtomState(version2, a, v2);
      }
      if (!isSync) {
        flushPending(version2);
      }
      return promiseOrVoid2;
    };
    const promiseOrVoid = atom2.write(writeGetter, setter, update);
    isSync = false;
    version2 = void 0;
    return promiseOrVoid;
  };
  const writeAtom = (writingAtom, update, version2) => {
    const promiseOrVoid = writeAtomState(version2, writingAtom, update);
    flushPending(version2);
    return promiseOrVoid;
  };
  const isActuallyWritableAtom = (atom2) => !!atom2.write;
  const mountAtom = (atom2, initialDependent) => {
    const mounted = {
      t: new Set(initialDependent && [initialDependent]),
      l: /* @__PURE__ */ new Set()
    };
    mountedMap.set(atom2, mounted);
    if (({ "REEARTH_MARKETPLACE_REEARTH_API": "https://api.test.reearth.dev/api", "REEARTH_MARKETPLACE_API": "https://api.marketplace.test.reearth.dev/api", "REEARTH_MARKETPLACE_AUTH_DOMAIN": "reearth-oss-test.eu.auth0.com", "REEARTH_MARKETPLACE_AUTH_AUDIENCE": "https://api.test.reearth.dev", "REEARTH_MARKETPLACE_AUTH_CLIENT_ID": "k6F1sgFikzVkkcW9Cpz7Ztvwq5cBRXlv", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
      mountedAtoms.add(atom2);
    }
    const atomState = readAtomState(void 0, atom2);
    atomState.d.forEach((_24, a) => {
      const aMounted = mountedMap.get(a);
      if (aMounted) {
        aMounted.t.add(atom2);
      } else {
        if (a !== atom2) {
          mountAtom(a, atom2);
        }
      }
    });
    if (isActuallyWritableAtom(atom2) && atom2.onMount) {
      const setAtom = (update) => writeAtom(atom2, update);
      const onUnmount = atom2.onMount(setAtom);
      if (onUnmount) {
        mounted.u = onUnmount;
      }
    }
    return mounted;
  };
  const unmountAtom = (atom2) => {
    var _a2;
    const onUnmount = (_a2 = mountedMap.get(atom2)) == null ? void 0 : _a2.u;
    if (onUnmount) {
      onUnmount();
    }
    mountedMap.delete(atom2);
    if (({ "REEARTH_MARKETPLACE_REEARTH_API": "https://api.test.reearth.dev/api", "REEARTH_MARKETPLACE_API": "https://api.marketplace.test.reearth.dev/api", "REEARTH_MARKETPLACE_AUTH_DOMAIN": "reearth-oss-test.eu.auth0.com", "REEARTH_MARKETPLACE_AUTH_AUDIENCE": "https://api.test.reearth.dev", "REEARTH_MARKETPLACE_AUTH_CLIENT_ID": "k6F1sgFikzVkkcW9Cpz7Ztvwq5cBRXlv", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
      mountedAtoms.delete(atom2);
    }
    const atomState = getAtomState(void 0, atom2);
    if (atomState) {
      atomState.d.forEach((_24, a) => {
        if (a !== atom2) {
          const mounted = mountedMap.get(a);
          if (mounted) {
            mounted.t.delete(atom2);
            if (canUnmountAtom(a, mounted)) {
              unmountAtom(a);
            }
          }
        }
      });
    } else if (({ "REEARTH_MARKETPLACE_REEARTH_API": "https://api.test.reearth.dev/api", "REEARTH_MARKETPLACE_API": "https://api.marketplace.test.reearth.dev/api", "REEARTH_MARKETPLACE_AUTH_DOMAIN": "reearth-oss-test.eu.auth0.com", "REEARTH_MARKETPLACE_AUTH_AUDIENCE": "https://api.test.reearth.dev", "REEARTH_MARKETPLACE_AUTH_CLIENT_ID": "k6F1sgFikzVkkcW9Cpz7Ztvwq5cBRXlv", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
      console.warn("[Bug] could not find atom state to unmount", atom2);
    }
  };
  const mountDependencies = (atom2, atomState, prevReadDependencies) => {
    const dependencies = new Set(atomState.d.keys());
    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_24, a) => {
      if (dependencies.has(a)) {
        dependencies.delete(a);
        return;
      }
      const mounted = mountedMap.get(a);
      if (mounted) {
        mounted.t.delete(atom2);
        if (canUnmountAtom(a, mounted)) {
          unmountAtom(a);
        }
      }
    });
    dependencies.forEach((a) => {
      const mounted = mountedMap.get(a);
      if (mounted) {
        mounted.t.add(atom2);
      } else if (mountedMap.has(atom2)) {
        mountAtom(a, atom2);
      }
    });
  };
  const flushPending = (version2) => {
    if (version2) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version2);
      versionedAtomStateMap.forEach((atomState, atom2) => {
        const committedAtomState = committedAtomStateMap.get(atom2);
        if (atomState !== committedAtomState) {
          const mounted = mountedMap.get(atom2);
          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version2));
        }
      });
      return;
    }
    while (pendingMap.size) {
      const pending = Array.from(pendingMap);
      pendingMap.clear();
      pending.forEach(([atom2, prevAtomState]) => {
        const atomState = getAtomState(void 0, atom2);
        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
          mountDependencies(atom2, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
        }
        if (prevAtomState && "i" in prevAtomState && atomState && !("i" in atomState)) {
          return;
        }
        const mounted = mountedMap.get(atom2);
        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());
      });
    }
    if (({ "REEARTH_MARKETPLACE_REEARTH_API": "https://api.test.reearth.dev/api", "REEARTH_MARKETPLACE_API": "https://api.marketplace.test.reearth.dev/api", "REEARTH_MARKETPLACE_AUTH_DOMAIN": "reearth-oss-test.eu.auth0.com", "REEARTH_MARKETPLACE_AUTH_AUDIENCE": "https://api.test.reearth.dev", "REEARTH_MARKETPLACE_AUTH_CLIENT_ID": "k6F1sgFikzVkkcW9Cpz7Ztvwq5cBRXlv", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
      stateListeners.forEach((l2) => l2());
    }
  };
  const commitVersionedAtomStateMap = (version2) => {
    const versionedAtomStateMap = getVersionedAtomStateMap(version2);
    versionedAtomStateMap.forEach((atomState, atom2) => {
      const prevAtomState = committedAtomStateMap.get(atom2);
      if (atomState.r > ((prevAtomState == null ? void 0 : prevAtomState.r) || 0) || "v" in atomState && atomState.r === (prevAtomState == null ? void 0 : prevAtomState.r) && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
        committedAtomStateMap.set(atom2, atomState);
        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
          mountDependencies(atom2, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
        }
      }
    });
  };
  const commitAtom = (_atom, version2) => {
    if (version2) {
      commitVersionedAtomStateMap(version2);
    }
    flushPending(void 0);
  };
  const subscribeAtom = (atom2, callback) => {
    const mounted = addAtom(atom2);
    const listeners = mounted.l;
    listeners.add(callback);
    return () => {
      listeners.delete(callback);
      delAtom(atom2);
    };
  };
  const restoreAtoms = (values, version2) => {
    for (const [atom2, value] of values) {
      if (hasInitialValue(atom2)) {
        setAtomPromiseOrValue(version2, atom2, value);
        invalidateDependents(version2, atom2);
      }
    }
    flushPending(version2);
  };
  if (({ "REEARTH_MARKETPLACE_REEARTH_API": "https://api.test.reearth.dev/api", "REEARTH_MARKETPLACE_API": "https://api.marketplace.test.reearth.dev/api", "REEARTH_MARKETPLACE_AUTH_DOMAIN": "reearth-oss-test.eu.auth0.com", "REEARTH_MARKETPLACE_AUTH_AUDIENCE": "https://api.test.reearth.dev", "REEARTH_MARKETPLACE_AUTH_CLIENT_ID": "k6F1sgFikzVkkcW9Cpz7Ztvwq5cBRXlv", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
    return {
      [READ_ATOM]: readAtom,
      [WRITE_ATOM]: writeAtom,
      [COMMIT_ATOM]: commitAtom,
      [SUBSCRIBE_ATOM]: subscribeAtom,
      [RESTORE_ATOMS]: restoreAtoms,
      [DEV_SUBSCRIBE_STATE]: (l2) => {
        stateListeners.add(l2);
        return () => {
          stateListeners.delete(l2);
        };
      },
      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),
      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),
      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)
    };
  }
  return {
    [READ_ATOM]: readAtom,
    [WRITE_ATOM]: writeAtom,
    [COMMIT_ATOM]: commitAtom,
    [SUBSCRIBE_ATOM]: subscribeAtom,
    [RESTORE_ATOMS]: restoreAtoms
  };
};
const createScopeContainer = (initialValues, unstable_createStore) => {
  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);
  return { s: store };
};
const ScopeContextMap = /* @__PURE__ */ new Map();
const getScopeContext = (scope) => {
  if (!ScopeContextMap.has(scope)) {
    ScopeContextMap.set(scope, React.createContext(createScopeContainer()));
  }
  return ScopeContextMap.get(scope);
};
let keyCount = 0;
function atom(read2, write) {
  const key = `atom${++keyCount}`;
  const config = {
    toString: () => key
  };
  if (typeof read2 === "function") {
    config.read = read2;
  } else {
    config.init = read2;
    config.read = (get2) => get2(config);
    config.write = (get2, set2, update) => set2(config, typeof update === "function" ? update(get2(config)) : update);
  }
  if (write) {
    config.write = write;
  }
  return config;
}
function useAtomValue(atom2, scope) {
  const ScopeContext = getScopeContext(scope);
  const { s: store } = React.useContext(ScopeContext);
  const getAtomValue = React.useCallback((version22) => {
    const atomState = store[READ_ATOM](atom2, version22);
    if ("e" in atomState) {
      throw atomState.e;
    }
    if ("p" in atomState) {
      throw atomState.p;
    }
    if ("v" in atomState) {
      return atomState.v;
    }
    throw new Error("no atom value");
  }, [store, atom2]);
  const [[version2, value, atomFromUseReducer], rerenderIfChanged] = React.useReducer(React.useCallback((prev2, nextVersion) => {
    const nextValue = getAtomValue(nextVersion);
    if (Object.is(prev2[1], nextValue) && prev2[2] === atom2) {
      return prev2;
    }
    return [nextVersion, nextValue, atom2];
  }, [getAtomValue, atom2]), void 0, () => {
    const initialVersion = void 0;
    const initialValue = getAtomValue(initialVersion);
    return [initialVersion, initialValue, atom2];
  });
  if (atomFromUseReducer !== atom2) {
    rerenderIfChanged(void 0);
  }
  React.useEffect(() => {
    const unsubscribe = store[SUBSCRIBE_ATOM](atom2, rerenderIfChanged);
    rerenderIfChanged(void 0);
    return unsubscribe;
  }, [store, atom2]);
  React.useEffect(() => {
    store[COMMIT_ATOM](atom2, version2);
  });
  React.useDebugValue(value);
  return value;
}
function useSetAtom(atom2, scope) {
  const ScopeContext = getScopeContext(scope);
  const { s: store, w: versionedWrite } = React.useContext(ScopeContext);
  const setAtom = React.useCallback((update) => {
    if (({ "REEARTH_MARKETPLACE_REEARTH_API": "https://api.test.reearth.dev/api", "REEARTH_MARKETPLACE_API": "https://api.marketplace.test.reearth.dev/api", "REEARTH_MARKETPLACE_AUTH_DOMAIN": "reearth-oss-test.eu.auth0.com", "REEARTH_MARKETPLACE_AUTH_AUDIENCE": "https://api.test.reearth.dev", "REEARTH_MARKETPLACE_AUTH_CLIENT_ID": "k6F1sgFikzVkkcW9Cpz7Ztvwq5cBRXlv", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production" && !("write" in atom2)) {
      throw new Error("not writable atom");
    }
    const write = (version2) => store[WRITE_ATOM](atom2, update, version2);
    return versionedWrite ? versionedWrite(write) : write();
  }, [store, versionedWrite, atom2]);
  return setAtom;
}
function useAtom(atom2, scope) {
  if ("scope" in atom2) {
    console.warn("atom.scope is deprecated. Please do useAtom(atom, scope) instead.");
    scope = atom2.scope;
  }
  return [
    useAtomValue(atom2, scope),
    useSetAtom(atom2, scope)
  ];
}
const error = atom(void 0);
const useError = () => useAtom(error);
const currentTheme = atom("dark");
const useCurrentTheme = () => useAtom(currentTheme);
const currentLang = atom("und");
const useCurrentLang = () => useAtom(currentLang);
const Provider$4 = ({ children, accessToken: accessToken2 }) => {
  const cofig = getConfig();
  const endpoint = (cofig == null ? void 0 : cofig.marketplaceApi) ? `${cofig.marketplaceApi}/graphql` : "/api/graphql";
  const [, setError] = useError();
  const { getAccessToken } = useAuth();
  const authLink = setContext(async (_24, { headers }) => {
    let accessToken;
    try {
      accessToken = accessToken2 || await getAccessToken();
    } catch {
    }
    return {
      headers: {
        ...headers,
        ...accessToken ? { Authorization: `Bearer ${accessToken}` } : {}
      }
    };
  });
  const errorLink = onError(({ graphQLErrors, networkError }) => {
    var _a2;
    if (!networkError && !graphQLErrors)
      return;
    const error3 = (_a2 = networkError == null ? void 0 : networkError.message) != null ? _a2 : graphQLErrors == null ? void 0 : graphQLErrors.map((e2) => e2.message).join(", ");
    if (error3) {
      setError(error3);
    }
  });
  const uploadLink = createUploadLink$1({
    uri: endpoint
  });
  const cache2 = new InMemoryCache({
    typePolicies: {
      Query: {
        fields: {
          plugins: {
            keyArgs: [
              "input",
              ["keyword", "liked", "tags", "types", "publisher", "sort", "first", "offset"]
            ]
          }
        }
      },
      Me: {
        fields: {
          plugins: {
            keyArgs: ["first", "offset"]
          }
        }
      }
    }
  });
  const client = new ApolloClient({
    uri: endpoint,
    link: ApolloLink$1.from([errorLink, authLink, uploadLink]),
    cache: cache2,
    connectToDevTools: false
  });
  return /* @__PURE__ */ React.createElement(ApolloProvider, {
    client
  }, children);
};
function ownKeys$a(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$a(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$3(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends$4() {
  _extends$4 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf$4(subClass, superClass);
}
function _getPrototypeOf$4(o) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$4(o);
}
function _setPrototypeOf$4(o, p2) {
  _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$4(o, p2);
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties$2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn$3(self2, call2) {
  if (call2 && (typeof call2 === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$3(self2);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _slicedToArray$2(arr2, i) {
  return _arrayWithHoles$2(arr2) || _iterableToArrayLimit$2(arr2, i) || _unsupportedIterableToArray$2(arr2, i) || _nonIterableRest$2();
}
function _toConsumableArray$1(arr2) {
  return _arrayWithoutHoles$1(arr2) || _iterableToArray$1(arr2) || _unsupportedIterableToArray$2(arr2) || _nonIterableSpread$1();
}
function _arrayWithoutHoles$1(arr2) {
  if (Array.isArray(arr2))
    return _arrayLikeToArray$2(arr2);
}
function _arrayWithHoles$2(arr2) {
  if (Array.isArray(arr2))
    return arr2;
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterableToArrayLimit$2(arr2, i) {
  var _i2 = arr2 == null ? null : typeof Symbol !== "undefined" && arr2[Symbol.iterator] || arr2["@@iterator"];
  if (_i2 == null)
    return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i2 = _i2.call(arr2); !(_n2 = (_s = _i2.next()).done); _n2 = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i2["return"] != null)
        _i2["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr2, len) {
  if (len == null || len > arr2.length)
    len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++)
    arr22[i] = arr2[i];
  return arr22;
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var AccordionStore = /* @__PURE__ */ _createClass$3(function AccordionStore2(_ref2) {
  var _this = this;
  var _ref$expanded = _ref2.expanded, _expanded = _ref$expanded === void 0 ? [] : _ref$expanded, _ref$allowMultipleExp = _ref2.allowMultipleExpanded, allowMultipleExpanded = _ref$allowMultipleExp === void 0 ? false : _ref$allowMultipleExp, _ref$allowZeroExpande = _ref2.allowZeroExpanded, allowZeroExpanded = _ref$allowZeroExpande === void 0 ? false : _ref$allowZeroExpande;
  _classCallCheck$3(this, AccordionStore2);
  _defineProperty$4(this, "expanded", void 0);
  _defineProperty$4(this, "allowMultipleExpanded", void 0);
  _defineProperty$4(this, "allowZeroExpanded", void 0);
  _defineProperty$4(this, "toggleExpanded", function(uuid2) {
    if (_this.isItemDisabled(uuid2)) {
      return _this;
    }
    var isExpanded = _this.isItemExpanded(uuid2);
    if (!isExpanded) {
      return _this.augment({
        expanded: _this.allowMultipleExpanded ? [].concat(_toConsumableArray$1(_this.expanded), [uuid2]) : [uuid2]
      });
    } else {
      return _this.augment({
        expanded: _this.expanded.filter(function(expandedUuid) {
          return expandedUuid !== uuid2;
        })
      });
    }
  });
  _defineProperty$4(this, "isItemDisabled", function(uuid2) {
    var isExpanded = _this.isItemExpanded(uuid2);
    var isOnlyOneExpanded = _this.expanded.length === 1;
    return Boolean(isExpanded && !_this.allowZeroExpanded && isOnlyOneExpanded);
  });
  _defineProperty$4(this, "isItemExpanded", function(uuid2) {
    return _this.expanded.indexOf(uuid2) !== -1;
  });
  _defineProperty$4(this, "getPanelAttributes", function(uuid2, dangerouslySetExpanded) {
    var expanded = dangerouslySetExpanded !== null && dangerouslySetExpanded !== void 0 ? dangerouslySetExpanded : _this.isItemExpanded(uuid2);
    return {
      role: _this.allowMultipleExpanded ? void 0 : "region",
      "aria-hidden": _this.allowMultipleExpanded ? !expanded : void 0,
      "aria-labelledby": _this.getButtonId(uuid2),
      id: _this.getPanelId(uuid2),
      hidden: expanded ? void 0 : true
    };
  });
  _defineProperty$4(this, "getHeadingAttributes", function() {
    return {
      role: "heading"
    };
  });
  _defineProperty$4(this, "getButtonAttributes", function(uuid2, dangerouslySetExpanded) {
    var expanded = dangerouslySetExpanded !== null && dangerouslySetExpanded !== void 0 ? dangerouslySetExpanded : _this.isItemExpanded(uuid2);
    var disabled = _this.isItemDisabled(uuid2);
    return {
      id: _this.getButtonId(uuid2),
      "aria-disabled": disabled,
      "aria-expanded": expanded,
      "aria-controls": _this.getPanelId(uuid2),
      role: "button",
      tabIndex: 0
    };
  });
  _defineProperty$4(this, "getPanelId", function(id) {
    return "accordion__panel-".concat(id);
  });
  _defineProperty$4(this, "getButtonId", function(id) {
    return "accordion__heading-".concat(id);
  });
  _defineProperty$4(this, "augment", function(args) {
    return new AccordionStore2(_objectSpread2$e({
      expanded: _this.expanded,
      allowMultipleExpanded: _this.allowMultipleExpanded,
      allowZeroExpanded: _this.allowZeroExpanded
    }, args));
  });
  this.expanded = _expanded;
  this.allowMultipleExpanded = allowMultipleExpanded;
  this.allowZeroExpanded = allowZeroExpanded;
});
var Context$4 = /* @__PURE__ */ React.createContext(null);
var Provider$3 = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits$3(Provider3, _React$PureComponent);
  var _super = _createSuper$4(Provider3);
  function Provider3() {
    var _this;
    _classCallCheck$3(this, Provider3);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$4(_assertThisInitialized$3(_this), "state", new AccordionStore({
      expanded: _this.props.preExpanded,
      allowMultipleExpanded: _this.props.allowMultipleExpanded,
      allowZeroExpanded: _this.props.allowZeroExpanded
    }));
    _defineProperty$4(_assertThisInitialized$3(_this), "toggleExpanded", function(key) {
      _this.setState(function(state) {
        return state.toggleExpanded(key);
      }, function() {
        if (_this.props.onChange) {
          _this.props.onChange(_this.state.expanded);
        }
      });
    });
    _defineProperty$4(_assertThisInitialized$3(_this), "isItemDisabled", function(key) {
      return _this.state.isItemDisabled(key);
    });
    _defineProperty$4(_assertThisInitialized$3(_this), "isItemExpanded", function(key) {
      return _this.state.isItemExpanded(key);
    });
    _defineProperty$4(_assertThisInitialized$3(_this), "getPanelAttributes", function(key, dangerouslySetExpanded) {
      return _this.state.getPanelAttributes(key, dangerouslySetExpanded);
    });
    _defineProperty$4(_assertThisInitialized$3(_this), "getHeadingAttributes", function() {
      return _this.state.getHeadingAttributes();
    });
    _defineProperty$4(_assertThisInitialized$3(_this), "getButtonAttributes", function(key, dangerouslySetExpanded) {
      return _this.state.getButtonAttributes(key, dangerouslySetExpanded);
    });
    return _this;
  }
  _createClass$3(Provider3, [{
    key: "render",
    value: function render2() {
      var _this$state = this.state, allowZeroExpanded = _this$state.allowZeroExpanded, allowMultipleExpanded = _this$state.allowMultipleExpanded;
      return /* @__PURE__ */ React.createElement(Context$4.Provider, {
        value: {
          allowMultipleExpanded,
          allowZeroExpanded,
          toggleExpanded: this.toggleExpanded,
          isItemDisabled: this.isItemDisabled,
          isItemExpanded: this.isItemExpanded,
          getPanelAttributes: this.getPanelAttributes,
          getHeadingAttributes: this.getHeadingAttributes,
          getButtonAttributes: this.getButtonAttributes
        }
      }, this.props.children || null);
    }
  }]);
  return Provider3;
}(React.PureComponent);
_defineProperty$4(Provider$3, "defaultProps", {
  allowMultipleExpanded: false,
  allowZeroExpanded: false
});
var Consumer = /* @__PURE__ */ function(_React$PureComponent2) {
  _inherits$3(Consumer3, _React$PureComponent2);
  var _super2 = _createSuper$4(Consumer3);
  function Consumer3() {
    var _this2;
    _classCallCheck$3(this, Consumer3);
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _defineProperty$4(_assertThisInitialized$3(_this2), "renderChildren", function(container) {
      return container ? _this2.props.children(container) : null;
    });
    return _this2;
  }
  _createClass$3(Consumer3, [{
    key: "render",
    value: function render2() {
      return /* @__PURE__ */ React.createElement(Context$4.Consumer, null, this.renderChildren);
    }
  }]);
  return Consumer3;
}(React.PureComponent);
var _excluded$T = ["className", "allowMultipleExpanded", "allowZeroExpanded", "onChange", "preExpanded"];
var Accordion$1 = function Accordion(_ref2) {
  var _ref$className = _ref2.className, className = _ref$className === void 0 ? "accordion" : _ref$className, allowMultipleExpanded = _ref2.allowMultipleExpanded, allowZeroExpanded = _ref2.allowZeroExpanded, onChange = _ref2.onChange, preExpanded = _ref2.preExpanded, rest = _objectWithoutProperties$2(_ref2, _excluded$T);
  return /* @__PURE__ */ React.createElement(Provider$3, {
    preExpanded,
    allowMultipleExpanded,
    allowZeroExpanded,
    onChange
  }, /* @__PURE__ */ React.createElement("div", _extends$4({
    "data-accordion-component": "Accordion",
    className
  }, rest)));
};
var DisplayName;
(function(DisplayName2) {
  DisplayName2["Accordion"] = "Accordion";
  DisplayName2["AccordionItem"] = "AccordionItem";
  DisplayName2["AccordionItemButton"] = "AccordionItemButton";
  DisplayName2["AccordionItemHeading"] = "AccordionItemHeading";
  DisplayName2["AccordionItemPanel"] = "AccordionItemPanel";
})(DisplayName || (DisplayName = {}));
var DisplayName$1 = DisplayName;
var counter = 0;
function useGlobalCounterId() {
  var current = counter;
  counter = counter + 1;
  return "raa-".concat(current);
}
var useNextId = React.useId || useGlobalCounterId;
var idRegex = /[\u0009\u000a\u000c\u000d\u0020]/g;
function assertValidHtmlId(htmlId) {
  if (htmlId === "" || idRegex.test(htmlId)) {
    console.error('uuid must be a valid HTML5 id but was given "'.concat(htmlId, '", ASCII whitespaces are forbidden'));
    return false;
  }
  return true;
}
var Context$1$1 = /* @__PURE__ */ React.createContext(null);
var Provider$1$1 = function Provider(_ref2) {
  var children = _ref2.children, uuid2 = _ref2.uuid, accordionContext = _ref2.accordionContext, dangerouslySetExpanded = _ref2.dangerouslySetExpanded;
  var toggleExpanded = function toggleExpanded2() {
    accordionContext.toggleExpanded(uuid2);
  };
  var renderChildren = function renderChildren2(accordionContext2) {
    var expanded = dangerouslySetExpanded !== null && dangerouslySetExpanded !== void 0 ? dangerouslySetExpanded : accordionContext2.isItemExpanded(uuid2);
    var disabled = accordionContext2.isItemDisabled(uuid2);
    var panelAttributes = accordionContext2.getPanelAttributes(uuid2, dangerouslySetExpanded);
    var headingAttributes = accordionContext2.getHeadingAttributes(uuid2);
    var buttonAttributes = accordionContext2.getButtonAttributes(uuid2, dangerouslySetExpanded);
    return /* @__PURE__ */ React.createElement(Context$1$1.Provider, {
      value: {
        uuid: uuid2,
        expanded,
        disabled,
        toggleExpanded,
        panelAttributes,
        headingAttributes,
        buttonAttributes
      }
    }, children);
  };
  return /* @__PURE__ */ React.createElement(Consumer, null, renderChildren);
};
var ProviderWrapper = function ProviderWrapper2(props) {
  return /* @__PURE__ */ React.createElement(Consumer, null, function(accordionContext) {
    return /* @__PURE__ */ React.createElement(Provider$1$1, _extends$4({}, props, {
      accordionContext
    }));
  });
};
var Consumer$1 = function Consumer2(_ref2) {
  var children = _ref2.children;
  var renderChildren = function renderChildren2(container) {
    return container ? children(container) : null;
  };
  return /* @__PURE__ */ React.createElement(Context$1$1.Consumer, null, renderChildren);
};
var _excluded$1$1 = ["uuid", "dangerouslySetExpanded", "className", "activeClassName"];
var AccordionItem$1 = function AccordionItem(_ref2) {
  var customUuid = _ref2.uuid, dangerouslySetExpanded = _ref2.dangerouslySetExpanded, _ref$className = _ref2.className, className = _ref$className === void 0 ? "accordion__item" : _ref$className, activeClassName = _ref2.activeClassName, rest = _objectWithoutProperties$2(_ref2, _excluded$1$1);
  var _useState = React.useState(useNextId()), _useState2 = _slicedToArray$2(_useState, 1), instanceUuid = _useState2[0];
  var uuid2 = customUuid !== null && customUuid !== void 0 ? customUuid : instanceUuid;
  var renderChildren = function renderChildren2(itemContext) {
    var expanded = itemContext.expanded;
    var cx = expanded && activeClassName ? activeClassName : className;
    return /* @__PURE__ */ React.createElement("div", _extends$4({
      "data-accordion-component": "AccordionItem",
      className: cx
    }, rest));
  };
  assertValidHtmlId(uuid2.toString());
  if (rest.id) {
    assertValidHtmlId(rest.id);
  }
  return /* @__PURE__ */ React.createElement(ProviderWrapper, {
    uuid: uuid2,
    dangerouslySetExpanded
  }, /* @__PURE__ */ React.createElement(Consumer$1, null, renderChildren));
};
AccordionItem$1.displayName = DisplayName$1.AccordionItem;
function getClosestAccordion(el) {
  return el && (el.matches('[data-accordion-component="Accordion"]') ? el : getClosestAccordion(el.parentElement));
}
function getSiblingButtons(item) {
  var parentAccordion = getClosestAccordion(item);
  return parentAccordion && Array.from(parentAccordion.querySelectorAll('[data-accordion-component="AccordionItemButton"]'));
}
function focusFirstSiblingOf(item) {
  var siblings = getSiblingButtons(item) || [];
  var first = siblings[0];
  if (first) {
    first.focus();
  }
}
function focusLastSiblingOf(item) {
  var siblings = getSiblingButtons(item) || [];
  var last = siblings[siblings.length - 1];
  if (last) {
    last.focus();
  }
}
function focusNextSiblingOf(item) {
  var siblings = getSiblingButtons(item) || [];
  var currentIndex = siblings.indexOf(item);
  if (currentIndex !== -1) {
    var next2 = siblings[currentIndex + 1];
    if (next2) {
      next2.focus();
    }
  }
}
function focusPreviousSiblingOf(item) {
  var siblings = getSiblingButtons(item) || [];
  var currentIndex = siblings.indexOf(item);
  if (currentIndex !== -1) {
    var previous2 = siblings[currentIndex - 1];
    if (previous2) {
      previous2.focus();
    }
  }
}
var keycodes = {
  END: "End",
  ENTER: "Enter",
  HOME: "Home",
  SPACE: " ",
  SPACE_DEPRECATED: "Spacebar",
  UP: "ArrowUp",
  DOWN: "ArrowDown",
  LEFT: "ArrowLeft",
  RIGHT: "ArrowRight"
};
var _excluded$2$1 = ["toggleExpanded", "className"];
var AccordionItemButton = function AccordionItemButton2(_ref2) {
  var toggleExpanded = _ref2.toggleExpanded, _ref$className = _ref2.className, className = _ref$className === void 0 ? "accordion__button" : _ref$className, rest = _objectWithoutProperties$2(_ref2, _excluded$2$1);
  var handleKeyPress = function handleKeyPress2(evt) {
    var keyCode = evt.key;
    if (keyCode === keycodes.ENTER || keyCode === keycodes.SPACE || keyCode === keycodes.SPACE_DEPRECATED) {
      evt.preventDefault();
      toggleExpanded();
    }
    if (evt.target instanceof HTMLElement) {
      switch (keyCode) {
        case keycodes.HOME: {
          evt.preventDefault();
          focusFirstSiblingOf(evt.target);
          break;
        }
        case keycodes.END: {
          evt.preventDefault();
          focusLastSiblingOf(evt.target);
          break;
        }
        case keycodes.LEFT:
        case keycodes.UP: {
          evt.preventDefault();
          focusPreviousSiblingOf(evt.target);
          break;
        }
        case keycodes.RIGHT:
        case keycodes.DOWN: {
          evt.preventDefault();
          focusNextSiblingOf(evt.target);
          break;
        }
      }
    }
  };
  if (rest.id) {
    assertValidHtmlId(rest.id);
  }
  return /* @__PURE__ */ React.createElement("div", _extends$4({
    className
  }, rest, {
    role: "button",
    tabIndex: 0,
    onClick: toggleExpanded,
    onKeyDown: handleKeyPress,
    "data-accordion-component": "AccordionItemButton"
  }));
};
var AccordionItemButtonWrapper = function AccordionItemButtonWrapper2(props) {
  return /* @__PURE__ */ React.createElement(Consumer$1, null, function(itemContext) {
    var toggleExpanded = itemContext.toggleExpanded, buttonAttributes = itemContext.buttonAttributes;
    return /* @__PURE__ */ React.createElement(AccordionItemButton, _extends$4({
      toggleExpanded
    }, props, buttonAttributes));
  });
};
var defaultProps$1 = {
  className: "accordion__heading",
  "aria-level": 3
};
var SPEC_ERROR = "AccordionItemButton may contain only one child element, which must be an instance of AccordionItemButton.\n\nFrom the WAI-ARIA spec (https://www.w3.org/TR/wai-aria-practices-1.1/#accordion):\n\n\u201CThe button element is the only element inside the heading element. That is, if there are other visually persistent elements, they are not included inside the heading element.\u201D\n\n";
var AccordionItemHeading = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits$3(AccordionItemHeading2, _React$PureComponent);
  var _super = _createSuper$4(AccordionItemHeading2);
  function AccordionItemHeading2() {
    var _this;
    _classCallCheck$3(this, AccordionItemHeading2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$4(_assertThisInitialized$3(_this), "ref", void 0);
    _defineProperty$4(_assertThisInitialized$3(_this), "setRef", function(ref2) {
      _this.ref = ref2;
    });
    return _this;
  }
  _createClass$3(AccordionItemHeading2, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      AccordionItemHeading2.VALIDATE(this.ref);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      AccordionItemHeading2.VALIDATE(this.ref);
    }
  }, {
    key: "render",
    value: function render2() {
      return /* @__PURE__ */ React.createElement("div", _extends$4({
        "data-accordion-component": "AccordionItemHeading"
      }, this.props, {
        ref: this.setRef
      }));
    }
  }], [{
    key: "VALIDATE",
    value: function VALIDATE(ref2) {
      if (ref2 === void 0) {
        throw new Error("ref is undefined");
      }
      if (!(ref2.childElementCount === 1 && ref2.firstElementChild && ref2.firstElementChild.getAttribute("data-accordion-component") === "AccordionItemButton")) {
        throw new Error(SPEC_ERROR);
      }
    }
  }]);
  return AccordionItemHeading2;
}(React.PureComponent);
_defineProperty$4(AccordionItemHeading, "defaultProps", defaultProps$1);
var AccordionItemHeadingWrapper = function AccordionItemHeadingWrapper2(props) {
  return /* @__PURE__ */ React.createElement(Consumer$1, null, function(itemContext) {
    var headingAttributes = itemContext.headingAttributes;
    if (props.id) {
      assertValidHtmlId(props.id);
    }
    return /* @__PURE__ */ React.createElement(AccordionItemHeading, _extends$4({}, props, headingAttributes));
  });
};
AccordionItemHeadingWrapper.displayName = DisplayName$1.AccordionItemHeading;
var _excluded$3$1 = ["className", "region", "id"];
var AccordionItemPanel = function AccordionItemPanel2(_ref2) {
  var _ref$className = _ref2.className, className = _ref$className === void 0 ? "accordion__panel" : _ref$className, region = _ref2.region, id = _ref2.id, rest = _objectWithoutProperties$2(_ref2, _excluded$3$1);
  var renderChildren = function renderChildren2(_ref22) {
    var panelAttributes = _ref22.panelAttributes;
    if (id) {
      assertValidHtmlId(id);
    }
    var attrs = _objectSpread2$e(_objectSpread2$e({}, panelAttributes), {}, {
      "aria-labelledby": region ? panelAttributes["aria-labelledby"] : void 0
    });
    return /* @__PURE__ */ React.createElement("div", _extends$4({
      "data-accordion-component": "AccordionItemPanel",
      className
    }, rest, attrs, {
      role: region ? "region" : void 0
    }));
  };
  return /* @__PURE__ */ React.createElement(Consumer$1, null, renderChildren);
};
var AccordionItemState = function AccordionItemState2(_ref2) {
  var children = _ref2.children;
  var renderChildren = function renderChildren2(itemContext) {
    var expanded = itemContext.expanded, disabled = itemContext.disabled;
    return /* @__PURE__ */ React.createElement(React.Fragment, null, children({
      expanded,
      disabled
    }));
  };
  return /* @__PURE__ */ React.createElement(Consumer$1, null, renderChildren);
};
var IconContext$2 = /* @__PURE__ */ React.createContext({});
var Context$3 = IconContext$2;
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var defineProperty$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _defineProperty$3
}, Symbol.toStringTag, { value: "Module" }));
function ownKeys$9(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$d(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$9(Object(source), true).forEach(function(key) {
      _defineProperty$3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _arrayWithHoles$1(arr2) {
  if (Array.isArray(arr2))
    return arr2;
}
function _iterableToArrayLimit$1(arr2, i) {
  var _i2 = arr2 == null ? null : typeof Symbol !== "undefined" && arr2[Symbol.iterator] || arr2["@@iterator"];
  if (_i2 == null)
    return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i2 = _i2.call(arr2); !(_n2 = (_s = _i2.next()).done); _n2 = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i2["return"] != null)
        _i2["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _arrayLikeToArray$1(arr2, len) {
  if (len == null || len > arr2.length)
    len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++) {
    arr22[i] = arr2[i];
  }
  return arr22;
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o, minLen);
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray$1(arr2, i) {
  return _arrayWithHoles$1(arr2) || _iterableToArrayLimit$1(arr2, i) || _unsupportedIterableToArray$1(arr2, i) || _nonIterableRest$1();
}
var slicedToArray = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _slicedToArray$1
}, Symbol.toStringTag, { value: "Module" }));
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var objectWithoutProperties = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _objectWithoutProperties$1
}, Symbol.toStringTag, { value: "Module" }));
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module2) {
  (function() {
    var hasOwn2 = {}.hasOwnProperty;
    function classNames2() {
      var classes = [];
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames2.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            classes.push(arg.toString());
            continue;
          }
          for (var key in arg) {
            if (hasOwn2.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        }
      }
      return classes.join(" ");
    }
    if (module2.exports) {
      classNames2.default = classNames2;
      module2.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classNames = classnames.exports;
function _typeof$8(obj) {
  "@babel/helpers - typeof";
  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$8(obj);
}
var _typeof$9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _typeof$8
}, Symbol.toStringTag, { value: "Module" }));
function bound01$2(n2, max) {
  if (isOnePointZero$2(n2)) {
    n2 = "100%";
  }
  var isPercent = isPercentage$2(n2);
  n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
  if (isPercent) {
    n2 = parseInt(String(n2 * max), 10) / 100;
  }
  if (Math.abs(n2 - max) < 1e-6) {
    return 1;
  }
  if (max === 360) {
    n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
  } else {
    n2 = n2 % max / parseFloat(String(max));
  }
  return n2;
}
function isOnePointZero$2(n2) {
  return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
}
function isPercentage$2(n2) {
  return typeof n2 === "string" && n2.indexOf("%") !== -1;
}
function boundAlpha$2(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function convertToPercentage$2(n2) {
  if (n2 <= 1) {
    return "".concat(Number(n2) * 100, "%");
  }
  return n2;
}
function pad2$2(c2) {
  return c2.length === 1 ? "0" + c2 : String(c2);
}
function rgbToRgb$2(r2, g2, b2) {
  return {
    r: bound01$2(r2, 255) * 255,
    g: bound01$2(g2, 255) * 255,
    b: bound01$2(b2, 255) * 255
  };
}
function hue2rgb$2(p2, q2, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p2 + (q2 - p2) * (6 * t2);
  }
  if (t2 < 1 / 2) {
    return q2;
  }
  if (t2 < 2 / 3) {
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  }
  return p2;
}
function hslToRgb$2(h2, s2, l2) {
  var r2;
  var g2;
  var b2;
  h2 = bound01$2(h2, 360);
  s2 = bound01$2(s2, 100);
  l2 = bound01$2(l2, 100);
  if (s2 === 0) {
    g2 = l2;
    b2 = l2;
    r2 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q2;
    r2 = hue2rgb$2(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb$2(p2, q2, h2);
    b2 = hue2rgb$2(p2, q2, h2 - 1 / 3);
  }
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHsv$2(r2, g2, b2) {
  r2 = bound01$2(r2, 255);
  g2 = bound01$2(g2, 255);
  b2 = bound01$2(b2, 255);
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2 = 0;
  var v2 = max;
  var d2 = max - min;
  var s2 = max === 0 ? 0 : d2 / max;
  if (max === min) {
    h2 = 0;
  } else {
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, v: v2 };
}
function hsvToRgb$2(h2, s2, v2) {
  h2 = bound01$2(h2, 360) * 6;
  s2 = bound01$2(s2, 100);
  v2 = bound01$2(v2, 100);
  var i = Math.floor(h2);
  var f2 = h2 - i;
  var p2 = v2 * (1 - s2);
  var q2 = v2 * (1 - f2 * s2);
  var t2 = v2 * (1 - (1 - f2) * s2);
  var mod = i % 6;
  var r2 = [v2, q2, p2, p2, t2, v2][mod];
  var g2 = [t2, v2, v2, q2, p2, p2][mod];
  var b2 = [p2, p2, t2, v2, v2, q2][mod];
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHex$2(r2, g2, b2, allow3Char) {
  var hex2 = [
    pad2$2(Math.round(r2).toString(16)),
    pad2$2(Math.round(g2).toString(16)),
    pad2$2(Math.round(b2).toString(16))
  ];
  if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function convertHexToDecimal$2(h2) {
  return parseIntFromHex$2(h2) / 255;
}
function parseIntFromHex$2(val) {
  return parseInt(val, 16);
}
var names$2 = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB$2(color2) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok2 = false;
  var format2 = false;
  if (typeof color2 === "string") {
    color2 = stringInputToObject$2(color2);
  }
  if (typeof color2 === "object") {
    if (isValidCSSUnit$2(color2.r) && isValidCSSUnit$2(color2.g) && isValidCSSUnit$2(color2.b)) {
      rgb = rgbToRgb$2(color2.r, color2.g, color2.b);
      ok2 = true;
      format2 = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit$2(color2.h) && isValidCSSUnit$2(color2.s) && isValidCSSUnit$2(color2.v)) {
      s2 = convertToPercentage$2(color2.s);
      v2 = convertToPercentage$2(color2.v);
      rgb = hsvToRgb$2(color2.h, s2, v2);
      ok2 = true;
      format2 = "hsv";
    } else if (isValidCSSUnit$2(color2.h) && isValidCSSUnit$2(color2.s) && isValidCSSUnit$2(color2.l)) {
      s2 = convertToPercentage$2(color2.s);
      l2 = convertToPercentage$2(color2.l);
      rgb = hslToRgb$2(color2.h, s2, l2);
      ok2 = true;
      format2 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color2, "a")) {
      a = color2.a;
    }
  }
  a = boundAlpha$2(a);
  return {
    ok: ok2,
    format: color2.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
var CSS_INTEGER$2 = "[-\\+]?\\d+%?";
var CSS_NUMBER$2 = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT$2 = "(?:".concat(CSS_NUMBER$2, ")|(?:").concat(CSS_INTEGER$2, ")");
var PERMISSIVE_MATCH3$2 = "[\\s|\\(]+(".concat(CSS_UNIT$2, ")[,|\\s]+(").concat(CSS_UNIT$2, ")[,|\\s]+(").concat(CSS_UNIT$2, ")\\s*\\)?");
var PERMISSIVE_MATCH4$2 = "[\\s|\\(]+(".concat(CSS_UNIT$2, ")[,|\\s]+(").concat(CSS_UNIT$2, ")[,|\\s]+(").concat(CSS_UNIT$2, ")[,|\\s]+(").concat(CSS_UNIT$2, ")\\s*\\)?");
var matchers$2 = {
  CSS_UNIT: new RegExp(CSS_UNIT$2),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3$2),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4$2),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3$2),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4$2),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3$2),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4$2),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject$2(color2) {
  color2 = color2.trim().toLowerCase();
  if (color2.length === 0) {
    return false;
  }
  var named = false;
  if (names$2[color2]) {
    color2 = names$2[color2];
    named = true;
  } else if (color2 === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match2 = matchers$2.rgb.exec(color2);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3] };
  }
  match2 = matchers$2.rgba.exec(color2);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
  }
  match2 = matchers$2.hsl.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3] };
  }
  match2 = matchers$2.hsla.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
  }
  match2 = matchers$2.hsv.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3] };
  }
  match2 = matchers$2.hsva.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
  }
  match2 = matchers$2.hex8.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex$2(match2[1]),
      g: parseIntFromHex$2(match2[2]),
      b: parseIntFromHex$2(match2[3]),
      a: convertHexToDecimal$2(match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers$2.hex6.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex$2(match2[1]),
      g: parseIntFromHex$2(match2[2]),
      b: parseIntFromHex$2(match2[3]),
      format: named ? "name" : "hex"
    };
  }
  match2 = matchers$2.hex4.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex$2(match2[1] + match2[1]),
      g: parseIntFromHex$2(match2[2] + match2[2]),
      b: parseIntFromHex$2(match2[3] + match2[3]),
      a: convertHexToDecimal$2(match2[4] + match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers$2.hex3.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex$2(match2[1] + match2[1]),
      g: parseIntFromHex$2(match2[2] + match2[2]),
      b: parseIntFromHex$2(match2[3] + match2[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit$2(color2) {
  return Boolean(matchers$2.CSS_UNIT.exec(String(color2)));
}
var hueStep$1 = 2;
var saturationStep$1 = 0.16;
var saturationStep2$1 = 0.05;
var brightnessStep1$1 = 0.05;
var brightnessStep2$1 = 0.15;
var lightColorCount$1 = 5;
var darkColorCount$1 = 4;
var darkColorMap$1 = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function toHsv$1(_ref2) {
  var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
  var hsv = rgbToHsv$2(r2, g2, b2);
  return {
    h: hsv.h * 360,
    s: hsv.s,
    v: hsv.v
  };
}
function toHex$1(_ref2) {
  var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
  return "#".concat(rgbToHex$2(r2, g2, b2, false));
}
function mix$2(rgb1, rgb2, amount) {
  var p2 = amount / 100;
  var rgb = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b
  };
  return rgb;
}
function getHue$1(hsv, i, light) {
  var hue;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep$1 * i : Math.round(hsv.h) + hueStep$1 * i;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep$1 * i : Math.round(hsv.h) - hueStep$1 * i;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}
function getSaturation$1(hsv, i, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep$1 * i;
  } else if (i === darkColorCount$1) {
    saturation = hsv.s + saturationStep$1;
  } else {
    saturation = hsv.s + saturationStep2$1 * i;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i === lightColorCount$1 && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue$6(hsv, i, light) {
  var value;
  if (light) {
    value = hsv.v + brightnessStep1$1 * i;
  } else {
    value = hsv.v - brightnessStep2$1 * i;
  }
  if (value > 1) {
    value = 1;
  }
  return Number(value.toFixed(2));
}
function generate$4(color2) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = inputToRGB$2(color2);
  for (var i = lightColorCount$1; i > 0; i -= 1) {
    var hsv = toHsv$1(pColor);
    var colorString = toHex$1(inputToRGB$2({
      h: getHue$1(hsv, i, true),
      s: getSaturation$1(hsv, i, true),
      v: getValue$6(hsv, i, true)
    }));
    patterns.push(colorString);
  }
  patterns.push(toHex$1(pColor));
  for (var _i2 = 1; _i2 <= darkColorCount$1; _i2 += 1) {
    var _hsv = toHsv$1(pColor);
    var _colorString = toHex$1(inputToRGB$2({
      h: getHue$1(_hsv, _i2),
      s: getSaturation$1(_hsv, _i2),
      v: getValue$6(_hsv, _i2)
    }));
    patterns.push(_colorString);
  }
  if (opts.theme === "dark") {
    return darkColorMap$1.map(function(_ref3) {
      var index2 = _ref3.index, opacity = _ref3.opacity;
      var darkColorString = toHex$1(mix$2(inputToRGB$2(opts.backgroundColor || "#141414"), inputToRGB$2(patterns[index2]), opacity * 100));
      return darkColorString;
    });
  }
  return patterns;
}
var presetPrimaryColors$1 = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
};
var presetPalettes$1 = {};
var presetDarkPalettes$1 = {};
Object.keys(presetPrimaryColors$1).forEach(function(key) {
  presetPalettes$1[key] = generate$4(presetPrimaryColors$1[key]);
  presetPalettes$1[key].primary = presetPalettes$1[key][5];
  presetDarkPalettes$1[key] = generate$4(presetPrimaryColors$1[key], {
    theme: "dark",
    backgroundColor: "#141414"
  });
  presetDarkPalettes$1[key].primary = presetDarkPalettes$1[key][5];
});
var warned$7 = {};
function warning$e(valid2, message) {
}
function call$7(method4, valid2, message) {
  if (!valid2 && !warned$7[message]) {
    method4(false, message);
    warned$7[message] = true;
  }
}
function warningOnce$7(valid2, message) {
  call$7(warning$e, valid2, message);
}
function canUseDom$f() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function contains$a(root2, n2) {
  if (!root2) {
    return false;
  }
  if (root2.contains) {
    return root2.contains(n2);
  }
  var node2 = n2;
  while (node2) {
    if (node2 === root2) {
      return true;
    }
    node2 = node2.parentNode;
  }
  return false;
}
var APPEND_ORDER$6 = "data-rc-order";
var MARK_KEY$6 = "rc-util-key";
var containerCache$6 = /* @__PURE__ */ new Map();
function getMark$6() {
  var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark2 = _ref2.mark;
  if (mark2) {
    return mark2.startsWith("data-") ? mark2 : "data-".concat(mark2);
  }
  return MARK_KEY$6;
}
function getContainer$6(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function getOrder$6(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles$6(container) {
  return Array.from((containerCache$6.get(container) || container).children).filter(function(node2) {
    return node2.tagName === "STYLE";
  });
}
function injectCSS$6(css2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom$f()) {
    return null;
  }
  var csp = option.csp, prepend = option.prepend;
  var styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER$6, getOrder$6(prepend));
  if (csp === null || csp === void 0 ? void 0 : csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css2;
  var container = getContainer$6(option);
  var firstChild = container.firstChild;
  if (prepend) {
    if (prepend === "queue") {
      var existStyle = findStyles$6(container).filter(function(node2) {
        return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER$6));
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode$6(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer$6(option);
  return findStyles$6(container).find(function(node2) {
    return node2.getAttribute(getMark$6(option)) === key;
  });
}
function syncRealContainer$6(container, option) {
  var cachedRealContainer = containerCache$6.get(container);
  if (!cachedRealContainer || !contains$a(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS$6("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache$6.set(container, parentNode);
    parentNode.removeChild(placeholderStyle);
  }
}
function updateCSS$6(css2, key) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer$6(option);
  syncRealContainer$6(container, option);
  var existNode = findExistNode$6(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if (((_option$csp = option.csp) === null || _option$csp === void 0 ? void 0 : _option$csp.nonce) && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  var newNode = injectCSS$6(css2, option);
  newNode.setAttribute(getMark$6(option), key);
  return newNode;
}
function warning$d(valid2, message) {
  warningOnce$7(valid2, "[@ant-design/icons] ".concat(message));
}
function isIconDefinition$2(target) {
  return _typeof$8(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof$8(target.icon) === "object" || typeof target.icon === "function");
}
function normalizeAttrs$2() {
  var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(attrs).reduce(function(acc, key) {
    var val = attrs[key];
    switch (key) {
      case "class":
        acc.className = val;
        delete acc.class;
        break;
      default:
        acc[key] = val;
    }
    return acc;
  }, {});
}
function generate$3(node2, key, rootProps) {
  if (!rootProps) {
    return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2$d({
      key
    }, normalizeAttrs$2(node2.attrs)), (node2.children || []).map(function(child, index2) {
      return generate$3(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
    }));
  }
  return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2$d(_objectSpread2$d({
    key
  }, normalizeAttrs$2(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
    return generate$3(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
  }));
}
function getSecondaryColor$2(primaryColor) {
  return generate$4(primaryColor)[0];
}
function normalizeTwoToneColors$2(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }
  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var iconStyles$2 = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var useInsertStyles$2 = function useInsertStyles() {
  var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles$2;
  var _useContext = React.useContext(Context$3), csp = _useContext.csp;
  React.useEffect(function() {
    updateCSS$6(styleStr, "@ant-design-icons", {
      prepend: true,
      csp
    });
  }, []);
};
var _excluded$S = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
var twoToneColorPalette$2 = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: false
};
function setTwoToneColors$2(_ref2) {
  var primaryColor = _ref2.primaryColor, secondaryColor = _ref2.secondaryColor;
  twoToneColorPalette$2.primaryColor = primaryColor;
  twoToneColorPalette$2.secondaryColor = secondaryColor || getSecondaryColor$2(primaryColor);
  twoToneColorPalette$2.calculated = !!secondaryColor;
}
function getTwoToneColors$2() {
  return _objectSpread2$d({}, twoToneColorPalette$2);
}
var IconBase$3 = function IconBase(props) {
  var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties$1(props, _excluded$S);
  var colors2 = twoToneColorPalette$2;
  if (primaryColor) {
    colors2 = {
      primaryColor,
      secondaryColor: secondaryColor || getSecondaryColor$2(primaryColor)
    };
  }
  useInsertStyles$2();
  warning$d(isIconDefinition$2(icon), "icon should be icon definiton, but got ".concat(icon));
  if (!isIconDefinition$2(icon)) {
    return null;
  }
  var target = icon;
  if (target && typeof target.icon === "function") {
    target = _objectSpread2$d(_objectSpread2$d({}, target), {}, {
      icon: target.icon(colors2.primaryColor, colors2.secondaryColor)
    });
  }
  return generate$3(target.icon, "svg-".concat(target.name), _objectSpread2$d({
    className,
    onClick,
    style: style2,
    "data-icon": target.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, restProps));
};
IconBase$3.displayName = "IconReact";
IconBase$3.getTwoToneColors = getTwoToneColors$2;
IconBase$3.setTwoToneColors = setTwoToneColors$2;
var ReactIcon$1 = IconBase$3;
function setTwoToneColor$2(twoToneColor) {
  var _normalizeTwoToneColo = normalizeTwoToneColors$2(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$1(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return ReactIcon$1.setTwoToneColors({
    primaryColor,
    secondaryColor
  });
}
function getTwoToneColor$2() {
  var colors2 = ReactIcon$1.getTwoToneColors();
  if (!colors2.calculated) {
    return colors2.primaryColor;
  }
  return [colors2.primaryColor, colors2.secondaryColor];
}
var _excluded$R = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
setTwoToneColor$2("#1890ff");
var Icon$5 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var _classNames;
  var className = props.className, icon = props.icon, spin2 = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties$1(props, _excluded$R);
  var _React$useContext = React.useContext(Context$3), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
  var classString = classNames(rootClassName, prefixCls, (_classNames = {}, _defineProperty$3(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty$3(_classNames, "".concat(prefixCls, "-spin"), !!spin2 || icon.name === "loading"), _classNames), className);
  var iconTabIndex = tabIndex;
  if (iconTabIndex === void 0 && onClick) {
    iconTabIndex = -1;
  }
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : void 0;
  var _normalizeTwoToneColo = normalizeTwoToneColors$2(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$1(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return /* @__PURE__ */ React.createElement("span", _objectSpread2$d(_objectSpread2$d({
    role: "img",
    "aria-label": icon.name
  }, restProps), {}, {
    ref: ref2,
    tabIndex: iconTabIndex,
    onClick,
    className: classString
  }), /* @__PURE__ */ React.createElement(ReactIcon$1, {
    icon,
    primaryColor,
    secondaryColor,
    style: svgStyle
  }));
});
Icon$5.displayName = "AntdIcon";
Icon$5.getTwoToneColor = getTwoToneColor$2;
Icon$5.setTwoToneColor = setTwoToneColor$2;
var AntdIcon$2 = Icon$5;
var ArrowDownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M862 465.3h-81c-4.6 0-9 2-12.1 5.5L550 723.1V160c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v563.1L255.1 470.8c-3-3.5-7.4-5.5-12.1-5.5h-81c-6.8 0-10.5 8.1-6 13.2L487.9 861a31.96 31.96 0 0048.3 0L868 478.5c4.5-5.2.8-13.2-6-13.2z" } }] }, "name": "arrow-down", "theme": "outlined" };
var ArrowDownOutlinedSvg = ArrowDownOutlined$2;
var ArrowDownOutlined = function ArrowDownOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: ArrowDownOutlinedSvg
  }));
};
ArrowDownOutlined.displayName = "ArrowDownOutlined";
var ArrowDownOutlined$1 = /* @__PURE__ */ React.forwardRef(ArrowDownOutlined);
var ArrowRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M869 487.8L491.2 159.9c-2.9-2.5-6.6-3.9-10.5-3.9h-88.5c-7.4 0-10.8 9.2-5.2 14l350.2 304H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h585.1L386.9 854c-5.6 4.9-2.2 14 5.2 14h91.5c1.9 0 3.8-.7 5.2-2L869 536.2a32.07 32.07 0 000-48.4z" } }] }, "name": "arrow-right", "theme": "outlined" };
var ArrowRightOutlinedSvg = ArrowRightOutlined$2;
var ArrowRightOutlined = function ArrowRightOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: ArrowRightOutlinedSvg
  }));
};
ArrowRightOutlined.displayName = "ArrowRightOutlined";
var ArrowRightOutlined$1 = /* @__PURE__ */ React.forwardRef(ArrowRightOutlined);
var CaretDownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "outlined" };
var CaretDownOutlinedSvg = CaretDownOutlined$2;
var CaretDownOutlined = function CaretDownOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: CaretDownOutlinedSvg
  }));
};
CaretDownOutlined.displayName = "CaretDownOutlined";
var CaretDownOutlined$1 = /* @__PURE__ */ React.forwardRef(CaretDownOutlined);
var CheckCircleFilled$4 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
var CheckCircleFilledSvg = CheckCircleFilled$4;
var CheckCircleFilled$2 = function CheckCircleFilled(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: CheckCircleFilledSvg
  }));
};
CheckCircleFilled$2.displayName = "CheckCircleFilled";
var CheckCircleFilled$3 = /* @__PURE__ */ React.forwardRef(CheckCircleFilled$2);
var CheckOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
var CheckOutlinedSvg = CheckOutlined$2;
var CloseCircleFilled$7 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z" } }] }, "name": "close-circle", "theme": "filled" };
var CloseCircleFilledSvg = CloseCircleFilled$7;
var CloseOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z" } }] }, "name": "close", "theme": "outlined" };
var CloseOutlinedSvg = CloseOutlined$2;
var CloudUploadOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M518.3 459a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V856c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V613.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 459z" } }, { "tag": "path", "attrs": { "d": "M811.4 366.7C765.6 245.9 648.9 160 512.2 160S258.8 245.8 213 366.6C127.3 389.1 64 467.2 64 560c0 110.5 89.5 200 199.9 200H304c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8h-40.1c-33.7 0-65.4-13.4-89-37.7-23.5-24.2-36-56.8-34.9-90.6.9-26.4 9.9-51.2 26.2-72.1 16.7-21.3 40.1-36.8 66.1-43.7l37.9-9.9 13.9-36.6c8.6-22.8 20.6-44.1 35.7-63.4a245.6 245.6 0 0152.4-49.9c41.1-28.9 89.5-44.2 140-44.2s98.9 15.3 140 44.2c19.9 14 37.5 30.8 52.4 49.9 15.1 19.3 27.1 40.7 35.7 63.4l13.8 36.5 37.8 10C846.1 454.5 884 503.8 884 560c0 33.1-12.9 64.3-36.3 87.7a123.07 123.07 0 01-87.6 36.3H720c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h40.1C870.5 760 960 670.5 960 560c0-92.7-63.1-170.7-148.6-193.3z" } }] }, "name": "cloud-upload", "theme": "outlined" };
var CloudUploadOutlinedSvg = CloudUploadOutlined$2;
var CloudUploadOutlined = function CloudUploadOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: CloudUploadOutlinedSvg
  }));
};
CloudUploadOutlined.displayName = "CloudUploadOutlined";
var CloudUploadOutlined$1 = /* @__PURE__ */ React.forwardRef(CloudUploadOutlined);
var DeleteOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, "name": "delete", "theme": "outlined" };
var DeleteOutlinedSvg = DeleteOutlined$2;
var DeleteOutlined = function DeleteOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: DeleteOutlinedSvg
  }));
};
DeleteOutlined.displayName = "DeleteOutlined";
var DeleteOutlined$1 = /* @__PURE__ */ React.forwardRef(DeleteOutlined);
var DesktopOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 140H96c-17.7 0-32 14.3-32 32v496c0 17.7 14.3 32 32 32h380v112H304c-8.8 0-16 7.2-16 16v48c0 4.4 3.6 8 8 8h432c4.4 0 8-3.6 8-8v-48c0-8.8-7.2-16-16-16H548V700h380c17.7 0 32-14.3 32-32V172c0-17.7-14.3-32-32-32zm-40 488H136V212h752v416z" } }] }, "name": "desktop", "theme": "outlined" };
var DesktopOutlinedSvg = DesktopOutlined$2;
var DesktopOutlined = function DesktopOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: DesktopOutlinedSvg
  }));
};
DesktopOutlined.displayName = "DesktopOutlined";
var DesktopOutlined$1 = /* @__PURE__ */ React.forwardRef(DesktopOutlined);
var DotChartOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M888 792H200V168c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h752c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM288 604a64 64 0 10128 0 64 64 0 10-128 0zm118-224a48 48 0 1096 0 48 48 0 10-96 0zm158 228a96 96 0 10192 0 96 96 0 10-192 0zm148-314a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "dot-chart", "theme": "outlined" };
var DotChartOutlinedSvg = DotChartOutlined$2;
var DoubleLeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
var DoubleLeftOutlinedSvg = DoubleLeftOutlined$2;
var DoubleRightOutlined$4 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
var DoubleRightOutlinedSvg = DoubleRightOutlined$4;
var DoubleRightOutlined$2 = function DoubleRightOutlined(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: DoubleRightOutlinedSvg
  }));
};
DoubleRightOutlined$2.displayName = "DoubleRightOutlined";
var DoubleRightOutlined$3 = /* @__PURE__ */ React.forwardRef(DoubleRightOutlined$2);
var DownOutlined$4 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
var DownOutlinedSvg = DownOutlined$4;
var DownOutlined$2 = function DownOutlined(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: DownOutlinedSvg
  }));
};
DownOutlined$2.displayName = "DownOutlined";
var DownOutlined$3 = /* @__PURE__ */ React.forwardRef(DownOutlined$2);
var DownloadOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, "name": "download", "theme": "outlined" };
var DownloadOutlinedSvg = DownloadOutlined$2;
var DownloadOutlined = function DownloadOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: DownloadOutlinedSvg
  }));
};
DownloadOutlined.displayName = "DownloadOutlined";
var DownloadOutlined$1 = /* @__PURE__ */ React.forwardRef(DownloadOutlined);
var EditOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, "name": "edit", "theme": "outlined" };
var EditOutlinedSvg = EditOutlined$2;
var EditOutlined = function EditOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: EditOutlinedSvg
  }));
};
EditOutlined.displayName = "EditOutlined";
var EditOutlined$1 = /* @__PURE__ */ React.forwardRef(EditOutlined);
var EllipsisOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
var EllipsisOutlinedSvg = EllipsisOutlined$2;
var ExclamationCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
var ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
var ExclamationCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" } }] }, "name": "exclamation-circle", "theme": "outlined" };
var ExclamationCircleOutlinedSvg = ExclamationCircleOutlined$2;
var ExclamationCircleOutlined = function ExclamationCircleOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: ExclamationCircleOutlinedSvg
  }));
};
ExclamationCircleOutlined.displayName = "ExclamationCircleOutlined";
var ExclamationCircleOutlined$1 = /* @__PURE__ */ React.forwardRef(ExclamationCircleOutlined);
var ExportOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M888.3 757.4h-53.8c-4.2 0-7.7 3.5-7.7 7.7v61.8H197.1V197.1h629.8v61.8c0 4.2 3.5 7.7 7.7 7.7h53.8c4.2 0 7.7-3.4 7.7-7.7V158.7c0-17-13.7-30.7-30.7-30.7H158.7c-17 0-30.7 13.7-30.7 30.7v706.6c0 17 13.7 30.7 30.7 30.7h706.6c17 0 30.7-13.7 30.7-30.7V765.1c0-4.3-3.5-7.7-7.7-7.7zm18.6-251.7L765 393.7c-5.3-4.2-13-.4-13 6.3v76H438c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h314v76c0 6.7 7.8 10.5 13 6.3l141.9-112a8 8 0 000-12.6z" } }] }, "name": "export", "theme": "outlined" };
var ExportOutlinedSvg = ExportOutlined$2;
var ExportOutlined = function ExportOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: ExportOutlinedSvg
  }));
};
ExportOutlined.displayName = "ExportOutlined";
var ExportOutlined$1 = /* @__PURE__ */ React.forwardRef(ExportOutlined);
var EyeOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
var EyeOutlinedSvg = EyeOutlined$2;
var HeartFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M923 283.6a260.04 260.04 0 00-56.9-82.8 264.4 264.4 0 00-84-55.5A265.34 265.34 0 00679.7 125c-49.3 0-97.4 13.5-139.2 39-10 6.1-19.5 12.8-28.5 20.1-9-7.3-18.5-14-28.5-20.1-41.8-25.5-89.9-39-139.2-39-35.5 0-69.9 6.8-102.4 20.3-31.4 13-59.7 31.7-84 55.5a258.44 258.44 0 00-56.9 82.8c-13.9 32.3-21 66.6-21 101.9 0 33.3 6.8 68 20.3 103.3 11.3 29.5 27.5 60.1 48.2 91 32.8 48.9 77.9 99.9 133.9 151.6 92.8 85.7 184.7 144.9 188.6 147.3l23.7 15.2c10.5 6.7 24 6.7 34.5 0l23.7-15.2c3.9-2.5 95.7-61.6 188.6-147.3 56-51.7 101.1-102.7 133.9-151.6 20.7-30.9 37-61.5 48.2-91 13.5-35.3 20.3-70 20.3-103.3.1-35.3-7-69.6-20.9-101.9z" } }] }, "name": "heart", "theme": "filled" };
var HeartFilledSvg = HeartFilled$2;
var HeartFilled = function HeartFilled2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: HeartFilledSvg
  }));
};
HeartFilled.displayName = "HeartFilled";
var HeartFilled$1 = /* @__PURE__ */ React.forwardRef(HeartFilled);
var HeartOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M923 283.6a260.04 260.04 0 00-56.9-82.8 264.4 264.4 0 00-84-55.5A265.34 265.34 0 00679.7 125c-49.3 0-97.4 13.5-139.2 39-10 6.1-19.5 12.8-28.5 20.1-9-7.3-18.5-14-28.5-20.1-41.8-25.5-89.9-39-139.2-39-35.5 0-69.9 6.8-102.4 20.3-31.4 13-59.7 31.7-84 55.5a258.44 258.44 0 00-56.9 82.8c-13.9 32.3-21 66.6-21 101.9 0 33.3 6.8 68 20.3 103.3 11.3 29.5 27.5 60.1 48.2 91 32.8 48.9 77.9 99.9 133.9 151.6 92.8 85.7 184.7 144.9 188.6 147.3l23.7 15.2c10.5 6.7 24 6.7 34.5 0l23.7-15.2c3.9-2.5 95.7-61.6 188.6-147.3 56-51.7 101.1-102.7 133.9-151.6 20.7-30.9 37-61.5 48.2-91 13.5-35.3 20.3-70 20.3-103.3.1-35.3-7-69.6-20.9-101.9zM512 814.8S156 586.7 156 385.5C156 283.6 240.3 201 344.3 201c73.1 0 136.5 40.8 167.7 100.4C543.2 241.8 606.6 201 679.7 201c104 0 188.3 82.6 188.3 184.5 0 201.2-356 429.3-356 429.3z" } }] }, "name": "heart", "theme": "outlined" };
var HeartOutlinedSvg = HeartOutlined$2;
var HeartOutlined = function HeartOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: HeartOutlinedSvg
  }));
};
HeartOutlined.displayName = "HeartOutlined";
var HeartOutlined$1 = /* @__PURE__ */ React.forwardRef(HeartOutlined);
var InboxOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M885.2 446.3l-.2-.8-112.2-285.1c-5-16.1-19.9-27.2-36.8-27.2H281.2c-17 0-32.1 11.3-36.9 27.6L139.4 443l-.3.7-.2.8c-1.3 4.9-1.7 9.9-1 14.8-.1 1.6-.2 3.2-.2 4.8V830a60.9 60.9 0 0060.8 60.8h627.2c33.5 0 60.8-27.3 60.9-60.8V464.1c0-1.3 0-2.6-.1-3.7.4-4.9 0-9.6-1.3-14.1zm-295.8-43l-.3 15.7c-.8 44.9-31.8 75.1-77.1 75.1-22.1 0-41.1-7.1-54.8-20.6S436 441.2 435.6 419l-.3-15.7H229.5L309 210h399.2l81.7 193.3H589.4zm-375 76.8h157.3c24.3 57.1 76 90.8 140.4 90.8 33.7 0 65-9.4 90.3-27.2 22.2-15.6 39.5-37.4 50.7-63.6h156.5V814H214.4V480.1z" } }] }, "name": "inbox", "theme": "outlined" };
var InboxOutlinedSvg = InboxOutlined$2;
var InboxOutlined = function InboxOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: InboxOutlinedSvg
  }));
};
InboxOutlined.displayName = "InboxOutlined";
var InboxOutlined$1 = /* @__PURE__ */ React.forwardRef(InboxOutlined);
var InfoCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
var InfoCircleFilledSvg = InfoCircleFilled$2;
var LeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
var LeftOutlinedSvg = LeftOutlined$2;
var LoadingOutlined$9 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
var LoadingOutlinedSvg = LoadingOutlined$9;
var LoadingOutlined$7 = function LoadingOutlined(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: LoadingOutlinedSvg
  }));
};
LoadingOutlined$7.displayName = "LoadingOutlined";
var LoadingOutlined$8 = /* @__PURE__ */ React.forwardRef(LoadingOutlined$7);
var MailOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 110.8V792H136V270.8l-27.6-21.5 39.3-50.5 42.8 33.3h643.1l42.8-33.3 39.3 50.5-27.7 21.5zM833.6 232L512 482 190.4 232l-42.8-33.3-39.3 50.5 27.6 21.5 341.6 265.6a55.99 55.99 0 0068.7 0L888 270.8l27.6-21.5-39.3-50.5-42.7 33.2z" } }] }, "name": "mail", "theme": "outlined" };
var MailOutlinedSvg = MailOutlined$2;
var MailOutlined = function MailOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: MailOutlinedSvg
  }));
};
MailOutlined.displayName = "MailOutlined";
var MailOutlined$1 = /* @__PURE__ */ React.forwardRef(MailOutlined);
var PaperClipOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" } }] }, "name": "paper-clip", "theme": "outlined" };
var PaperClipOutlinedSvg = PaperClipOutlined$2;
var PaperClipOutlined = function PaperClipOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: PaperClipOutlinedSvg
  }));
};
PaperClipOutlined.displayName = "PaperClipOutlined";
var PaperClipOutlined$1 = /* @__PURE__ */ React.forwardRef(PaperClipOutlined);
var PlusOutlined$4 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { "tag": "path", "attrs": { "d": "M176 474h672q8 0 8 8v60q0 8-8 8H176q-8 0-8-8v-60q0-8 8-8z" } }] }, "name": "plus", "theme": "outlined" };
var PlusOutlinedSvg = PlusOutlined$4;
var PlusOutlined$2 = function PlusOutlined(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: PlusOutlinedSvg
  }));
};
PlusOutlined$2.displayName = "PlusOutlined";
var PlusOutlined$3 = /* @__PURE__ */ React.forwardRef(PlusOutlined$2);
var RightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
var RightOutlinedSvg = RightOutlined$2;
var RocketOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M864 736c0-111.6-65.4-208-160-252.9V317.3c0-15.1-5.3-29.7-15.1-41.2L536.5 95.4C530.1 87.8 521 84 512 84s-18.1 3.8-24.5 11.4L335.1 276.1a63.97 63.97 0 00-15.1 41.2v165.8C225.4 528 160 624.4 160 736h156.5c-2.3 7.2-3.5 15-3.5 23.8 0 22.1 7.6 43.7 21.4 60.8a97.2 97.2 0 0043.1 30.6c23.1 54 75.6 88.8 134.5 88.8 29.1 0 57.3-8.6 81.4-24.8 23.6-15.8 41.9-37.9 53-64a97 97 0 0043.1-30.5 97.52 97.52 0 0021.4-60.8c0-8.4-1.1-16.4-3.1-23.8H864zM762.3 621.4c9.4 14.6 17 30.3 22.5 46.6H700V558.7a211.6 211.6 0 0162.3 62.7zM388 483.1V318.8l124-147 124 147V668H388V483.1zM239.2 668c5.5-16.3 13.1-32 22.5-46.6 16.3-25.2 37.5-46.5 62.3-62.7V668h-84.8zm388.9 116.2c-5.2 3-11.2 4.2-17.1 3.4l-19.5-2.4-2.8 19.4c-5.4 37.9-38.4 66.5-76.7 66.5-38.3 0-71.3-28.6-76.7-66.5l-2.8-19.5-19.5 2.5a27.7 27.7 0 01-17.1-3.5c-8.7-5-14.1-14.3-14.1-24.4 0-10.6 5.9-19.4 14.6-23.8h231.3c8.8 4.5 14.6 13.3 14.6 23.8-.1 10.2-5.5 19.6-14.2 24.5zM464 400a48 48 0 1096 0 48 48 0 10-96 0z" } }] }, "name": "rocket", "theme": "outlined" };
var RocketOutlinedSvg = RocketOutlined$2;
var RocketOutlined = function RocketOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: RocketOutlinedSvg
  }));
};
RocketOutlined.displayName = "RocketOutlined";
var RocketOutlined$1 = /* @__PURE__ */ React.forwardRef(RocketOutlined);
var RotateLeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M672 418H144c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H188V494h440v326z" } }, { "tag": "path", "attrs": { "d": "M819.3 328.5c-78.8-100.7-196-153.6-314.6-154.2l-.2-64c0-6.5-7.6-10.1-12.6-6.1l-128 101c-4 3.1-3.9 9.1 0 12.3L492 318.6c5.1 4 12.7.4 12.6-6.1v-63.9c12.9.1 25.9.9 38.8 2.5 42.1 5.2 82.1 18.2 119 38.7 38.1 21.2 71.2 49.7 98.4 84.3 27.1 34.7 46.7 73.7 58.1 115.8a325.95 325.95 0 016.5 140.9h74.9c14.8-103.6-11.3-213-81-302.3z" } }] }, "name": "rotate-left", "theme": "outlined" };
var RotateLeftOutlinedSvg = RotateLeftOutlined$2;
var RotateRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M480.5 251.2c13-1.6 25.9-2.4 38.8-2.5v63.9c0 6.5 7.5 10.1 12.6 6.1L660 217.6c4-3.2 4-9.2 0-12.3l-128-101c-5.1-4-12.6-.4-12.6 6.1l-.2 64c-118.6.5-235.8 53.4-314.6 154.2A399.75 399.75 0 00123.5 631h74.9c-.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1 8.9-124.8 11.4-42.2 31-81.1 58.1-115.8 27.2-34.7 60.3-63.2 98.4-84.3 37-20.6 76.9-33.6 119.1-38.8z" } }, { "tag": "path", "attrs": { "d": "M880 418H352c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H396V494h440v326z" } }] }, "name": "rotate-right", "theme": "outlined" };
var RotateRightOutlinedSvg = RotateRightOutlined$2;
var SearchOutlined$7 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
var SearchOutlinedSvg = SearchOutlined$7;
var SettingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M924.8 625.7l-65.5-56c3.1-19 4.7-38.4 4.7-57.8s-1.6-38.8-4.7-57.8l65.5-56a32.03 32.03 0 009.3-35.2l-.9-2.6a443.74 443.74 0 00-79.7-137.9l-1.8-2.1a32.12 32.12 0 00-35.1-9.5l-81.3 28.9c-30-24.6-63.5-44-99.7-57.6l-15.7-85a32.05 32.05 0 00-25.8-25.7l-2.7-.5c-52.1-9.4-106.9-9.4-159 0l-2.7.5a32.05 32.05 0 00-25.8 25.7l-15.8 85.4a351.86 351.86 0 00-99 57.4l-81.9-29.1a32 32 0 00-35.1 9.5l-1.8 2.1a446.02 446.02 0 00-79.7 137.9l-.9 2.6c-4.5 12.5-.8 26.5 9.3 35.2l66.3 56.6c-3.1 18.8-4.6 38-4.6 57.1 0 19.2 1.5 38.4 4.6 57.1L99 625.5a32.03 32.03 0 00-9.3 35.2l.9 2.6c18.1 50.4 44.9 96.9 79.7 137.9l1.8 2.1a32.12 32.12 0 0035.1 9.5l81.9-29.1c29.8 24.5 63.1 43.9 99 57.4l15.8 85.4a32.05 32.05 0 0025.8 25.7l2.7.5a449.4 449.4 0 00159 0l2.7-.5a32.05 32.05 0 0025.8-25.7l15.7-85a350 350 0 0099.7-57.6l81.3 28.9a32 32 0 0035.1-9.5l1.8-2.1c34.8-41.1 61.6-87.5 79.7-137.9l.9-2.6c4.5-12.3.8-26.3-9.3-35zM788.3 465.9c2.5 15.1 3.8 30.6 3.8 46.1s-1.3 31-3.8 46.1l-6.6 40.1 74.7 63.9a370.03 370.03 0 01-42.6 73.6L721 702.8l-31.4 25.8c-23.9 19.6-50.5 35-79.3 45.8l-38.1 14.3-17.9 97a377.5 377.5 0 01-85 0l-17.9-97.2-37.8-14.5c-28.5-10.8-55-26.2-78.7-45.7l-31.4-25.9-93.4 33.2c-17-22.9-31.2-47.6-42.6-73.6l75.5-64.5-6.5-40c-2.4-14.9-3.7-30.3-3.7-45.5 0-15.3 1.2-30.6 3.7-45.5l6.5-40-75.5-64.5c11.3-26.1 25.6-50.7 42.6-73.6l93.4 33.2 31.4-25.9c23.7-19.5 50.2-34.9 78.7-45.7l37.9-14.3 17.9-97.2c28.1-3.2 56.8-3.2 85 0l17.9 97 38.1 14.3c28.7 10.8 55.4 26.2 79.3 45.8l31.4 25.8 92.8-32.9c17 22.9 31.2 47.6 42.6 73.6L781.8 426l6.5 39.9zM512 326c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm79.2 255.2A111.6 111.6 0 01512 614c-29.9 0-58-11.7-79.2-32.8A111.6 111.6 0 01400 502c0-29.9 11.7-58 32.8-79.2C454 401.6 482.1 390 512 390c29.9 0 58 11.6 79.2 32.8A111.6 111.6 0 01624 502c0 29.9-11.7 58-32.8 79.2z" } }] }, "name": "setting", "theme": "outlined" };
var SettingOutlinedSvg = SettingOutlined$2;
var SettingOutlined = function SettingOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: SettingOutlinedSvg
  }));
};
SettingOutlined.displayName = "SettingOutlined";
var SettingOutlined$1 = /* @__PURE__ */ React.forwardRef(SettingOutlined);
var SwapOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M847.9 592H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h605.2L612.9 851c-4.1 5.2-.4 13 6.3 13h72.5c4.9 0 9.5-2.2 12.6-6.1l168.8-214.1c16.5-21 1.6-51.8-25.2-51.8zM872 356H266.8l144.3-183c4.1-5.2.4-13-6.3-13h-72.5c-4.9 0-9.5 2.2-12.6 6.1L150.9 380.2c-16.5 21-1.6 51.8 25.1 51.8h696c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, "name": "swap", "theme": "outlined" };
var SwapOutlinedSvg = SwapOutlined$2;
var UserOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.5 763.6a374 374 0 00-80.6-119.5 375.63 375.63 0 00-119.5-80.6c-.4-.2-.8-.3-1.2-.5C719.5 518 760 444.7 760 362c0-137-111-248-248-248S264 225 264 362c0 82.7 40.5 156 102.8 201.1-.4.2-.8.3-1.2.5-44.8 18.9-85 46-119.5 80.6a375.63 375.63 0 00-80.6 119.5A371.7 371.7 0 00136 901.8a8 8 0 008 8.2h60c4.4 0 7.9-3.5 8-7.8 2-77.2 33-149.5 87.8-204.3 56.7-56.7 132-87.9 212.2-87.9s155.5 31.2 212.2 87.9C779 752.7 810 825 812 902.2c.1 4.4 3.6 7.8 8 7.8h60a8 8 0 008-8.2c-1-47.8-10.9-94.3-29.5-138.2zM512 534c-45.9 0-89.1-17.9-121.6-50.4S340 407.9 340 362c0-45.9 17.9-89.1 50.4-121.6S466.1 190 512 190s89.1 17.9 121.6 50.4S684 316.1 684 362c0 45.9-17.9 89.1-50.4 121.6S557.9 534 512 534z" } }] }, "name": "user", "theme": "outlined" };
var UserOutlinedSvg = UserOutlined$2;
var UserOutlined = function UserOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$2, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: UserOutlinedSvg
  }));
};
UserOutlined.displayName = "UserOutlined";
var UserOutlined$1 = /* @__PURE__ */ React.forwardRef(UserOutlined);
var ZoomInOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, "name": "zoom-in", "theme": "outlined" };
var ZoomInOutlinedSvg = ZoomInOutlined$2;
var ZoomOutOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, "name": "zoom-out", "theme": "outlined" };
var ZoomOutOutlinedSvg = ZoomOutOutlined$2;
var Icons = {
  arrowDown: ArrowDownOutlined$1,
  arrowRight: ArrowRightOutlined$1,
  arrowRightDouble: DoubleRightOutlined$3,
  downOutlined: DownOutlined$3,
  heartOutlined: HeartOutlined$1,
  heartFilled: HeartFilled$1,
  download: DownloadOutlined$1,
  upload: CloudUploadOutlined$1,
  downFilled: CaretDownOutlined$1,
  user: UserOutlined$1,
  logout: ExportOutlined$1,
  exclamation: ExclamationCircleOutlined$1,
  plus: PlusOutlined$3,
  checkFilled: CheckCircleFilled$3,
  edit: EditOutlined$1,
  rocket: RocketOutlined$1,
  setting: SettingOutlined$1,
  desktop: DesktopOutlined$1,
  email: MailOutlined$1,
  inbox: InboxOutlined$1,
  paperClip: PaperClipOutlined$1,
  delete: DeleteOutlined$1,
  loading: LoadingOutlined$8
};
const Icon$4 = ({ className, icon, style: style2, twoToneColor, spin: spin2 }) => {
  if (!icon)
    return null;
  const IconComponent = Icons[icon];
  if (!IconComponent)
    return null;
  return /* @__PURE__ */ React.createElement(IconComponent, {
    className,
    style: style2,
    twoToneColor,
    spin: spin2
  });
};
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT$1 = "comm";
var RULESET$1 = "rule";
var DECLARATION$1 = "decl";
var IMPORT$1 = "@import";
var KEYFRAMES$1 = "@keyframes";
var abs$1 = Math.abs;
var from$1 = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return (((length2 << 2 ^ charat$1(value, 0)) << 2 ^ charat$1(value, 1)) << 2 ^ charat$1(value, 2)) << 2 ^ charat$1(value, 3);
}
function trim$2(value) {
  return value.trim();
}
function match$4(value, pattern4) {
  return (value = pattern4.exec(value)) ? value[0] : value;
}
function replace$2(value, pattern4, replacement) {
  return value.replace(pattern4, replacement);
}
function indexof$1(value, search2) {
  return value.indexOf(search2);
}
function charat$1(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr$1(value, begin, end) {
  return value.slice(begin, end);
}
function strlen$1(value) {
  return value.length;
}
function sizeof$1(value) {
  return value.length;
}
function append$1(value, array4) {
  return array4.push(value), value;
}
function combine(array4, callback) {
  return array4.map(callback).join("");
}
var line$1 = 1;
var column$1 = 1;
var length$1 = 0;
var position$2 = 0;
var character$1 = 0;
var characters$1 = "";
function node$1(value, root2, parent, type4, props, children, length2) {
  return { value, root: root2, parent, type: type4, props, children, line: line$1, column: column$1, length: length2, return: "" };
}
function copy$1(root2, props) {
  return assign(node$1("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char$1() {
  return character$1;
}
function prev$1() {
  character$1 = position$2 > 0 ? charat$1(characters$1, --position$2) : 0;
  if (column$1--, character$1 === 10)
    column$1 = 1, line$1--;
  return character$1;
}
function next$1() {
  character$1 = position$2 < length$1 ? charat$1(characters$1, position$2++) : 0;
  if (column$1++, character$1 === 10)
    column$1 = 1, line$1++;
  return character$1;
}
function peek$1() {
  return charat$1(characters$1, position$2);
}
function caret$1() {
  return position$2;
}
function slice$2(begin, end) {
  return substr$1(characters$1, begin, end);
}
function token$1(type4) {
  switch (type4) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc$1(value) {
  return line$1 = column$1 = 1, length$1 = strlen$1(characters$1 = value), position$2 = 0, [];
}
function dealloc$1(value) {
  return characters$1 = "", value;
}
function delimit$1(type4) {
  return trim$2(slice$2(position$2 - 1, delimiter$1(type4 === 91 ? type4 + 2 : type4 === 40 ? type4 + 1 : type4)));
}
function whitespace$3(type4) {
  while (character$1 = peek$1())
    if (character$1 < 33)
      next$1();
    else
      break;
  return token$1(type4) > 2 || token$1(character$1) > 3 ? "" : " ";
}
function escaping$1(index2, count) {
  while (--count && next$1())
    if (character$1 < 48 || character$1 > 102 || character$1 > 57 && character$1 < 65 || character$1 > 70 && character$1 < 97)
      break;
  return slice$2(index2, caret$1() + (count < 6 && peek$1() == 32 && next$1() == 32));
}
function delimiter$1(type4) {
  while (next$1())
    switch (character$1) {
      case type4:
        return position$2;
      case 34:
      case 39:
        if (type4 !== 34 && type4 !== 39)
          delimiter$1(character$1);
        break;
      case 40:
        if (type4 === 41)
          delimiter$1(type4);
        break;
      case 92:
        next$1();
        break;
    }
  return position$2;
}
function commenter$1(type4, index2) {
  while (next$1())
    if (type4 + character$1 === 47 + 10)
      break;
    else if (type4 + character$1 === 42 + 42 && peek$1() === 47)
      break;
  return "/*" + slice$2(index2, position$2 - 1) + "*" + from$1(type4 === 47 ? type4 : next$1());
}
function identifier$1(index2) {
  while (!token$1(peek$1()))
    next$1();
  return slice$2(index2, position$2);
}
function compile$1(value) {
  return dealloc$1(parse$3("", null, null, null, [""], value = alloc$1(value), 0, [0], value));
}
function parse$3(value, root2, parent, rule, rules2, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous2 = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type4 = "";
  var props = rules2;
  var children = rulesets;
  var reference = rule;
  var characters2 = type4;
  while (scanning)
    switch (previous2 = character2, character2 = next$1()) {
      case 40:
        if (previous2 != 108 && characters2.charCodeAt(length2 - 1) == 58) {
          if (indexof$1(characters2 += replace$2(delimit$1(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit$1(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace$3(previous2);
        break;
      case 92:
        characters2 += escaping$1(caret$1() - 1, 7);
        continue;
      case 47:
        switch (peek$1()) {
          case 42:
          case 47:
            append$1(comment$1(commenter$1(next$1(), caret$1()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen$1(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset3:
            if (property > 0 && strlen$1(characters2) - length2)
              append$1(property > 32 ? declaration$1(characters2 + ";", rule, parent, length2 - 1) : declaration$1(replace$2(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append$1(reference = ruleset$1(characters2, root2, parent, index2, offset3, rules2, points, type4, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse$3(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule) {
                  case 100:
                  case 109:
                  case 115:
                    parse$3(value, reference, reference, rule && append$1(ruleset$1(value, reference, reference, 0, 0, rules2, points, type4, rules2, props = [], length2), children), rules2, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$3(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset3 = property = 0, variable = ampersand = 1, type4 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen$1(characters2), property = previous2;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev$1() == 125)
            continue;
        }
        switch (characters2 += from$1(character2), character2 * variable) {
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen$1(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek$1() === 45)
              characters2 += delimit$1(next$1());
            atrule = peek$1(), offset3 = length2 = strlen$1(type4 = characters2 += identifier$1(caret$1())), character2++;
            break;
          case 45:
            if (previous2 === 45 && strlen$1(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset$1(value, root2, parent, index2, offset3, rules2, points, type4, props, children, length2) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules2 : [""];
  var size = sizeof$1(rule);
  for (var i = 0, j2 = 0, k2 = 0; i < index2; ++i)
    for (var x2 = 0, y2 = substr$1(value, post + 1, post = abs$1(j2 = points[i])), z2 = value; x2 < size; ++x2)
      if (z2 = trim$2(j2 > 0 ? rule[x2] + " " + y2 : replace$2(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node$1(value, root2, parent, offset3 === 0 ? RULESET$1 : type4, props, children, length2);
}
function comment$1(value, root2, parent) {
  return node$1(value, root2, parent, COMMENT$1, from$1(char$1()), substr$1(value, 2, -2), 0);
}
function declaration$1(value, root2, parent, length2) {
  return node$1(value, root2, parent, DECLARATION$1, substr$1(value, 0, length2), substr$1(value, length2 + 1, -1), length2);
}
function prefix(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace$2(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace$2(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace$2(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace$2(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace$2(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace$2(value, "-grow", "") + WEBKIT + value + MS + replace$2(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace$2(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace$2(replace$2(replace$2(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace$2(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace$2(replace$2(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$2(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen$1(value) - 1 - length2 > 6)
        switch (charat$1(value, length2 + 1)) {
          case 109:
            if (charat$1(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace$2(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat$1(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof$1(value, "stretch") ? prefix(replace$2(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat$1(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat$1(value, strlen$1(value) - 3 - (~indexof$1(value, "!important") && 10))) {
        case 107:
          return replace$2(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace$2(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat$1(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat$1(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace$2(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace$2(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace$2(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
function serialize$2(children, callback) {
  var output2 = "";
  var length2 = sizeof$1(children);
  for (var i = 0; i < length2; i++)
    output2 += callback(children[i], i, children, callback) || "";
  return output2;
}
function stringify$5(element2, index2, children, callback) {
  switch (element2.type) {
    case IMPORT$1:
    case DECLARATION$1:
      return element2.return = element2.return || element2.value;
    case COMMENT$1:
      return "";
    case KEYFRAMES$1:
      return element2.return = element2.value + "{" + serialize$2(element2.children, callback) + "}";
    case RULESET$1:
      element2.value = element2.props.join(",");
  }
  return strlen$1(children = serialize$2(element2.children, callback)) ? element2.return = element2.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof$1(collection);
  return function(element2, index2, children, callback) {
    var output2 = "";
    for (var i = 0; i < length2; i++)
      output2 += collection[i](element2, index2, children, callback) || "";
    return output2;
  };
}
function rulesheet(callback) {
  return function(element2) {
    if (!element2.root) {
      if (element2 = element2.return)
        callback(element2);
    }
  };
}
function prefixer(element2, index2, children, callback) {
  if (element2.length > -1) {
    if (!element2.return)
      switch (element2.type) {
        case DECLARATION$1:
          element2.return = prefix(element2.value, element2.length);
          break;
        case KEYFRAMES$1:
          return serialize$2([copy$1(element2, { value: replace$2(element2.value, "@", "@" + WEBKIT) })], callback);
        case RULESET$1:
          if (element2.length)
            return combine(element2.props, function(value) {
              switch (match$4(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize$2([copy$1(element2, { props: [replace$2(value, /:(read-\w+)/, ":" + MOZ + "$1")] })], callback);
                case "::placeholder":
                  return serialize$2([
                    copy$1(element2, { props: [replace$2(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }),
                    copy$1(element2, { props: [replace$2(value, /:(plac\w+)/, ":" + MOZ + "$1")] }),
                    copy$1(element2, { props: [replace$2(value, /:(plac\w+)/, MS + "input-$1")] })
                  ], callback);
              }
              return "";
            });
      }
  }
}
function memoize(fn2) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0)
      cache2[arg] = fn2(arg);
    return cache2[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous2 = 0;
  var character2 = 0;
  while (true) {
    previous2 = character2;
    character2 = peek$1();
    if (previous2 === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token$1(character2)) {
      break;
    }
    next$1();
  }
  return slice$2(begin, position$2);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token$1(character2)) {
      case 0:
        if (character2 === 38 && peek$1() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position$2 - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit$1(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek$1() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from$1(character2);
    }
  } while (character2 = next$1());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc$1(toRules(alloc$1(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element2) {
  if (element2.type !== "rule" || !element2.parent || element2.length < 1) {
    return;
  }
  var value = element2.value, parent = element2.parent;
  var isImplicitRule = element2.column === parent.column && element2.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element2.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element2, true);
  var points = [];
  var rules2 = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules2.length; i++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element2.props[k2] = points[i] ? rules2[i].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules2[i];
    }
  }
};
var removeLabel = function removeLabel2(element2) {
  if (element2.type === "decl") {
    var value = element2.value;
    if (value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98) {
      element2["return"] = "";
      element2.value = "";
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache$1 = function createCache(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$5, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize$2(compile$1(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
var weakMemoize = function weakMemoize2(func) {
  var cache2 = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache2.has(arg)) {
      return cache2.get(arg);
    }
    var ret = func(arg);
    cache2.set(arg, ret);
    return ret;
  };
};
var reactIs$2 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$1 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$1 = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$1 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$1 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r = b$1 ? Symbol.for("react.memo") : 60115, t$1 = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w = b$1 ? Symbol.for("react.fundamental") : 60117, x = b$1 ? Symbol.for("react.responder") : 60118, y = b$1 ? Symbol.for("react.scope") : 60119;
function z(a) {
  if ("object" === typeof a && null !== a) {
    var u2 = a.$$typeof;
    switch (u2) {
      case c$1:
        switch (a = a.type, a) {
          case l$1:
          case m$1:
          case e$1:
          case g$1:
          case f$1:
          case p$1:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k$1:
              case n$1:
              case t$1:
              case r:
              case h$1:
                return a;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
function A(a) {
  return z(a) === m$1;
}
reactIs_production_min$1.AsyncMode = l$1;
reactIs_production_min$1.ConcurrentMode = m$1;
reactIs_production_min$1.ContextConsumer = k$1;
reactIs_production_min$1.ContextProvider = h$1;
reactIs_production_min$1.Element = c$1;
reactIs_production_min$1.ForwardRef = n$1;
reactIs_production_min$1.Fragment = e$1;
reactIs_production_min$1.Lazy = t$1;
reactIs_production_min$1.Memo = r;
reactIs_production_min$1.Portal = d$1;
reactIs_production_min$1.Profiler = g$1;
reactIs_production_min$1.StrictMode = f$1;
reactIs_production_min$1.Suspense = p$1;
reactIs_production_min$1.isAsyncMode = function(a) {
  return A(a) || z(a) === l$1;
};
reactIs_production_min$1.isConcurrentMode = A;
reactIs_production_min$1.isContextConsumer = function(a) {
  return z(a) === k$1;
};
reactIs_production_min$1.isContextProvider = function(a) {
  return z(a) === h$1;
};
reactIs_production_min$1.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === c$1;
};
reactIs_production_min$1.isForwardRef = function(a) {
  return z(a) === n$1;
};
reactIs_production_min$1.isFragment = function(a) {
  return z(a) === e$1;
};
reactIs_production_min$1.isLazy = function(a) {
  return z(a) === t$1;
};
reactIs_production_min$1.isMemo = function(a) {
  return z(a) === r;
};
reactIs_production_min$1.isPortal = function(a) {
  return z(a) === d$1;
};
reactIs_production_min$1.isProfiler = function(a) {
  return z(a) === g$1;
};
reactIs_production_min$1.isStrictMode = function(a) {
  return z(a) === f$1;
};
reactIs_production_min$1.isSuspense = function(a) {
  return z(a) === p$1;
};
reactIs_production_min$1.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === e$1 || a === m$1 || a === g$1 || a === f$1 || a === p$1 || a === q$1 || "object" === typeof a && null !== a && (a.$$typeof === t$1 || a.$$typeof === r || a.$$typeof === h$1 || a.$$typeof === k$1 || a.$$typeof === n$1 || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v$1);
};
reactIs_production_min$1.typeOf = z;
{
  reactIs$2.exports = reactIs_production_min$1;
}
var reactIs$1 = reactIs$2.exports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
function murmur2$2(str) {
  var h2 = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= k2 >>> 24;
    h2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys$2 = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex$1 = /[A-Z]|^ms/g;
var animationRegex$1 = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty$1 = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue$1 = function isProcessableValue(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName$1 = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty$1(styleName) ? styleName : styleName.replace(hyphenateRegex$1, "-$&").toLowerCase();
});
var processStyleValue$1 = function processStyleValue(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex$1, function(match2, p1, p2) {
          cursor$1 = {
            name: p1,
            styles: p2,
            next: cursor$1
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys$2[key] !== 1 && !isCustomProperty$1(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage$1 = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation$1(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor$1 = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor$1
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor$1 = {
              name: next2.name,
              styles: next2.styles,
              next: cursor$1
            };
            next2 = next2.next;
          }
        }
        var styles = interpolation.styles + ";";
        return styles;
      }
      return createStringFromObject$1(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor$1;
        var result = interpolation(mergedProps);
        cursor$1 = previousCursor;
        return handleInterpolation$1(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached2 = registered[interpolation];
  return cached2 !== void 0 ? cached2 : interpolation;
}
function createStringFromObject$1(mergedProps, registered, obj) {
  var string3 = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string3 += handleInterpolation$1(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string3 += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue$1(value)) {
          string3 += processStyleName$1(_key) + ":" + processStyleValue$1(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage$1);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i2 = 0; _i2 < value.length; _i2++) {
            if (isProcessableValue$1(value[_i2])) {
              string3 += processStyleName$1(_key) + ":" + processStyleValue$1(_key, value[_i2]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation$1(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string3 += processStyleName$1(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string3 += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string3;
}
var labelPattern$1 = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor$1;
var serializeStyles$1 = function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor$1 = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation$1(mergedProps, registered, strings);
  } else {
    styles += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation$1(mergedProps, registered, args[i]);
    if (stringMode) {
      styles += strings[i];
    }
  }
  labelPattern$1.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern$1.exec(styles)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2$2(styles) + identifierName;
  return {
    name,
    styles,
    next: cursor$1
  };
};
var EmotionCacheContext = /* @__PURE__ */ React.createContext(
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache$1({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ React.forwardRef(function(props, ref2) {
    var cache2 = React.useContext(EmotionCacheContext);
    return func(props, cache2, ref2);
  });
};
var ThemeContext = /* @__PURE__ */ React.createContext({});
var getTheme = function getTheme2(outerTheme, theme2) {
  if (typeof theme2 === "function") {
    var mergedTheme = theme2(outerTheme);
    return mergedTheme;
  }
  return _extends$3({}, outerTheme, theme2);
};
var createCacheWithTheme = /* @__PURE__ */ weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme2) {
    return getTheme(outerTheme, theme2);
  });
});
var ThemeProvider = function ThemeProvider2(props) {
  var theme2 = React.useContext(ThemeContext);
  if (props.theme !== theme2) {
    theme2 = createCacheWithTheme(theme2)(props.theme);
  }
  return /* @__PURE__ */ React.createElement(ThemeContext.Provider, {
    value: theme2
  }, props.children);
};
React["useInsertionEffect"] ? React["useInsertionEffect"] : function useInsertionEffect(create3) {
  create3();
};
React["useInsertionEffect"] ? React["useInsertionEffect"] : React.useLayoutEffect;
function css$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles$1(args);
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
);
var isBrowser$1 = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
  var className = cache2.key + "-" + serialized.name;
  if ((isStringTag === false || isBrowser$1 === false) && cache2.registered[className] === void 0) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
  registerStyles(cache2, serialized, isStringTag);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2$1(str) {
  var h2 = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= k2 >>> 24;
    h2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys$1 = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty2 = function isCustomProperty3(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue2 = function isProcessableValue3(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty2(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue2 = function processStyleValue3(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys$1[key] !== 1 && !isCustomProperty2(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = interpolation.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached2 = registered[interpolation];
  return cached2 !== void 0 ? cached2 : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string3 = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string3 += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string3 += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue2(value)) {
          string3 += processStyleName(_key) + ":" + processStyleValue2(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i2 = 0; _i2 < value.length; _i2++) {
            if (isProcessableValue2(value[_i2])) {
              string3 += processStyleName(_key) + ":" + processStyleValue2(_key, value[_i2]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string3 += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string3 += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string3;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles2 = function serializeStyles3(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      styles += strings[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2$1(styles) + identifierName;
  return {
    name,
    styles,
    next: cursor
  };
};
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
var useInsertionEffect2 = React["useInsertionEffect"] ? React["useInsertionEffect"] : function useInsertionEffect3(create3) {
  create3();
};
function useInsertionEffectMaybe(create3) {
  useInsertionEffect2(create3);
}
var Insertion = function Insertion2(_ref2) {
  var cache2 = _ref2.cache, serialized = _ref2.serialized, isStringTag = _ref2.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectMaybe(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var createStyled = function createStyled2(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles.push.apply(styles, args);
    } else {
      styles.push(args[0][0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        styles.push(args[i], args[0][i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache2, ref2) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = React.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache2.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles2(styles.concat(classInterpolations), cache2.registered, mergedProps);
      className += cache2.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref2;
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Insertion, {
        cache: cache2,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ React.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles;
    Styled.__emotion_forwardProp = shouldForwardProp;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && false) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends$3({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
const styled = newStyled;
const useTheme$3 = () => React.useContext(ThemeContext);
const darkTheme = {
  main: {
    text: "#C7C5C5",
    antiText: "black",
    weakText: "rgba(250, 250, 250, 0.45)",
    background: "#171618",
    lightBackground: "#232226",
    border: "#4A4A4A",
    shadow: "#fafafa3d"
  },
  footer: {
    text: "#c7c5c5",
    textHover: "#FFFFFF"
  }
};
const lightTheme = {
  main: {
    text: "black",
    antiText: "white",
    weakText: "rgba(0, 0, 0, 0.45)",
    background: "transparent",
    lightBackground: "#D0D0D0",
    border: "#8B8B8B",
    shadow: "#0000003d"
  },
  footer: {
    text: "#c7c5c5",
    textHover: "#FFFFFF"
  }
};
const Provider$2 = ({
  theme: theme2,
  children
}) => {
  const [currentTheme2, setThemeType] = useCurrentTheme();
  React.useEffect(() => {
    setThemeType(theme2 != null ? theme2 : "light");
  }, [theme2, setThemeType]);
  const themePackage = currentTheme2 === "light" ? lightTheme : darkTheme;
  return /* @__PURE__ */ React.createElement(ThemeProvider, {
    theme: themePackage
  }, children);
};
const AccordionItem2 = ({ className, id, heading: heading2, content: content2 }) => {
  return /* @__PURE__ */ React.createElement(Wrapper$8, {
    key: id,
    className,
    "data-testid": "atoms-accordion-item"
  }, /* @__PURE__ */ React.createElement(AccordionItem$1, null, /* @__PURE__ */ React.createElement(AccordionItemHeadingWrapper, null, /* @__PURE__ */ React.createElement(StyledAccordionItemButton, {
    "data-testid": "atoms-accordion-item-header"
  }, /* @__PURE__ */ React.createElement(InnerWrapper$2, null, /* @__PURE__ */ React.createElement(Content$3, null, /* @__PURE__ */ React.createElement(AccordionItemState, null, ({ expanded }) => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StyledIcon$2, {
    icon: "downFilled",
    open: !!expanded
  }), heading2)))))), /* @__PURE__ */ React.createElement(StyledAccordionItemPanel, {
    "data-testid": "atoms-accordion-item-content"
  }, content2)));
};
const Wrapper$8 = styled.div`
  margin: 24px 0;
  background: ${({ theme: theme2 }) => theme2.main.lightBackground};
  transition: all 0.4s;
`;
const InnerWrapper$2 = styled.div`
  padding: 0 24px;
`;
const Content$3 = styled.div`
  display: flex;
  align-items: center;
`;
const StyledIcon$2 = styled(Icon$4)`
  color: ${({ theme: theme2 }) => theme2.main.weakText};
  transition: transform 0.15s ease;
  transform: ${({ open }) => !open && "translateY(10%) rotate(-90deg)"};
  margin-right: 24px;
  font-size: 18px;
`;
const StyledAccordionItemButton = styled(AccordionItemButtonWrapper)`
  outline: none;
  cursor: pointer;
`;
const StyledAccordionItemPanel = styled(AccordionItemPanel)`
  border-top: 1px solid ${({ theme: theme2 }) => theme2.main.border};
`;
const Accordion2 = ({
  className,
  items,
  allowMultipleExpanded,
  allowZeroExpanded = true
}) => {
  return /* @__PURE__ */ React.createElement(Accordion$1, {
    className,
    allowZeroExpanded,
    "data-testid": "atoms-accordion",
    allowMultipleExpanded
  }, items == null ? void 0 : items.map((i) => {
    return /* @__PURE__ */ React.createElement(AccordionItem2, {
      key: i.id,
      id: i.id,
      heading: i.heading,
      content: i.content
    });
  }));
};
const protocols = ["http", "https", "mailto", "tel"];
function uriTransformer(uri) {
  const url2 = (uri || "").trim();
  const first = url2.charAt(0);
  if (first === "#" || first === "/") {
    return url2;
  }
  const colon = url2.indexOf(":");
  if (colon === -1) {
    return url2;
  }
  let index2 = -1;
  while (++index2 < protocols.length) {
    const protocol = protocols[index2];
    if (colon === protocol.length && url2.slice(0, protocol.length).toLowerCase() === protocol) {
      return url2;
    }
  }
  index2 = url2.indexOf("?");
  if (index2 !== -1 && colon > index2) {
    return url2;
  }
  index2 = url2.indexOf("#");
  if (index2 !== -1 && colon > index2) {
    return url2;
  }
  return "javascript:void(0)";
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var isBuffer$3 = function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position$1(value.position);
  }
  if ("start" in value || "end" in value) {
    return position$1(value);
  }
  if ("line" in value || "column" in value) {
    return point$1(value);
  }
  return "";
}
function point$1(point2) {
  return index$2(point2 && point2.line) + ":" + index$2(point2 && point2.column);
}
function position$1(pos) {
  return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);
}
function index$2(value) {
  return value && typeof value === "number" ? value : 1;
}
class VFileMessage$1 extends Error {
  constructor(reason, place, origin) {
    const parts = [null, null];
    let position2 = {
      start: { line: null, column: null },
      end: { line: null, column: null }
    };
    super();
    if (typeof place === "string") {
      origin = place;
      place = void 0;
    }
    if (typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index2);
        parts[1] = origin.slice(index2 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position2 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position2 = place;
      } else if ("line" in place || "column" in place) {
        position2.start = place;
      }
    }
    this.name = stringifyPosition(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = typeof reason === "object" ? reason.stack : "";
    this.reason = this.message;
    this.fatal;
    this.line = position2.start.line;
    this.column = position2.start.column;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.position = position2;
    this.actual;
    this.expected;
    this.file;
    this.url;
    this.note;
  }
}
VFileMessage$1.prototype.file = "";
VFileMessage$1.prototype.name = "";
VFileMessage$1.prototype.reason = "";
VFileMessage$1.prototype.message = "";
VFileMessage$1.prototype.stack = "";
VFileMessage$1.prototype.fatal = null;
VFileMessage$1.prototype.column = null;
VFileMessage$1.prototype.line = null;
VFileMessage$1.prototype.source = null;
VFileMessage$1.prototype.ruleId = null;
VFileMessage$1.prototype.position = null;
const path$4 = { basename: basename$1, dirname: dirname$1, extname: extname$1, join: join$1, sep: "/" };
function basename$1(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$3(path2);
  let start = 0;
  let end = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index2--) {
      if (path2.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path2.charCodeAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path2.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end = index2;
          }
        } else {
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname$1(path2) {
  assertPath$3(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.charCodeAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname$1(path2) {
  assertPath$3(path2);
  let index2 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path2.charCodeAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join$1(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath$3(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize$3(joined);
}
function normalize$3(path2) {
  assertPath$3(path2);
  const absolute = path2.charCodeAt(0) === 47;
  let value = normalizeString$1(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.charCodeAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString$1(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code2 = path2.charCodeAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1)
        ;
      else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath$3(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}
const proc$1 = { cwd: cwd$1 };
function cwd$1() {
  return "/";
}
function isUrl$1(fileURLOrPath) {
  return fileURLOrPath !== null && typeof fileURLOrPath === "object" && fileURLOrPath.href && fileURLOrPath.origin;
}
function urlToPath$1(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl$1(path2)) {
    const error3 = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error3.code = "ERR_INVALID_ARG_TYPE";
    throw error3;
  }
  if (path2.protocol !== "file:") {
    const error3 = new TypeError("The URL must be of scheme file");
    error3.code = "ERR_INVALID_URL_SCHEME";
    throw error3;
  }
  return getPathFromURLPosix$1(path2);
}
function getPathFromURLPosix$1(url2) {
  if (url2.hostname !== "") {
    const error3 = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error3.code = "ERR_INVALID_FILE_URL_HOST";
    throw error3;
  }
  const pathname = url2.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
      const third = pathname.charCodeAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error3 = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error3.code = "ERR_INVALID_FILE_URL_PATH";
        throw error3;
      }
    }
  }
  return decodeURIComponent(pathname);
}
const order$1 = ["history", "path", "basename", "stem", "extname", "dirname"];
class VFile$1 {
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (typeof value === "string" || isBuffer$3(value)) {
      options = { value };
    } else if (isUrl$1(value)) {
      options = { path: value };
    } else {
      options = value;
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = proc$1.cwd();
    this.value;
    this.stored;
    this.result;
    this.map;
    let index2 = -1;
    while (++index2 < order$1.length) {
      const prop2 = order$1[index2];
      if (prop2 in options && options[prop2] !== void 0) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order$1.includes(prop))
        this[prop] = options[prop];
    }
  }
  get path() {
    return this.history[this.history.length - 1];
  }
  set path(path2) {
    if (isUrl$1(path2)) {
      path2 = urlToPath$1(path2);
    }
    assertNonEmpty$1(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  get dirname() {
    return typeof this.path === "string" ? path$4.dirname(this.path) : void 0;
  }
  set dirname(dirname2) {
    assertPath$2(this.basename, "dirname");
    this.path = path$4.join(dirname2 || "", this.basename);
  }
  get basename() {
    return typeof this.path === "string" ? path$4.basename(this.path) : void 0;
  }
  set basename(basename2) {
    assertNonEmpty$1(basename2, "basename");
    assertPart$1(basename2, "basename");
    this.path = path$4.join(this.dirname || "", basename2);
  }
  get extname() {
    return typeof this.path === "string" ? path$4.extname(this.path) : void 0;
  }
  set extname(extname2) {
    assertPart$1(extname2, "extname");
    assertPath$2(this.dirname, "extname");
    if (extname2) {
      if (extname2.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path$4.join(this.dirname, this.stem + (extname2 || ""));
  }
  get stem() {
    return typeof this.path === "string" ? path$4.basename(this.path, this.extname) : void 0;
  }
  set stem(stem) {
    assertNonEmpty$1(stem, "stem");
    assertPart$1(stem, "stem");
    this.path = path$4.join(this.dirname || "", stem + (this.extname || ""));
  }
  toString(encoding) {
    return (this.value || "").toString(encoding);
  }
  message(reason, place, origin) {
    const message = new VFileMessage$1(reason, place, origin);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  info(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = null;
    return message;
  }
  fail(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = true;
    throw message;
  }
}
function assertPart$1(part, name) {
  if (part && part.includes(path$4.sep)) {
    throw new Error(
      "`" + name + "` cannot be a path: did not expect `" + path$4.sep + "`"
    );
  }
}
function assertNonEmpty$1(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath$2(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function bail(error3) {
  if (error3) {
    throw error3;
  }
}
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty$1 = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray$4 = function isArray(arr2) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr2);
  }
  return toStr.call(arr2) === "[object Array]";
};
var isPlainObject$1 = function isPlainObject(obj) {
  if (!obj || toStr.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key;
  for (key in obj) {
  }
  return typeof key === "undefined" || hasOwn.call(obj, key);
};
var setProperty = function setProperty2(target, options) {
  if (defineProperty$1 && options.name === "__proto__") {
    defineProperty$1(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  } else {
    target[options.name] = options.newValue;
  }
};
var getProperty = function getProperty2(obj, name) {
  if (name === "__proto__") {
    if (!hasOwn.call(obj, name)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj, name).value;
    }
  }
  return obj[name];
};
var extend = function extend2() {
  var options, name, src, copy2, copyIsArray, clone2;
  var target = arguments[0];
  var i = 1;
  var length2 = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i < length2; ++i) {
    options = arguments[i];
    if (options != null) {
      for (name in options) {
        src = getProperty(target, name);
        copy2 = getProperty(options, name);
        if (target !== copy2) {
          if (deep && copy2 && (isPlainObject$1(copy2) || (copyIsArray = isArray$4(copy2)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone2 = src && isArray$4(src) ? src : [];
            } else {
              clone2 = src && isPlainObject$1(src) ? src : {};
            }
            setProperty(target, { name, newValue: extend2(deep, clone2, copy2) });
          } else if (typeof copy2 !== "undefined") {
            setProperty(target, { name, newValue: copy2 });
          }
        }
      }
    }
  }
  return target;
};
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype2 = Object.getPrototypeOf(value);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next2(null, ...values);
    function next2(error3, ...output2) {
      const fn2 = fns[++middlewareIndex];
      let index2 = -1;
      if (error3) {
        callback(error3);
        return;
      }
      while (++index2 < values.length) {
        if (output2[index2] === null || output2[index2] === void 0) {
          output2[index2] = values[index2];
        }
      }
      values = output2;
      if (fn2) {
        wrap$1(fn2, next2)(...output2);
      } else {
        callback(null, ...output2);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap$1(middleware2, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware2.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware2.apply(this, parameters);
    } catch (error3) {
      const exception = error3;
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result instanceof Promise) {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error3, ...output2) {
    if (!called) {
      called = true;
      callback(error3, ...output2);
    }
  }
  function then(value) {
    done(null, value);
  }
}
class VFileMessage extends Error {
  constructor(reason, place, origin) {
    const parts = [null, null];
    let position2 = {
      start: { line: null, column: null },
      end: { line: null, column: null }
    };
    super();
    if (typeof place === "string") {
      origin = place;
      place = void 0;
    }
    if (typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index2);
        parts[1] = origin.slice(index2 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position2 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position2 = place;
      } else if ("line" in place || "column" in place) {
        position2.start = place;
      }
    }
    this.name = stringifyPosition(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = typeof reason === "object" ? reason.stack : "";
    this.reason = this.message;
    this.fatal;
    this.line = position2.start.line;
    this.column = position2.start.column;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.position = position2;
    this.actual;
    this.expected;
    this.file;
    this.url;
    this.note;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;
const path$3 = { basename, dirname, extname, join, sep: "/" };
function basename(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$1(path2);
  let start = 0;
  let end = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index2--) {
      if (path2.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path2.charCodeAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path2.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end = index2;
          }
        } else {
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname(path2) {
  assertPath$1(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.charCodeAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname(path2) {
  assertPath$1(path2);
  let index2 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path2.charCodeAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath$1(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize$2(joined);
}
function normalize$2(path2) {
  assertPath$1(path2);
  const absolute = path2.charCodeAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.charCodeAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code2 = path2.charCodeAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1)
        ;
      else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath$1(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}
const proc = { cwd };
function cwd() {
  return "/";
}
function isUrl(fileURLOrPath) {
  return fileURLOrPath !== null && typeof fileURLOrPath === "object" && fileURLOrPath.href && fileURLOrPath.origin;
}
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error3 = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error3.code = "ERR_INVALID_ARG_TYPE";
    throw error3;
  }
  if (path2.protocol !== "file:") {
    const error3 = new TypeError("The URL must be of scheme file");
    error3.code = "ERR_INVALID_URL_SCHEME";
    throw error3;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url2) {
  if (url2.hostname !== "") {
    const error3 = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error3.code = "ERR_INVALID_FILE_URL_HOST";
    throw error3;
  }
  const pathname = url2.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
      const third = pathname.charCodeAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error3 = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error3.code = "ERR_INVALID_FILE_URL_PATH";
        throw error3;
      }
    }
  }
  return decodeURIComponent(pathname);
}
const order = ["history", "path", "basename", "stem", "extname", "dirname"];
class VFile {
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (typeof value === "string" || isBuffer$3(value)) {
      options = { value };
    } else if (isUrl(value)) {
      options = { path: value };
    } else {
      options = value;
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = proc.cwd();
    this.value;
    this.stored;
    this.result;
    this.map;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop2 = order[index2];
      if (prop2 in options && options[prop2] !== void 0) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order.includes(prop))
        this[prop] = options[prop];
    }
  }
  get path() {
    return this.history[this.history.length - 1];
  }
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  get dirname() {
    return typeof this.path === "string" ? path$3.dirname(this.path) : void 0;
  }
  set dirname(dirname2) {
    assertPath(this.basename, "dirname");
    this.path = path$3.join(dirname2 || "", this.basename);
  }
  get basename() {
    return typeof this.path === "string" ? path$3.basename(this.path) : void 0;
  }
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path$3.join(this.dirname || "", basename2);
  }
  get extname() {
    return typeof this.path === "string" ? path$3.extname(this.path) : void 0;
  }
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath(this.dirname, "extname");
    if (extname2) {
      if (extname2.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path$3.join(this.dirname, this.stem + (extname2 || ""));
  }
  get stem() {
    return typeof this.path === "string" ? path$3.basename(this.path, this.extname) : void 0;
  }
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path$3.join(this.dirname || "", stem + (this.extname || ""));
  }
  toString(encoding) {
    return (this.value || "").toString(encoding);
  }
  message(reason, place, origin) {
    const message = new VFileMessage(reason, place, origin);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  info(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = null;
    return message;
  }
  fail(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = true;
    throw message;
  }
}
function assertPart(part, name) {
  if (part && part.includes(path$3.sep)) {
    throw new Error(
      "`" + name + "` cannot be a path: did not expect `" + path$3.sep + "`"
    );
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
const unified = base().freeze();
const own$8 = {}.hasOwnProperty;
function base() {
  const transformers = trough();
  const attachers = [];
  let namespace = {};
  let frozen;
  let freezeIndex = -1;
  processor.data = data2;
  processor.Parser = void 0;
  processor.Compiler = void 0;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse2;
  processor.stringify = stringify2;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    const destination = base();
    let index2 = -1;
    while (++index2 < attachers.length) {
      destination.use(...attachers[index2]);
    }
    destination.data(extend(true, {}, namespace));
    return destination;
  }
  function data2(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key] = value;
        return processor;
      }
      return own$8.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function freeze() {
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(processor, ...options);
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;
    return processor;
  }
  function use(value, ...options) {
    let settings;
    assertUnfrozen("use", frozen);
    if (value === null || value === void 0)
      ;
    else if (typeof value === "function") {
      addPlugin(value, ...options);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings);
    }
    return processor;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...options2] = value2;
          addPlugin(plugin, ...options2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }
    function addList(plugins2) {
      let index2 = -1;
      if (plugins2 === null || plugins2 === void 0)
        ;
      else if (Array.isArray(plugins2)) {
        while (++index2 < plugins2.length) {
          const thing = plugins2[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins2 + "`");
      }
    }
    function addPlugin(plugin, value2) {
      let index2 = -1;
      let entry;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entry = attachers[index2];
          break;
        }
      }
      if (entry) {
        if (isPlainObject2(entry[1]) && isPlainObject2(value2)) {
          value2 = extend(true, entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push([...arguments]);
      }
    }
  }
  function parse2(doc) {
    processor.freeze();
    const file = vfile(doc);
    const Parser2 = processor.Parser;
    assertParser("parse", Parser2);
    if (newable(Parser2, "parse")) {
      return new Parser2(String(file), file).parse();
    }
    return Parser2(String(file), file);
  }
  function stringify2(node2, doc) {
    processor.freeze();
    const file = vfile(doc);
    const Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node2);
    if (newable(Compiler, "compile")) {
      return new Compiler(node2, file).compile();
    }
    return Compiler(node2, file);
  }
  function run(node2, doc, callback) {
    assertNode(node2);
    processor.freeze();
    if (!callback && typeof doc === "function") {
      callback = doc;
      doc = void 0;
    }
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      transformers.run(node2, vfile(doc), done);
      function done(error3, tree, file) {
        tree = tree || node2;
        if (error3) {
          reject(error3);
        } else if (resolve) {
          resolve(tree);
        } else {
          callback(null, tree, file);
        }
      }
    }
  }
  function runSync(node2, file) {
    let result;
    let complete;
    processor.run(node2, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(error3, tree) {
      bail(error3);
      result = tree;
      complete = true;
    }
  }
  function process2(doc, callback) {
    processor.freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      const file = vfile(doc);
      processor.run(processor.parse(file), file, (error3, tree, file2) => {
        if (error3 || !tree || !file2) {
          done(error3);
        } else {
          const result = processor.stringify(tree, file2);
          if (result === void 0 || result === null)
            ;
          else if (looksLikeAVFileValue(result)) {
            file2.value = result;
          } else {
            file2.result = result;
          }
          done(error3, file2);
        }
      });
      function done(error3, file2) {
        if (error3 || !file2) {
          reject(error3);
        } else if (resolve) {
          resolve(file2);
        } else {
          callback(null, file2);
        }
      }
    }
  }
  function processSync(doc) {
    let complete;
    processor.freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    const file = vfile(doc);
    processor.process(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(error3) {
      complete = true;
      bail(error3);
    }
  }
}
function newable(value, name) {
  return typeof value === "function" && value.prototype && (keys$2(value.prototype) || name in value.prototype);
}
function keys$2(value) {
  let key;
  for (key in value) {
    if (own$8.call(value, key)) {
      return true;
    }
  }
  return false;
}
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject2(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAVFileValue(value) {
  return typeof value === "string" || isBuffer$3(value);
}
function toString(node2, options) {
  var { includeImageAlt = true } = options || {};
  return one$1(node2, includeImageAlt);
}
function one$1(node2, includeImageAlt) {
  return node2 && typeof node2 === "object" && (node2.value || (includeImageAlt ? node2.alt : "") || "children" in node2 && all$1(node2.children, includeImageAlt) || Array.isArray(node2) && all$1(node2, includeImageAlt)) || "";
}
function all$1(values, includeImageAlt) {
  var result = [];
  var index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one$1(values[index2], includeImageAlt);
  }
  return result.join("");
}
function splice$1(list2, start, remove3, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove3 = remove3 > 0 ? remove3 : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove3);
    [].splice.apply(list2, parameters);
  } else {
    if (remove3)
      [].splice.apply(list2, [start, remove3]);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      [].splice.apply(list2, parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list2, items) {
  if (list2.length > 0) {
    splice$1(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}
const hasOwnProperty$9 = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe2 = hasOwnProperty$9.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe2 || (all2[hook] = {});
    const right = extension2[hook];
    let code2;
    for (code2 in right) {
      if (!hasOwnProperty$9.call(left, code2))
        left[code2] = [];
      const value = right[code2];
      constructs(
        left[code2],
        Array.isArray(value) ? value : value ? [value] : []
      );
    }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice$1(existing, 0, 0, before);
}
const unicodePunctuationRegex = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
const asciiAlpha = regexCheck(/[A-Za-z]/);
const asciiDigit = regexCheck(/\d/);
const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return code2 !== null && (code2 < 32 || code2 === 127);
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
const unicodeWhitespace = regexCheck(/\s/);
const unicodePunctuation = regexCheck(unicodePunctuationRegex);
function regexCheck(regex) {
  return check2;
  function check2(code2) {
    return code2 !== null && regex.test(String.fromCharCode(code2));
  }
}
function factorySpace(effects, ok2, type4, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type4);
      return prefix2(code2);
    }
    return ok2(code2);
  }
  function prefix2(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix2;
    }
    effects.exit(type4);
    return ok2(code2);
  }
}
const content$1 = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    effects.enter("paragraph");
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token2 = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token2;
    }
    previous2 = token2;
    return data2(code2);
  }
  function data2(code2) {
    if (code2 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return data2;
  }
}
const document$2 = {
  tokenize: initializeDocument
};
const containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          point2 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice$1(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
      return checkNewContainers(code2);
    }
    return start(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code2);
  }
  function containerContinue(code2) {
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self2.interrupt = void 0;
      return start;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token2, eof) {
    const stream = self2.sliceStream(token2);
    if (eof)
      stream.push(null);
    token2.previous = childToken;
    if (childToken)
      childToken.next = token2;
    childToken = token2;
    childFlow.defineSkip(token2.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token2.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (childFlow.events[index2][1].start.offset < lineStartOffset && (!childFlow.events[index2][1].end || childFlow.events[index2][1].end.offset > lineStartOffset)) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point2 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice$1(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok2, nok),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return 1;
  }
  if (unicodePunctuation(code2)) {
    return 2;
  }
}
function resolveAll(constructs2, events, context2) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context2);
      called.push(resolve);
    }
  }
  return events;
}
const attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context2) {
  let index2 = -1;
  let open;
  let group2;
  let text2;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset3;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context2.sliceSerialize(events[open][1]).charCodeAt(0) === context2.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index2][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end
          };
          text2 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group2 = {
            type: use > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context2],
              ["exit", events[open][1], context2]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group2, context2],
            ["enter", openingSequence, context2],
            ["exit", openingSequence, context2],
            ["enter", text2, context2]
          ]);
          nextEvents = push(
            nextEvents,
            resolveAll(
              context2.parser.constructs.insideSpan.null,
              events.slice(open + 1, index2),
              context2
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text2, context2],
            ["enter", closingSequence, context2],
            ["exit", closingSequence, context2],
            ["exit", group2, context2]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset3 = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context2],
              ["exit", events[index2][1], context2]
            ]);
          } else {
            offset3 = 0;
          }
          splice$1(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset3 - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start;
  function start(code2) {
    effects.enter("attentionSequence");
    marker = code2;
    return sequence(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return sequence;
    }
    const token2 = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
    const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
    token2._open = Boolean(marker === 42 ? open : open && (before || !close));
    token2._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok2(code2);
  }
}
function movePoint(point2, offset3) {
  point2.column += offset3;
  point2.offset += offset3;
  point2._bufferIndex += offset3;
}
const autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size = 1;
  return start;
  function start(code2) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return asciiAtext(code2) ? emailAtext(code2) : nok(code2);
  }
  function schemeOrEmailAtext(code2) {
    return code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2) ? schemeInsideOrEmailAtext(code2) : emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      return urlInside;
    }
    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === 62) {
      effects.exit("autolinkProtocol");
      return end(code2);
    }
    if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === 64) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      return end(code2);
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
      effects.consume(code2);
      return code2 === 45 ? emailValue : emailLabel;
    }
    return nok(code2);
  }
  function end(code2) {
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.exit("autolink");
    return ok2;
  }
}
const blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok2, nok) {
  return factorySpace(effects, afterWhitespace, "linePrefix");
  function afterWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit: exit$1
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 === 62) {
      const state = self2.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code2);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code2);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  return factorySpace(
    effects,
    effects.attempt(blockQuote, ok2, nok),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function exit$1(effects) {
  effects.exit("blockQuote");
}
const characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    effects.exit("escapeMarker");
    return open;
  }
  function open(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter("characterEscapeValue");
      effects.consume(code2);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code2);
  }
}
const element = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element.innerHTML = characterReference2;
  const char2 = element.textContent;
  if (char2.charCodeAt(char2.length - 1) === 59 && value !== "semi") {
    return false;
  }
  return char2 === characterReference2 ? false : char2;
}
const characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let max;
  let test;
  return start;
  function start(code2) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code2);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric;
    return value(code2);
  }
  function numeric(code2) {
    if (code2 === 88 || code2 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit;
    return value(code2);
  }
  function value(code2) {
    let token2;
    if (code2 === 59 && size) {
      token2 = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token2))) {
        return nok(code2);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test(code2) && size++ < max) {
      effects.consume(code2);
      return value;
    }
    return nok(code2);
  }
}
const codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self2 = this;
  const closingFenceConstruct = {
    tokenize: tokenizeClosingFence,
    partial: true
  };
  const nonLazyLine = {
    tokenize: tokenizeNonLazyLine,
    partial: true
  };
  const tail = this.events[this.events.length - 1];
  const initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    marker = code2;
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeFencedFenceSequence");
    return sizeOpen < 3 ? nok(code2) : factorySpace(effects, infoOpen, "whitespace")(code2);
  }
  function infoOpen(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return openAfter(code2);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code2);
  }
  function info(code2) {
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, infoAfter, "whitespace")(code2);
    }
    if (code2 === 96 && code2 === marker)
      return nok(code2);
    effects.consume(code2);
    return info;
  }
  function infoAfter(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return openAfter(code2);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return openAfter(code2);
    }
    if (code2 === 96 && code2 === marker)
      return nok(code2);
    effects.consume(code2);
    return meta;
  }
  function openAfter(code2) {
    effects.exit("codeFencedFence");
    return self2.interrupt ? ok2(code2) : contentStart(code2);
  }
  function contentStart(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(
        nonLazyLine,
        effects.attempt(
          closingFenceConstruct,
          after,
          initialPrefix ? factorySpace(
            effects,
            contentStart,
            "linePrefix",
            initialPrefix + 1
          ) : contentStart
        ),
        after
      )(code2);
    }
    effects.enter("codeFlowValue");
    return contentContinue(code2);
  }
  function contentContinue(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return contentStart(code2);
    }
    effects.consume(code2);
    return contentContinue;
  }
  function after(code2) {
    effects.exit("codeFenced");
    return ok2(code2);
  }
  function tokenizeNonLazyLine(effects2, ok3, nok2) {
    const self3 = this;
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code2) {
      return self3.parser.lazy[self3.now().line] ? nok2(code2) : ok3(code2);
    }
  }
  function tokenizeClosingFence(effects2, ok3, nok2) {
    let size = 0;
    return factorySpace(
      effects2,
      closingSequenceStart,
      "linePrefix",
      this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    );
    function closingSequenceStart(code2) {
      effects2.enter("codeFencedFence");
      effects2.enter("codeFencedFenceSequence");
      return closingSequence(code2);
    }
    function closingSequence(code2) {
      if (code2 === marker) {
        effects2.consume(code2);
        size++;
        return closingSequence;
      }
      if (size < sizeOpen)
        return nok2(code2);
      effects2.exit("codeFencedFenceSequence");
      return factorySpace(effects2, closingSequenceEnd, "whitespace")(code2);
    }
    function closingSequenceEnd(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("codeFencedFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
const codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
const indentedContent = {
  tokenize: tokenizeIndentedContent,
  partial: true
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterStartPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterStartPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code2) : nok(code2);
  }
  function afterPrefix(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(indentedContent, afterPrefix, after)(code2);
    }
    effects.enter("codeFlowValue");
    return content2(code2);
  }
  function content2(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return afterPrefix(code2);
    }
    effects.consume(code2);
    return content2;
  }
  function after(code2) {
    effects.exit("codeIndented");
    return ok2(code2);
  }
}
function tokenizeIndentedContent(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return start;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? start(code2) : nok(code2);
  }
}
const codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous: previous$1
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous$1(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  let sizeOpen = 0;
  let size;
  let token2;
  return start;
  function start(code2) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return openingSequence(code2);
  }
  function openingSequence(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      sizeOpen++;
      return openingSequence;
    }
    effects.exit("codeTextSequence");
    return gap(code2);
  }
  function gap(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 96) {
      token2 = effects.enter("codeTextSequence");
      size = 0;
      return closingSequence(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return gap;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return gap;
    }
    effects.enter("codeTextData");
    return data2(code2);
  }
  function data2(code2) {
    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
      effects.exit("codeTextData");
      return gap(code2);
    }
    effects.consume(code2);
    return data2;
  }
  function closingSequence(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      size++;
      return closingSequence;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code2);
    }
    token2.type = "codeTextData";
    return data2(code2);
  }
}
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice$1(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token2 = events[eventIndex][1];
  const context2 = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token2._tokenizer || context2.parser[token2.contentType](token2.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token2;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context2.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token2;
  while (++index2 < childEvents.length) {
    if (childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line) {
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice2 = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    jumps.unshift([start2, start2 + slice2.length - 1]);
    splice$1(events, start2, 2, slice2);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}
const content = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
const continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous2;
  return start;
  function start(code2) {
    effects.enter("content");
    previous2 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return data2(code2);
  }
  function data2(code2) {
    if (code2 === null) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code2);
    }
    effects.consume(code2);
    return data2;
  }
  function contentEnd(code2) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code2);
  }
  function contentContinue(code2) {
    effects.consume(code2);
    effects.exit("chunkContent");
    previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    });
    previous2 = previous2.next;
    return data2;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok2(code2);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
  }
}
function factoryDestination(effects, ok2, nok, type4, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code2) {
    if (code2 === 60) {
      effects.enter(type4);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return destinationEnclosedBefore;
    }
    if (code2 === null || code2 === 41 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type4);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationRaw(code2);
  }
  function destinationEnclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type4);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationEnclosed(code2);
  }
  function destinationEnclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return destinationEnclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? destinationEnclosedEscape : destinationEnclosed;
  }
  function destinationEnclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return destinationEnclosed;
    }
    return destinationEnclosed(code2);
  }
  function destinationRaw(code2) {
    if (code2 === 40) {
      if (++balance > limit)
        return nok(code2);
      effects.consume(code2);
      return destinationRaw;
    }
    if (code2 === 41) {
      if (!balance--) {
        effects.exit("chunkString");
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type4);
        return ok2(code2);
      }
      effects.consume(code2);
      return destinationRaw;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      if (balance)
        return nok(code2);
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type4);
      return ok2(code2);
    }
    if (asciiControl(code2))
      return nok(code2);
    effects.consume(code2);
    return code2 === 92 ? destinationRawEscape : destinationRaw;
  }
  function destinationRawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return destinationRaw;
    }
    return destinationRaw(code2);
  }
}
function factoryLabel(effects, ok2, nok, type4, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let data2;
  return start;
  function start(code2) {
    effects.enter(type4);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 && !data2 || code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs || size > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type4);
      return ok2;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return label(code2);
  }
  function label(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    data2 = data2 || !markdownSpace(code2);
    return code2 === 92 ? labelEscape : label;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return label;
    }
    return label(code2);
  }
}
function factoryTitle(effects, ok2, nok, type4, markerType, stringType) {
  let marker;
  return start;
  function start(code2) {
    effects.enter(type4);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    marker = code2 === 40 ? 41 : code2;
    return atFirstTitleBreak;
  }
  function atFirstTitleBreak(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type4);
      return ok2;
    }
    effects.enter(stringType);
    return atTitleBreak(code2);
  }
  function atTitleBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return atFirstTitleBreak(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, atTitleBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return title(code2);
  }
  function title(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      return atTitleBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? titleEscape : title;
  }
  function titleEscape(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return title;
    }
    return title(code2);
  }
}
function factoryWhitespace(effects, ok2) {
  let seen;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        start,
        seen ? "linePrefix" : "lineSuffix"
      )(code2);
    }
    return ok2(code2);
  }
}
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
const titleConstruct = {
  tokenize: tokenizeTitle,
  partial: true
};
function tokenizeDefinition(effects, ok2, nok) {
  const self2 = this;
  let identifier2;
  return start;
  function start(code2) {
    effects.enter("definition");
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      nok,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(code2);
  }
  function labelAfter(code2) {
    identifier2 = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return factoryWhitespace(
        effects,
        factoryDestination(
          effects,
          effects.attempt(
            titleConstruct,
            factorySpace(effects, after, "whitespace"),
            factorySpace(effects, after, "whitespace")
          ),
          nok,
          "definitionDestination",
          "definitionDestinationLiteral",
          "definitionDestinationLiteralMarker",
          "definitionDestinationRaw",
          "definitionDestinationString"
        )
      );
    }
    return nok(code2);
  }
  function after(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("definition");
      if (!self2.parser.defined.includes(identifier2)) {
        self2.parser.defined.push(identifier2);
      }
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitle(effects, ok2, nok) {
  return start;
  function start(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, before)(code2) : nok(code2);
  }
  function before(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(
        effects,
        factorySpace(effects, after, "whitespace"),
        nok,
        "definitionTitle",
        "definitionTitleMarker",
        "definitionTitleString"
      )(code2);
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("hardBreakEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit("escapeMarker");
      effects.exit("hardBreakEscape");
      return ok2(code2);
    }
    return nok(code2);
  }
}
const headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context2) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content2;
  let text2;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content2 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text2 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice$1(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content2, context2],
      ["enter", text2, context2],
      ["exit", text2, context2],
      ["exit", content2, context2]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("atxHeading");
    effects.enter("atxHeadingSequence");
    return fenceOpenInside(code2);
  }
  function fenceOpenInside(code2) {
    if (code2 === 35 && size++ < 6) {
      effects.consume(code2);
      return fenceOpenInside;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingSequence");
      return self2.interrupt ? ok2(code2) : headingBreak(code2);
    }
    return nok(code2);
  }
  function headingBreak(code2) {
    if (code2 === 35) {
      effects.enter("atxHeadingSequence");
      return sequence(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("atxHeading");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, headingBreak, "whitespace")(code2);
    }
    effects.enter("atxHeadingText");
    return data2(code2);
  }
  function sequence(code2) {
    if (code2 === 35) {
      effects.consume(code2);
      return sequence;
    }
    effects.exit("atxHeadingSequence");
    return headingBreak(code2);
  }
  function data2(code2) {
    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingText");
      return headingBreak(code2);
    }
    effects.consume(code2);
    return data2;
  }
}
const htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
const htmlRawNames = ["pre", "script", "style", "textarea"];
const htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
const nextBlankConstruct = {
  tokenize: tokenizeNextBlank,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self2 = this;
  let kind;
  let startTag;
  let buffer;
  let index2;
  let marker;
  return start;
  function start(code2) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationStart;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      kind = 3;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      startTag = true;
      return tagName;
    }
    return nok(code2);
  }
  function declarationStart(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      kind = 2;
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      kind = 5;
      buffer = "CDATA[";
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      kind = 4;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    if (code2 === buffer.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === buffer.length ? self2.interrupt ? ok2 : continuation : cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      if (code2 !== 47 && startTag && htmlRawNames.includes(buffer.toLowerCase())) {
        kind = 1;
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        kind = 6;
        if (code2 === 47) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      kind = 7;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : startTag ? completeAttributeNameBefore(code2) : completeClosingTagAfter(code2);
    }
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    marker = null;
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    if (code2 === marker) {
      effects.consume(code2);
      return completeAttributeValueQuotedAfter;
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return code2 === null || markdownLineEnding(code2) ? continuation(code2) : nok(code2);
  }
  function continuation(code2) {
    if (code2 === 45 && kind === 2) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === 60 && kind === 1) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === 62 && kind === 4) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 63 && kind === 3) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === 93 && kind === 5) {
      effects.consume(code2);
      return continuationCharacterDataInside;
    }
    if (markdownLineEnding(code2) && (kind === 6 || kind === 7)) {
      return effects.check(
        nextBlankConstruct,
        continuationClose,
        continuationAtLineEnding
      )(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return continuationAtLineEnding(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationAtLineEnding(code2) {
    effects.exit("htmlFlowData");
    return htmlContinueStart(code2);
  }
  function htmlContinueStart(code2) {
    if (code2 === null) {
      return done(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(
        {
          tokenize: htmlLineEnd,
          partial: true
        },
        htmlContinueStart,
        done
      )(code2);
    }
    effects.enter("htmlFlowData");
    return continuation(code2);
  }
  function htmlLineEnd(effects2, ok3, nok2) {
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code2) {
      return self2.parser.lazy[self2.now().line] ? nok2(code2) : ok3(code2);
    }
  }
  function continuationCommentInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62 && htmlRawNames.includes(buffer.toLowerCase())) {
      effects.consume(code2);
      return continuationClose;
    }
    if (asciiAlpha(code2) && buffer.length < 8) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCharacterDataInside(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 45 && kind === 2) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return done(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function done(code2) {
    effects.exit("htmlFlow");
    return ok2(code2);
  }
}
function tokenizeNextBlank(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.exit("htmlFlowData");
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    return effects.attempt(blankLine, ok2, nok);
  }
}
const htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let buffer;
  let index2;
  let returnState;
  return start;
  function start(code2) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentOpen;
    }
    if (code2 === 91) {
      effects.consume(code2);
      buffer = "CDATA[";
      index2 = 0;
      return cdataOpen;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration2;
    }
    return nok(code2);
  }
  function commentOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentStart;
    }
    return nok(code2);
  }
  function commentStart(code2) {
    if (code2 === null || code2 === 62) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentStartDash;
    }
    return comment2(code2);
  }
  function commentStartDash(code2) {
    if (code2 === null || code2 === 62) {
      return nok(code2);
    }
    return comment2(code2);
  }
  function comment2(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment2;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return comment2;
  }
  function commentClose(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return end;
    }
    return comment2(code2);
  }
  function cdataOpen(code2) {
    if (code2 === buffer.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === buffer.length ? cdata : cdataOpen;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === 62) {
      return end(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration2(code2) {
    if (code2 === null || code2 === 62) {
      return end(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration2;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return declaration2;
  }
  function instruction(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === 62 ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return end;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    marker = void 0;
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === 62 || code2 === 47 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function atLineEnding(code2) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(
      effects,
      afterPrefix,
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    );
  }
  function afterPrefix(code2) {
    effects.enter("htmlTextData");
    return returnState(code2);
  }
  function end(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code2);
  }
}
const labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
const resourceConstruct = {
  tokenize: tokenizeResource
};
const fullReferenceConstruct = {
  tokenize: tokenizeFullReference
};
const collapsedReferenceConstruct = {
  tokenize: tokenizeCollapsedReference
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  let token2;
  while (++index2 < events.length) {
    token2 = events[index2][1];
    if (token2.type === "labelImage" || token2.type === "labelLink" || token2.type === "labelEnd") {
      events.splice(index2 + 1, token2.type === "labelImage" ? 4 : 2);
      token2.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context2) {
  let index2 = events.length;
  let offset3 = 0;
  let token2;
  let open;
  let close;
  let media;
  while (index2--) {
    token2 = events[index2][1];
    if (open) {
      if (token2.type === "link" || token2.type === "labelLink" && token2._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token2.type === "labelLink") {
        token2._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token2.type === "labelImage" || token2.type === "labelLink") && !token2._balanced) {
        open = index2;
        if (token2.type !== "labelLink") {
          offset3 = 2;
          break;
        }
      }
    } else if (token2.type === "labelEnd") {
      close = index2;
    }
  }
  const group2 = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text2 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset3 + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ["enter", group2, context2],
    ["enter", label, context2]
  ];
  media = push(media, events.slice(open + 1, open + offset3 + 3));
  media = push(media, [["enter", text2, context2]]);
  media = push(
    media,
    resolveAll(
      context2.parser.constructs.insideSpan.null,
      events.slice(open + offset3 + 4, close - 3),
      context2
    )
  );
  media = push(media, [
    ["exit", text2, context2],
    events[close - 2],
    events[close - 1],
    ["exit", label, context2]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group2, context2]]);
  splice$1(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive)
      return balanced(code2);
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({
          start: labelStart.end,
          end: self2.now()
        })
      )
    );
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return afterLabelEnd;
  }
  function afterLabelEnd(code2) {
    if (code2 === 40) {
      return effects.attempt(
        resourceConstruct,
        ok2,
        defined ? ok2 : balanced
      )(code2);
    }
    if (code2 === 91) {
      return effects.attempt(
        fullReferenceConstruct,
        ok2,
        defined ? effects.attempt(collapsedReferenceConstruct, ok2, balanced) : balanced
      )(code2);
    }
    return defined ? ok2(code2) : balanced(code2);
  }
  function balanced(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return factoryWhitespace(effects, open);
  }
  function open(code2) {
    if (code2 === 41) {
      return end(code2);
    }
    return factoryDestination(
      effects,
      destinationAfter,
      nok,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(code2);
  }
  function destinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, between)(code2) : end(code2);
  }
  function between(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(
        effects,
        factoryWhitespace(effects, end),
        nok,
        "resourceTitle",
        "resourceTitleMarker",
        "resourceTitleString"
      )(code2);
    }
    return end(code2);
  }
  function end(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeFullReference(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    return factoryLabel.call(
      self2,
      effects,
      afterLabel,
      nok,
      "reference",
      "referenceMarker",
      "referenceString"
    )(code2);
  }
  function afterLabel(code2) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok2(code2) : nok(code2);
  }
}
function tokenizeCollapsedReference(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code2);
  }
}
const labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, ok2, "linePrefix");
  }
}
const thematicBreak$1 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("thematicBreak");
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, "whitespace")(code2);
    }
    if (size < 3 || code2 !== null && !markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.exit("thematicBreak");
    return ok2(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return atBreak(code2);
  }
}
const list$1 = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
const listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
const indentConstruct = {
  tokenize: tokenizeIndent$1,
  partial: true
};
function tokenizeListStart(effects, ok2, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code2) {
    const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$1, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self2.interrupt || code2 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    if (asciiDigit(code2) && ++size < 10) {
      effects.consume(code2);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    effects.enter("listItemMarker");
    effects.consume(code2);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code2;
    return effects.check(
      blankLine,
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code2) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code2);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok2,
      "listItemIndent",
      self2.containerState.size + 1
    )(code2);
  }
  function notBlank(code2) {
    if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace(
      effects,
      effects.attempt(list$1, ok2, nok),
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(code2);
  }
}
function tokenizeIndent$1(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "listItemIndent",
    self2.containerState.size + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "listItemPrefixWhitespace",
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
  }
}
const setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context2) {
  let index2 = events.length;
  let content2;
  let text2;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content2 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text2 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  const heading2 = {
    type: "setextHeading",
    start: Object.assign({}, events[text2][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text2][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text2, 0, ["enter", heading2, context2]);
    events.splice(definition2 + 1, 0, ["exit", events[content2][1], context2]);
    events[content2][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content2][1] = heading2;
  }
  events.push(["exit", heading2, context2]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let marker;
  let paragraph2;
  while (index2--) {
    if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
      paragraph2 = self2.events[index2][1].type === "paragraph";
      break;
    }
  }
  return start;
  function start(code2) {
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter("setextHeadingLine");
      effects.enter("setextHeadingLineSequence");
      marker = code2;
      return closingSequence(code2);
    }
    return nok(code2);
  }
  function closingSequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return closingSequence;
    }
    effects.exit("setextHeadingLineSequence");
    return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code2);
  }
  function closingSequenceEnd(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("setextHeadingLine");
      return ok2(code2);
    }
    return nok(code2);
  }
}
const flow$1 = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    blankLine,
    atBlankEnding,
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content, afterConstruct)
        ),
        "linePrefix"
      )
    )
  );
  return initial;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial;
  }
}
const resolver = {
  resolveAll: createResolver()
};
const string$2 = initializeFactory("string");
const text$3 = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text2 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code2) {
      return atBreak(code2) ? text2(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("data");
      effects.consume(code2);
      return data2;
    }
    function data2(code2) {
      if (atBreak(code2)) {
        effects.exit("data");
        return text2(code2);
      }
      effects.consume(code2);
      return data2;
    }
    function atBreak(code2) {
      if (code2 === null) {
        return true;
      }
      const list2 = constructs2[code2];
      let index2 = -1;
      if (list2) {
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context2) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context2) : events;
  }
}
function resolveAllLineSuffixes(events, context2) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data2 = events[eventIndex - 1][1];
      const chunks = context2.sliceStream(data2);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1)
          ;
        else {
          index2++;
          break;
        }
      }
      if (size) {
        const token2 = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data2.end.line,
            column: data2.end.column - size,
            offset: data2.end.offset - size,
            _index: data2.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data2.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data2.end)
        };
        data2.end = Object.assign({}, token2.start);
        if (data2.start.offset === data2.end.offset) {
          Object.assign(data2, token2);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token2, context2],
            ["exit", token2, context2]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}
function createTokenizer(parser2, initialize, from2) {
  let point2 = Object.assign(
    from2 ? Object.assign({}, from2) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  const effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context2 = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: parser2,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context2, effects);
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context2;
  function write(slice2) {
    chunks = push(chunks, slice2);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context2.events = resolveAll(resolveAllConstructs, context2.events, context2);
    return context2.events;
  }
  function sliceSerialize(token2, expandTabs) {
    return serializeChunks(sliceStream(token2), expandTabs);
  }
  function sliceStream(token2) {
    return sliceChunks(chunks, token2);
  }
  function now() {
    return Object.assign({}, point2);
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point2._index < chunks.length) {
      const chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go2(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go2(chunk);
      }
    }
  }
  function go2(code2) {
    state = state(code2);
  }
  function consume(code2) {
    if (markdownLineEnding(code2)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code2 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code2 !== -1) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context2.previous = code2;
  }
  function enter(type4, fields) {
    const token2 = fields || {};
    token2.type = type4;
    token2.start = now();
    context2.events.push(["enter", token2, context2]);
    stack.push(token2);
    return token2;
  }
  function exit2(type4) {
    const token2 = stack.pop();
    token2.end = now();
    context2.events.push(["exit", token2, context2]);
    return token2;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_24, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map) {
        return start;
        function start(code2) {
          const def = code2 !== null && map[code2];
          const all2 = code2 !== null && map.null;
          const list2 = [
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code2);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context2.currentConstruct = construct;
          }
          if (construct.name && context2.parser.constructs.disable.null.includes(construct.name)) {
            return nok();
          }
          return construct.tokenize.call(
            fields ? Object.assign(Object.create(context2), fields) : context2,
            effects,
            ok2,
            nok
          )(code2);
        }
      }
      function ok2(code2) {
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from3) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice$1(
        context2.events,
        from3,
        context2.events.length - from3,
        construct.resolve(context2.events.slice(from3), context2)
      );
    }
    if (construct.resolveTo) {
      context2.events = construct.resolveTo(context2.events, context2);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context2.previous;
    const startCurrentConstruct = context2.currentConstruct;
    const startEventsIndex = context2.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point2 = startPoint;
      context2.previous = startPrevious;
      context2.currentConstruct = startCurrentConstruct;
      context2.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
function sliceChunks(chunks, token2) {
  const startIndex = token2.start._index;
  const startBufferIndex = token2.start._bufferIndex;
  const endIndex = token2.end._index;
  const endBufferIndex = token2.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      view[0] = view[0].slice(startBufferIndex);
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}
const document$1 = {
  [42]: list$1,
  [43]: list$1,
  [45]: list$1,
  [48]: list$1,
  [49]: list$1,
  [50]: list$1,
  [51]: list$1,
  [52]: list$1,
  [53]: list$1,
  [54]: list$1,
  [55]: list$1,
  [56]: list$1,
  [57]: list$1,
  [62]: blockQuote
};
const contentInitial = {
  [91]: definition
};
const flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
const flow = {
  [35]: headingAtx,
  [42]: thematicBreak$1,
  [45]: [setextUnderline, thematicBreak$1],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak$1,
  [96]: codeFenced,
  [126]: codeFenced
};
const string$1 = {
  [38]: characterReference,
  [92]: characterEscape
};
const text$2 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
const insideSpan = {
  null: [attention, resolver]
};
const attentionMarkers = {
  null: [42, 95]
};
const disable = {
  null: []
};
var defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  document: document$1,
  contentInitial,
  flowInitial,
  flow,
  string: string$1,
  text: text$2,
  insideSpan,
  attentionMarkers,
  disable
}, Symbol.toStringTag, { value: "Module" }));
function parse$2(options = {}) {
  const constructs2 = combineExtensions(
    [defaultConstructs].concat(options.extensions || [])
  );
  const parser2 = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create3(content$1),
    document: create3(document$2),
    flow: create3(flow$1),
    string: create3(string$2),
    text: create3(text$3)
  };
  return parser2;
  function create3(initial) {
    return creator;
    function creator(from2) {
      return createTokenizer(parser2, initial, from2);
    }
  }
}
const search = /[\0\t\n\r]/g;
function preprocess() {
  let column2 = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match2;
    let next2;
    let startPosition;
    let endPosition;
    let code2;
    value = buffer + value.toString(encoding);
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match2 = search.exec(value);
      endPosition = match2 && match2.index !== void 0 ? match2.index : value.length;
      code2 = value.charCodeAt(endPosition);
      if (!match2) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column2 += endPosition - startPosition;
        }
        switch (code2) {
          case 0: {
            chunks.push(65533);
            column2++;
            break;
          }
          case 9: {
            next2 = Math.ceil(column2 / 4) * 4;
            chunks.push(-2);
            while (column2++ < next2)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column2 = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column2 = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer)
        chunks.push(buffer);
      chunks.push(null);
    }
    return chunks;
  }
}
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}
function decodeNumericCharacterReference(value, base2) {
  const code2 = Number.parseInt(value, base2);
  if (code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || code2 > 126 && code2 < 160 || code2 > 55295 && code2 < 57344 || code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || code2 > 1114111) {
    return "\uFFFD";
  }
  return String.fromCharCode(code2);
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex2 = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex2 ? 2 : 1), hex2 ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}
const own$7 = {}.hasOwnProperty;
const fromMarkdown = function(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(
    postprocess(
      parse$2(options).document().write(preprocess()(value, encoding, true))
    )
  );
};
function compiler(options = {}) {
  const config = configure(
    {
      transforms: [],
      canContainEols: [
        "emphasis",
        "fragment",
        "heading",
        "paragraph",
        "strong"
      ],
      enter: {
        autolink: opener(link2),
        autolinkProtocol: onenterdata,
        autolinkEmail: onenterdata,
        atxHeading: opener(heading2),
        blockQuote: opener(blockQuote2),
        characterEscape: onenterdata,
        characterReference: onenterdata,
        codeFenced: opener(codeFlow),
        codeFencedFenceInfo: buffer,
        codeFencedFenceMeta: buffer,
        codeIndented: opener(codeFlow, buffer),
        codeText: opener(codeText2, buffer),
        codeTextData: onenterdata,
        data: onenterdata,
        codeFlowValue: onenterdata,
        definition: opener(definition2),
        definitionDestinationString: buffer,
        definitionLabelString: buffer,
        definitionTitleString: buffer,
        emphasis: opener(emphasis2),
        hardBreakEscape: opener(hardBreak2),
        hardBreakTrailing: opener(hardBreak2),
        htmlFlow: opener(html2, buffer),
        htmlFlowData: onenterdata,
        htmlText: opener(html2, buffer),
        htmlTextData: onenterdata,
        image: opener(image2),
        label: buffer,
        link: opener(link2),
        listItem: opener(listItem2),
        listItemValue: onenterlistitemvalue,
        listOrdered: opener(list2, onenterlistordered),
        listUnordered: opener(list2),
        paragraph: opener(paragraph2),
        reference: onenterreference,
        referenceString: buffer,
        resourceDestinationString: buffer,
        resourceTitleString: buffer,
        setextHeading: opener(heading2),
        strong: opener(strong2),
        thematicBreak: opener(thematicBreak2)
      },
      exit: {
        atxHeading: closer(),
        atxHeadingSequence: onexitatxheadingsequence,
        autolink: closer(),
        autolinkEmail: onexitautolinkemail,
        autolinkProtocol: onexitautolinkprotocol,
        blockQuote: closer(),
        characterEscapeValue: onexitdata,
        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
        characterReferenceValue: onexitcharacterreferencevalue,
        codeFenced: closer(onexitcodefenced),
        codeFencedFence: onexitcodefencedfence,
        codeFencedFenceInfo: onexitcodefencedfenceinfo,
        codeFencedFenceMeta: onexitcodefencedfencemeta,
        codeFlowValue: onexitdata,
        codeIndented: closer(onexitcodeindented),
        codeText: closer(onexitcodetext),
        codeTextData: onexitdata,
        data: onexitdata,
        definition: closer(),
        definitionDestinationString: onexitdefinitiondestinationstring,
        definitionLabelString: onexitdefinitionlabelstring,
        definitionTitleString: onexitdefinitiontitlestring,
        emphasis: closer(),
        hardBreakEscape: closer(onexithardbreak),
        hardBreakTrailing: closer(onexithardbreak),
        htmlFlow: closer(onexithtmlflow),
        htmlFlowData: onexitdata,
        htmlText: closer(onexithtmltext),
        htmlTextData: onexitdata,
        image: closer(onexitimage),
        label: onexitlabel,
        labelText: onexitlabeltext,
        lineEnding: onexitlineending,
        link: closer(onexitlink),
        listItem: closer(),
        listOrdered: closer(),
        listUnordered: closer(),
        paragraph: closer(),
        referenceString: onexitreferencestring,
        resourceDestinationString: onexitresourcedestinationstring,
        resourceTitleString: onexitresourcetitlestring,
        resource: onexitresource,
        setextHeading: closer(onexitsetextheading),
        setextHeadingLineSequence: onexitsetextheadinglinesequence,
        setextHeadingText: onexitsetextheadingtext,
        strong: closer(),
        thematicBreak: closer()
      }
    },
    options.mdastExtensions || []
  );
  const data2 = {};
  return compile2;
  function compile2(events) {
    let tree = {
      type: "root",
      children: []
    };
    const stack = [tree];
    const tokenStack = [];
    const listStack = [];
    const context2 = {
      stack,
      tokenStack,
      config,
      enter,
      exit: exit2,
      buffer,
      resume,
      setData,
      getData
    };
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own$7.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(
          Object.assign(
            {
              sliceSerialize: events[index2][2].sliceSerialize
            },
            context2
          ),
          events[index2][1]
        );
      }
    }
    if (tokenStack.length > 0) {
      const tail = tokenStack[tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context2, void 0, tail[0]);
    }
    tree.position = {
      start: point2(
        events.length > 0 ? events[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: point2(
        events.length > 0 ? events[events.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length2) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length2) {
      const event = events[index2];
      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === "lineEndingBlank") {
        if (event[0] === "enter") {
          if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index2;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace")
        ;
      else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")
              ;
            else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length2++;
        }
        if (event[1].type === "listItemPrefix") {
          listItem3 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start)
          };
          events.splice(index2, 0, ["enter", listItem3, event[2]]);
          index2++;
          length2++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length2;
  }
  function setData(key, value) {
    data2[key] = value;
  }
  function getData(key) {
    return data2[key];
  }
  function point2(d2) {
    return {
      line: d2.line,
      column: d2.column,
      offset: d2.offset
    };
  }
  function opener(create3, and) {
    return open;
    function open(token2) {
      enter.call(this, create3(token2), token2);
      if (and)
        and.call(this, token2);
    }
  }
  function buffer() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node2, token2, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    parent.children.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token2, errorHandler]);
    node2.position = {
      start: point2(token2.start)
    };
    return node2;
  }
  function closer(and) {
    return close;
    function close(token2) {
      if (and)
        and.call(this, token2);
      exit2.call(this, token2);
    }
  }
  function exit2(token2, onExitError) {
    const node2 = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token2.type + "` (" + stringifyPosition({
          start: token2.start,
          end: token2.end
        }) + "): it\u2019s not open"
      );
    } else if (open[0].type !== token2.type) {
      if (onExitError) {
        onExitError.call(this, token2, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token2, open[0]);
      }
    }
    node2.position.end = point2(token2.end);
    return node2;
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token2) {
    if (getData("expectingFirstListItemValue")) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token2), 10);
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.lang = data3;
  }
  function onexitcodefencedfencemeta() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.meta = data3;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside"))
      return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token2) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data3;
  }
  function onexitdefinitiondestinationstring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data3;
  }
  function onexitatxheadingsequence(token2) {
    const node2 = this.stack[this.stack.length - 1];
    if (!node2.depth) {
      const depth = this.sliceSerialize(token2).length;
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token2) {
    const node2 = this.stack[this.stack.length - 1];
    node2.depth = this.sliceSerialize(token2).charCodeAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token2) {
    const parent = this.stack[this.stack.length - 1];
    let tail = parent.children[parent.children.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text2();
      tail.position = {
        start: point2(token2.start)
      };
      parent.children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token2) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token2);
    tail.position.end = point2(token2.end);
  }
  function onexitlineending(token2) {
    const context2 = this.stack[this.stack.length - 1];
    if (getData("atHardBreak")) {
      const tail = context2.children[context2.children.length - 1];
      tail.position.end = point2(token2.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context2.type)) {
      onenterdata.call(this, token2);
      onexitdata.call(this, token2);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3;
  }
  function onexithtmltext() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3;
  }
  function onexitcodetext() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3;
  }
  function onexitlink() {
    const context2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context2.type += "Reference";
      context2.referenceType = getData("referenceType") || "shortcut";
      delete context2.url;
      delete context2.title;
    } else {
      delete context2.identifier;
      delete context2.label;
    }
    setData("referenceType");
  }
  function onexitimage() {
    const context2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context2.type += "Reference";
      context2.referenceType = getData("referenceType") || "shortcut";
      delete context2.url;
      delete context2.title;
    } else {
      delete context2.identifier;
      delete context2.label;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token2) {
    const ancestor = this.stack[this.stack.length - 2];
    const string3 = this.sliceSerialize(token2);
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    setData("inReference", true);
    if (node2.type === "link") {
      node2.children = fragment.children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data3;
  }
  function onexitresourcetitlestring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data3;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token2) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token2) {
    setData("characterReferenceType", token2.type);
  }
  function onexitcharacterreferencevalue(token2) {
    const data3 = this.sliceSerialize(token2);
    const type4 = getData("characterReferenceType");
    let value;
    if (type4) {
      value = decodeNumericCharacterReference(
        data3,
        type4 === "characterReferenceMarkerNumeric" ? 10 : 16
      );
      setData("characterReferenceType");
    } else {
      value = decodeNamedCharacterReference(data3);
    }
    const tail = this.stack.pop();
    tail.value += value;
    tail.position.end = point2(token2.end);
  }
  function onexitautolinkprotocol(token2) {
    onexitdata.call(this, token2);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = this.sliceSerialize(token2);
  }
  function onexitautolinkemail(token2) {
    onexitdata.call(this, token2);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = "mailto:" + this.sliceSerialize(token2);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading2() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function hardBreak2() {
    return {
      type: "break"
    };
  }
  function html2() {
    return {
      type: "html",
      value: ""
    };
  }
  function image2() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link2() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token2) {
    return {
      type: "list",
      ordered: token2.type === "listOrdered",
      start: null,
      spread: token2._spread,
      children: []
    };
  }
  function listItem2(token2) {
    return {
      type: "listItem",
      spread: token2._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong2() {
    return {
      type: "strong",
      children: []
    };
  }
  function text2() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension$1(combined, value);
    }
  }
  return combined;
}
function extension$1(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own$7.call(extension2, key)) {
      const list2 = key === "canContainEols" || key === "transforms";
      const maybe2 = own$7.call(combined, key) ? combined[key] : void 0;
      const left = maybe2 || (combined[key] = list2 ? [] : {});
      const right = extension2[key];
      if (right) {
        if (list2) {
          combined[key] = [...left, ...right];
        } else {
          Object.assign(left, right);
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({
        start: left.start,
        end: left.end
      }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is still open"
    );
  }
}
function remarkParse(options) {
  const parser2 = (doc) => {
    const settings = this.data("settings");
    return fromMarkdown(
      doc,
      Object.assign({}, settings, options, {
        extensions: this.data("micromarkExtensions") || [],
        mdastExtensions: this.data("fromMarkdownExtensions") || []
      })
    );
  };
  Object.assign(this, { Parser: parser2 });
}
var u$1 = function(type4, props, value) {
  var node2 = { type: String(type4) };
  if ((value === void 0 || value === null) && (typeof props === "string" || Array.isArray(props))) {
    value = props;
  } else {
    Object.assign(node2, props);
  }
  if (Array.isArray(value)) {
    node2.children = value;
  } else if (value !== void 0 && value !== null) {
    node2.value = String(value);
  }
  return node2;
};
const own$6 = {}.hasOwnProperty;
function unknown(h2, node2) {
  const data2 = node2.data || {};
  if ("value" in node2 && !(own$6.call(data2, "hName") || own$6.call(data2, "hProperties") || own$6.call(data2, "hChildren"))) {
    return h2.augment(node2, u$1("text", node2.value));
  }
  return h2(node2, "div", all(h2, node2));
}
function one(h2, node2, parent) {
  const type4 = node2 && node2.type;
  let fn2;
  if (!type4) {
    throw new Error("Expected node, got `" + node2 + "`");
  }
  if (own$6.call(h2.handlers, type4)) {
    fn2 = h2.handlers[type4];
  } else if (h2.passThrough && h2.passThrough.includes(type4)) {
    fn2 = returnNode;
  } else {
    fn2 = h2.unknownHandler;
  }
  return (typeof fn2 === "function" ? fn2 : unknown)(h2, node2, parent);
}
function returnNode(h2, node2) {
  return "children" in node2 ? { ...node2, children: all(h2, node2) } : node2;
}
function all(h2, parent) {
  const values = [];
  if ("children" in parent) {
    const nodes = parent.children;
    let index2 = -1;
    while (++index2 < nodes.length) {
      const result = one(h2, nodes[index2], parent);
      if (result) {
        if (index2 && nodes[index2 - 1].type === "break") {
          if (!Array.isArray(result) && result.type === "text") {
            result.value = result.value.replace(/^\s+/, "");
          }
          if (!Array.isArray(result) && result.type === "element") {
            const head = result.children[0];
            if (head && head.type === "text") {
              head.value = head.value.replace(/^\s+/, "");
            }
          }
        }
        if (Array.isArray(result)) {
          values.push(...result);
        } else {
          values.push(result);
        }
      }
    }
  }
  return values;
}
const convert$1 = function(test) {
  if (test === void 0 || test === null) {
    return ok$1;
  }
  if (typeof test === "string") {
    return typeFactory$1(test);
  }
  if (typeof test === "object") {
    return Array.isArray(test) ? anyFactory$1(test) : propsFactory$1(test);
  }
  if (typeof test === "function") {
    return castFactory$1(test);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory$1(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert$1(tests[index2]);
  }
  return castFactory$1(any3);
  function any3(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory$1(check2) {
  return castFactory$1(all2);
  function all2(node2) {
    let key;
    for (key in check2) {
      if (node2[key] !== check2[key])
        return false;
    }
    return true;
  }
}
function typeFactory$1(check2) {
  return castFactory$1(type4);
  function type4(node2) {
    return node2 && node2.type === check2;
  }
}
function castFactory$1(check2) {
  return assertion;
  function assertion(...parameters) {
    return Boolean(check2.call(this, ...parameters));
  }
}
function ok$1() {
  return true;
}
function color$1(d2) {
  return d2;
}
const CONTINUE = true;
const SKIP = "skip";
const EXIT = false;
const visitParents = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  const is = convert$1(test);
  const step = reverse ? -1 : 1;
  factory2(tree, null, [])();
  function factory2(node2, index2, parents) {
    const value = typeof node2 === "object" && node2 !== null ? node2 : {};
    let name;
    if (typeof value.type === "string") {
      name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
      Object.defineProperty(visit3, "name", {
        value: "node (" + color$1(value.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit3;
    function visit3() {
      let result = [];
      let subresult;
      let offset3;
      let grandparents;
      if (!test || is(node2, index2, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if (node2.children && result[0] !== SKIP) {
        offset3 = (reverse ? node2.children.length : -1) + step;
        grandparents = parents.concat(node2);
        while (offset3 > -1 && offset3 < node2.children.length) {
          subresult = factory2(node2.children[offset3], offset3, grandparents)();
          if (subresult[0] === EXIT) {
            return subresult;
          }
          offset3 = typeof subresult[1] === "number" ? subresult[1] : offset3 + step;
        }
      }
      return result;
    }
  }
};
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}
const visit$1 = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    return visitor(
      node2,
      parent ? parent.children.indexOf(node2) : null,
      parent
    );
  }
};
const pointStart = point("start");
const pointEnd = point("end");
function point(type4) {
  return point2;
  function point2(node2) {
    const point3 = node2 && node2.position && node2.position[type4] || {};
    return {
      line: point3.line || null,
      column: point3.column || null,
      offset: point3.offset > -1 ? point3.offset : null
    };
  }
}
function generated(node2) {
  return !node2 || !node2.position || !node2.position.start || !node2.position.start.line || !node2.position.start.column || !node2.position.end || !node2.position.end.line || !node2.position.end.column;
}
const own$5 = {}.hasOwnProperty;
function definitions(node2) {
  const cache2 = /* @__PURE__ */ Object.create(null);
  if (!node2 || !node2.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  visit$1(node2, "definition", (definition3) => {
    const id = clean(definition3.identifier);
    if (id && !own$5.call(cache2, id)) {
      cache2[id] = definition3;
    }
  });
  return definition2;
  function definition2(identifier2) {
    const id = clean(identifier2);
    return id && own$5.call(cache2, id) ? cache2[id] : null;
  }
}
function clean(value) {
  return String(value || "").toUpperCase();
}
function normalizeUri(value) {
  const result = [];
  let index2 = -1;
  let start = 0;
  let skip = 0;
  while (++index2 < value.length) {
    const code2 = value.charCodeAt(index2);
    let replace2 = "";
    if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
      skip = 2;
    } else if (code2 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
        replace2 = String.fromCharCode(code2);
      }
    } else if (code2 > 55295 && code2 < 57344) {
      const next2 = value.charCodeAt(index2 + 1);
      if (code2 < 56320 && next2 > 56319 && next2 < 57344) {
        replace2 = String.fromCharCode(code2, next2);
        skip = 1;
      } else {
        replace2 = "\uFFFD";
      }
    } else {
      replace2 = String.fromCharCode(code2);
    }
    if (replace2) {
      result.push(value.slice(start, index2), encodeURIComponent(replace2));
      start = index2 + skip + 1;
      replace2 = "";
    }
    if (skip) {
      index2 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start);
}
function wrap(nodes, loose) {
  const result = [];
  let index2 = -1;
  if (loose) {
    result.push(u$1("text", "\n"));
  }
  while (++index2 < nodes.length) {
    if (index2)
      result.push(u$1("text", "\n"));
    result.push(nodes[index2]);
  }
  if (loose && nodes.length > 0) {
    result.push(u$1("text", "\n"));
  }
  return result;
}
function footer(h2) {
  let index2 = -1;
  const listItems = [];
  while (++index2 < h2.footnoteOrder.length) {
    const def = h2.footnoteById[h2.footnoteOrder[index2].toUpperCase()];
    if (!def) {
      continue;
    }
    const content2 = all(h2, def);
    const id = String(def.identifier);
    const safeId = normalizeUri(id.toLowerCase());
    let referenceIndex = 0;
    const backReferences = [];
    while (++referenceIndex <= h2.footnoteCounts[id]) {
      const backReference = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + h2.clobberPrefix + "fnref-" + safeId + (referenceIndex > 1 ? "-" + referenceIndex : ""),
          dataFootnoteBackref: true,
          className: ["data-footnote-backref"],
          ariaLabel: h2.footnoteBackLabel
        },
        children: [{ type: "text", value: "\u21A9" }]
      };
      if (referenceIndex > 1) {
        backReference.children.push({
          type: "element",
          tagName: "sup",
          children: [{ type: "text", value: String(referenceIndex) }]
        });
      }
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      backReferences.push(backReference);
    }
    const tail = content2[content2.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content2.push(...backReferences);
    }
    const listItem2 = {
      type: "element",
      tagName: "li",
      properties: { id: h2.clobberPrefix + "fn-" + safeId },
      children: wrap(content2, true)
    };
    if (def.position) {
      listItem2.position = def.position;
    }
    listItems.push(listItem2);
  }
  if (listItems.length === 0) {
    return null;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: h2.footnoteLabelTagName,
        properties: {
          ...JSON.parse(JSON.stringify(h2.footnoteLabelProperties)),
          id: "footnote-label"
        },
        children: [u$1("text", h2.footnoteLabel)]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}
function blockquote(h2, node2) {
  return h2(node2, "blockquote", wrap(all(h2, node2), true));
}
function hardBreak(h2, node2) {
  return [h2(node2, "br"), u$1("text", "\n")];
}
function code$1(h2, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const lang = node2.lang && node2.lang.match(/^[^ \t]+(?=[ \t]|$)/);
  const props = {};
  if (lang) {
    props.className = ["language-" + lang];
  }
  const code2 = h2(node2, "code", props, [u$1("text", value)]);
  if (node2.meta) {
    code2.data = { meta: node2.meta };
  }
  return h2(node2.position, "pre", [code2]);
}
function strikethrough(h2, node2) {
  return h2(node2, "del", all(h2, node2));
}
function emphasis(h2, node2) {
  return h2(node2, "em", all(h2, node2));
}
function footnoteReference(h2, node2) {
  const id = String(node2.identifier);
  const safeId = normalizeUri(id.toLowerCase());
  const index2 = h2.footnoteOrder.indexOf(id);
  let counter2;
  if (index2 === -1) {
    h2.footnoteOrder.push(id);
    h2.footnoteCounts[id] = 1;
    counter2 = h2.footnoteOrder.length;
  } else {
    h2.footnoteCounts[id]++;
    counter2 = index2 + 1;
  }
  const reuseCounter = h2.footnoteCounts[id];
  return h2(node2, "sup", [
    h2(
      node2.position,
      "a",
      {
        href: "#" + h2.clobberPrefix + "fn-" + safeId,
        id: h2.clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
        dataFootnoteRef: true,
        ariaDescribedBy: "footnote-label"
      },
      [u$1("text", String(counter2))]
    )
  ]);
}
function footnote(h2, node2) {
  const footnoteById = h2.footnoteById;
  let no2 = 1;
  while (no2 in footnoteById)
    no2++;
  const identifier2 = String(no2);
  footnoteById[identifier2] = {
    type: "footnoteDefinition",
    identifier: identifier2,
    children: [{ type: "paragraph", children: node2.children }],
    position: node2.position
  };
  return footnoteReference(h2, {
    type: "footnoteReference",
    identifier: identifier2,
    position: node2.position
  });
}
function heading(h2, node2) {
  return h2(node2, "h" + node2.depth, all(h2, node2));
}
function html$2(h2, node2) {
  return h2.dangerous ? h2.augment(node2, u$1("raw", node2.value)) : null;
}
function revert(h2, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return u$1("text", "![" + node2.alt + suffix);
  }
  const contents = all(h2, node2);
  const head = contents[0];
  if (head && head.type === "text") {
    head.value = "[" + head.value;
  } else {
    contents.unshift(u$1("text", "["));
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push(u$1("text", suffix));
  }
  return contents;
}
function imageReference(h2, node2) {
  const def = h2.definition(node2.identifier);
  if (!def) {
    return revert(h2, node2);
  }
  const props = { src: normalizeUri(def.url || ""), alt: node2.alt };
  if (def.title !== null && def.title !== void 0) {
    props.title = def.title;
  }
  return h2(node2, "img", props);
}
function image(h2, node2) {
  const props = { src: normalizeUri(node2.url), alt: node2.alt };
  if (node2.title !== null && node2.title !== void 0) {
    props.title = node2.title;
  }
  return h2(node2, "img", props);
}
function inlineCode$1(h2, node2) {
  return h2(node2, "code", [u$1("text", node2.value.replace(/\r?\n|\r/g, " "))]);
}
function linkReference(h2, node2) {
  const def = h2.definition(node2.identifier);
  if (!def) {
    return revert(h2, node2);
  }
  const props = { href: normalizeUri(def.url || "") };
  if (def.title !== null && def.title !== void 0) {
    props.title = def.title;
  }
  return h2(node2, "a", props, all(h2, node2));
}
function link(h2, node2) {
  const props = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    props.title = node2.title;
  }
  return h2(node2, "a", props, all(h2, node2));
}
function listItem$1(h2, node2, parent) {
  const result = all(h2, node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const props = {};
  const wrapped = [];
  if (typeof node2.checked === "boolean") {
    let paragraph2;
    if (result[0] && result[0].type === "element" && result[0].tagName === "p") {
      paragraph2 = result[0];
    } else {
      paragraph2 = h2(null, "p", []);
      result.unshift(paragraph2);
    }
    if (paragraph2.children.length > 0) {
      paragraph2.children.unshift(u$1("text", " "));
    }
    paragraph2.children.unshift(
      h2(null, "input", {
        type: "checkbox",
        checked: node2.checked,
        disabled: true
      })
    );
    props.className = ["task-list-item"];
  }
  let index2 = -1;
  while (++index2 < result.length) {
    const child = result[index2];
    if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
      wrapped.push(u$1("text", "\n"));
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      wrapped.push(...child.children);
    } else {
      wrapped.push(child);
    }
  }
  const tail = result[result.length - 1];
  if (tail && (loose || !("tagName" in tail) || tail.tagName !== "p")) {
    wrapped.push(u$1("text", "\n"));
  }
  return h2(node2, "li", props, wrapped);
}
function listLoose(node2) {
  let loose = node2.spread;
  const children = node2.children;
  let index2 = -1;
  while (!loose && ++index2 < children.length) {
    loose = listItemLoose(children[index2]);
  }
  return Boolean(loose);
}
function listItemLoose(node2) {
  const spread = node2.spread;
  return spread === void 0 || spread === null ? node2.children.length > 1 : spread;
}
function list(h2, node2) {
  const props = {};
  const name = node2.ordered ? "ol" : "ul";
  const items = all(h2, node2);
  let index2 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    props.start = node2.start;
  }
  while (++index2 < items.length) {
    const item = items[index2];
    if (item.type === "element" && item.tagName === "li" && item.properties && Array.isArray(item.properties.className) && item.properties.className.includes("task-list-item")) {
      props.className = ["contains-task-list"];
      break;
    }
  }
  return h2(node2, name, props, wrap(items, true));
}
function paragraph(h2, node2) {
  return h2(node2, "p", all(h2, node2));
}
function root$9(h2, node2) {
  return h2.augment(node2, u$1("root", wrap(all(h2, node2))));
}
function strong(h2, node2) {
  return h2(node2, "strong", all(h2, node2));
}
function table(h2, node2) {
  const rows = node2.children;
  let index2 = -1;
  const align = node2.align || [];
  const result = [];
  while (++index2 < rows.length) {
    const row = rows[index2].children;
    const name = index2 === 0 ? "th" : "td";
    const out = [];
    let cellIndex = -1;
    const length2 = node2.align ? align.length : row.length;
    while (++cellIndex < length2) {
      const cell = row[cellIndex];
      out.push(
        h2(cell, name, { align: align[cellIndex] }, cell ? all(h2, cell) : [])
      );
    }
    result[index2] = h2(rows[index2], "tr", wrap(out, true));
  }
  return h2(
    node2,
    "table",
    wrap(
      [h2(result[0].position, "thead", wrap([result[0]], true))].concat(
        result[1] ? h2(
          {
            start: pointStart(result[1]),
            end: pointEnd(result[result.length - 1])
          },
          "tbody",
          wrap(result.slice(1), true)
        ) : []
      ),
      true
    )
  );
}
const tab = 9;
const space = 32;
function trimLines(value) {
  const source = String(value);
  const search2 = /\r?\n|\r/g;
  let match2 = search2.exec(source);
  let last = 0;
  const lines = [];
  while (match2) {
    lines.push(
      trimLine(source.slice(last, match2.index), last > 0, true),
      match2[0]
    );
    last = match2.index + match2[0].length;
    match2 = search2.exec(source);
  }
  lines.push(trimLine(source.slice(last), last > 0, false));
  return lines.join("");
}
function trimLine(value, start, end) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start) {
    let code2 = value.codePointAt(startIndex);
    while (code2 === tab || code2 === space) {
      startIndex++;
      code2 = value.codePointAt(startIndex);
    }
  }
  if (end) {
    let code2 = value.codePointAt(endIndex - 1);
    while (code2 === tab || code2 === space) {
      endIndex--;
      code2 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}
function text$1(h2, node2) {
  return h2.augment(node2, u$1("text", trimLines(String(node2.value))));
}
function thematicBreak(h2, node2) {
  return h2(node2, "hr");
}
const handlers = {
  blockquote,
  break: hardBreak,
  code: code$1,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  footnote,
  heading,
  html: html$2,
  imageReference,
  image,
  inlineCode: inlineCode$1,
  linkReference,
  link,
  listItem: listItem$1,
  list,
  paragraph,
  root: root$9,
  strong,
  table,
  text: text$1,
  thematicBreak,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return null;
}
const own$4 = {}.hasOwnProperty;
function factory(tree, options) {
  const settings = options || {};
  const dangerous = settings.allowDangerousHtml || false;
  const footnoteById = {};
  h2.dangerous = dangerous;
  h2.clobberPrefix = settings.clobberPrefix === void 0 || settings.clobberPrefix === null ? "user-content-" : settings.clobberPrefix;
  h2.footnoteLabel = settings.footnoteLabel || "Footnotes";
  h2.footnoteLabelTagName = settings.footnoteLabelTagName || "h2";
  h2.footnoteLabelProperties = settings.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  h2.footnoteBackLabel = settings.footnoteBackLabel || "Back to content";
  h2.definition = definitions(tree);
  h2.footnoteById = footnoteById;
  h2.footnoteOrder = [];
  h2.footnoteCounts = {};
  h2.augment = augment;
  h2.handlers = { ...handlers, ...settings.handlers };
  h2.unknownHandler = settings.unknownHandler;
  h2.passThrough = settings.passThrough;
  visit$1(tree, "footnoteDefinition", (definition2) => {
    const id = String(definition2.identifier).toUpperCase();
    if (!own$4.call(footnoteById, id)) {
      footnoteById[id] = definition2;
    }
  });
  return h2;
  function augment(left, right) {
    if (left && "data" in left && left.data) {
      const data2 = left.data;
      if (data2.hName) {
        if (right.type !== "element") {
          right = {
            type: "element",
            tagName: "",
            properties: {},
            children: []
          };
        }
        right.tagName = data2.hName;
      }
      if (right.type === "element" && data2.hProperties) {
        right.properties = { ...right.properties, ...data2.hProperties };
      }
      if ("children" in right && right.children && data2.hChildren) {
        right.children = data2.hChildren;
      }
    }
    if (left) {
      const ctx = "type" in left ? left : { position: left };
      if (!generated(ctx)) {
        right.position = { start: pointStart(ctx), end: pointEnd(ctx) };
      }
    }
    return right;
  }
  function h2(node2, tagName, props, children) {
    if (Array.isArray(props)) {
      children = props;
      props = {};
    }
    return augment(node2, {
      type: "element",
      tagName,
      properties: props || {},
      children: children || []
    });
  }
}
function toHast(tree, options) {
  const h2 = factory(tree, options);
  const node2 = one(h2, tree, null);
  const foot = footer(h2);
  if (foot) {
    node2.children.push(u$1("text", "\n"), foot);
  }
  return Array.isArray(node2) ? { type: "root", children: node2 } : node2;
}
const remarkRehype = function(destination, options) {
  return destination && "run" in destination ? bridge(destination, options) : mutate(destination || options);
};
var remarkRehype$1 = remarkRehype;
function bridge(destination, options) {
  return (node2, file, next2) => {
    destination.run(toHast(node2, options), file, (error3) => {
      next2(error3);
    });
  };
}
function mutate(options) {
  return (node2) => toHast(node2, options);
}
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location2, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var PropTypes = propTypes.exports;
class Schema$1 {
  constructor(property, normal, space2) {
    this.property = property;
    this.normal = normal;
    if (space2) {
      this.space = space2;
    }
  }
}
Schema$1.prototype.property = {};
Schema$1.prototype.normal = {};
Schema$1.prototype.space = null;
function merge$2(definitions2, space2) {
  const property = {};
  const normal = {};
  let index2 = -1;
  while (++index2 < definitions2.length) {
    Object.assign(property, definitions2[index2].property);
    Object.assign(normal, definitions2[index2].normal);
  }
  return new Schema$1(property, normal, space2);
}
function normalize$1(value) {
  return value.toLowerCase();
}
class Info {
  constructor(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
}
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;
let powers = 0;
const boolean = increment();
const booleanish = increment();
const overloadedBoolean = increment();
const number$1 = increment();
const spaceSeparated = increment();
const commaSeparated = increment();
const commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
var types$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean,
  booleanish,
  overloadedBoolean,
  number: number$1,
  spaceSeparated,
  commaSeparated,
  commaOrSpaceSeparated
}, Symbol.toStringTag, { value: "Module" }));
const checks = Object.keys(types$1);
class DefinedInfo extends Info {
  constructor(property, attribute, mask, space2) {
    let index2 = -1;
    super(property, attribute);
    mark(this, "space", space2);
    if (typeof mask === "number") {
      while (++index2 < checks.length) {
        const check2 = checks[index2];
        mark(this, checks[index2], (mask & types$1[check2]) === types$1[check2]);
      }
    }
  }
}
DefinedInfo.prototype.defined = true;
function mark(values, key, value) {
  if (value) {
    values[key] = value;
  }
}
const own$3 = {}.hasOwnProperty;
function create(definition2) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition2.properties) {
    if (own$3.call(definition2.properties, prop)) {
      const value = definition2.properties[prop];
      const info = new DefinedInfo(
        prop,
        definition2.transform(definition2.attributes || {}, prop),
        value,
        definition2.space
      );
      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
        info.mustUseProperty = true;
      }
      property[prop] = info;
      normal[normalize$1(prop)] = prop;
      normal[normalize$1(info.attribute)] = prop;
    }
  }
  return new Schema$1(property, normal, definition2.space);
}
const xlink = create({
  space: "xlink",
  transform(_24, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
const xml = create({
  space: "xml",
  transform(_24, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function caseSensitiveTransform(attributes2, attribute) {
  return attribute in attributes2 ? attributes2[attribute] : attribute;
}
function caseInsensitiveTransform(attributes2, property) {
  return caseSensitiveTransform(attributes2, property.toLowerCase());
}
const xmlns = create({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});
const aria = create({
  transform(_24, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number$1,
    ariaColIndex: number$1,
    ariaColSpan: number$1,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number$1,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number$1,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number$1,
    ariaRowIndex: number$1,
    ariaRowSpan: number$1,
    ariaSelected: booleanish,
    ariaSetSize: number$1,
    ariaSort: null,
    ariaValueMax: number$1,
    ariaValueMin: number$1,
    ariaValueNow: number$1,
    ariaValueText: null,
    role: null
  }
});
const html$1 = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    capture: boolean,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number$1,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number$1 | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number$1,
    hidden: boolean,
    high: number$1,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number$1,
    manifest: null,
    max: null,
    maxLength: number$1,
    media: null,
    method: null,
    min: null,
    minLength: number$1,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number$1,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number$1,
    rowSpan: number$1,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shape: null,
    size: number$1,
    sizes: null,
    slot: null,
    span: number$1,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number$1,
    step: null,
    style: null,
    tabIndex: number$1,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number$1,
    wrap: null,
    align: null,
    aLink: null,
    archive: spaceSeparated,
    axis: null,
    background: null,
    bgColor: null,
    border: number$1,
    borderColor: null,
    bottomMargin: number$1,
    cellPadding: null,
    cellSpacing: null,
    char: null,
    charOff: null,
    classId: null,
    clear: null,
    code: null,
    codeBase: null,
    codeType: null,
    color: null,
    compact: boolean,
    declare: boolean,
    event: null,
    face: null,
    frame: null,
    frameBorder: null,
    hSpace: number$1,
    leftMargin: number$1,
    link: null,
    longDesc: null,
    lowSrc: null,
    marginHeight: number$1,
    marginWidth: number$1,
    noResize: boolean,
    noHref: boolean,
    noShade: boolean,
    noWrap: boolean,
    object: null,
    profile: null,
    prompt: null,
    rev: null,
    rightMargin: number$1,
    rules: null,
    scheme: null,
    scrolling: booleanish,
    standby: null,
    summary: null,
    text: null,
    topMargin: number$1,
    valueType: null,
    version: null,
    vAlign: null,
    vLink: null,
    vSpace: number$1,
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number$1,
    security: null,
    unselectable: null
  }
});
const svg$1 = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number$1,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number$1,
    amplitude: number$1,
    arabicForm: null,
    ascent: number$1,
    attributeName: null,
    attributeType: null,
    azimuth: number$1,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number$1,
    by: null,
    calcMode: null,
    capHeight: number$1,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number$1,
    diffuseConstant: number$1,
    direction: null,
    display: null,
    dur: null,
    divisor: number$1,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number$1,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number$1,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number$1,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number$1,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number$1,
    horizOriginX: number$1,
    horizOriginY: number$1,
    id: null,
    ideographic: number$1,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number$1,
    k: number$1,
    k1: number$1,
    k2: number$1,
    k3: number$1,
    k4: number$1,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    keySplines: null,
    keyTimes: null,
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number$1,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number$1,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number$1,
    overlineThickness: number$1,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number$1,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number$1,
    pointsAtY: number$1,
    pointsAtZ: number$1,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number$1,
    specularExponent: number$1,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number$1,
    strikethroughThickness: number$1,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number$1,
    strokeOpacity: number$1,
    strokeWidth: null,
    style: null,
    surfaceScale: number$1,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number$1,
    tableValues: null,
    target: null,
    targetX: number$1,
    targetY: number$1,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: number$1,
    underlineThickness: number$1,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number$1,
    values: null,
    vAlphabetic: number$1,
    vMathematical: number$1,
    vectorEffect: null,
    vHanging: number$1,
    vIdeographic: number$1,
    version: null,
    vertAdvY: number$1,
    vertOriginX: number$1,
    vertOriginY: number$1,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number$1,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
const valid = /^data[-\w.:]+$/i;
const dash = /-[a-z]/g;
const cap = /[A-Z]/g;
function find(schema, value) {
  const normal = normalize$1(value);
  let prop = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(prop, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
const hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};
const html = merge$2([xml, xlink, xmlns, aria, html$1], "html");
const svg = merge$2([xml, xlink, xmlns, aria, svg$1], "svg");
const visit = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    return visitor(
      node2,
      parent ? parent.children.indexOf(node2) : null,
      parent
    );
  }
};
function rehypeFilter(options) {
  if (options.allowedElements && options.disallowedElements) {
    throw new TypeError(
      "Only one of `allowedElements` and `disallowedElements` should be defined"
    );
  }
  if (options.allowedElements || options.disallowedElements || options.allowElement) {
    return (tree) => {
      visit(tree, "element", (node2, index2, parent_) => {
        const parent = parent_;
        let remove3;
        if (options.allowedElements) {
          remove3 = !options.allowedElements.includes(node2.tagName);
        } else if (options.disallowedElements) {
          remove3 = options.disallowedElements.includes(node2.tagName);
        }
        if (!remove3 && options.allowElement && typeof index2 === "number") {
          remove3 = !options.allowElement(node2, index2, parent);
        }
        if (remove3 && typeof index2 === "number") {
          if (options.unwrapDisallowed && node2.children) {
            parent.children.splice(index2, 1, ...node2.children);
          } else {
            parent.children.splice(index2, 1);
          }
          return index2;
        }
        return void 0;
      });
    };
  }
}
var reactIs = { exports: {} };
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
u = Symbol.for("react.module.reference");
function v(a) {
  if ("object" === typeof a && null !== a) {
    var r2 = a.$$typeof;
    switch (r2) {
      case b:
        switch (a = a.type, a) {
          case d:
          case f:
          case e:
          case m:
          case n:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case h:
              case l:
              case q:
              case p:
              case g:
                return a;
              default:
                return r2;
            }
        }
      case c:
        return r2;
    }
  }
}
reactIs_production_min.ContextConsumer = h;
reactIs_production_min.ContextProvider = g;
reactIs_production_min.Element = b;
reactIs_production_min.ForwardRef = l;
reactIs_production_min.Fragment = d;
reactIs_production_min.Lazy = q;
reactIs_production_min.Memo = p;
reactIs_production_min.Portal = c;
reactIs_production_min.Profiler = f;
reactIs_production_min.StrictMode = e;
reactIs_production_min.Suspense = m;
reactIs_production_min.SuspenseList = n;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a) {
  return v(a) === h;
};
reactIs_production_min.isContextProvider = function(a) {
  return v(a) === g;
};
reactIs_production_min.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === b;
};
reactIs_production_min.isForwardRef = function(a) {
  return v(a) === l;
};
reactIs_production_min.isFragment = function(a) {
  return v(a) === d;
};
reactIs_production_min.isLazy = function(a) {
  return v(a) === q;
};
reactIs_production_min.isMemo = function(a) {
  return v(a) === p;
};
reactIs_production_min.isPortal = function(a) {
  return v(a) === c;
};
reactIs_production_min.isProfiler = function(a) {
  return v(a) === f;
};
reactIs_production_min.isStrictMode = function(a) {
  return v(a) === e;
};
reactIs_production_min.isSuspense = function(a) {
  return v(a) === m;
};
reactIs_production_min.isSuspenseList = function(a) {
  return v(a) === n;
};
reactIs_production_min.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || "object" === typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId) ? true : false;
};
reactIs_production_min.typeOf = v;
{
  reactIs.exports = reactIs_production_min;
}
var ReactIs = reactIs.exports;
function whitespace$2(thing) {
  var value = thing && typeof thing === "object" && thing.type === "text" ? thing.value || "" : thing;
  return typeof value === "string" && value.replace(/[ \t\n\f\r]/g, "") === "";
}
function stringify$4(values) {
  return values.join(" ").trim();
}
function stringify$3(values, options) {
  var settings = options || {};
  if (values[values.length - 1] === "") {
    values = values.concat("");
  }
  return values.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}
var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
var NEWLINE_REGEX = /\n/g;
var WHITESPACE_REGEX = /^\s*/;
var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var COLON_REGEX = /^:\s*/;
var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var SEMICOLON_REGEX = /^[;\s]*/;
var TRIM_REGEX = /^\s+|\s+$/g;
var NEWLINE = "\n";
var FORWARD_SLASH = "/";
var ASTERISK = "*";
var EMPTY_STRING = "";
var TYPE_COMMENT = "comment";
var TYPE_DECLARATION = "declaration";
var inlineStyleParser = function(style2, options) {
  if (typeof style2 !== "string") {
    throw new TypeError("First argument must be a string");
  }
  if (!style2)
    return [];
  options = options || {};
  var lineno = 1;
  var column2 = 1;
  function updatePosition(str) {
    var lines = str.match(NEWLINE_REGEX);
    if (lines)
      lineno += lines.length;
    var i = str.lastIndexOf(NEWLINE);
    column2 = ~i ? str.length - i : column2 + str.length;
  }
  function position2() {
    var start = { line: lineno, column: column2 };
    return function(node2) {
      node2.position = new Position(start);
      whitespace3();
      return node2;
    };
  }
  function Position(start) {
    this.start = start;
    this.end = { line: lineno, column: column2 };
    this.source = options.source;
  }
  Position.prototype.content = style2;
  function error3(msg) {
    var err = new Error(
      options.source + ":" + lineno + ":" + column2 + ": " + msg
    );
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column2;
    err.source = style2;
    if (options.silent)
      ;
    else {
      throw err;
    }
  }
  function match2(re2) {
    var m2 = re2.exec(style2);
    if (!m2)
      return;
    var str = m2[0];
    updatePosition(str);
    style2 = style2.slice(str.length);
    return m2;
  }
  function whitespace3() {
    match2(WHITESPACE_REGEX);
  }
  function comments(rules2) {
    var c2;
    rules2 = rules2 || [];
    while (c2 = comment2()) {
      if (c2 !== false) {
        rules2.push(c2);
      }
    }
    return rules2;
  }
  function comment2() {
    var pos = position2();
    if (FORWARD_SLASH != style2.charAt(0) || ASTERISK != style2.charAt(1))
      return;
    var i = 2;
    while (EMPTY_STRING != style2.charAt(i) && (ASTERISK != style2.charAt(i) || FORWARD_SLASH != style2.charAt(i + 1))) {
      ++i;
    }
    i += 2;
    if (EMPTY_STRING === style2.charAt(i - 1)) {
      return error3("End of comment missing");
    }
    var str = style2.slice(2, i - 2);
    column2 += 2;
    updatePosition(str);
    style2 = style2.slice(i);
    column2 += 2;
    return pos({
      type: TYPE_COMMENT,
      comment: str
    });
  }
  function declaration2() {
    var pos = position2();
    var prop = match2(PROPERTY_REGEX);
    if (!prop)
      return;
    comment2();
    if (!match2(COLON_REGEX))
      return error3("property missing ':'");
    var val = match2(VALUE_REGEX);
    var ret = pos({
      type: TYPE_DECLARATION,
      property: trim$1(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
      value: val ? trim$1(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
    });
    match2(SEMICOLON_REGEX);
    return ret;
  }
  function declarations() {
    var decls = [];
    comments(decls);
    var decl;
    while (decl = declaration2()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }
    return decls;
  }
  whitespace3();
  return declarations();
};
function trim$1(str) {
  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}
var parse$1 = inlineStyleParser;
function StyleToObject(style2, iterator) {
  var output2 = null;
  if (!style2 || typeof style2 !== "string") {
    return output2;
  }
  var declaration2;
  var declarations = parse$1(style2);
  var hasIterator = typeof iterator === "function";
  var property;
  var value;
  for (var i = 0, len = declarations.length; i < len; i++) {
    declaration2 = declarations[i];
    property = declaration2.property;
    value = declaration2.value;
    if (hasIterator) {
      iterator(property, value, declaration2);
    } else if (value) {
      output2 || (output2 = {});
      output2[property] = value;
    }
  }
  return output2;
}
var styleToObject = StyleToObject;
const own$2 = {}.hasOwnProperty;
const tableElements = /* @__PURE__ */ new Set(["table", "thead", "tbody", "tfoot", "tr"]);
function childrenToReact(context2, node2) {
  const children = [];
  let childIndex = -1;
  let child;
  while (++childIndex < node2.children.length) {
    child = node2.children[childIndex];
    if (child.type === "element") {
      children.push(toReact(context2, child, childIndex, node2));
    } else if (child.type === "text") {
      if (node2.type !== "element" || !tableElements.has(node2.tagName) || !whitespace$2(child)) {
        children.push(child.value);
      }
    } else if (child.type === "raw" && !context2.options.skipHtml) {
      children.push(child.value);
    }
  }
  return children;
}
function toReact(context2, node2, index2, parent) {
  const options = context2.options;
  const parentSchema = context2.schema;
  const name = node2.tagName;
  const properties = {};
  let schema = parentSchema;
  let property;
  if (parentSchema.space === "html" && name === "svg") {
    schema = svg;
    context2.schema = schema;
  }
  if (node2.properties) {
    for (property in node2.properties) {
      if (own$2.call(node2.properties, property)) {
        addProperty(properties, property, node2.properties[property], context2);
      }
    }
  }
  if (name === "ol" || name === "ul") {
    context2.listDepth++;
  }
  const children = childrenToReact(context2, node2);
  if (name === "ol" || name === "ul") {
    context2.listDepth--;
  }
  context2.schema = parentSchema;
  const position2 = node2.position || {
    start: { line: null, column: null, offset: null },
    end: { line: null, column: null, offset: null }
  };
  const component = options.components && own$2.call(options.components, name) ? options.components[name] : name;
  const basic = typeof component === "string" || component === React.Fragment;
  if (!ReactIs.isValidElementType(component)) {
    throw new TypeError(
      `Component for name \`${name}\` not defined or is not renderable`
    );
  }
  properties.key = [
    name,
    position2.start.line,
    position2.start.column,
    index2
  ].join("-");
  if (name === "a" && options.linkTarget) {
    properties.target = typeof options.linkTarget === "function" ? options.linkTarget(
      String(properties.href || ""),
      node2.children,
      typeof properties.title === "string" ? properties.title : null
    ) : options.linkTarget;
  }
  if (name === "a" && options.transformLinkUri) {
    properties.href = options.transformLinkUri(
      String(properties.href || ""),
      node2.children,
      typeof properties.title === "string" ? properties.title : null
    );
  }
  if (!basic && name === "code" && parent.type === "element" && parent.tagName !== "pre") {
    properties.inline = true;
  }
  if (!basic && (name === "h1" || name === "h2" || name === "h3" || name === "h4" || name === "h5" || name === "h6")) {
    properties.level = Number.parseInt(name.charAt(1), 10);
  }
  if (name === "img" && options.transformImageUri) {
    properties.src = options.transformImageUri(
      String(properties.src || ""),
      String(properties.alt || ""),
      typeof properties.title === "string" ? properties.title : null
    );
  }
  if (!basic && name === "li" && parent.type === "element") {
    const input = getInputElement(node2);
    properties.checked = input && input.properties ? Boolean(input.properties.checked) : null;
    properties.index = getElementsBeforeCount(parent, node2);
    properties.ordered = parent.tagName === "ol";
  }
  if (!basic && (name === "ol" || name === "ul")) {
    properties.ordered = name === "ol";
    properties.depth = context2.listDepth;
  }
  if (name === "td" || name === "th") {
    if (properties.align) {
      if (!properties.style)
        properties.style = {};
      properties.style.textAlign = properties.align;
      delete properties.align;
    }
    if (!basic) {
      properties.isHeader = name === "th";
    }
  }
  if (!basic && name === "tr" && parent.type === "element") {
    properties.isHeader = Boolean(parent.tagName === "thead");
  }
  if (options.sourcePos) {
    properties["data-sourcepos"] = flattenPosition(position2);
  }
  if (!basic && options.rawSourcePos) {
    properties.sourcePosition = node2.position;
  }
  if (!basic && options.includeElementIndex) {
    properties.index = getElementsBeforeCount(parent, node2);
    properties.siblingCount = getElementsBeforeCount(parent);
  }
  if (!basic) {
    properties.node = node2;
  }
  return children.length > 0 ? React.createElement(component, properties, children) : React.createElement(component, properties);
}
function getInputElement(node2) {
  let index2 = -1;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    if (child.type === "element" && child.tagName === "input") {
      return child;
    }
  }
  return null;
}
function getElementsBeforeCount(parent, node2) {
  let index2 = -1;
  let count = 0;
  while (++index2 < parent.children.length) {
    if (parent.children[index2] === node2)
      break;
    if (parent.children[index2].type === "element")
      count++;
  }
  return count;
}
function addProperty(props, prop, value, ctx) {
  const info = find(ctx.schema, prop);
  let result = value;
  if (result === null || result === void 0 || result !== result) {
    return;
  }
  if (Array.isArray(result)) {
    result = info.commaSeparated ? stringify$3(result) : stringify$4(result);
  }
  if (info.property === "style" && typeof result === "string") {
    result = parseStyle$1(result);
  }
  if (info.space && info.property) {
    props[own$2.call(hastToReact, info.property) ? hastToReact[info.property] : info.property] = result;
  } else if (info.attribute) {
    props[info.attribute] = result;
  }
}
function parseStyle$1(value) {
  const result = {};
  try {
    styleToObject(value, iterator);
  } catch {
  }
  return result;
  function iterator(name, v2) {
    const k2 = name.slice(0, 4) === "-ms-" ? `ms-${name.slice(4)}` : name;
    result[k2.replace(/-([a-z])/g, styleReplacer)] = v2;
  }
}
function styleReplacer(_24, $1) {
  return $1.toUpperCase();
}
function flattenPosition(pos) {
  return [
    pos.start.line,
    ":",
    pos.start.column,
    "-",
    pos.end.line,
    ":",
    pos.end.column
  ].map((d2) => String(d2)).join("");
}
const own$1 = {}.hasOwnProperty;
const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
const deprecated = {
  plugins: { to: "plugins", id: "change-plugins-to-remarkplugins" },
  renderers: { to: "components", id: "change-renderers-to-components" },
  astPlugins: { id: "remove-buggy-html-in-markdown-parser" },
  allowDangerousHtml: { id: "remove-buggy-html-in-markdown-parser" },
  escapeHtml: { id: "remove-buggy-html-in-markdown-parser" },
  source: { to: "children", id: "change-source-to-children" },
  allowNode: {
    to: "allowElement",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  allowedTypes: {
    to: "allowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  disallowedTypes: {
    to: "disallowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  includeNodeIndex: {
    to: "includeElementIndex",
    id: "change-includenodeindex-to-includeelementindex"
  }
};
function ReactMarkdown(options) {
  for (const key in deprecated) {
    if (own$1.call(deprecated, key) && own$1.call(options, key)) {
      const deprecation = deprecated[key];
      console.warn(
        `[react-markdown] Warning: please ${deprecation.to ? `use \`${deprecation.to}\` instead of` : "remove"} \`${key}\` (see <${changelog}#${deprecation.id}> for more info)`
      );
      delete deprecated[key];
    }
  }
  const processor = unified().use(remarkParse).use(options.remarkPlugins || []).use(remarkRehype$1, {
    ...options.remarkRehypeOptions,
    allowDangerousHtml: true
  }).use(options.rehypePlugins || []).use(rehypeFilter, options);
  const file = new VFile$1();
  if (typeof options.children === "string") {
    file.value = options.children;
  } else if (options.children !== void 0 && options.children !== null) {
    console.warn(
      `[react-markdown] Warning: please pass a string as \`children\` (not: \`${options.children}\`)`
    );
  }
  const hastNode = processor.runSync(processor.parse(file), file);
  if (hastNode.type !== "root") {
    throw new TypeError("Expected a `root` node");
  }
  let result = React.createElement(
    React.Fragment,
    {},
    childrenToReact({ options, schema: html, listDepth: 0 }, hastNode)
  );
  if (options.className) {
    result = React.createElement("div", { className: options.className }, result);
  }
  return result;
}
ReactMarkdown.defaultProps = { transformLinkUri: uriTransformer };
ReactMarkdown.propTypes = {
  children: PropTypes.string,
  className: PropTypes.string,
  allowElement: PropTypes.func,
  allowedElements: PropTypes.arrayOf(PropTypes.string),
  disallowedElements: PropTypes.arrayOf(PropTypes.string),
  unwrapDisallowed: PropTypes.bool,
  remarkPlugins: PropTypes.arrayOf(
    PropTypes.oneOfType([
      PropTypes.object,
      PropTypes.func,
      PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.bool,
          PropTypes.string,
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(
            PropTypes.any
          )
        ])
      )
    ])
  ),
  rehypePlugins: PropTypes.arrayOf(
    PropTypes.oneOfType([
      PropTypes.object,
      PropTypes.func,
      PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.bool,
          PropTypes.string,
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(
            PropTypes.any
          )
        ])
      )
    ])
  ),
  sourcePos: PropTypes.bool,
  rawSourcePos: PropTypes.bool,
  skipHtml: PropTypes.bool,
  includeElementIndex: PropTypes.bool,
  transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  transformImageUri: PropTypes.func,
  components: PropTypes.object
};
const www = {
  tokenize: tokenizeWww,
  partial: true
};
const domain = {
  tokenize: tokenizeDomain,
  partial: true
};
const path$2 = {
  tokenize: tokenizePath,
  partial: true
};
const punctuation = {
  tokenize: tokenizePunctuation,
  partial: true
};
const namedCharacterReference = {
  tokenize: tokenizeNamedCharacterReference,
  partial: true
};
const wwwAutolink = {
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
const httpAutolink = {
  tokenize: tokenizeHttpAutolink,
  previous: previousHttp
};
const emailAutolink = {
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
const text = {};
const gfmAutolinkLiteral = {
  text
};
let code = 48;
while (code < 123) {
  text[code] = emailAutolink;
  code++;
  if (code === 58)
    code = 65;
  else if (code === 91)
    code = 97;
}
text[43] = emailAutolink;
text[45] = emailAutolink;
text[46] = emailAutolink;
text[95] = emailAutolink;
text[72] = [emailAutolink, httpAutolink];
text[104] = [emailAutolink, httpAutolink];
text[87] = [emailAutolink, wwwAutolink];
text[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok2, nok) {
  const self2 = this;
  let hasDot;
  let hasDigitInLastSegment;
  return start;
  function start(code2) {
    if (!gfmAtext(code2) || !previousEmail(self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code2);
  }
  function atext(code2) {
    if (gfmAtext(code2)) {
      effects.consume(code2);
      return atext;
    }
    if (code2 === 64) {
      effects.consume(code2);
      return label;
    }
    return nok(code2);
  }
  function label(code2) {
    if (code2 === 46) {
      return effects.check(punctuation, done, dotContinuation)(code2);
    }
    if (code2 === 45 || code2 === 95) {
      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code2);
    }
    if (asciiAlphanumeric(code2)) {
      if (!hasDigitInLastSegment && asciiDigit(code2)) {
        hasDigitInLastSegment = true;
      }
      effects.consume(code2);
      return label;
    }
    return done(code2);
  }
  function dotContinuation(code2) {
    effects.consume(code2);
    hasDot = true;
    hasDigitInLastSegment = void 0;
    return label;
  }
  function dashOrUnderscoreContinuation(code2) {
    effects.consume(code2);
    return afterDashOrUnderscore;
  }
  function afterDashOrUnderscore(code2) {
    if (code2 === 46) {
      return effects.check(punctuation, nok, dotContinuation)(code2);
    }
    return label(code2);
  }
  function done(code2) {
    if (hasDot && !hasDigitInLastSegment) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeWwwAutolink(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 !== 87 && code2 !== 119 || !previousWww(self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(
      www,
      effects.attempt(domain, effects.attempt(path$2, done), nok),
      nok
    )(code2);
  }
  function done(code2) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeHttpAutolink(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 !== 72 && code2 !== 104 || !previousHttp(self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkHttp");
    effects.consume(code2);
    return t1;
  }
  function t1(code2) {
    if (code2 === 84 || code2 === 116) {
      effects.consume(code2);
      return t2;
    }
    return nok(code2);
  }
  function t2(code2) {
    if (code2 === 84 || code2 === 116) {
      effects.consume(code2);
      return p2;
    }
    return nok(code2);
  }
  function p2(code2) {
    if (code2 === 80 || code2 === 112) {
      effects.consume(code2);
      return s2;
    }
    return nok(code2);
  }
  function s2(code2) {
    if (code2 === 83 || code2 === 115) {
      effects.consume(code2);
      return colon;
    }
    return colon(code2);
  }
  function colon(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      return slash1;
    }
    return nok(code2);
  }
  function slash1(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return slash2;
    }
    return nok(code2);
  }
  function slash2(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === null || asciiControl(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path$2, done), nok)(code2);
  }
  function done(code2) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeWww(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return w2;
  }
  function w2(code2) {
    if (code2 === 87 || code2 === 119) {
      effects.consume(code2);
      return w3;
    }
    return nok(code2);
  }
  function w3(code2) {
    if (code2 === 87 || code2 === 119) {
      effects.consume(code2);
      return dot;
    }
    return nok(code2);
  }
  function dot(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? nok(code2) : ok2(code2);
  }
}
function tokenizeDomain(effects, ok2, nok) {
  let hasUnderscoreInLastSegment;
  let hasUnderscoreInLastLastSegment;
  return domain2;
  function domain2(code2) {
    if (code2 === 38) {
      return effects.check(
        namedCharacterReference,
        done,
        punctuationContinuation
      )(code2);
    }
    if (code2 === 46 || code2 === 95) {
      return effects.check(punctuation, done, punctuationContinuation)(code2);
    }
    if (code2 === null || asciiControl(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
      return done(code2);
    }
    effects.consume(code2);
    return domain2;
  }
  function punctuationContinuation(code2) {
    if (code2 === 46) {
      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;
      hasUnderscoreInLastSegment = void 0;
      effects.consume(code2);
      return domain2;
    }
    if (code2 === 95)
      hasUnderscoreInLastSegment = true;
    effects.consume(code2);
    return domain2;
  }
  function done(code2) {
    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizePath(effects, ok2) {
  let balance = 0;
  return inPath;
  function inPath(code2) {
    if (code2 === 38) {
      return effects.check(
        namedCharacterReference,
        ok2,
        continuedPunctuation
      )(code2);
    }
    if (code2 === 40) {
      balance++;
    }
    if (code2 === 41) {
      return effects.check(
        punctuation,
        parenAtPathEnd,
        continuedPunctuation
      )(code2);
    }
    if (pathEnd(code2)) {
      return ok2(code2);
    }
    if (trailingPunctuation(code2)) {
      return effects.check(punctuation, ok2, continuedPunctuation)(code2);
    }
    effects.consume(code2);
    return inPath;
  }
  function continuedPunctuation(code2) {
    effects.consume(code2);
    return inPath;
  }
  function parenAtPathEnd(code2) {
    balance--;
    return balance < 0 ? ok2(code2) : continuedPunctuation(code2);
  }
}
function tokenizeNamedCharacterReference(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return inside;
  }
  function inside(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return inside;
    }
    if (code2 === 59) {
      effects.consume(code2);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return pathEnd(code2) ? ok2(code2) : nok(code2);
  }
}
function tokenizePunctuation(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (trailingPunctuation(code2)) {
      effects.consume(code2);
      return after;
    }
    return pathEnd(code2) ? ok2(code2) : nok(code2);
  }
}
function trailingPunctuation(code2) {
  return code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 95 || code2 === 126;
}
function pathEnd(code2) {
  return code2 === null || code2 === 60 || markdownLineEndingOrSpace(code2);
}
function gfmAtext(code2) {
  return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
}
function previousWww(code2) {
  return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 126 || markdownLineEndingOrSpace(code2);
}
function previousHttp(code2) {
  return code2 === null || !asciiAlpha(code2);
}
function previousEmail(code2) {
  return code2 !== 47 && previousHttp(code2);
}
function previousUnbalanced(events) {
  let index2 = events.length;
  let result = false;
  while (index2--) {
    const token2 = events[index2][1];
    if ((token2.type === "labelLink" || token2.type === "labelImage") && !token2._balanced) {
      result = true;
      break;
    }
    if (token2._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}
const indent = {
  tokenize: tokenizeIndent,
  partial: true
};
function gfmFootnote() {
  return {
    document: {
      [91]: {
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let labelStart;
  while (index2--) {
    const token2 = self2.events[index2][1];
    if (token2.type === "labelImage") {
      labelStart = token2;
      break;
    }
    if (token2.type === "gfmFootnoteCall" || token2.type === "labelLink" || token2.type === "label" || token2.type === "image" || token2.type === "link") {
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code2);
    }
    const id = normalizeIdentifier(
      self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      })
    );
    if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {
      return nok(code2);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok2(code2);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context2) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
      events[index2][1];
      break;
    }
  }
  events[index2 + 1][1].type = "data";
  events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call2 = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index2 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index2 + 3][1].end),
    end: Object.assign({}, events[index2 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string3 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, string3.start),
    end: Object.assign({}, string3.end)
  };
  const replacement = [
    events[index2 + 1],
    events[index2 + 2],
    ["enter", call2, context2],
    events[index2 + 3],
    events[index2 + 4],
    ["enter", marker, context2],
    ["exit", marker, context2],
    ["enter", string3, context2],
    ["enter", chunk, context2],
    ["exit", chunk, context2],
    ["exit", string3, context2],
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call2, context2]
  ];
  events.splice(index2, events.length - index2 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok2, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let size = 0;
  let data2;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code2) {
    if (code2 !== 94)
      return nok(code2);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code2) {
    let token2;
    if (code2 === null || code2 === 91 || size++ > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      if (!data2) {
        return nok(code2);
      }
      effects.exit("chunkString");
      token2 = effects.exit("gfmFootnoteCallString");
      return defined.includes(normalizeIdentifier(self2.sliceSerialize(token2))) ? end(code2) : nok(code2);
    }
    effects.consume(code2);
    if (!markdownLineEndingOrSpace(code2)) {
      data2 = true;
    }
    return code2 === 92 ? callEscape : callData;
  }
  function callEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return callData;
    }
    return callData(code2);
  }
  function end(code2) {
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    effects.exit("gfmFootnoteCall");
    return ok2;
  }
}
function tokenizeDefinitionStart(effects, ok2, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let identifier2;
  let size = 0;
  let data2;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelStart;
  }
  function labelStart(code2) {
    if (code2 === 94) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      return atBreak;
    }
    return nok(code2);
  }
  function atBreak(code2) {
    let token2;
    if (code2 === null || code2 === 91 || size > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      if (!data2) {
        return nok(code2);
      }
      token2 = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier2 = normalizeIdentifier(self2.sliceSerialize(token2));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      size++;
      return atBreak;
    }
    effects.enter("chunkString").contentType = "string";
    return label(code2);
  }
  function label(code2) {
    if (code2 === null || markdownLineEnding(code2) || code2 === 91 || code2 === 93 || size > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    if (!markdownLineEndingOrSpace(code2)) {
      data2 = true;
    }
    size++;
    effects.consume(code2);
    return code2 === 92 ? labelEscape : label;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return label;
    }
    return label(code2);
  }
  function labelAfter(code2) {
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return factorySpace(effects, done, "gfmFootnoteDefinitionWhitespace");
    }
    return nok(code2);
  }
  function done(code2) {
    if (!defined.includes(identifier2)) {
      defined.push(identifier2);
    }
    return ok2(code2);
  }
}
function tokenizeDefinitionContinuation(effects, ok2, nok) {
  return effects.check(blankLine, ok2, effects.attempt(indent, ok2, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "gfmFootnoteDefinitionIndent",
    4 + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code2) : nok(code2);
  }
}
function gfmStrikethrough(options = {}) {
  let single = options.singleTilde;
  const tokenizer = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: {
      [126]: tokenizer
    },
    insideSpan: {
      null: [tokenizer]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function resolveAllStrikethrough(events, context2) {
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
        let open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index2][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough2 = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index2][1].end)
            };
            const text2 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough2, context2],
              ["enter", events[open][1], context2],
              ["exit", events[open][1], context2],
              ["enter", text2, context2]
            ];
            splice$1(
              nextEvents,
              nextEvents.length,
              0,
              resolveAll(
                context2.parser.constructs.insideSpan.null,
                events.slice(open + 1, index2),
                context2
              )
            );
            splice$1(nextEvents, nextEvents.length, 0, [
              ["exit", text2, context2],
              ["enter", events[index2][1], context2],
              ["exit", events[index2][1], context2],
              ["exit", strikethrough2, context2]
            ]);
            splice$1(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "strikethroughSequenceTemporary") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok2, nok) {
    const previous2 = this.previous;
    const events = this.events;
    let size = 0;
    return start;
    function start(code2) {
      if (previous2 === 126 && events[events.length - 1][1].type !== "characterEscape") {
        return nok(code2);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code2);
    }
    function more(code2) {
      const before = classifyCharacter(previous2);
      if (code2 === 126) {
        if (size > 1)
          return nok(code2);
        effects.consume(code2);
        size++;
        return more;
      }
      if (size < 2 && !single)
        return nok(code2);
      const token2 = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code2);
      token2._open = !after || after === 2 && Boolean(before);
      token2._close = !before || before === 2 && Boolean(after);
      return ok2(code2);
    }
  }
}
const gfmTable = {
  flow: {
    null: {
      tokenize: tokenizeTable,
      resolve: resolveTable
    }
  }
};
const nextPrefixedOrBlank = {
  tokenize: tokenizeNextPrefixedOrBlank,
  partial: true
};
function resolveTable(events, context2) {
  let index2 = -1;
  let inHead;
  let inDelimiterRow;
  let inRow;
  let contentStart;
  let contentEnd;
  let cellStart;
  let seenCellInRow;
  while (++index2 < events.length) {
    const token2 = events[index2][1];
    if (inRow) {
      if (token2.type === "temporaryTableCellContent") {
        contentStart = contentStart || index2;
        contentEnd = index2;
      }
      if ((token2.type === "tableCellDivider" || token2.type === "tableRow") && contentEnd) {
        const content2 = {
          type: "tableContent",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end
        };
        const text2 = {
          type: "chunkText",
          start: content2.start,
          end: content2.end,
          contentType: "text"
        };
        events.splice(
          contentStart,
          contentEnd - contentStart + 1,
          ["enter", content2, context2],
          ["enter", text2, context2],
          ["exit", text2, context2],
          ["exit", content2, context2]
        );
        index2 -= contentEnd - contentStart - 3;
        contentStart = void 0;
        contentEnd = void 0;
      }
    }
    if (events[index2][0] === "exit" && cellStart !== void 0 && cellStart + (seenCellInRow ? 0 : 1) < index2 && (token2.type === "tableCellDivider" || token2.type === "tableRow" && (cellStart + 3 < index2 || events[cellStart][1].type !== "whitespace"))) {
      const cell = {
        type: inDelimiterRow ? "tableDelimiter" : inHead ? "tableHeader" : "tableData",
        start: events[cellStart][1].start,
        end: events[index2][1].end
      };
      events.splice(index2 + (token2.type === "tableCellDivider" ? 1 : 0), 0, [
        "exit",
        cell,
        context2
      ]);
      events.splice(cellStart, 0, ["enter", cell, context2]);
      index2 += 2;
      cellStart = index2 + 1;
      seenCellInRow = true;
    }
    if (token2.type === "tableRow") {
      inRow = events[index2][0] === "enter";
      if (inRow) {
        cellStart = index2 + 1;
        seenCellInRow = false;
      }
    }
    if (token2.type === "tableDelimiterRow") {
      inDelimiterRow = events[index2][0] === "enter";
      if (inDelimiterRow) {
        cellStart = index2 + 1;
        seenCellInRow = false;
      }
    }
    if (token2.type === "tableHead") {
      inHead = events[index2][0] === "enter";
    }
  }
  return events;
}
function tokenizeTable(effects, ok2, nok) {
  const self2 = this;
  const align = [];
  let tableHeaderCount = 0;
  let seenDelimiter;
  let hasDash;
  return start;
  function start(code2) {
    effects.enter("table")._align = align;
    effects.enter("tableHead");
    effects.enter("tableRow");
    if (code2 === 124) {
      return cellDividerHead(code2);
    }
    tableHeaderCount++;
    effects.enter("temporaryTableCellContent");
    return inCellContentHead(code2);
  }
  function cellDividerHead(code2) {
    effects.enter("tableCellDivider");
    effects.consume(code2);
    effects.exit("tableCellDivider");
    seenDelimiter = true;
    return cellBreakHead;
  }
  function cellBreakHead(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return atRowEndHead(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceHead;
    }
    if (seenDelimiter) {
      seenDelimiter = void 0;
      tableHeaderCount++;
    }
    if (code2 === 124) {
      return cellDividerHead(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentHead(code2);
  }
  function inWhitespaceHead(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return inWhitespaceHead;
    }
    effects.exit("whitespace");
    return cellBreakHead(code2);
  }
  function inCellContentHead(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("temporaryTableCellContent");
      return cellBreakHead(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? inCellContentEscapeHead : inCellContentHead;
  }
  function inCellContentEscapeHead(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return inCellContentHead;
    }
    return inCellContentHead(code2);
  }
  function atRowEndHead(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    effects.exit("tableRow");
    effects.exit("tableHead");
    const originalInterrupt = self2.interrupt;
    self2.interrupt = true;
    return effects.attempt(
      {
        tokenize: tokenizeRowEnd,
        partial: true
      },
      function(code3) {
        self2.interrupt = originalInterrupt;
        effects.enter("tableDelimiterRow");
        return atDelimiterRowBreak(code3);
      },
      function(code3) {
        self2.interrupt = originalInterrupt;
        return nok(code3);
      }
    )(code2);
  }
  function atDelimiterRowBreak(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return rowEndDelimiter(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      effects.consume(code2);
      hasDash = true;
      align.push("none");
      return inFillerDelimiter;
    }
    if (code2 === 58) {
      effects.enter("tableDelimiterAlignment");
      effects.consume(code2);
      effects.exit("tableDelimiterAlignment");
      align.push("left");
      return afterLeftAlignment;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return atDelimiterRowBreak;
    }
    return nok(code2);
  }
  function inWhitespaceDelimiter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    effects.exit("whitespace");
    return atDelimiterRowBreak(code2);
  }
  function inFillerDelimiter(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return inFillerDelimiter;
    }
    effects.exit("tableDelimiterFiller");
    if (code2 === 58) {
      effects.enter("tableDelimiterAlignment");
      effects.consume(code2);
      effects.exit("tableDelimiterAlignment");
      align[align.length - 1] = align[align.length - 1] === "left" ? "center" : "right";
      return afterRightAlignment;
    }
    return atDelimiterRowBreak(code2);
  }
  function afterLeftAlignment(code2) {
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      effects.consume(code2);
      hasDash = true;
      return inFillerDelimiter;
    }
    return nok(code2);
  }
  function afterRightAlignment(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return rowEndDelimiter(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return atDelimiterRowBreak;
    }
    return nok(code2);
  }
  function rowEndDelimiter(code2) {
    effects.exit("tableDelimiterRow");
    if (!hasDash || tableHeaderCount !== align.length) {
      return nok(code2);
    }
    if (code2 === null) {
      return tableClose(code2);
    }
    return effects.check(
      nextPrefixedOrBlank,
      tableClose,
      effects.attempt(
        {
          tokenize: tokenizeRowEnd,
          partial: true
        },
        factorySpace(effects, bodyStart, "linePrefix", 4),
        tableClose
      )
    )(code2);
  }
  function tableClose(code2) {
    effects.exit("table");
    return ok2(code2);
  }
  function bodyStart(code2) {
    effects.enter("tableBody");
    return rowStartBody(code2);
  }
  function rowStartBody(code2) {
    effects.enter("tableRow");
    if (code2 === 124) {
      return cellDividerBody(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentBody(code2);
  }
  function cellDividerBody(code2) {
    effects.enter("tableCellDivider");
    effects.consume(code2);
    effects.exit("tableCellDivider");
    return cellBreakBody;
  }
  function cellBreakBody(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return atRowEndBody(code2);
    }
    if (markdownSpace(code2)) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceBody;
    }
    if (code2 === 124) {
      return cellDividerBody(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentBody(code2);
  }
  function inWhitespaceBody(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return inWhitespaceBody;
    }
    effects.exit("whitespace");
    return cellBreakBody(code2);
  }
  function inCellContentBody(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("temporaryTableCellContent");
      return cellBreakBody(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? inCellContentEscapeBody : inCellContentBody;
  }
  function inCellContentEscapeBody(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return inCellContentBody;
    }
    return inCellContentBody(code2);
  }
  function atRowEndBody(code2) {
    effects.exit("tableRow");
    if (code2 === null) {
      return tableBodyClose(code2);
    }
    return effects.check(
      nextPrefixedOrBlank,
      tableBodyClose,
      effects.attempt(
        {
          tokenize: tokenizeRowEnd,
          partial: true
        },
        factorySpace(effects, rowStartBody, "linePrefix", 4),
        tableBodyClose
      )
    )(code2);
  }
  function tableBodyClose(code2) {
    effects.exit("tableBody");
    return tableClose(code2);
  }
  function tokenizeRowEnd(effects2, ok3, nok2) {
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return factorySpace(effects2, prefixed, "linePrefix");
    }
    function prefixed(code2) {
      if (self2.parser.lazy[self2.now().line] || code2 === null || markdownLineEnding(code2)) {
        return nok2(code2);
      }
      const tail = self2.events[self2.events.length - 1];
      if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
        return nok2(code2);
      }
      self2._gfmTableDynamicInterruptHack = true;
      return effects2.check(
        self2.parser.constructs.flow,
        function(code3) {
          self2._gfmTableDynamicInterruptHack = false;
          return nok2(code3);
        },
        function(code3) {
          self2._gfmTableDynamicInterruptHack = false;
          return ok3(code3);
        }
      )(code2);
    }
  }
}
function tokenizeNextPrefixedOrBlank(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("check");
    effects.consume(code2);
    return whitespace3;
  }
  function whitespace3(code2) {
    if (code2 === -1 || code2 === 32) {
      effects.consume(code2);
      size++;
      return size === 4 ? ok2 : whitespace3;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      return ok2(code2);
    }
    return nok(code2);
  }
}
const tasklistCheck = {
  tokenize: tokenizeTasklistCheck
};
const gfmTaskListItem = {
  text: {
    [91]: tasklistCheck
  }
};
function tokenizeTasklistCheck(effects, ok2, nok) {
  const self2 = this;
  return open;
  function open(code2) {
    if (self2.previous !== null || !self2._gfmTasklistFirstContentOfListItem) {
      return nok(code2);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code2);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code2) {
    if (markdownLineEndingOrSpace(code2)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueUnchecked");
      return close;
    }
    if (code2 === 88 || code2 === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueChecked");
      return close;
    }
    return nok(code2);
  }
  function close(code2) {
    if (code2 === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code2);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return effects.check(
        {
          tokenize: spaceThenNonSpace
        },
        ok2,
        nok
      );
    }
    return nok(code2);
  }
}
function spaceThenNonSpace(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(effects, after, "whitespace");
  function after(code2) {
    const tail = self2.events[self2.events.length - 1];
    return (tail && tail[1].type === "whitespace" || markdownLineEnding(code2)) && code2 !== null ? ok2(code2) : nok(code2);
  }
}
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral,
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable,
    gfmTaskListItem
  ]);
}
function ccount(value, character2) {
  const source = String(value);
  if (typeof character2 !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source.indexOf(character2);
  while (index2 !== -1) {
    count++;
    index2 = source.indexOf(character2, index2 + character2.length);
  }
  return count;
}
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const convert = function(test) {
  if (test === void 0 || test === null) {
    return ok;
  }
  if (typeof test === "string") {
    return typeFactory(test);
  }
  if (typeof test === "object") {
    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
  }
  if (typeof test === "function") {
    return castFactory(test);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert(tests[index2]);
  }
  return castFactory(any3);
  function any3(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check2) {
  return castFactory(all2);
  function all2(node2) {
    let key;
    for (key in check2) {
      if (node2[key] !== check2[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check2) {
  return castFactory(type4);
  function type4(node2) {
    return node2 && node2.type === check2;
  }
}
function castFactory(check2) {
  return assertion;
  function assertion(...parameters) {
    return Boolean(check2.call(this, ...parameters));
  }
}
function ok() {
  return true;
}
const own = {}.hasOwnProperty;
const findAndReplace = function(tree, find2, replace2, options) {
  let settings;
  let schema;
  if (typeof find2 === "string" || find2 instanceof RegExp) {
    schema = [[find2, replace2]];
    settings = options;
  } else {
    schema = find2;
    settings = replace2;
  }
  if (!settings) {
    settings = {};
  }
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(schema);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  return tree;
  function visitor(node2, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      if (ignored(
        parent,
        grandparent ? grandparent.children.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node2, parents);
    }
  }
  function handler(node2, parents) {
    const parent = parents[parents.length - 1];
    const find3 = pairs[pairIndex][0];
    const replace3 = pairs[pairIndex][1];
    let start = 0;
    const index2 = parent.children.indexOf(node2);
    let change = false;
    let nodes = [];
    let position2;
    find3.lastIndex = 0;
    let match2 = find3.exec(node2.value);
    while (match2) {
      position2 = match2.index;
      const matchObject = {
        index: match2.index,
        input: match2.input,
        stack: [...parents, node2]
      };
      let value = replace3(...match2, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : void 0;
      }
      if (value !== false) {
        if (start !== position2) {
          nodes.push({
            type: "text",
            value: node2.value.slice(start, position2)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start = position2 + match2[0].length;
        change = true;
      }
      if (!find3.global) {
        break;
      }
      match2 = find3.exec(node2.value);
    }
    if (change) {
      if (start < node2.value.length) {
        nodes.push({ type: "text", value: node2.value.slice(start) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node2];
    }
    return index2 + nodes.length;
  }
};
function toPairs(schema) {
  const result = [];
  if (typeof schema !== "object") {
    throw new TypeError("Expected array or object as schema");
  }
  if (Array.isArray(schema)) {
    let index2 = -1;
    while (++index2 < schema.length) {
      result.push([
        toExpression(schema[index2][0]),
        toFunction(schema[index2][1])
      ]);
    }
  } else {
    let key;
    for (key in schema) {
      if (own.call(schema, key)) {
        result.push([toExpression(key), toFunction(schema[key])]);
      }
    }
  }
  return result;
}
function toExpression(find2) {
  return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : () => replace2;
}
const inConstruct = "phrasing";
const notInConstruct = ["autolink", "link", "image", "label"];
const gfmAutolinkLiteralFromMarkdown = {
  transforms: [transformGfmAutolinkLiterals],
  enter: {
    literalAutolink: enterLiteralAutolink,
    literalAutolinkEmail: enterLiteralAutolinkValue,
    literalAutolinkHttp: enterLiteralAutolinkValue,
    literalAutolinkWww: enterLiteralAutolinkValue
  },
  exit: {
    literalAutolink: exitLiteralAutolink,
    literalAutolinkEmail: exitLiteralAutolinkEmail,
    literalAutolinkHttp: exitLiteralAutolinkHttp,
    literalAutolinkWww: exitLiteralAutolinkWww
  }
};
const gfmAutolinkLiteralToMarkdown = {
  unsafe: [
    {
      character: "@",
      before: "[+\\-.\\w]",
      after: "[\\-.\\w]",
      inConstruct,
      notInConstruct
    },
    {
      character: ".",
      before: "[Ww]",
      after: "[\\-.\\w]",
      inConstruct,
      notInConstruct
    },
    { character: ":", before: "[ps]", after: "\\/", inConstruct, notInConstruct }
  ]
};
function enterLiteralAutolink(token2) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token2);
}
function enterLiteralAutolinkValue(token2) {
  this.config.enter.autolinkProtocol.call(this, token2);
}
function exitLiteralAutolinkHttp(token2) {
  this.config.exit.autolinkProtocol.call(this, token2);
}
function exitLiteralAutolinkWww(token2) {
  this.config.exit.data.call(this, token2);
  const node2 = this.stack[this.stack.length - 1];
  node2.url = "http://" + this.sliceSerialize(token2);
}
function exitLiteralAutolinkEmail(token2) {
  this.config.exit.autolinkEmail.call(this, token2);
}
function exitLiteralAutolink(token2) {
  this.exit(token2);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_24, protocol, domain2, path2, match2) {
  let prefix2 = "";
  if (!previous(match2)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix2 = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path2);
  if (!parts[0])
    return false;
  const result = {
    type: "link",
    title: null,
    url: prefix2 + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_24, atext, label, match2) {
  if (!previous(match2, true) || /[_-\d]$/.test(label)) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url2) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url2);
  let closingParenIndex;
  let openingParens;
  let closingParens;
  let trail;
  if (trailExec) {
    url2 = url2.slice(0, trailExec.index);
    trail = trailExec[0];
    closingParenIndex = trail.indexOf(")");
    openingParens = ccount(url2, "(");
    closingParens = ccount(url2, ")");
    while (closingParenIndex !== -1 && openingParens > closingParens) {
      url2 += trail.slice(0, closingParenIndex + 1);
      trail = trail.slice(closingParenIndex + 1);
      closingParenIndex = trail.indexOf(")");
      closingParens++;
    }
  }
  return [url2, trail];
}
function previous(match2, email2) {
  const code2 = match2.input.charCodeAt(match2.index - 1);
  return (match2.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email2 || code2 !== 47);
}
function association(node2) {
  if (node2.label || !node2.identifier) {
    return node2.label || "";
  }
  return decodeString(node2.identifier);
}
function track(options_) {
  const options = options_ || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line2 = now.line || 1;
  let column2 = now.column || 1;
  return { move: move2, current, shift };
  function current() {
    return { now: { line: line2, column: column2 }, lineShift };
  }
  function shift(value) {
    lineShift += value;
  }
  function move2(value = "") {
    const chunks = value.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line2 += chunks.length - 1;
    column2 = chunks.length === 1 ? column2 + tail.length : 1 + tail.length + lineShift;
    return value;
  }
}
function containerFlow(parent, context2, safeOptions) {
  const indexStack = context2.indexStack;
  const children = parent.children || [];
  const tracker = track(safeOptions);
  const results = [];
  let index2 = -1;
  indexStack.push(-1);
  while (++index2 < children.length) {
    const child = children[index2];
    indexStack[indexStack.length - 1] = index2;
    results.push(
      tracker.move(
        context2.handle(child, parent, context2, {
          before: "\n",
          after: "\n",
          ...tracker.current()
        })
      )
    );
    if (child.type !== "list") {
      context2.bulletLastUsed = void 0;
    }
    if (index2 < children.length - 1) {
      results.push(tracker.move(between(child, children[index2 + 1])));
    }
  }
  indexStack.pop();
  return results.join("");
  function between(left, right) {
    let index3 = context2.join.length;
    while (index3--) {
      const result = context2.join[index3](left, right, parent, context2);
      if (result === true || result === 1) {
        break;
      }
      if (typeof result === "number") {
        return "\n".repeat(1 + result);
      }
      if (result === false) {
        return "\n\n<!---->\n\n";
      }
    }
    return "\n\n";
  }
}
const eol = /\r?\n|\r/g;
function indentLines(value, map) {
  const result = [];
  let start = 0;
  let line2 = 0;
  let match2;
  while (match2 = eol.exec(value)) {
    one2(value.slice(start, match2.index));
    result.push(match2[0]);
    start = match2.index + match2[0].length;
    line2++;
  }
  one2(value.slice(start));
  return result.join("");
  function one2(value2) {
    result.push(map(value2, line2, !value2));
  }
}
function patternCompile(pattern4) {
  if (!pattern4._compiled) {
    const before = (pattern4.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern4.before ? "(?:" + pattern4.before + ")" : "");
    pattern4._compiled = new RegExp(
      (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern4.character) ? "\\" : "") + pattern4.character + (pattern4.after ? "(?:" + pattern4.after + ")" : ""),
      "g"
    );
  }
  return pattern4._compiled;
}
function patternInScope(stack, pattern4) {
  return listInScope(stack, pattern4.inConstruct, true) && !listInScope(stack, pattern4.notInConstruct, false);
}
function listInScope(stack, list2, none) {
  if (!list2) {
    return none;
  }
  if (typeof list2 === "string") {
    list2 = [list2];
  }
  let index2 = -1;
  while (++index2 < list2.length) {
    if (stack.includes(list2[index2])) {
      return true;
    }
  }
  return false;
}
function safe(context2, input, config) {
  const value = (config.before || "") + (input || "") + (config.after || "");
  const positions = [];
  const result = [];
  const infos = {};
  let index2 = -1;
  while (++index2 < context2.unsafe.length) {
    const pattern4 = context2.unsafe[index2];
    if (!patternInScope(context2.stack, pattern4)) {
      continue;
    }
    const expression = patternCompile(pattern4);
    let match2;
    while (match2 = expression.exec(value)) {
      const before = "before" in pattern4 || Boolean(pattern4.atBreak);
      const after = "after" in pattern4;
      const position2 = match2.index + (before ? match2[1].length : 0);
      if (positions.includes(position2)) {
        if (infos[position2].before && !before) {
          infos[position2].before = false;
        }
        if (infos[position2].after && !after) {
          infos[position2].after = false;
        }
      } else {
        positions.push(position2);
        infos[position2] = { before, after };
      }
    }
  }
  positions.sort(numerical);
  let start = config.before ? config.before.length : 0;
  const end = value.length - (config.after ? config.after.length : 0);
  index2 = -1;
  while (++index2 < positions.length) {
    const position2 = positions[index2];
    if (position2 < start || position2 >= end) {
      continue;
    }
    if (position2 + 1 < end && positions[index2 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after || positions[index2 - 1] === position2 - 1 && infos[position2].before && !infos[position2 - 1].before && !infos[position2 - 1].after) {
      continue;
    }
    if (start !== position2) {
      result.push(escapeBackslashes(value.slice(start, position2), "\\"));
    }
    start = position2;
    if (/[!-/:-@[-`{-~]/.test(value.charAt(position2)) && (!config.encode || !config.encode.includes(value.charAt(position2)))) {
      result.push("\\");
    } else {
      result.push(
        "&#x" + value.charCodeAt(position2).toString(16).toUpperCase() + ";"
      );
      start++;
    }
  }
  result.push(escapeBackslashes(value.slice(start, end), config.after));
  return result.join("");
}
function numerical(a, b2) {
  return a - b2;
}
function escapeBackslashes(value, after) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  const positions = [];
  const results = [];
  const whole = value + after;
  let index2 = -1;
  let start = 0;
  let match2;
  while (match2 = expression.exec(whole)) {
    positions.push(match2.index);
  }
  while (++index2 < positions.length) {
    if (start !== positions[index2]) {
      results.push(value.slice(start, positions[index2]));
    }
    results.push("\\");
    start = positions[index2];
  }
  results.push(value.slice(start));
  return results.join("");
}
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  };
  function enterFootnoteDefinition(token2) {
    this.enter(
      { type: "footnoteDefinition", identifier: "", label: "", children: [] },
      token2
    );
  }
  function enterFootnoteDefinitionLabelString() {
    this.buffer();
  }
  function exitFootnoteDefinitionLabelString(token2) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
  }
  function exitFootnoteDefinition(token2) {
    this.exit(token2);
  }
  function enterFootnoteCall(token2) {
    this.enter({ type: "footnoteReference", identifier: "", label: "" }, token2);
  }
  function enterFootnoteCallString() {
    this.buffer();
  }
  function exitFootnoteCallString(token2) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
  }
  function exitFootnoteCall(token2) {
    this.exit(token2);
  }
}
function gfmFootnoteToMarkdown() {
  footnoteReference2.peek = footnoteReferencePeek;
  return {
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition, footnoteReference: footnoteReference2 }
  };
  function footnoteReference2(node2, _24, context2, safeOptions) {
    const tracker = track(safeOptions);
    let value = tracker.move("[^");
    const exit2 = context2.enter("footnoteReference");
    const subexit = context2.enter("reference");
    value += tracker.move(
      safe(context2, association(node2), {
        ...tracker.current(),
        before: value,
        after: "]"
      })
    );
    subexit();
    exit2();
    value += tracker.move("]");
    return value;
  }
  function footnoteReferencePeek() {
    return "[";
  }
  function footnoteDefinition(node2, _24, context2, safeOptions) {
    const tracker = track(safeOptions);
    let value = tracker.move("[^");
    const exit2 = context2.enter("footnoteDefinition");
    const subexit = context2.enter("label");
    value += tracker.move(
      safe(context2, association(node2), {
        ...tracker.current(),
        before: value,
        after: "]"
      })
    );
    subexit();
    value += tracker.move(
      "]:" + (node2.children && node2.children.length > 0 ? " " : "")
    );
    tracker.shift(4);
    value += tracker.move(
      indentLines(containerFlow(node2, context2, tracker.current()), map)
    );
    exit2();
    return value;
    function map(line2, index2, blank) {
      if (index2) {
        return (blank ? "" : "    ") + line2;
      }
      return line2;
    }
  }
}
function containerPhrasing(parent, context2, safeOptions) {
  const indexStack = context2.indexStack;
  const children = parent.children || [];
  const results = [];
  let index2 = -1;
  let before = safeOptions.before;
  indexStack.push(-1);
  let tracker = track(safeOptions);
  while (++index2 < children.length) {
    const child = children[index2];
    let after;
    indexStack[indexStack.length - 1] = index2;
    if (index2 + 1 < children.length) {
      let handle2 = context2.handle.handlers[children[index2 + 1].type];
      if (handle2 && handle2.peek)
        handle2 = handle2.peek;
      after = handle2 ? handle2(children[index2 + 1], parent, context2, {
        before: "",
        after: "",
        ...tracker.current()
      }).charAt(0) : "";
    } else {
      after = safeOptions.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(
        /(\r?\n|\r)$/,
        " "
      );
      before = " ";
      tracker = track(safeOptions);
      tracker.move(results.join(""));
    }
    results.push(
      tracker.move(
        context2.handle(child, parent, context2, {
          ...tracker.current(),
          before,
          after
        })
      )
    );
    before = results[results.length - 1].slice(-1);
  }
  indexStack.pop();
  return results.join("");
}
const gfmStrikethroughFromMarkdown = {
  canContainEols: ["delete"],
  enter: { strikethrough: enterStrikethrough },
  exit: { strikethrough: exitStrikethrough }
};
const gfmStrikethroughToMarkdown = {
  unsafe: [{ character: "~", inConstruct: "phrasing" }],
  handlers: { delete: handleDelete }
};
handleDelete.peek = peekDelete;
function enterStrikethrough(token2) {
  this.enter({ type: "delete", children: [] }, token2);
}
function exitStrikethrough(token2) {
  this.exit(token2);
}
function handleDelete(node2, _24, context2, safeOptions) {
  const tracker = track(safeOptions);
  const exit2 = context2.enter("emphasis");
  let value = tracker.move("~~");
  value += containerPhrasing(node2, context2, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit2();
  return value;
}
function peekDelete() {
  return "~";
}
inlineCode.peek = inlineCodePeek;
function inlineCode(node2, _24, context2) {
  let value = node2.value || "";
  let sequence = "`";
  let index2 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index2 < context2.unsafe.length) {
    const pattern4 = context2.unsafe[index2];
    const expression = patternCompile(pattern4);
    let match2;
    if (!pattern4.atBreak)
      continue;
    while (match2 = expression.exec(value)) {
      let position2 = match2.index;
      if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value = value.slice(0, position2) + " " + value.slice(match2.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}
function markdownTable(table2, options = {}) {
  const align = (options.align || []).concat();
  const stringLength = options.stringLength || defaultStringLength;
  const alignments = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table2.length) {
    const row2 = [];
    const sizes3 = [];
    let columnIndex2 = -1;
    if (table2[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table2[rowIndex].length;
    }
    while (++columnIndex2 < table2[rowIndex].length) {
      const cell = serialize$1(table2[rowIndex][columnIndex2]);
      if (options.alignDelimiters !== false) {
        const size = stringLength(cell);
        sizes3[columnIndex2] = size;
        if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size;
        }
      }
      row2.push(cell);
    }
    cellMatrix[rowIndex] = row2;
    sizeMatrix[rowIndex] = sizes3;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code2 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code2;
    }
  }
  columnIndex = -1;
  const row = [];
  const sizes2 = [];
  while (++columnIndex < mostCellsPerRow) {
    const code2 = alignments[columnIndex];
    let before = "";
    let after = "";
    if (code2 === 99) {
      before = ":";
      after = ":";
    } else if (code2 === 108) {
      before = ":";
    } else if (code2 === 114) {
      after = ":";
    }
    let size = options.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before.length - after.length
    );
    const cell = before + "-".repeat(size) + after;
    if (options.alignDelimiters !== false) {
      size = before.length + size + after.length;
      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size;
      }
      sizes2[columnIndex] = size;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes2);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row2 = cellMatrix[rowIndex];
    const sizes3 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line2 = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell = row2[columnIndex] || "";
      let before = "";
      let after = "";
      if (options.alignDelimiters !== false) {
        const size = longestCellByColumn[columnIndex] - (sizes3[columnIndex] || 0);
        const code2 = alignments[columnIndex];
        if (code2 === 114) {
          before = " ".repeat(size);
        } else if (code2 === 99) {
          if (size % 2) {
            before = " ".repeat(size / 2 + 0.5);
            after = " ".repeat(size / 2 - 0.5);
          } else {
            before = " ".repeat(size / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size);
        }
      }
      if (options.delimiterStart !== false && !columnIndex) {
        line2.push("|");
      }
      if (options.padding !== false && !(options.alignDelimiters === false && cell === "") && (options.delimiterStart !== false || columnIndex)) {
        line2.push(" ");
      }
      if (options.alignDelimiters !== false) {
        line2.push(before);
      }
      line2.push(cell);
      if (options.alignDelimiters !== false) {
        line2.push(after);
      }
      if (options.padding !== false) {
        line2.push(" ");
      }
      if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line2.push("|");
      }
    }
    lines.push(
      options.delimiterEnd === false ? line2.join("").replace(/ +$/, "") : line2.join("")
    );
  }
  return lines.join("\n");
}
function serialize$1(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function defaultStringLength(value) {
  return value.length;
}
function toAlignment(value) {
  const code2 = typeof value === "string" ? value.codePointAt(0) : 0;
  return code2 === 67 || code2 === 99 ? 99 : code2 === 76 || code2 === 108 ? 108 : code2 === 82 || code2 === 114 ? 114 : 0;
}
const gfmTableFromMarkdown = {
  enter: {
    table: enterTable,
    tableData: enterCell,
    tableHeader: enterCell,
    tableRow: enterRow
  },
  exit: {
    codeText: exitCodeText,
    table: exitTable,
    tableData: exit,
    tableHeader: exit,
    tableRow: exit
  }
};
function enterTable(token2) {
  const align = token2._align;
  this.enter(
    {
      type: "table",
      align: align.map((d2) => d2 === "none" ? null : d2),
      children: []
    },
    token2
  );
  this.setData("inTable", true);
}
function exitTable(token2) {
  this.exit(token2);
  this.setData("inTable");
}
function enterRow(token2) {
  this.enter({ type: "tableRow", children: [] }, token2);
}
function exit(token2) {
  this.exit(token2);
}
function enterCell(token2) {
  this.enter({ type: "tableCell", children: [] }, token2);
}
function exitCodeText(token2) {
  let value = this.resume();
  if (this.getData("inTable")) {
    value = value.replace(/\\([\\|])/g, replace$1);
  }
  const node2 = this.stack[this.stack.length - 1];
  node2.value = value;
  this.exit(token2);
}
function replace$1($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      { atBreak: true, character: "|", after: "[	 :-]" },
      { character: "|", inConstruct: "tableCell" },
      { atBreak: true, character: ":", after: "-" },
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      table: handleTable,
      tableRow: handleTableRow,
      tableCell: handleTableCell,
      inlineCode: inlineCodeWithTable
    }
  };
  function handleTable(node2, _24, context2, safeOptions) {
    return serializeData(
      handleTableAsData(node2, context2, safeOptions),
      node2.align
    );
  }
  function handleTableRow(node2, _24, context2, safeOptions) {
    const row = handleTableRowAsData(node2, context2, safeOptions);
    const value = serializeData([row]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node2, _24, context2, safeOptions) {
    const exit2 = context2.enter("tableCell");
    const subexit = context2.enter("phrasing");
    const value = containerPhrasing(node2, context2, {
      ...safeOptions,
      before: around,
      after: around
    });
    subexit();
    exit2();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      alignDelimiters,
      padding,
      stringLength
    });
  }
  function handleTableAsData(node2, context2, safeOptions) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = context2.enter("table");
    while (++index2 < children.length) {
      result[index2] = handleTableRowAsData(
        children[index2],
        context2,
        safeOptions
      );
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node2, context2, safeOptions) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = context2.enter("tableRow");
    while (++index2 < children.length) {
      result[index2] = handleTableCell(
        children[index2],
        node2,
        context2,
        safeOptions
      );
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node2, parent, context2) {
    let value = inlineCode(node2, parent, context2);
    if (context2.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}
function checkBullet(context2) {
  const marker = context2.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker;
}
function checkListItemIndent(context2) {
  const style2 = context2.options.listItemIndent || "tab";
  if (style2 === 1 || style2 === "1") {
    return "one";
  }
  if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style2;
}
function listItem(node2, parent, context2, safeOptions) {
  const listItemIndent = checkListItemIndent(context2);
  let bullet = context2.bulletCurrent || checkBullet(context2);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (context2.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size = Math.ceil(size / 4) * 4;
  }
  const tracker = track(safeOptions);
  tracker.move(bullet + " ".repeat(size - bullet.length));
  tracker.shift(size);
  const exit2 = context2.enter("listItem");
  const value = indentLines(
    containerFlow(node2, context2, tracker.current()),
    map
  );
  exit2();
  return value;
  function map(line2, index2, blank) {
    if (index2) {
      return (blank ? "" : " ".repeat(size)) + line2;
    }
    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line2;
  }
}
const gfmTaskListItemFromMarkdown = {
  exit: {
    taskListCheckValueChecked: exitCheck,
    taskListCheckValueUnchecked: exitCheck,
    paragraph: exitParagraphWithTaskListItem
  }
};
const gfmTaskListItemToMarkdown = {
  unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
  handlers: { listItem: listItemWithTaskListItem }
};
function exitCheck(token2) {
  const node2 = this.stack[this.stack.length - 2];
  node2.checked = token2.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token2) {
  const parent = this.stack[this.stack.length - 2];
  const node2 = this.stack[this.stack.length - 1];
  const siblings = parent.children;
  const head = node2.children[0];
  let index2 = -1;
  let firstParaghraph;
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean" && head && head.type === "text") {
    while (++index2 < siblings.length) {
      const sibling = siblings[index2];
      if (sibling.type === "paragraph") {
        firstParaghraph = sibling;
        break;
      }
    }
    if (firstParaghraph === node2) {
      head.value = head.value.slice(1);
      if (head.value.length === 0) {
        node2.children.shift();
      } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
        head.position.start.column++;
        head.position.start.offset++;
        node2.position.start = Object.assign({}, head.position.start);
      }
    }
  }
  this.exit(token2);
}
function listItemWithTaskListItem(node2, parent, context2, safeOptions) {
  const head = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = track(safeOptions);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = listItem(node2, parent, context2, {
    ...safeOptions,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check2);
  }
  return value;
  function check2($0) {
    return $0 + checkbox;
  }
}
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown,
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown,
    gfmTableFromMarkdown,
    gfmTaskListItemFromMarkdown
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown,
      gfmFootnoteToMarkdown(),
      gfmStrikethroughToMarkdown,
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown
    ]
  };
}
function remarkGfm(options = {}) {
  const data2 = this.data();
  add("micromarkExtensions", gfm(options));
  add("fromMarkdownExtensions", gfmFromMarkdown());
  add("toMarkdownExtensions", gfmToMarkdown(options));
  function add(field, value) {
    const list2 = data2[field] ? data2[field] : data2[field] = [];
    list2.push(value);
  }
}
var tinycolor$2 = { exports: {} };
(function(module2) {
  (function(Math2) {
    var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
    function tinycolor2(color2, opts) {
      color2 = color2 ? color2 : "";
      opts = opts || {};
      if (color2 instanceof tinycolor2) {
        return color2;
      }
      if (!(this instanceof tinycolor2)) {
        return new tinycolor2(color2, opts);
      }
      var rgb = inputToRGB2(color2);
      this._originalInput = color2, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
      this._gradientType = opts.gradientType;
      if (this._r < 1) {
        this._r = mathRound(this._r);
      }
      if (this._g < 1) {
        this._g = mathRound(this._g);
      }
      if (this._b < 1) {
        this._b = mathRound(this._b);
      }
      this._ok = rgb.ok;
      this._tc_id = tinyCounter++;
    }
    tinycolor2.prototype = {
      isDark: function() {
        return this.getBrightness() < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      isValid: function() {
        return this._ok;
      },
      getOriginalInput: function() {
        return this._originalInput;
      },
      getFormat: function() {
        return this._format;
      },
      getAlpha: function() {
        return this._a;
      },
      getBrightness: function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      },
      getLuminance: function() {
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R2, G2, B2;
        RsRGB = rgb.r / 255;
        GsRGB = rgb.g / 255;
        BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) {
          R2 = RsRGB / 12.92;
        } else {
          R2 = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G2 = GsRGB / 12.92;
        } else {
          G2 = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B2 = BsRGB / 12.92;
        } else {
          B2 = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
      },
      setAlpha: function(value) {
        this._a = boundAlpha2(value);
        this._roundA = mathRound(100 * this._a) / 100;
        return this;
      },
      toHsv: function() {
        var hsv = rgbToHsv2(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
      },
      toHsvString: function() {
        var hsv = rgbToHsv2(this._r, this._g, this._b);
        var h2 = mathRound(hsv.h * 360), s2 = mathRound(hsv.s * 100), v2 = mathRound(hsv.v * 100);
        return this._a == 1 ? "hsv(" + h2 + ", " + s2 + "%, " + v2 + "%)" : "hsva(" + h2 + ", " + s2 + "%, " + v2 + "%, " + this._roundA + ")";
      },
      toHsl: function() {
        var hsl = rgbToHsl2(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
      },
      toHslString: function() {
        var hsl = rgbToHsl2(this._r, this._g, this._b);
        var h2 = mathRound(hsl.h * 360), s2 = mathRound(hsl.s * 100), l2 = mathRound(hsl.l * 100);
        return this._a == 1 ? "hsl(" + h2 + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
      },
      toHex: function(allow3Char) {
        return rgbToHex2(this._r, this._g, this._b, allow3Char);
      },
      toHexString: function(allow3Char) {
        return "#" + this.toHex(allow3Char);
      },
      toHex8: function(allow4Char) {
        return rgbaToHex2(this._r, this._g, this._b, this._a, allow4Char);
      },
      toHex8String: function(allow4Char) {
        return "#" + this.toHex8(allow4Char);
      },
      toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
      },
      toRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
      },
      toPercentageRgb: function() {
        return { r: mathRound(bound012(this._r, 255) * 100) + "%", g: mathRound(bound012(this._g, 255) * 100) + "%", b: mathRound(bound012(this._b, 255) * 100) + "%", a: this._a };
      },
      toPercentageRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(bound012(this._r, 255) * 100) + "%, " + mathRound(bound012(this._g, 255) * 100) + "%, " + mathRound(bound012(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound012(this._r, 255) * 100) + "%, " + mathRound(bound012(this._g, 255) * 100) + "%, " + mathRound(bound012(this._b, 255) * 100) + "%, " + this._roundA + ")";
      },
      toName: function() {
        if (this._a === 0) {
          return "transparent";
        }
        if (this._a < 1) {
          return false;
        }
        return hexNames[rgbToHex2(this._r, this._g, this._b, true)] || false;
      },
      toFilter: function(secondColor) {
        var hex8String = "#" + rgbaToArgbHex2(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";
        if (secondColor) {
          var s2 = tinycolor2(secondColor);
          secondHex8String = "#" + rgbaToArgbHex2(s2._r, s2._g, s2._b, s2._a);
        }
        return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
      },
      toString: function(format2) {
        var formatSet = !!format2;
        format2 = format2 || this._format;
        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
        if (needsAlphaFormat) {
          if (format2 === "name" && this._a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format2 === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format2 === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format2 === "hex" || format2 === "hex6") {
          formattedString = this.toHexString();
        }
        if (format2 === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format2 === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format2 === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format2 === "name") {
          formattedString = this.toName();
        }
        if (format2 === "hsl") {
          formattedString = this.toHslString();
        }
        if (format2 === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      },
      clone: function() {
        return tinycolor2(this.toString());
      },
      _applyModification: function(fn2, args) {
        var color2 = fn2.apply(null, [this].concat([].slice.call(args)));
        this._r = color2._r;
        this._g = color2._g;
        this._b = color2._b;
        this.setAlpha(color2._a);
        return this;
      },
      lighten: function() {
        return this._applyModification(lighten, arguments);
      },
      brighten: function() {
        return this._applyModification(brighten, arguments);
      },
      darken: function() {
        return this._applyModification(darken, arguments);
      },
      desaturate: function() {
        return this._applyModification(desaturate, arguments);
      },
      saturate: function() {
        return this._applyModification(saturate, arguments);
      },
      greyscale: function() {
        return this._applyModification(greyscale, arguments);
      },
      spin: function() {
        return this._applyModification(spin2, arguments);
      },
      _applyCombination: function(fn2, args) {
        return fn2.apply(null, [this].concat([].slice.call(args)));
      },
      analogous: function() {
        return this._applyCombination(analogous, arguments);
      },
      complement: function() {
        return this._applyCombination(complement, arguments);
      },
      monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
      },
      splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
      },
      triad: function() {
        return this._applyCombination(triad, arguments);
      },
      tetrad: function() {
        return this._applyCombination(tetrad, arguments);
      }
    };
    tinycolor2.fromRatio = function(color2, opts) {
      if (typeof color2 == "object") {
        var newColor = {};
        for (var i in color2) {
          if (color2.hasOwnProperty(i)) {
            if (i === "a") {
              newColor[i] = color2[i];
            } else {
              newColor[i] = convertToPercentage2(color2[i]);
            }
          }
        }
        color2 = newColor;
      }
      return tinycolor2(color2, opts);
    };
    function inputToRGB2(color2) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a = 1;
      var s2 = null;
      var v2 = null;
      var l2 = null;
      var ok2 = false;
      var format2 = false;
      if (typeof color2 == "string") {
        color2 = stringInputToObject2(color2);
      }
      if (typeof color2 == "object") {
        if (isValidCSSUnit2(color2.r) && isValidCSSUnit2(color2.g) && isValidCSSUnit2(color2.b)) {
          rgb = rgbToRgb2(color2.r, color2.g, color2.b);
          ok2 = true;
          format2 = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit2(color2.h) && isValidCSSUnit2(color2.s) && isValidCSSUnit2(color2.v)) {
          s2 = convertToPercentage2(color2.s);
          v2 = convertToPercentage2(color2.v);
          rgb = hsvToRgb2(color2.h, s2, v2);
          ok2 = true;
          format2 = "hsv";
        } else if (isValidCSSUnit2(color2.h) && isValidCSSUnit2(color2.s) && isValidCSSUnit2(color2.l)) {
          s2 = convertToPercentage2(color2.s);
          l2 = convertToPercentage2(color2.l);
          rgb = hslToRgb2(color2.h, s2, l2);
          ok2 = true;
          format2 = "hsl";
        }
        if (color2.hasOwnProperty("a")) {
          a = color2.a;
        }
      }
      a = boundAlpha2(a);
      return {
        ok: ok2,
        format: color2.format || format2,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a
      };
    }
    function rgbToRgb2(r2, g2, b2) {
      return {
        r: bound012(r2, 255) * 255,
        g: bound012(g2, 255) * 255,
        b: bound012(b2, 255) * 255
      };
    }
    function rgbToHsl2(r2, g2, b2) {
      r2 = bound012(r2, 255);
      g2 = bound012(g2, 255);
      b2 = bound012(b2, 255);
      var max = mathMax(r2, g2, b2), min = mathMin(r2, g2, b2);
      var h2, s2, l2 = (max + min) / 2;
      if (max == min) {
        h2 = s2 = 0;
      } else {
        var d2 = max - min;
        s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
        switch (max) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, l: l2 };
    }
    function hslToRgb2(h2, s2, l2) {
      var r2, g2, b2;
      h2 = bound012(h2, 360);
      s2 = bound012(s2, 100);
      l2 = bound012(l2, 100);
      function hue2rgb2(p3, q3, t2) {
        if (t2 < 0)
          t2 += 1;
        if (t2 > 1)
          t2 -= 1;
        if (t2 < 1 / 6)
          return p3 + (q3 - p3) * 6 * t2;
        if (t2 < 1 / 2)
          return q3;
        if (t2 < 2 / 3)
          return p3 + (q3 - p3) * (2 / 3 - t2) * 6;
        return p3;
      }
      if (s2 === 0) {
        r2 = g2 = b2 = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        var p2 = 2 * l2 - q2;
        r2 = hue2rgb2(p2, q2, h2 + 1 / 3);
        g2 = hue2rgb2(p2, q2, h2);
        b2 = hue2rgb2(p2, q2, h2 - 1 / 3);
      }
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHsv2(r2, g2, b2) {
      r2 = bound012(r2, 255);
      g2 = bound012(g2, 255);
      b2 = bound012(b2, 255);
      var max = mathMax(r2, g2, b2), min = mathMin(r2, g2, b2);
      var h2, s2, v2 = max;
      var d2 = max - min;
      s2 = max === 0 ? 0 : d2 / max;
      if (max == min) {
        h2 = 0;
      } else {
        switch (max) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, v: v2 };
    }
    function hsvToRgb2(h2, s2, v2) {
      h2 = bound012(h2, 360) * 6;
      s2 = bound012(s2, 100);
      v2 = bound012(v2, 100);
      var i = Math2.floor(h2), f2 = h2 - i, p2 = v2 * (1 - s2), q2 = v2 * (1 - f2 * s2), t2 = v2 * (1 - (1 - f2) * s2), mod = i % 6, r2 = [v2, q2, p2, p2, t2, v2][mod], g2 = [t2, v2, v2, q2, p2, p2][mod], b2 = [p2, p2, t2, v2, v2, q2][mod];
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHex2(r2, g2, b2, allow3Char) {
      var hex2 = [
        pad22(mathRound(r2).toString(16)),
        pad22(mathRound(g2).toString(16)),
        pad22(mathRound(b2).toString(16))
      ];
      if (allow3Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1)) {
        return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
      }
      return hex2.join("");
    }
    function rgbaToHex2(r2, g2, b2, a, allow4Char) {
      var hex2 = [
        pad22(mathRound(r2).toString(16)),
        pad22(mathRound(g2).toString(16)),
        pad22(mathRound(b2).toString(16)),
        pad22(convertDecimalToHex2(a))
      ];
      if (allow4Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1) && hex2[3].charAt(0) == hex2[3].charAt(1)) {
        return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
      }
      return hex2.join("");
    }
    function rgbaToArgbHex2(r2, g2, b2, a) {
      var hex2 = [
        pad22(convertDecimalToHex2(a)),
        pad22(mathRound(r2).toString(16)),
        pad22(mathRound(g2).toString(16)),
        pad22(mathRound(b2).toString(16))
      ];
      return hex2.join("");
    }
    tinycolor2.equals = function(color1, color2) {
      if (!color1 || !color2) {
        return false;
      }
      return tinycolor2(color1).toRgbString() == tinycolor2(color2).toRgbString();
    };
    tinycolor2.random = function() {
      return tinycolor2.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
      });
    };
    function desaturate(color2, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color2).toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp012(hsl.s);
      return tinycolor2(hsl);
    }
    function saturate(color2, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color2).toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp012(hsl.s);
      return tinycolor2(hsl);
    }
    function greyscale(color2) {
      return tinycolor2(color2).desaturate(100);
    }
    function lighten(color2, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color2).toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp012(hsl.l);
      return tinycolor2(hsl);
    }
    function brighten(color2, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var rgb = tinycolor2(color2).toRgb();
      rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
      rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
      rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
      return tinycolor2(rgb);
    }
    function darken(color2, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color2).toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp012(hsl.l);
      return tinycolor2(hsl);
    }
    function spin2(color2, amount) {
      var hsl = tinycolor2(color2).toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return tinycolor2(hsl);
    }
    function complement(color2) {
      var hsl = tinycolor2(color2).toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return tinycolor2(hsl);
    }
    function triad(color2) {
      var hsl = tinycolor2(color2).toHsl();
      var h2 = hsl.h;
      return [
        tinycolor2(color2),
        tinycolor2({ h: (h2 + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h2 + 240) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function tetrad(color2) {
      var hsl = tinycolor2(color2).toHsl();
      var h2 = hsl.h;
      return [
        tinycolor2(color2),
        tinycolor2({ h: (h2 + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h2 + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h2 + 270) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function splitcomplement(color2) {
      var hsl = tinycolor2(color2).toHsl();
      var h2 = hsl.h;
      return [
        tinycolor2(color2),
        tinycolor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function analogous(color2, results, slices) {
      results = results || 6;
      slices = slices || 30;
      var hsl = tinycolor2(color2).toHsl();
      var part = 360 / slices;
      var ret = [tinycolor2(color2)];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor2(hsl));
      }
      return ret;
    }
    function monochromatic(color2, results) {
      results = results || 6;
      var hsv = tinycolor2(color2).toHsv();
      var h2 = hsv.h, s2 = hsv.s, v2 = hsv.v;
      var ret = [];
      var modification = 1 / results;
      while (results--) {
        ret.push(tinycolor2({ h: h2, s: s2, v: v2 }));
        v2 = (v2 + modification) % 1;
      }
      return ret;
    }
    tinycolor2.mix = function(color1, color2, amount) {
      amount = amount === 0 ? 0 : amount || 50;
      var rgb1 = tinycolor2(color1).toRgb();
      var rgb2 = tinycolor2(color2).toRgb();
      var p2 = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
        a: (rgb2.a - rgb1.a) * p2 + rgb1.a
      };
      return tinycolor2(rgba);
    };
    tinycolor2.readability = function(color1, color2) {
      var c1 = tinycolor2(color1);
      var c2 = tinycolor2(color2);
      return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
    };
    tinycolor2.isReadable = function(color1, color2, wcag2) {
      var readability2 = tinycolor2.readability(color1, color2);
      var wcag2Parms, out;
      out = false;
      wcag2Parms = validateWCAG2Parms(wcag2);
      switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
          out = readability2 >= 4.5;
          break;
        case "AAlarge":
          out = readability2 >= 3;
          break;
        case "AAAsmall":
          out = readability2 >= 7;
          break;
      }
      return out;
    };
    tinycolor2.mostReadable = function(baseColor, colorList, args) {
      var bestColor = null;
      var bestScore = 0;
      var readability2;
      var includeFallbackColors, level, size;
      args = args || {};
      includeFallbackColors = args.includeFallbackColors;
      level = args.level;
      size = args.size;
      for (var i = 0; i < colorList.length; i++) {
        readability2 = tinycolor2.readability(baseColor, colorList[i]);
        if (readability2 > bestScore) {
          bestScore = readability2;
          bestColor = tinycolor2(colorList[i]);
        }
      }
      if (tinycolor2.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
        return bestColor;
      } else {
        args.includeFallbackColors = false;
        return tinycolor2.mostReadable(baseColor, ["#fff", "#000"], args);
      }
    };
    var names2 = tinycolor2.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    var hexNames = tinycolor2.hexNames = flip2(names2);
    function flip2(o) {
      var flipped = {};
      for (var i in o) {
        if (o.hasOwnProperty(i)) {
          flipped[o[i]] = i;
        }
      }
      return flipped;
    }
    function boundAlpha2(a) {
      a = parseFloat(a);
      if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
      }
      return a;
    }
    function bound012(n2, max) {
      if (isOnePointZero2(n2)) {
        n2 = "100%";
      }
      var processPercent = isPercentage2(n2);
      n2 = mathMin(max, mathMax(0, parseFloat(n2)));
      if (processPercent) {
        n2 = parseInt(n2 * max, 10) / 100;
      }
      if (Math2.abs(n2 - max) < 1e-6) {
        return 1;
      }
      return n2 % max / parseFloat(max);
    }
    function clamp012(val) {
      return mathMin(1, mathMax(0, val));
    }
    function parseIntFromHex2(val) {
      return parseInt(val, 16);
    }
    function isOnePointZero2(n2) {
      return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
    }
    function isPercentage2(n2) {
      return typeof n2 === "string" && n2.indexOf("%") != -1;
    }
    function pad22(c2) {
      return c2.length == 1 ? "0" + c2 : "" + c2;
    }
    function convertToPercentage2(n2) {
      if (n2 <= 1) {
        n2 = n2 * 100 + "%";
      }
      return n2;
    }
    function convertDecimalToHex2(d2) {
      return Math2.round(parseFloat(d2) * 255).toString(16);
    }
    function convertHexToDecimal2(h2) {
      return parseIntFromHex2(h2) / 255;
    }
    var matchers2 = function() {
      var CSS_INTEGER2 = "[-\\+]?\\d+%?";
      var CSS_NUMBER2 = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT2 = "(?:" + CSS_NUMBER2 + ")|(?:" + CSS_INTEGER2 + ")";
      var PERMISSIVE_MATCH32 = "[\\s|\\(]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")\\s*\\)?";
      var PERMISSIVE_MATCH42 = "[\\s|\\(]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")\\s*\\)?";
      return {
        CSS_UNIT: new RegExp(CSS_UNIT2),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH32),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH42),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH32),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH42),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH32),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH42),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
    }();
    function isValidCSSUnit2(color2) {
      return !!matchers2.CSS_UNIT.exec(color2);
    }
    function stringInputToObject2(color2) {
      color2 = color2.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
      var named = false;
      if (names2[color2]) {
        color2 = names2[color2];
        named = true;
      } else if (color2 == "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match2;
      if (match2 = matchers2.rgb.exec(color2)) {
        return { r: match2[1], g: match2[2], b: match2[3] };
      }
      if (match2 = matchers2.rgba.exec(color2)) {
        return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
      }
      if (match2 = matchers2.hsl.exec(color2)) {
        return { h: match2[1], s: match2[2], l: match2[3] };
      }
      if (match2 = matchers2.hsla.exec(color2)) {
        return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
      }
      if (match2 = matchers2.hsv.exec(color2)) {
        return { h: match2[1], s: match2[2], v: match2[3] };
      }
      if (match2 = matchers2.hsva.exec(color2)) {
        return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
      }
      if (match2 = matchers2.hex8.exec(color2)) {
        return {
          r: parseIntFromHex2(match2[1]),
          g: parseIntFromHex2(match2[2]),
          b: parseIntFromHex2(match2[3]),
          a: convertHexToDecimal2(match2[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match2 = matchers2.hex6.exec(color2)) {
        return {
          r: parseIntFromHex2(match2[1]),
          g: parseIntFromHex2(match2[2]),
          b: parseIntFromHex2(match2[3]),
          format: named ? "name" : "hex"
        };
      }
      if (match2 = matchers2.hex4.exec(color2)) {
        return {
          r: parseIntFromHex2(match2[1] + "" + match2[1]),
          g: parseIntFromHex2(match2[2] + "" + match2[2]),
          b: parseIntFromHex2(match2[3] + "" + match2[3]),
          a: convertHexToDecimal2(match2[4] + "" + match2[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match2 = matchers2.hex3.exec(color2)) {
        return {
          r: parseIntFromHex2(match2[1] + "" + match2[1]),
          g: parseIntFromHex2(match2[2] + "" + match2[2]),
          b: parseIntFromHex2(match2[3] + "" + match2[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function validateWCAG2Parms(parms) {
      var level, size;
      parms = parms || { "level": "AA", "size": "small" };
      level = (parms.level || "AA").toUpperCase();
      size = (parms.size || "small").toLowerCase();
      if (level !== "AA" && level !== "AAA") {
        level = "AA";
      }
      if (size !== "small" && size !== "large") {
        size = "small";
      }
      return { "level": level, "size": size };
    }
    if (module2.exports) {
      module2.exports = tinycolor2;
    } else {
      window.tinycolor = tinycolor2;
    }
  })(Math);
})(tinycolor$2);
var tinycolor$1 = tinycolor$2.exports;
const getCSSFontFamily = (f2) => {
  return !f2 ? void 0 : f2 === "YuGothic" ? `"\u6E38\u30B4\u30B7\u30C3\u30AF\u4F53", YuGothic, "\u6E38\u30B4\u30B7\u30C3\u30AF Medium", "Yu Gothic Medium", "\u6E38\u30B4\u30B7\u30C3\u30AF", "Yu Gothic"` : f2;
};
const toCSSFont = (t2, d2) => {
  var _a2, _b, _c, _d, _e2, _f, _g, _h;
  const ff = (_b = getCSSFontFamily((_a2 = t2 == null ? void 0 : t2.fontFamily) != null ? _a2 : d2 == null ? void 0 : d2.fontFamily)) == null ? void 0 : _b.replace("'", '"').trim();
  return `${((_c = t2 == null ? void 0 : t2.italic) != null ? _c : d2 == null ? void 0 : d2.italic) ? "italic " : ""}${((_d = t2 == null ? void 0 : t2.bold) != null ? _d : d2 == null ? void 0 : d2.bold) ? "bold " : ((_f = (_e2 = t2 == null ? void 0 : t2.fontWeight) != null ? _e2 : d2 == null ? void 0 : d2.fontWeight) != null ? _f : "") + " "}${(_h = (_g = t2 == null ? void 0 : t2.fontSize) != null ? _g : d2 == null ? void 0 : d2.fontSize) != null ? _h : 16}px ${ff ? ff.includes(`"`) ? ff : `"${ff}"` : "sans-serif"}`;
};
const toTextDecoration = (t2) => (t2 == null ? void 0 : t2.underline) ? "underline" : "none";
const typographyStyles = (t2) => {
  var _a2, _b;
  if (!t2)
    return null;
  return css$1`
    font: ${toCSSFont(t2)};
    text-decoration: ${toTextDecoration(t2)};
    color: ${(_a2 = t2.color) != null ? _a2 : null};
    text-align: ${(_b = t2.textAlign) != null ? _b : null};
  `;
};
const plugins = [remarkGfm];
const Markdown = ({
  className,
  styles,
  backgroundColor,
  children,
  onClick,
  onDoubleClick
}) => {
  const dark = React.useMemo(
    () => backgroundColor ? isDark(backgroundColor) : false,
    [backgroundColor]
  );
  return /* @__PURE__ */ React.createElement(Wrapper$7, {
    className: "markdown-body",
    styles,
    dark,
    onClick,
    onDoubleClick
  }, /* @__PURE__ */ React.createElement(ReactMarkdown, {
    remarkPlugins: plugins,
    className,
    linkTarget: "_blank"
  }, children || ""));
};
const Wrapper$7 = styled.div`
  background-color: transparent;
  color: inherit;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;

  ${({ styles }) => typographyStyles(styles)}

  h1,
  h2 {
    border-bottom: none;
  }

  code {
    background-color: ${({ dark }) => dark ? "rgba(240, 246, 252, 0.15)" : "rgba(27, 31, 35, 0.05)"};
  }

  .highlight pre,
  pre {
    background-color: ${({ dark }) => color(dark ? "#161b22" : "#f6f8fa", 0.1, dark)}; // #161b22 #f6f8fa
  }

  table tr {
    background-color: inherit;
    border-top-color: ${({ dark }) => color(dark ? "#272c32" : "#c6cbd1", 0.1, dark)};
  }

  table tr:nth-of-type(2n) {
    background-color: ${({ dark }) => color(dark ? "#161b22" : "#f6f8fa", 0.1, dark)};
  }

  img {
    max-width: 346px;
  }

  table td,
  table th {
    border-color: ${({ dark }) => color(dark ? "#3b434b" : "#dfe2e5", 0.1, dark)};
  }

  blockquote {
    color: inherit; /* #8b949e #6a737d */
    border-left-color: ${({ dark }) => color(dark ? "#3b434b" : "#dfe2e5", 0.1, dark)};
  }

  hr {
    background-color: ${({ dark }) => color(dark ? "#30363d" : "#e1e4e8", 0.1, dark)};
  }
`;
const color = (hex2, alpha, dark) => {
  const color2 = tinycolor$1(hex2).toRgb();
  const bg = dark ? 0 : 255;
  const nr2 = Math.floor((color2.r - (1 - alpha) * bg) / alpha);
  const ng = Math.floor((color2.g - (1 - alpha) * bg) / alpha);
  const nb = Math.floor((color2.b - (1 - alpha) * bg) / alpha);
  return `rgba(${nr2}, ${ng}, ${nb}, ${alpha})`;
};
const isDark = (hex2) => tinycolor$1(hex2).isDark();
const PluginAccordionItemBody = ({ children }) => {
  const theme2 = useTheme$3();
  const markdownTypographyStyle = {
    color: theme2.main.text
  };
  return /* @__PURE__ */ React.createElement(Wrapper$6, null, /* @__PURE__ */ React.createElement(Markdown, {
    backgroundColor: theme2.main.lightBackground,
    styles: markdownTypographyStyle
  }, children != null ? children : ""));
};
const Wrapper$6 = styled.div`
  padding: 24px;
`;
function _classCallCheck$2(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function ownKeys$8(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$8(Object(source), true).forEach(function(key) {
        _defineProperty$3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true
};
var i18nInstance;
var I18nContext = React.createContext();
function setDefaults() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  defaultOptions = _objectSpread$8(_objectSpread$8({}, defaultOptions), options);
}
function getDefaults$1() {
  return defaultOptions;
}
var ReportNamespaces = function() {
  function ReportNamespaces2() {
    _classCallCheck$2(this, ReportNamespaces2);
    this.usedNamespaces = {};
  }
  _createClass$2(ReportNamespaces2, [{
    key: "addUsedNamespaces",
    value: function addUsedNamespaces(namespaces) {
      var _this = this;
      namespaces.forEach(function(ns) {
        if (!_this.usedNamespaces[ns])
          _this.usedNamespaces[ns] = true;
      });
    }
  }, {
    key: "getUsedNamespaces",
    value: function getUsedNamespaces() {
      return Object.keys(this.usedNamespaces);
    }
  }]);
  return ReportNamespaces2;
}();
function setI18n(instance2) {
  i18nInstance = instance2;
}
function getI18n() {
  return i18nInstance;
}
var initReactI18next = {
  type: "3rdParty",
  init: function init(instance2) {
    setDefaults(instance2.options.react);
    setI18n(instance2);
  }
};
function warn() {
  if (console && console.warn) {
    var _console;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "string")
      args[0] = "react-i18next:: ".concat(args[0]);
    (_console = console).warn.apply(_console, args);
  }
}
var alreadyWarned = {};
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (typeof args[0] === "string" && alreadyWarned[args[0]])
    return;
  if (typeof args[0] === "string")
    alreadyWarned[args[0]] = new Date();
  warn.apply(void 0, args);
}
function loadNamespaces(i18n, ns, cb) {
  i18n.loadNamespaces(ns, function() {
    if (i18n.isInitialized) {
      cb();
    } else {
      var initialized = function initialized2() {
        setTimeout(function() {
          i18n.off("initialized", initialized2);
        }, 0);
        cb();
      };
      i18n.on("initialized", initialized);
    }
  });
}
function oldI18nextHasLoadedNamespace(ns, i18n) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var lng = i18n.languages[0];
  var fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
  var lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng.toLowerCase() === "cimode")
    return true;
  var loadNotPending = function loadNotPending2(l2, n2) {
    var loadState = i18n.services.backendConnector.state["".concat(l2, "|").concat(n2)];
    return loadState === -1 || loadState === 2;
  };
  if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns))
    return false;
  if (i18n.hasResourceBundle(lng, ns))
    return true;
  if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages)
    return true;
  if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
    return true;
  return false;
}
function hasLoadedNamespace(ns, i18n) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce("i18n.languages were undefined or empty", i18n.languages);
    return true;
  }
  var isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
  if (!isNewerI18next) {
    return oldI18nextHasLoadedNamespace(ns, i18n, options);
  }
  return i18n.hasLoadedNamespace(ns, {
    precheck: function precheck(i18nInstance2, loadNotPending) {
      if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns))
        return false;
    }
  });
}
function ownKeys$7(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$7(Object(source), true).forEach(function(key) {
        _defineProperty$3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function useTranslation(ns) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var i18nFromProps = props.i18n;
  var _ref2 = React.useContext(I18nContext) || {}, i18nFromContext = _ref2.i18n, defaultNSFromContext = _ref2.defaultNS;
  var i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces)
    i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    var notReadyT = function notReadyT2(k2) {
      return Array.isArray(k2) ? k2[k2.length - 1] : k2;
    };
    var retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if (i18n.options.react && i18n.options.react.wait !== void 0)
    warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  var i18nOptions = _objectSpread$7(_objectSpread$7(_objectSpread$7({}, getDefaults$1()), i18n.options.react), props);
  var useSuspense = i18nOptions.useSuspense, keyPrefix = i18nOptions.keyPrefix;
  var namespaces = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  if (i18n.reportNamespaces.addUsedNamespaces)
    i18n.reportNamespaces.addUsedNamespaces(namespaces);
  var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(function(n2) {
    return hasLoadedNamespace(n2, i18n, i18nOptions);
  });
  function getT() {
    return i18n.getFixedT(null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  }
  var _useState = React.useState(getT), _useState2 = _slicedToArray$1(_useState, 2), t2 = _useState2[0], setT = _useState2[1];
  var isMounted = React.useRef(true);
  React.useEffect(function() {
    var bindI18n = i18nOptions.bindI18n, bindI18nStore = i18nOptions.bindI18nStore;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      loadNamespaces(i18n, namespaces, function() {
        if (isMounted.current)
          setT(getT);
      });
    }
    function boundReset() {
      if (isMounted.current)
        setT(getT);
    }
    if (bindI18n && i18n)
      i18n.on(bindI18n, boundReset);
    if (bindI18nStore && i18n)
      i18n.store.on(bindI18nStore, boundReset);
    return function() {
      isMounted.current = false;
      if (bindI18n && i18n)
        bindI18n.split(" ").forEach(function(e2) {
          return i18n.off(e2, boundReset);
        });
      if (bindI18nStore && i18n)
        bindI18nStore.split(" ").forEach(function(e2) {
          return i18n.store.off(e2, boundReset);
        });
    };
  }, [i18n, namespaces.join()]);
  var isInitial = React.useRef(true);
  React.useEffect(function() {
    if (isMounted.current && !isInitial.current) {
      setT(getT);
    }
    isInitial.current = false;
  }, [i18n]);
  var ret = [t2, i18n, ready];
  ret.t = t2;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready)
    return ret;
  if (!ready && !useSuspense)
    return ret;
  throw new Promise(function(resolve) {
    loadNamespaces(i18n, namespaces, function() {
      resolve();
    });
  });
}
function I18nextProvider(_ref2) {
  var i18n = _ref2.i18n, defaultNS = _ref2.defaultNS, children = _ref2.children;
  var value = React.useMemo(function() {
    return {
      i18n,
      defaultNS
    };
  }, [i18n, defaultNS]);
  return React.createElement(I18nContext.Provider, {
    value
  }, children);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _setPrototypeOf$3(o, p2) {
  _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$3(o, p2);
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf$3(subClass, superClass);
}
function _possibleConstructorReturn$2(self2, call2) {
  if (call2 && (_typeof$8(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$2(self2);
}
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$3(o);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _toArray$1(arr2) {
  return _arrayWithHoles$1(arr2) || _iterableToArray(arr2) || _unsupportedIterableToArray$1(arr2) || _nonIterableRest$1();
}
function ownKeys$3(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty$3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn2(args) {
    this.output("warn", args);
  },
  error: function error2(args) {
    this.output("error", args);
  },
  output: function output(type4, args) {
    if (console && console[type4])
      console[type4].apply(console, args);
  }
};
var Logger = function() {
  function Logger2(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$2(this, Logger2);
    this.init(concreteLogger, options);
  }
  _createClass$2(Logger2, [{
    key: "init",
    value: function init2(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn3() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error3() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix2, debugOnly) {
      if (debugOnly && !this.debug)
        return null;
      if (typeof args[0] === "string")
        args[0] = "".concat(prefix2).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create3(moduleName) {
      return new Logger2(this.logger, _objectSpread(_objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger();
var EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck$2(this, EventEmitter2);
    this.observers = {};
  }
  _createClass$2(EventEmitter2, [{
    key: "on",
    value: function on2(events, listener) {
      var _this = this;
      events.split(" ").forEach(function(event) {
        _this.observers[event] = _this.observers[event] || [];
        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event])
        return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event] = this.observers[event].filter(function(l2) {
        return l2 !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise = new Promise(function(resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object4) {
  if (object4 == null)
    return "";
  return "" + object4;
}
function copy(a, s2, t2) {
  a.forEach(function(m2) {
    if (s2[m2])
      t2[m2] = s2[m2];
  });
}
function getLastOfPath(object4, path2, Empty2) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object4 || typeof object4 === "string";
  }
  var stack = typeof path2 !== "string" ? [].concat(path2) : path2.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    if (!object4[key] && Empty2)
      object4[key] = new Empty2();
    if (Object.prototype.hasOwnProperty.call(object4, key)) {
      object4 = object4[key];
    } else {
      object4 = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object4,
    k: cleanKey(stack.shift())
  };
}
function setPath(object4, path2, newValue) {
  var _getLastOfPath = getLastOfPath(object4, path2, Object), obj = _getLastOfPath.obj, k2 = _getLastOfPath.k;
  obj[k2] = newValue;
}
function pushPath(object4, path2, newValue, concat2) {
  var _getLastOfPath2 = getLastOfPath(object4, path2, Object), obj = _getLastOfPath2.obj, k2 = _getLastOfPath2.k;
  obj[k2] = obj[k2] || [];
  if (concat2)
    obj[k2] = obj[k2].concat(newValue);
  if (!concat2)
    obj[k2].push(newValue);
}
function getPath$1(object4, path2) {
  var _getLastOfPath3 = getLastOfPath(object4, path2), obj = _getLastOfPath3.obj, k2 = _getLastOfPath3.k;
  if (!obj)
    return void 0;
  return obj[k2];
}
function getPathWithDefaults(data2, defaultData, key) {
  var value = getPath$1(data2, key);
  if (value !== void 0) {
    return value;
  }
  return getPath$1(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data2) {
  if (typeof data2 === "string") {
    return data2.replace(/[&<>"'\/]/g, function(s2) {
      return _entityMap[s2];
    });
  }
  return data2;
}
var isIE10 = typeof window !== "undefined" && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c2) {
    return nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0;
  });
  if (possibleChars.length === 0)
    return true;
  var r2 = new RegExp("(".concat(possibleChars.map(function(c2) {
    return c2 === "?" ? "\\?" : c2;
  }).join("|"), ")"));
  var matched = !r2.test(key);
  if (!matched) {
    var ki2 = key.indexOf(keySeparator);
    if (ki2 > 0 && !r2.test(key.substring(0, ki2))) {
      matched = true;
    }
  }
  return matched;
}
function ownKeys$1$1(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1$1(Object(source), true).forEach(function(key) {
        _defineProperty$3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function deepFind(obj, path2) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path2])
    return obj[path2];
  var paths = path2.split(keySeparator);
  var current = obj;
  for (var i = 0; i < paths.length; ++i) {
    if (!current)
      return void 0;
    if (typeof current[paths[i]] === "string" && i + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i]] === void 0) {
      var j2 = 2;
      var p2 = paths.slice(i, i + j2).join(keySeparator);
      var mix2 = current[p2];
      while (mix2 === void 0 && paths.length > i + j2) {
        j2++;
        p2 = paths.slice(i, i + j2).join(keySeparator);
        mix2 = current[p2];
      }
      if (mix2 === void 0)
        return void 0;
      if (path2.endsWith(p2)) {
        if (typeof mix2 === "string")
          return mix2;
        if (p2 && typeof mix2[p2] === "string")
          return mix2[p2];
      }
      var joinedPath = paths.slice(i + j2).join(keySeparator);
      if (joinedPath)
        return deepFind(mix2, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i]];
  }
  return current;
}
var ResourceStore = function(_EventEmitter) {
  _inherits$2(ResourceStore2, _EventEmitter);
  var _super = _createSuper$3(ResourceStore2);
  function ResourceStore2(data2) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck$2(this, ResourceStore2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized$2(_this));
    }
    _this.data = data2 || {};
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    if (_this.options.ignoreJSONStructure === void 0) {
      _this.options.ignoreJSONStructure = true;
    }
    return _this;
  }
  _createClass$2(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index2 = this.options.ns.indexOf(ns);
      if (index2 > -1) {
        this.options.ns.splice(index2, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path2 = [lng, ns];
      if (key && typeof key !== "string")
        path2 = path2.concat(key);
      if (key && typeof key === "string")
        path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
      }
      var result = getPath$1(this.data, path2);
      if (result || !ignoreJSONStructure || typeof key !== "string")
        return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0)
        keySeparator = ".";
      var path2 = [lng, ns];
      if (key)
        path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        value = ns;
        ns = path2[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path2, value);
      if (!options.silent)
        this.emit("added", lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources2) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m2 in resources2) {
        if (typeof resources2[m2] === "string" || Object.prototype.toString.apply(resources2[m2]) === "[object Array]")
          this.addResource(lng, ns, m2, resources2[m2], {
            silent: true
          });
      }
      if (!options.silent)
        this.emit("added", lng, ns, resources2);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources2, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path2 = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        deep = resources2;
        resources2 = ns;
        ns = path2[1];
      }
      this.addNamespaces(ns);
      var pack = getPath$1(this.data, path2) || {};
      if (deep) {
        deepExtend(pack, resources2, overwrite);
      } else {
        pack = _objectSpread$1(_objectSpread$1({}, pack), resources2);
      }
      setPath(this.data, path2, pack);
      if (!options.silent)
        this.emit("added", lng, ns, resources2);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns)
        ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1")
        return _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function hasLanguageSomeTranslations(lng) {
      var data2 = this.getDataByLanguage(lng);
      var n2 = data2 && Object.keys(data2) || [];
      return !!n2.find(function(v2) {
        return data2[v2] && Object.keys(data2[v2]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module2) {
    this.processors[module2.name] = module2;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor])
        value = _this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
function ownKeys$2$1(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$2$1(Object(source), true).forEach(function(key) {
        _defineProperty$3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$1$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _isNativeReflectConstruct$1$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var checkedLoadedFor = {};
var Translator = function(_EventEmitter) {
  _inherits$2(Translator2, _EventEmitter);
  var _super = _createSuper$1$1(Translator2);
  function Translator2(services) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$2(this, Translator2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized$2(_this));
    }
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized$2(_this));
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass$2(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng)
        this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key === void 0 || key === null) {
        return false;
      }
      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0)
        nsSeparator = ":";
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var namespaces = options.ns || this.options.defaultNS || [];
      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m2 = key.match(this.interpolator.nestingRegexp);
        if (m2 && m2.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
          namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys2, options, lastKey) {
      var _this2 = this;
      if (_typeof$8(options) !== "object" && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options)
        options = {};
      if (keys2 === void 0 || keys2 === null)
        return "";
      if (!Array.isArray(keys2))
        keys2 = [String(keys2)];
      var returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys2[keys2.length - 1], options), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
          if (returnDetails) {
            resolved.res = "".concat(namespace).concat(nsSeparator).concat(key);
            return resolved;
          }
          return "".concat(namespace).concat(nsSeparator).concat(key);
        }
        if (returnDetails) {
          resolved.res = key;
          return resolved;
        }
        return key;
      }
      var resolved = this.resolve(keys2, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          var r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
          if (returnDetails) {
            resolved.res = r2;
            return resolved;
          }
          return r2;
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m2 in res) {
            if (Object.prototype.hasOwnProperty.call(res, m2)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m2);
              copy2[m2] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options), {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy2[m2] === deepKey)
                copy2[m2] = res[m2];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res)
          res = this.extendTranslation(res, keys2, options, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
        var defaultValue = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options), {}, {
              keySeparator: false
            }));
            if (fk && fk.res)
              this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i = 0; i < fallbackLngs.length; i++) {
              lngs.push(fallbackLngs[i]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }
          var send = function send2(l2, k2, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options);
            }
            _this2.emit("missingKey", l2, namespace, k2, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language) {
                _this2.pluralResolver.getSuffixes(language, options).forEach(function(suffix) {
                  send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys2, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
          res = "".concat(namespace, ":").concat(key);
        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== "v1") {
            res = this.options.parseMissingKeyHandler(key, usedDefault ? res : void 0);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }
      if (returnDetails) {
        resolved.res = res;
        return resolved;
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation)
          this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options), {
            interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options.interpolation)
          }));
        var skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        var nestBef;
        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }
        var data2 = options.replace && typeof options.replace !== "string" ? options.replace : options;
        if (this.options.interpolation.defaultVariables)
          data2 = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data2);
        res = this.interpolator.interpolate(res, data2, options.lng || this.language, options);
        if (skipOnVariables) {
          var na2 = res.match(this.interpolator.nestingRegexp);
          var nestAft = na2 && na2.length;
          if (nestBef < nestAft)
            options.nest = false;
        }
        if (options.nest !== false)
          res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options.context) {
              _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
              return null;
            }
            return _this3.translate.apply(_this3, args.concat([key]));
          }, options);
        if (options.interpolation)
          this.interpolator.reset();
      }
      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
          i18nResolved: resolved
        }, options) : options, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys2) {
      var _this4 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys2 === "string")
        keys2 = [keys2];
      keys2.forEach(function(k2) {
        if (_this4.isValidLookup(found))
          return;
        var extracted = _this4.extractFromKey(k2, options);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS)
          namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
        var needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces.forEach(function(ns) {
          if (_this4.isValidLookup(found))
            return;
          usedNS = ns;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code2) {
            if (_this4.isValidLookup(found))
              return;
            usedLng = code2;
            var finalKeys = [key];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code2, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling)
                pluralSuffix = _this4.pluralResolver.getSuffix(code2, options.count, options);
              var zeroSuffix = "_zero";
              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }
              if (needsContextHandling) {
                var contextKey2 = "".concat(key).concat(_this4.options.contextSeparator).concat(options.context);
                finalKeys.push(contextKey2);
                if (needsPluralHandling) {
                  finalKeys.push(contextKey2 + pluralSuffix);
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey2 + zeroSuffix);
                  }
                }
              }
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code2, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code2, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource)
        return this.i18nFormat.getResource(code2, ns, key, options);
      return this.resourceStore.getResource(code2, ns, key, options);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options) {
      var prefix2 = "defaultValue";
      for (var option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option) && prefix2 === option.substring(0, prefix2.length) && void 0 !== options[option]) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize(string3) {
  return string3.charAt(0).toUpperCase() + string3.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options) {
    _classCallCheck$2(this, LanguageUtil2);
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass$2(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code2) {
      if (!code2 || code2.indexOf("-") < 0)
        return null;
      var p2 = code2.split("-");
      if (p2.length === 2)
        return null;
      p2.pop();
      if (p2[p2.length - 1].toLowerCase() === "x")
        return null;
      return this.formatLanguageCode(p2.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code2) {
      if (!code2 || code2.indexOf("-") < 0)
        return code2;
      var p2 = code2.split("-");
      return this.formatLanguageCode(p2[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code2) {
      if (typeof code2 === "string" && code2.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p2 = code2.split("-");
        if (this.options.lowerCaseLng) {
          p2 = p2.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p2.length === 2) {
          p2[0] = p2[0].toLowerCase();
          p2[1] = p2[1].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
        } else if (p2.length === 3) {
          p2[0] = p2[0].toLowerCase();
          if (p2[1].length === 2)
            p2[1] = p2[1].toUpperCase();
          if (p2[0] !== "sgn" && p2[2].length === 2)
            p2[2] = p2[2].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
          if (specialCases.indexOf(p2[2].toLowerCase()) > -1)
            p2[2] = capitalize(p2[2].toLowerCase());
        }
        return p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code2.toLowerCase() : code2;
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code2) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code2 = this.getLanguagePartFromCode(code2);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code2) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;
      if (!codes)
        return null;
      var found;
      codes.forEach(function(code2) {
        if (found)
          return;
        var cleanedLng = _this.formatLanguageCode(code2);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng))
          found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach(function(code2) {
          if (found)
            return;
          var lngOnly = _this.getLanguagePartFromCode(code2);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        });
      }
      if (!found)
        found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code2) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks === "function")
        fallbacks = fallbacks(code2);
      if (typeof fallbacks === "string")
        fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code2)
        return fallbacks["default"] || [];
      var found = fallbacks[code2];
      if (!found)
        found = fallbacks[this.getScriptPartFromCode(code2)];
      if (!found)
        found = fallbacks[this.formatLanguageCode(code2)];
      if (!found)
        found = fallbacks[this.getLanguagePartFromCode(code2)];
      if (!found)
        found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code2, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code2);
      var codes = [];
      var addCode = function addCode2(c2) {
        if (!c2)
          return;
        if (_this2.isSupportedCode(c2)) {
          codes.push(c2);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c2));
        }
      };
      if (typeof code2 === "string" && code2.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly")
          addCode(this.formatLanguageCode(code2));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
          addCode(this.getScriptPartFromCode(code2));
        if (this.options.load !== "currentOnly")
          addCode(this.getLanguagePartFromCode(code2));
      } else if (typeof code2 === "string") {
        addCode(this.formatLanguageCode(code2));
      }
      fallbackCodes.forEach(function(fc) {
        if (codes.indexOf(fc) < 0)
          addCode(_this2.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _2(n2) {
    return Number(n2 > 1);
  },
  2: function _3(n2) {
    return Number(n2 != 1);
  },
  3: function _4(n2) {
    return 0;
  },
  4: function _5(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  5: function _6(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
  },
  6: function _7(n2) {
    return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
  },
  7: function _8(n2) {
    return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  8: function _9(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
  },
  9: function _10(n2) {
    return Number(n2 >= 2);
  },
  10: function _11(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
  },
  11: function _12(n2) {
    return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
  },
  12: function _13(n2) {
    return Number(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function _14(n2) {
    return Number(n2 !== 0);
  },
  14: function _15(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
  },
  15: function _16(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  16: function _17(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
  },
  17: function _18(n2) {
    return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
  },
  18: function _19(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
  },
  19: function _20(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
  },
  20: function _21(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
  },
  21: function _22(n2) {
    return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
  },
  22: function _23(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
  }
};
var deprecatedJsonVersions = ["v1", "v2", "v3"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules2 = {};
  sets.forEach(function(set2) {
    set2.lngs.forEach(function(l2) {
      rules2[l2] = {
        numbers: set2.nr,
        plurals: _rulesPluralsTypes[set2.fc]
      };
    });
  });
  return rules2;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$2(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  _createClass$2(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code2) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) {
        try {
          return new Intl.PluralRules(code2, {
            type: options.ordinal ? "ordinal" : "cardinal"
          });
        } catch (_unused) {
          return;
        }
      }
      return this.rules[code2] || this.rules[this.languageUtils.getLanguagePartFromCode(code2)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code2) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code2, options);
      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code2, key) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code2, options).map(function(suffix) {
        return "".concat(key).concat(suffix);
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code2) {
      var _this = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code2, options);
      if (!rule) {
        return [];
      }
      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
        }).map(function(pluralCategory) {
          return "".concat(_this.options.prepend).concat(pluralCategory);
        });
      }
      return rule.numbers.map(function(number4) {
        return _this.getSuffix(code2, number4, options);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code2, count) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var rule = this.getRule(code2, options);
      if (rule) {
        if (this.shouldUseIntlApi()) {
          return "".concat(this.options.prepend).concat(rule.select(count));
        }
        return this.getSuffixRetroCompatible(rule, count);
      }
      this.logger.warn("no plural rule found for: ".concat(code2));
      return "";
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function getSuffixRetroCompatible(rule, count) {
      var _this2 = this;
      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      var suffix = rule.numbers[idx];
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = "plural";
        } else if (suffix === 1) {
          suffix = "";
        }
      }
      var returnSuffix = function returnSuffix2() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };
      if (this.options.compatibilityJSON === "v1") {
        if (suffix === 1)
          return "";
        if (typeof suffix === "number")
          return "_plural_".concat(suffix.toString());
        return returnSuffix();
      } else if (this.options.compatibilityJSON === "v2") {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function shouldUseIntlApi() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]);
  return PluralResolver2;
}();
function ownKeys$3$1(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$3$1(Object(source), true).forEach(function(key) {
        _defineProperty$3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Interpolator = function() {
  function Interpolator2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck$2(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || function(value) {
      return value;
    };
    this.init(options);
  }
  _createClass$2(Interpolator2, [{
    key: "init",
    value: function init2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options.interpolation)
        options.interpolation = {
          escapeValue: true
        };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options)
        this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data2, lng, options) {
      var _this = this;
      var match2;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path2 = getPathWithDefaults(data2, defaultData, key);
          return _this.alwaysFormat ? _this.format(path2, void 0, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data2), {}, {
            interpolationkey: key
          })) : path2;
        }
        var p2 = key.split(_this.formatSeparator);
        var k2 = p2.shift().trim();
        var f2 = p2.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data2, defaultData, k2), f2, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data2), {}, {
          interpolationkey: k2
        }));
      };
      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match2 = todo.regex.exec(str)) {
          var matchedVar = match2[1].trim();
          value = handleFormat(matchedVar);
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match2, options);
              value = typeof temp === "string" ? temp : "";
            } else if (options && options.hasOwnProperty(matchedVar)) {
              value = "";
            } else if (skipOnVariables) {
              value = match2[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          var safeValue = todo.safeValue(value);
          str = str.replace(match2[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += safeValue.length;
            todo.regex.lastIndex -= match2[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match2;
      var value;
      var clonedOptions = _objectSpread$3({}, options);
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        var c2 = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c2[1]);
        key = c2[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        optionsString = optionsString.replace(/'/g, '"');
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions)
            clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
        } catch (e2) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e2);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match2 = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;
        if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
          var r2 = match2[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match2[1] = r2.shift();
          formatters = r2;
          doReduce = true;
        }
        value = fc(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions);
        if (value && match2[0] === str && typeof value !== "string")
          return value;
        if (typeof value !== "string")
          value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match2[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce(function(v2, f2) {
            return _this2.format(v2, f2, options.lng, _objectSpread$3(_objectSpread$3({}, options), {}, {
              interpolationkey: match2[1].trim()
            }));
          }, value.trim());
        }
        str = str.replace(match2[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function ownKeys$4(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty$3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    var optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (!opt)
          return;
        var _opt$split = opt.split(":"), _opt$split2 = _toArray$1(_opt$split), key = _opt$split2[0], rest = _opt$split2.slice(1);
        var val = rest.join(":");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val.trim();
        if (val.trim() === "false")
          formatOptions[key.trim()] = false;
        if (val.trim() === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val.trim()))
          formatOptions[key.trim()] = parseInt(val.trim(), 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
var Formatter = function() {
  function Formatter2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck$2(this, Formatter2);
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: function number4(val, lng, options2) {
        return new Intl.NumberFormat(lng, options2).format(val);
      },
      currency: function currency(val, lng, options2) {
        return new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options2), {}, {
          style: "currency"
        })).format(val);
      },
      datetime: function datetime(val, lng, options2) {
        return new Intl.DateTimeFormat(lng, _objectSpread$4({}, options2)).format(val);
      },
      relativetime: function relativetime(val, lng, options2) {
        return new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options2)).format(val, options2.range || "day");
      },
      list: function list2(val, lng, options2) {
        return new Intl.ListFormat(lng, _objectSpread$4({}, options2)).format(val);
      }
    };
    this.init(options);
  }
  _createClass$2(Formatter2, [{
    key: "init",
    value: function init2(services) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var iOpts = options.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function add(name, fc) {
      this.formats[name.toLowerCase().trim()] = fc;
    }
  }, {
    key: "format",
    value: function format2(value, _format, lng, options) {
      var _this = this;
      var formats = _format.split(this.formatSeparator);
      var result = formats.reduce(function(mem, f2) {
        var _parseFormatStr = parseFormatStr(f2), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
            var l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
            formatted = _this.formats[formatName](mem, l2, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options), valOptions));
          } catch (error3) {
            _this.logger.warn(error3);
          }
          return formatted;
        } else {
          _this.logger.warn("there was no format function for ".concat(formatName));
        }
        return mem;
      }, value);
      return result;
    }
  }]);
  return Formatter2;
}();
function ownKeys$5(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty$3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$2$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _isNativeReflectConstruct$2$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function removePending(q2, name) {
  delete q2.pending[name];
  q2.pendingCount--;
}
var Connector = function(_EventEmitter) {
  _inherits$2(Connector2, _EventEmitter);
  var _super = _createSuper$2$1(Connector2);
  function Connector2(backend, store, services) {
    var _this;
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck$2(this, Connector2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized$2(_this));
    }
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create("backendConnector");
    _this.waitingReads = [];
    _this.maxParallelReads = options.maxParallelReads || 10;
    _this.readingCalls = 0;
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }
    return _this;
  }
  _createClass$2(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options, callback) {
      var _this2 = this;
      var toLoad = {};
      var pending = {};
      var toLoadLanguages = {};
      var toLoadNamespaces = {};
      languages.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns) {
          var name = "".concat(lng, "|").concat(ns);
          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0)
            ;
          else if (_this2.state[name] === 1) {
            if (pending[name] === void 0)
              pending[name] = true;
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending[name] === void 0)
              pending[name] = true;
            if (toLoad[name] === void 0)
              toLoad[name] = true;
            if (toLoadNamespaces[ns] === void 0)
              toLoadNamespaces[ns] = true;
          }
        });
        if (!hasAllNamespaces)
          toLoadLanguages[lng] = true;
      });
      if (Object.keys(toLoad).length || Object.keys(pending).length) {
        this.queue.push({
          pending,
          pendingCount: Object.keys(pending).length,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data2) {
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      if (err)
        this.emit("failedLoading", lng, ns, err);
      if (data2) {
        this.store.addResourceBundle(lng, ns, data2);
      }
      this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q2) {
        pushPath(q2.loaded, [lng], ns);
        removePending(q2, name);
        if (err)
          q2.errors.push(err);
        if (q2.pendingCount === 0 && !q2.done) {
          Object.keys(q2.loaded).forEach(function(l2) {
            if (!loaded2[l2])
              loaded2[l2] = {};
            var loadedKeys = Object.keys(loaded2[l2]);
            if (loadedKeys.length) {
              loadedKeys.forEach(function(ns2) {
                if (loadedKeys[ns2] !== void 0)
                  loaded2[l2][ns2] = true;
              });
            }
          });
          q2.done = true;
          if (q2.errors.length) {
            q2.callback(q2.errors);
          } else {
            q2.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q2) {
        return !q2.done;
      });
    }
  }, {
    key: "read",
    value: function read2(lng, ns, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 350;
      var callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length)
        return callback(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng,
          ns,
          fcName,
          tried,
          wait,
          callback
        });
        return;
      }
      this.readingCalls++;
      return this.backend[fcName](lng, ns, function(err, data2) {
        if (err && data2 && tried < 5) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        _this3.readingCalls--;
        if (_this3.waitingReads.length > 0) {
          var next2 = _this3.waitingReads.shift();
          _this3.read(next2.lng, next2.ns, next2.fcName, next2.tried, next2.wait, next2.callback);
        }
        callback(err, data2);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages === "string")
        languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length)
          callback();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      this.read(lng, ns, "read", void 0, void 0, function(err, data2) {
        if (err)
          _this5.logger.warn("".concat(prefix2, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data2)
          _this5.logger.log("".concat(prefix2, "loaded namespace ").concat(ns, " for language ").concat(lng), data2);
        _this5.loaded(name, err, data2);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "")
        return;
      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options), {}, {
          isUpdate
        }));
      }
      if (!languages || !languages[0])
        return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get$3() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof$8(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof$8(args[2]) === "object" || _typeof$8(args[3]) === "object") {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function(key) {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format2(value, _format, lng, options) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string")
    options.ns = [options.ns];
  if (typeof options.fallbackLng === "string")
    options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string")
    options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function ownKeys$6(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty$3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$3$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _isNativeReflectConstruct$3$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function noop$5() {
}
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = function(_EventEmitter) {
  _inherits$2(I18n2, _EventEmitter);
  var _super = _createSuper$3$1(I18n2);
  function I18n2() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck$2(this, I18n2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized$2(_this));
    }
    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized$2(_this));
    if (callback && !_this.isInitialized && !options.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options, callback);
        return _possibleConstructorReturn$2(_this, _assertThisInitialized$2(_this));
      }
      setTimeout(function() {
        _this.init(options, callback);
      }, 0);
    }
    return _this;
  }
  _createClass$2(I18n2, [{
    key: "init",
    value: function init2() {
      var _this2 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!options.defaultNS && options.ns) {
        if (typeof options.ns === "string") {
          options.defaultNS = options.ns;
        } else if (options.ns.indexOf("translation") < 0) {
          options.defaultNS = options.ns[0];
        }
      }
      var defOpts = get$3();
      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options));
      if (this.options.compatibilityAPI !== "v1") {
        this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);
      }
      if (options.keySeparator !== void 0) {
        this.options.userDefinedKeySeparator = options.keySeparator;
      }
      if (options.nsSeparator !== void 0) {
        this.options.userDefinedNsSeparator = options.nsSeparator;
      }
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject)
          return null;
        if (typeof ClassOrObject === "function")
          return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var formatter;
        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== "undefined") {
          formatter = Formatter;
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s2 = this.services;
        s2.logger = baseLogger;
        s2.resourceStore = this.store;
        s2.languageUtils = lu;
        s2.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s2.formatter = createClassOnDemand(formatter);
          s2.formatter.init(s2, this.options);
          this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
        }
        s2.interpolator = new Interpolator(this.options);
        s2.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
        s2.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        if (this.modules.languageDetector) {
          s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s2.languageDetector.init(s2, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s2.i18nFormat.init)
            s2.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function(m2) {
          if (m2.init)
            m2.init(_this2);
        });
      }
      this.format = this.options.interpolation.format;
      if (!callback)
        callback = noop$5;
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev")
          this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish = function finish2(err, t2) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce)
            _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone)
            _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t2);
          callback(err, t2);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$5;
      var usedCallback = callback;
      var usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function")
        usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [];
        var append2 = function append3(lng) {
          if (!lng)
            return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l2) {
            if (toLoad.indexOf(l2) < 0)
              toLoad.push(l2);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l2) {
            return append2(l2);
          });
        } else {
          append2(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l2) {
            return append2(l2);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, function(e2) {
          if (!e2 && !_this3.resolvedLanguage && _this3.language)
            _this3.setResolvedLanguage(_this3.language);
          usedCallback(e2);
        });
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs)
        lngs = this.languages;
      if (!ns)
        ns = this.options.ns;
      if (!callback)
        callback = noop$5;
      this.services.backendConnector.reload(lngs, ns, function(err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module2) {
      if (!module2)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module2.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module2.type === "backend") {
        this.modules.backend = module2;
      }
      if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
        this.modules.logger = module2;
      }
      if (module2.type === "languageDetector") {
        this.modules.languageDetector = module2;
      }
      if (module2.type === "i18nFormat") {
        this.modules.i18nFormat = module2;
      }
      if (module2.type === "postProcessor") {
        postProcessor.addPostProcessor(module2);
      }
      if (module2.type === "formatter") {
        this.modules.formatter = module2;
      }
      if (module2.type === "3rdParty") {
        this.modules.external.push(module2);
      }
      return this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function setResolvedLanguage(l2) {
      if (!l2 || !this.languages)
        return;
      if (["cimode", "dev"].indexOf(l2) > -1)
        return;
      for (var li2 = 0; li2 < this.languages.length; li2++) {
        var lngInLngs = this.languages[li2];
        if (["cimode", "dev"].indexOf(lngInLngs) > -1)
          continue;
        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var setLngProps = function setLngProps2(l2) {
        _this4.language = l2;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l2);
        _this4.resolvedLanguage = void 0;
        _this4.setResolvedLanguage(l2);
      };
      var done = function done2(err, l2) {
        if (l2) {
          setLngProps(l2);
          _this4.translator.changeLanguage(l2);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l2);
          _this4.logger.log("languageChanged", l2);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback)
          callback(err, function() {
            return _this4.t.apply(_this4, arguments);
          });
      };
      var setLng = function setLng2(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector)
          lngs = [];
        var l2 = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l2) {
          if (!_this4.language) {
            setLngProps(l2);
          }
          if (!_this4.translator.language)
            _this4.translator.changeLanguage(l2);
          if (_this4.services.languageDetector)
            _this4.services.languageDetector.cacheUserLanguage(l2);
        }
        _this4.loadResources(l2, function(err) {
          done(err, l2);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns, keyPrefix) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options;
        if (_typeof$8(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = _objectSpread$6({}, opts);
        }
        options.lng = options.lng || fixedT2.lng;
        options.lngs = options.lngs || fixedT2.lngs;
        options.ns = options.ns || fixedT2.ns;
        var keySeparator = _this5.options.keySeparator || ".";
        var resultKey = keyPrefix ? "".concat(keyPrefix).concat(keySeparator).concat(key) : key;
        return _this5.t(resultKey, options);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t2() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace2(ns) {
      var _this6 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.resolvedLanguage || this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      var loadNotPending = function loadNotPending2(l2, n2) {
        var loadState = _this6.services.backendConnector.state["".concat(l2, "|").concat(n2)];
        return loadState === -1 || loadState === 2;
      };
      if (options.precheck) {
        var preResult = options.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      if (this.hasResourceBundle(lng, ns))
        return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
        return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
        return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces2(ns, callback) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }
      if (typeof ns === "string")
        ns = [ns];
      ns.forEach(function(n2) {
        if (_this7.options.ns.indexOf(n2) < 0)
          _this7.options.ns.push(n2);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === "string")
        lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback)
          callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng)
        lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$5;
      var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options), {
        isClone: true
      });
      var clone2 = new I18n2(mergedOptions);
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m2) {
        clone2[m2] = _this8[m2];
      });
      clone2.services = _objectSpread$6({}, this.services);
      clone2.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      clone2.translator = new Translator(clone2.services, clone2.options);
      clone2.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone2.emit.apply(clone2, [event].concat(args));
      });
      clone2.init(mergedOptions, callback);
      clone2.translator.options = clone2.options;
      clone2.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      return clone2;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]);
  return I18n2;
}(EventEmitter);
_defineProperty$3(I18n, "createInstance", function() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var callback = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options, callback);
});
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
var arr = [];
var each$1 = arr.forEach;
var slice$1 = arr.slice;
function defaults(obj) {
  each$1.call(slice$1.call(arguments, 1), function(source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === void 0)
          obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var serializeCookie = function serializeCookie2(name, val, options) {
  var opt = options || {};
  opt.path = opt.path || "/";
  var value = encodeURIComponent(val);
  var str = name + "=" + value;
  if (opt.maxAge > 0) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge))
      throw new Error("maxAge should be a Number");
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + opt.expires.toUTCString();
  }
  if (opt.httpOnly)
    str += "; HttpOnly";
  if (opt.secure)
    str += "; Secure";
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
var cookie = {
  create: function create2(name, value, minutes, domain2) {
    var cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    if (minutes) {
      cookieOptions.expires = new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
    }
    if (domain2)
      cookieOptions.domain = domain2;
    document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);
  },
  read: function read(name) {
    var nameEQ = name + "=";
    var ca2 = document.cookie.split(";");
    for (var i = 0; i < ca2.length; i++) {
      var c2 = ca2[i];
      while (c2.charAt(0) === " ") {
        c2 = c2.substring(1, c2.length);
      }
      if (c2.indexOf(nameEQ) === 0)
        return c2.substring(nameEQ.length, c2.length);
    }
    return null;
  },
  remove: function remove2(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  lookup: function lookup(options) {
    var found;
    if (options.lookupCookie && typeof document !== "undefined") {
      var c2 = cookie.read(options.lookupCookie);
      if (c2)
        found = c2;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options) {
    if (options.lookupCookie && typeof document !== "undefined") {
      cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain, options.cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  lookup: function lookup2(options) {
    var found;
    if (typeof window !== "undefined") {
      var search2 = window.location.search;
      if (!window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1) {
        search2 = window.location.hash.substring(window.location.hash.indexOf("?"));
      }
      var query = search2.substring(1);
      var params = query.split("&");
      for (var i = 0; i < params.length; i++) {
        var pos = params[i].indexOf("=");
        if (pos > 0) {
          var key = params[i].substring(0, pos);
          if (key === options.lookupQuerystring) {
            found = params[i].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
var hasLocalStorageSupport = null;
var localStorageAvailable = function localStorageAvailable2() {
  if (hasLocalStorageSupport !== null)
    return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
    var testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo");
    window.localStorage.removeItem(testKey);
  } catch (e2) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
};
var localStorage = {
  name: "localStorage",
  lookup: function lookup3(options) {
    var found;
    if (options.lookupLocalStorage && localStorageAvailable()) {
      var lng = window.localStorage.getItem(options.lookupLocalStorage);
      if (lng)
        found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage2(lng, options) {
    if (options.lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(options.lookupLocalStorage, lng);
    }
  }
};
var hasSessionStorageSupport = null;
var sessionStorageAvailable = function sessionStorageAvailable2() {
  if (hasSessionStorageSupport !== null)
    return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
    var testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo");
    window.sessionStorage.removeItem(testKey);
  } catch (e2) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
};
var sessionStorage = {
  name: "sessionStorage",
  lookup: function lookup4(options) {
    var found;
    if (options.lookupSessionStorage && sessionStorageAvailable()) {
      var lng = window.sessionStorage.getItem(options.lookupSessionStorage);
      if (lng)
        found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage3(lng, options) {
    if (options.lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(options.lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup: function lookup5(options) {
    var found = [];
    if (typeof navigator !== "undefined") {
      if (navigator.languages) {
        for (var i = 0; i < navigator.languages.length; i++) {
          found.push(navigator.languages[i]);
        }
      }
      if (navigator.userLanguage) {
        found.push(navigator.userLanguage);
      }
      if (navigator.language) {
        found.push(navigator.language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  lookup: function lookup6(options) {
    var found;
    var htmlTag2 = options.htmlTag || (typeof document !== "undefined" ? document.documentElement : null);
    if (htmlTag2 && typeof htmlTag2.getAttribute === "function") {
      found = htmlTag2.getAttribute("lang");
    }
    return found;
  }
};
var path$1 = {
  name: "path",
  lookup: function lookup7(options) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (language instanceof Array) {
        if (typeof options.lookupFromPathIndex === "number") {
          if (typeof language[options.lookupFromPathIndex] !== "string") {
            return void 0;
          }
          found = language[options.lookupFromPathIndex].replace("/", "");
        } else {
          found = language[0].replace("/", "");
        }
      }
    }
    return found;
  }
};
var subdomain = {
  name: "subdomain",
  lookup: function lookup8(options) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.href.match(/(?:http[s]*\:\/\/)*(.*?)\.(?=[^\/]*\..{2,5})/gi);
      if (language instanceof Array) {
        if (typeof options.lookupFromSubdomainIndex === "number") {
          found = language[options.lookupFromSubdomainIndex].replace("http://", "").replace("https://", "").replace(".", "");
        } else {
          found = language[0].replace("http://", "").replace("https://", "").replace(".", "");
        }
      }
    }
    return found;
  }
};
function getDefaults() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"]
  };
}
var Browser = /* @__PURE__ */ function() {
  function Browser2(services) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$2(this, Browser2);
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options);
  }
  _createClass$2(Browser2, [{
    key: "init",
    value: function init2(services) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = services;
      this.options = defaults(options, this.options || {}, getDefaults());
      if (this.options.lookupFromUrlIndex)
        this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
      this.i18nOptions = i18nOptions;
      this.addDetector(cookie$1);
      this.addDetector(querystring);
      this.addDetector(localStorage);
      this.addDetector(sessionStorage);
      this.addDetector(navigator$1);
      this.addDetector(htmlTag);
      this.addDetector(path$1);
      this.addDetector(subdomain);
    }
  }, {
    key: "addDetector",
    value: function addDetector(detector) {
      this.detectors[detector.name] = detector;
    }
  }, {
    key: "detect",
    value: function detect(detectionOrder) {
      var _this = this;
      if (!detectionOrder)
        detectionOrder = this.options.order;
      var detected = [];
      detectionOrder.forEach(function(detectorName) {
        if (_this.detectors[detectorName]) {
          var lookup9 = _this.detectors[detectorName].lookup(_this.options);
          if (lookup9 && typeof lookup9 === "string")
            lookup9 = [lookup9];
          if (lookup9)
            detected = detected.concat(lookup9);
        }
      });
      if (this.services.languageUtils.getBestMatchFromCodes)
        return detected;
      return detected.length > 0 ? detected[0] : null;
    }
  }, {
    key: "cacheUserLanguage",
    value: function cacheUserLanguage4(lng, caches2) {
      var _this2 = this;
      if (!caches2)
        caches2 = this.options.caches;
      if (!caches2)
        return;
      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1)
        return;
      caches2.forEach(function(cacheName) {
        if (_this2.detectors[cacheName])
          _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
      });
    }
  }]);
  return Browser2;
}();
Browser.type = "languageDetector";
var data$1 = {
  "Re:Earth Marketplace": "",
  "Make Re:Earth the way you want it": "",
  Community: "",
  Discord: "",
  Discussion: "",
  Events: "",
  Support: "",
  "https://docs2.reearth.io/getting-started": "",
  "Getting Started": "",
  "https://eukarya.notion.site/Re-Earth-Marketplace-ba8ab625400647878af457a46a907e3b": "",
  "Marketplace User Manual": "",
  "https://docs2.reearth.io/reference": "",
  Reference: "",
  "https://docs.reearth.io/developer-guide/intro/about": "",
  "Developer Guide": "",
  "https://docs.reearth.io/tutorial/home": "",
  Tutorial: "",
  "https://reearth.io/docs/terms-of-use": "",
  "Terms of Use": "",
  Developers: "",
  Github: "",
  Roadmap: "",
  Changelog: "",
  "Code of Conduct": "",
  Company: "",
  Website: "",
  Facebook: "",
  "https://twitter.com/eukarya_EN": "",
  Twitter: "",
  "https://reearth.io/docs/privacy-policy": "",
  "Privacy Policy": "",
  Auto: "",
  "My Page": "",
  "My Plugins": "",
  "Log Out": "",
  "Upload new plugin": "",
  "Log in": "",
  "Plugins List": "",
  "New Plugin": "",
  Save: "",
  "Save & Publish": "",
  "Details Setting": "",
  "File uploaded successfully.": "",
  "File upload failed.": "",
  "Upload from local": "",
  "GitHub repository": "",
  "Click or drag file to this area to upload": "",
  "Please set your repository as public respository.": "",
  "Image uploaded successfully.": "",
  "Image upload failed.": "",
  Back: "",
  "Plugin Name": "",
  Version: "",
  Images: "",
  "Upload Image": "",
  Status: "",
  Published: "",
  "Not Published": "",
  "Updated Date": "",
  Action: "",
  "Update this plugin": "",
  Top: "",
  README: "",
  "Update Plugin": "",
  "Already installed": "",
  Install: "",
  "Open Plugin in your project": "",
  Description: "",
  Developer: "",
  "Report this plugin": "",
  "Choose one project to open this plugin": "",
  Workspace: "",
  Choose: "",
  Cancel: "",
  Update: "",
  Uninstall: "",
  "alt-plugin-cover-image": "",
  "Downloads Asc": "",
  "Downloads Desc": "",
  "Name Asc": "",
  "Name Desc": "",
  "Published Asc": "",
  "Published Desc": "",
  "search text": "",
  Liked: "",
  Details: "",
  "Something might be wrong with your plugin. Please check and try again.": "",
  "Your plugin was successfully published!": "",
  "Your plugin was successfully unpublished!": "",
  "Your plugin was successfully updated!": "",
  "Something went wrong with the update. Please try again.": "",
  Success: ""
};
data$1.Community;
data$1.Discord;
data$1.Discussion;
data$1.Events;
data$1.Support;
data$1.Reference;
data$1.Tutorial;
data$1.Developers;
data$1.Github;
data$1.Roadmap;
data$1.Changelog;
data$1.Company;
data$1.Website;
data$1.Facebook;
data$1.Twitter;
data$1.Auto;
data$1.Save;
data$1.Back;
data$1.Version;
data$1.Images;
data$1.Status;
data$1.Published;
data$1.Action;
data$1.Top;
data$1.README;
data$1.Install;
data$1.Description;
data$1.Developer;
data$1.Workspace;
data$1.Choose;
data$1.Cancel;
data$1.Update;
data$1.Uninstall;
data$1.Liked;
data$1.Details;
data$1.Success;
var data = {
  "Re:Earth Marketplace": "Re:Earth\u30DE\u30FC\u30B1\u30C3\u30C8\u30D7\u30EC\u30A4\u30B9",
  "Make Re:Earth the way you want it": "\u3042\u306A\u305F\u306ERe:Earth\u3092\u3082\u3063\u3068\u81EA\u7531\u306B",
  Community: "\u30B3\u30DF\u30E5\u30CB\u30C6\u30A3",
  Discord: "",
  Discussion: "",
  Events: "\u30A4\u30D9\u30F3\u30C8",
  Support: "\u30B5\u30DD\u30FC\u30C8",
  "https://docs2.reearth.io/getting-started": "https://docs2.reearth.io/ja/getting-started",
  "Getting Started": "Re:Earth\u3092\u306F\u3058\u3081\u3088\u3046",
  "https://eukarya.notion.site/Re-Earth-Marketplace-ba8ab625400647878af457a46a907e3b": "",
  "Marketplace User Manual": "\u30E6\u30FC\u30B6\u30FC\u30DE\u30CB\u30E5\u30A2\u30EB",
  "https://docs2.reearth.io/reference": "https://docs2.reearth.io/ja/reference",
  Reference: "\u53C2\u8003",
  "https://docs.reearth.io/developer-guide/intro/about": "https://docs.reearth.io/ja/developer-guide/intro/about",
  "Developer Guide": "\u30C7\u30D9\u30ED\u30C3\u30D1\u30FC\u30AC\u30A4\u30C9",
  "https://docs.reearth.io/tutorial/home": "https://docs.reearth.io/ja/tutorial/home",
  Tutorial: "\u30C1\u30E5\u30FC\u30C8\u30EA\u30A2\u30EB",
  "https://reearth.io/docs/terms-of-use": "https://reearth.io/ja/docs/terms-of-use",
  "Terms of Use": "\u5229\u7528\u898F\u7D04",
  Developers: "\u30C7\u30D9\u30ED\u30C3\u30D1\u30FC",
  Github: "",
  Roadmap: "\u30ED\u30FC\u30C9\u30DE\u30C3\u30D7",
  Changelog: "",
  "Code of Conduct": "",
  Company: "\u4F1A\u793E\u60C5\u5831",
  Website: "Web\u30B5\u30A4\u30C8",
  Facebook: "",
  "https://twitter.com/eukarya_EN": "https://twitter.com/eukaryaofficial",
  Twitter: "",
  "https://reearth.io/docs/privacy-policy": "https://reearth.io/ja/docs/privacy-policy",
  "Privacy Policy": "\u30D7\u30E9\u30A4\u30D0\u30B7\u30FC\u30DD\u30EA\u30B7\u30FC",
  Auto: "\u81EA\u52D5",
  "My Page": "\u30DE\u30A4\u30DA\u30FC\u30B8",
  "My Plugins": "\u30DE\u30A4\u30D7\u30E9\u30B0\u30A4\u30F3",
  "Log Out": "\u30ED\u30B0\u30A2\u30A6\u30C8",
  "Upload new plugin": "\u65B0\u3057\u3044\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9",
  "Log in": "\u30ED\u30B0\u30A4\u30F3",
  "Plugins List": "\u30D7\u30E9\u30B0\u30A4\u30F3\u4E00\u89A7",
  "New Plugin": "\u65B0\u898F\u30D7\u30E9\u30B0\u30A4\u30F3\u306E\u8FFD\u52A0",
  Save: "\u4E00\u6642\u4FDD\u5B58",
  "Save & Publish": "\u4FDD\u5B58\u3068\u516C\u958B",
  "Details Setting": "\u8A73\u7D30\u8A2D\u5B9A",
  "File uploaded successfully.": "\u30D5\u30A1\u30A4\u30EB\u306E\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u304C\u6210\u529F\u3057\u307E\u3057\u305F\u3002",
  "File upload failed.": "\u30D5\u30A1\u30A4\u30EB\u306E\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u306B\u5931\u6557\u3057\u307E\u3057\u305F\u3002",
  "Upload from local": "PC\u304B\u3089\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9",
  "GitHub repository": "GitHub\u30EC\u30DD\u30B8\u30C8\u30EA",
  "Click or drag file to this area to upload": "\u30AF\u30EA\u30C3\u30AF\u307E\u305F\u306F\u30C9\u30E9\u30C3\u30B0\u3057\u3066\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u3059\u308B\u30D5\u30A1\u30A4\u30EB\u3092\u8FFD\u52A0",
  "Please set your repository as public respository.": "\u30EC\u30DD\u30B8\u30C8\u30EA\u3092Public\u306B\u3059\u308B\u306E\u3092\u304A\u5FD8\u308C\u306A\u304F\u3002",
  "Image uploaded successfully.": "\u753B\u50CF\u304C\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u3055\u308C\u307E\u3057\u305F\u3002",
  "Image upload failed.": "\u753B\u50CF\u306E\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u306B\u5931\u6557\u3057\u307E\u3057\u305F\u3002",
  Back: "\u623B\u308B",
  "Plugin Name": "\u30D7\u30E9\u30B0\u30A4\u30F3\u540D",
  Version: "\u30D0\u30FC\u30B8\u30E7\u30F3",
  Images: "\u753B\u50CF",
  "Upload Image": "\u753B\u50CF\u306E\u8FFD\u52A0",
  Status: "\u516C\u958B\u72B6\u614B",
  Published: "\u516C\u958B\u4E2D",
  "Not Published": "\u975E\u516C\u958B",
  "Updated Date": "\u6700\u7D42\u66F4\u65B0\u65E5",
  Action: "\u30A2\u30AF\u30B7\u30E7\u30F3",
  "Update this plugin": "\u3053\u306E\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u66F4\u65B0\u3059\u308B",
  Top: "\u30C8\u30C3\u30D7",
  README: "",
  "Update Plugin": "\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u66F4\u65B0",
  "Already installed": "\u65E2\u306B\u30A4\u30F3\u30B9\u30C8\u30FC\u30EB\u3055\u308C\u3066\u3044\u307E\u3059",
  Install: "\u30A4\u30F3\u30B9\u30C8\u30FC\u30EB",
  "Open Plugin in your project": "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u306B\u8FFD\u52A0",
  Description: "\u8A73\u7D30",
  Developer: "\u958B\u767A\u8005",
  "Report this plugin": "\u3053\u306E\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u901A\u5831",
  "Choose one project to open this plugin": "\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u8FFD\u52A0\u3059\u308B\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\uFF11\u3064\u9078\u3093\u3067\u304F\u3060\u3055\u3044",
  Workspace: "\u30EF\u30FC\u30AF\u30B9\u30DA\u30FC\u30B9",
  Choose: "\u9078\u629E",
  Cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
  Update: "\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u66F4\u65B0",
  Uninstall: "\u30A2\u30F3\u30A4\u30F3\u30B9\u30C8\u30FC\u30EB",
  "alt-plugin-cover-image": "\u30D7\u30E9\u30B0\u30A4\u30F3\u306E\u753B\u50CF",
  "Downloads Asc": "\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u6570\u6607\u9806",
  "Downloads Desc": "\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u6570\u964D\u9806",
  "Name Asc": "\u540D\u524D\u6607\u9806",
  "Name Desc": "\u540D\u524D\u964D\u9806",
  "Published Asc": "\u516C\u958B\u65E5\u6607\u9806",
  "Published Desc": "\u516C\u958B\u65E5\u964D\u9806",
  "search text": "\u30AD\u30FC\u30EF\u30FC\u30C9\u3092\u5165\u529B",
  Liked: "\u304A\u6C17\u306B\u5165\u308A\u6E08",
  Details: "\u8A73\u7D30",
  "Something might be wrong with your plugin. Please check and try again.": "\u30D7\u30E9\u30B0\u30A4\u30F3\u306E\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u6642\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002",
  "Your plugin was successfully published!": "\u30D7\u30E9\u30B0\u30A4\u30F3\u304C\u6B63\u5E38\u306B\u516C\u958B\u3055\u308C\u307E\u3057\u305F\u3002",
  "Your plugin was successfully unpublished!": "\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u975E\u516C\u958B\u306B\u3057\u307E\u3057\u305F\u3002",
  "Your plugin was successfully updated!": "\u30D7\u30E9\u30B0\u30A4\u30F3\u306E\u30A2\u30C3\u30D7\u30C7\u30FC\u30C8\u304C\u5B8C\u4E86\u3057\u307E\u3057\u305F\u3002",
  "Something went wrong with the update. Please try again.": "\u30D7\u30E9\u30B0\u30A4\u30F3\u306E\u66F4\u65B0\u6642\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002",
  Success: "\u6210\u529F\u3057\u307E\u3057\u305F"
};
data.Community;
data.Discord;
data.Discussion;
data.Events;
data.Support;
data.Reference;
data.Tutorial;
data.Developers;
data.Github;
data.Roadmap;
data.Changelog;
data.Company;
data.Website;
data.Facebook;
data.Twitter;
data.Auto;
data.Save;
data.Back;
data.Version;
data.Images;
data.Status;
data.Published;
data.Action;
data.Top;
data.README;
data.Install;
data.Description;
data.Developer;
data.Workspace;
data.Choose;
data.Cancel;
data.Update;
data.Uninstall;
data.Liked;
data.Details;
data.Success;
const resources = {
  en: {
    translation: data$1
  },
  ja: {
    translation: data
  }
};
instance.use(Browser).use(initReactI18next).init({
  resources,
  fallbackLng: "en",
  nsSeparator: false,
  keySeparator: false,
  returnEmptyString: false
});
const getBrowserLanguage = () => {
  const lang = navigator.language;
  if (lang.includes("ja")) {
    return "ja";
  } else {
    return "en";
  }
};
function Provider$1({ children }) {
  var _a2;
  const { isAuthenticated } = useAuth();
  const [currentLang2, setLang] = useCurrentLang();
  const { data: data2 } = useGetMeQuery({
    variables: {
      first: 50
    },
    skip: !isAuthenticated
  });
  const locale2 = (_a2 = data2 == null ? void 0 : data2.me.lang) != null ? _a2 : currentLang2;
  React.useEffect(() => {
    const lang = locale2 === "und" ? getBrowserLanguage() : locale2;
    instance.changeLanguage(lang);
    if (currentLang2 !== locale2) {
      setLang(locale2);
    }
  }, [locale2, currentLang2, setLang]);
  return /* @__PURE__ */ React.createElement(I18nextProvider, {
    i18n: instance
  }, children);
}
const useT = () => useTranslation().t;
const PluginAccordionItemHeader = ({
  className,
  thumbnail,
  title,
  version: version2,
  author,
  installed,
  updatable,
  onInstall,
  onUninstall
}) => {
  const t2 = useT();
  return /* @__PURE__ */ React.createElement(Wrapper$5, {
    className
  }, /* @__PURE__ */ React.createElement(InnerWrapper$1, null, /* @__PURE__ */ React.createElement(InfoWrapper, null, /* @__PURE__ */ React.createElement(MainInfo, null, thumbnail && /* @__PURE__ */ React.createElement(Thumbnail, {
    src: thumbnail,
    alt: "plugin thumbnail"
  }), /* @__PURE__ */ React.createElement(Title$4, {
    style: { marginRight: "20px", maxWidth: "200px" }
  }, title)), /* @__PURE__ */ React.createElement(SecondaryInfo, null, /* @__PURE__ */ React.createElement("p", {
    id: "version"
  }, "v", version2), /* @__PURE__ */ React.createElement("p", {
    id: "author"
  }, author)))), /* @__PURE__ */ React.createElement(ButtonWrapper, null, updatable && /* @__PURE__ */ React.createElement(Button$3, {
    onClick: updatable && installed ? () => onInstall == null ? void 0 : onInstall() : void 0
  }, t2("Update")), /* @__PURE__ */ React.createElement(Button$3, {
    onClick: installed ? () => onUninstall == null ? void 0 : onUninstall() : void 0
  }, t2("Uninstall"))));
};
const Wrapper$5 = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  height: 88px;
  background: ${({ theme: theme2 }) => theme2.main.lightBackground};
`;
const InnerWrapper$1 = styled.div`
  display: flex;
  align-items: center;
`;
const InfoWrapper = styled.div`
  display: flex;
  margin-right: 32px;
  color: ${({ theme: theme2 }) => theme2.main.text};

  p {
    font-size: 16px;
  }
`;
const MainInfo = styled.div`
  display: flex;
  width: 250px;
`;
const SecondaryInfo = styled.div`
  display: flex;

  #version {
    margin-right: 32px;
  }
  #author {
    color: #4770ff;
  }
`;
const ButtonWrapper = styled.div`
  display: flex;
  justify-content: space-between;
  width: 316px;
  align-items: right;
`;
const Thumbnail = styled.img`
  border-radius: 8px;
  width: 64px;
  height: 64px;
  margin-right: 24px;
`;
const Title$4 = styled.p`
  font-weight: bold;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;
const Button$3 = styled.button`
  width: 153px;
  height: 38px;
  font-weight: bold;
  font-size: 16px;
  border-radius: 8px;
  transition: all 0.3s;
  border-style: solid;
  border-width: 1px;
  color: ${({ theme: theme2 }) => theme2.main.weakText};
  border-color: ${({ theme: theme2 }) => theme2.main.weakText};

  :hover {
    color: ${({ theme: theme2 }) => theme2.main.text};
    border-color: ${({ theme: theme2 }) => theme2.main.text};
  }

  :disabled {
    cursor: no-drop;
    color: ${({ theme: theme2 }) => theme2.main.weakText};
    border-color: ${({ theme: theme2 }) => theme2.main.weakText};
  }
`;
const PluginAccordion = ({
  className,
  plugins: plugins2,
  onInstall,
  onUninstall
}) => {
  var _a2;
  const { data: data2 } = usePluginsQuery({
    variables: {
      ids: (_a2 = plugins2 == null ? void 0 : plugins2.map((p2) => p2.id)) != null ? _a2 : []
    },
    skip: !(plugins2 == null ? void 0 : plugins2.length)
  });
  const installedPlugins = React.useMemo(
    () => plugins2 == null ? void 0 : plugins2.map((p2) => {
      var _a3, _b, _c;
      const pluginNode = data2 == null ? void 0 : data2.nodes.find((n2) => (n2 == null ? void 0 : n2.__typename) === "Plugin" && n2.id === p2.id);
      const plugin = (pluginNode == null ? void 0 : pluginNode.__typename) === "Plugin" ? pluginNode : void 0;
      const updatable = !!((_a3 = plugin == null ? void 0 : plugin.latestVersion) == null ? void 0 : _a3.version) && plugin.latestVersion.version !== p2.version;
      return {
        pluginId: `${p2.id}~${p2.version}`,
        newPluginId: updatable ? `${plugin.id}~${(_c = (_b = plugin == null ? void 0 : plugin.latestVersion) == null ? void 0 : _b.version) != null ? _c : ""}` : void 0,
        title: (plugin == null ? void 0 : plugin.name) || p2.title || p2.id,
        author: (plugin == null ? void 0 : plugin.author) || p2.author || "",
        installed: true,
        bodyMarkdown: (plugin == null ? void 0 : plugin.readme) || p2.readme,
        thumbnailUrl: (plugin == null ? void 0 : plugin.icon) || p2.icon || "",
        updatable
      };
    }).filter((p2) => !!p2),
    [data2 == null ? void 0 : data2.nodes, plugins2]
  );
  return installedPlugins ? /* @__PURE__ */ React.createElement(Accordion2, {
    className,
    allowMultipleExpanded: true,
    items: installedPlugins == null ? void 0 : installedPlugins.map((p2) => {
      var _a3;
      const version2 = (_a3 = p2.pluginId.split("~")[1]) != null ? _a3 : "x.x.x";
      return {
        id: p2.title,
        heading: /* @__PURE__ */ React.createElement(PluginAccordionItemHeader, {
          thumbnail: p2.thumbnailUrl,
          title: p2.title,
          version: version2,
          author: p2.author,
          installed: p2.installed,
          updatable: p2.updatable,
          onInstall: () => onInstall == null ? void 0 : onInstall(p2.newPluginId, p2.pluginId),
          onUninstall: () => onUninstall == null ? void 0 : onUninstall(p2.pluginId)
        }),
        content: /* @__PURE__ */ React.createElement(PluginAccordionItemBody, null, p2.bodyMarkdown)
      };
    })
  }) : null;
};
var index$1 = "";
function SharedProviders({
  theme: theme2,
  accessToken,
  children
}) {
  const config = useConfig$3();
  return (config == null ? void 0 : config.marketplaceApi) && accessToken ? /* @__PURE__ */ React.createElement(Provider$1, null, /* @__PURE__ */ React.createElement(Provider$4, {
    accessToken
  }, /* @__PURE__ */ React.createElement(Provider$2, {
    theme: theme2
  }, children))) : null;
}
function PluginInstalledList({
  theme: theme2,
  lang,
  installedPlugins,
  accessToken,
  onInstall,
  onUninstall
}) {
  return /* @__PURE__ */ React.createElement(SharedProviders, {
    accessToken,
    lang,
    theme: theme2
  }, /* @__PURE__ */ React.createElement(PluginAccordion, {
    plugins: installedPlugins,
    onInstall,
    onUninstall
  }));
}
const CoreWrapper = ({
  className = "light",
  header: Header,
  footer: Footer2,
  children
}) => {
  return /* @__PURE__ */ React.createElement(Wrapper$4, {
    className
  }, Header && /* @__PURE__ */ React.createElement(Header, null), /* @__PURE__ */ React.createElement(Content$2, null, children), Footer2 && /* @__PURE__ */ React.createElement(Footer2, null));
};
const Wrapper$4 = styled.div`
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
`;
const Content$2 = styled.div`
  flex: 1;
  display: flex;
  flex-direction: column;

  > :first-of-type {
    flex: 1;
    width: 100%;
  }
`;
var NoPluginCover = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABcAAAAM8CAYAAABwMwO6AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACPwSURBVHgB7d1hb1zlmcfhp8EUj+RRPRUT1RaOhFdkFRB9ASrd11E/2Ep8rVVfrSo2EiAacJaETZDj2haT7VjMwBjiQv1MMaJA5zgwZ8b5+7qkUSSf4xnj5w36+dZ9fvHmm29+XQAAAAAAIMyVAgAAAAAAgQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMA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AAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIAjgAAAAAAJEEcAAAAAAAIgngAAAAAABEEsABAAAAAIgkgAMAAAAAEEkABwAAAAAgkgAOAAAAAEAkARwAAAAAgEgCOAAAAAAAkQRwAAAAAAAiCeAAAAAAAEQSwAEAAAAAiCSAAwAAAAAQSQAHAAAAACCSAA4AAAAAQCQBHAAAAACASAI4AAAAAACRBHAAAAAAACIJ4AAAAAAARBLAAQAAAACIJIADAAAAABBJAAcAAAAAIJIADgAAAABAJAEcAAAAAIBIfwdyw88i/MiXpwAAAABJRU5ErkJggg==";
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function toArray$b(children) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var ret = [];
  React.Children.forEach(children, function(child) {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray$b(child));
    } else if (reactIs$2.exports.isFragment(child) && child.props) {
      ret = ret.concat(toArray$b(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}
function fillRef$7(ref2, node2) {
  if (typeof ref2 === "function") {
    ref2(node2);
  } else if (_typeof$8(ref2) === "object" && ref2 && "current" in ref2) {
    ref2.current = node2;
  }
}
function composeRef$7() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function(ref2) {
    return ref2;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function(node2) {
    refs.forEach(function(ref2) {
      fillRef$7(ref2, node2);
    });
  };
}
function supportRef$5(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type4 = reactIs$2.exports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  if (typeof type4 === "function" && !((_type$prototype = type4.prototype) === null || _type$prototype === void 0 ? void 0 : _type$prototype.render)) {
    return false;
  }
  if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) === null || _nodeOrComponent$prot === void 0 ? void 0 : _nodeOrComponent$prot.render)) {
    return false;
  }
  return true;
}
function findDOMNode$3(node2) {
  if (node2 instanceof HTMLElement) {
    return node2;
  }
  return ReactDOM.findDOMNode(node2);
}
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr2, key) {
    var result = -1;
    arr2.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key) {
      var index2 = getIndex(this.__entries__, key);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key, value) {
      var index2 = getIndex(this.__entries__, key);
      if (~index2) {
        this.__entries__[index2][1] = value;
      } else {
        this.__entries__.push([key, value]);
      }
    };
    class_1.prototype.delete = function(key) {
      var entries = this.__entries__;
      var index2 = getIndex(entries, key);
      if (~index2) {
        entries.splice(index2, 1);
      }
    };
    class_1.prototype.has = function(key) {
      return !!~getIndex(this.__entries__, key);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx) {
      if (ctx === void 0) {
        ctx = null;
      }
      for (var _i2 = 0, _a2 = this.__entries__; _i2 < _a2.length; _i2++) {
        var entry = _a2[_i2];
        callback.call(ctx, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle$1(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer) {
    var observers2 = this.observers_;
    var index2 = observers2.indexOf(observer);
    if (~index2) {
      observers2.splice(index2, 1);
    }
    if (!observers2.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    activeObservers.forEach(function(observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
    var _b = _a2.propertyName, propertyName = _b === void 0 ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key) {
      return !!~propertyName.indexOf(key);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2();
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target, props) {
  for (var _i2 = 0, _a2 = Object.keys(props); _i2 < _a2.length; _i2++) {
    var key = _a2[_i2];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    positions[_i2 - 1] = arguments[_i2];
  }
  return positions.reduce(function(size, position2) {
    var value = styles["border-" + position2 + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i2 = 0, positions_1 = positions; _i2 < positions_1.length; _i2++) {
    var position2 = positions_1[_i2];
    var value = styles["padding-" + position2];
    paddings[position2] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a2) {
  var x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: height + y2,
    left: x2
  });
  return rect;
}
function createRectInit(x2, y2, width, height) {
  return { x: x2, y: y2, width, height };
}
var ResizeObservation = function() {
  function ResizeObservation2(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, { target, contentRect });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx = this.callbackCtx_;
    var entries = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver$3 = function() {
  function ResizeObserver2(callback) {
    if (!(this instanceof ResizeObserver2)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver2;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method4) {
  ResizeObserver$3.prototype[method4] = function() {
    var _a2;
    return (_a2 = observers.get(this))[method4].apply(_a2, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver$3;
}();
var elementListeners$1 = /* @__PURE__ */ new Map();
function onResize$1(entities) {
  entities.forEach(function(entity) {
    var _elementListeners$get;
    var target = entity.target;
    (_elementListeners$get = elementListeners$1.get(target)) === null || _elementListeners$get === void 0 ? void 0 : _elementListeners$get.forEach(function(listener) {
      return listener(target);
    });
  });
}
var resizeObserver$1 = new index(onResize$1);
function observe$1(element2, callback) {
  if (!elementListeners$1.has(element2)) {
    elementListeners$1.set(element2, /* @__PURE__ */ new Set());
    resizeObserver$1.observe(element2);
  }
  elementListeners$1.get(element2).add(callback);
}
function unobserve$1(element2, callback) {
  if (elementListeners$1.has(element2)) {
    elementListeners$1.get(element2).delete(callback);
    if (!elementListeners$1.get(element2).size) {
      resizeObserver$1.unobserve(element2);
      elementListeners$1.delete(element2);
    }
  }
}
var DomWrapper$2 = /* @__PURE__ */ function(_React$Component) {
  _inherits$2(DomWrapper2, _React$Component);
  var _super = _createSuper$2(DomWrapper2);
  function DomWrapper2() {
    _classCallCheck$2(this, DomWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass$2(DomWrapper2, [{
    key: "render",
    value: function render2() {
      return this.props.children;
    }
  }]);
  return DomWrapper2;
}(React.Component);
var CollectionContext$1 = /* @__PURE__ */ React.createContext(null);
function Collection$1(_ref2) {
  var children = _ref2.children, onBatchResize = _ref2.onBatchResize;
  var resizeIdRef = React.useRef(0);
  var resizeInfosRef = React.useRef([]);
  var onCollectionResize = React.useContext(CollectionContext$1);
  var onResize2 = React.useCallback(function(size, element2, data2) {
    resizeIdRef.current += 1;
    var currentId = resizeIdRef.current;
    resizeInfosRef.current.push({
      size,
      element: element2,
      data: data2
    });
    Promise.resolve().then(function() {
      if (currentId === resizeIdRef.current) {
        onBatchResize === null || onBatchResize === void 0 ? void 0 : onBatchResize(resizeInfosRef.current);
        resizeInfosRef.current = [];
      }
    });
    onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(size, element2, data2);
  }, [onBatchResize, onCollectionResize]);
  return /* @__PURE__ */ React.createElement(CollectionContext$1.Provider, {
    value: onResize2
  }, children);
}
function SingleObserver$1(props) {
  var children = props.children, disabled = props.disabled;
  var elementRef = React.useRef(null);
  var wrapperRef = React.useRef(null);
  var onCollectionResize = React.useContext(CollectionContext$1);
  var isRenderProps = typeof children === "function";
  var mergedChildren = isRenderProps ? children(elementRef) : children;
  var sizeRef = React.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  });
  var canRef = !isRenderProps && /* @__PURE__ */ React.isValidElement(mergedChildren) && supportRef$5(mergedChildren);
  var originRef = canRef ? mergedChildren.ref : null;
  var mergedRef = React.useMemo(function() {
    return composeRef$7(originRef, elementRef);
  }, [originRef, elementRef]);
  var propsRef = React.useRef(props);
  propsRef.current = props;
  var onInternalResize = React.useCallback(function(target) {
    var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data2 = _propsRef$current.data;
    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
    var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      var size = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth,
        offsetHeight
      };
      sizeRef.current = size;
      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
      var sizeInfo = _objectSpread2$d(_objectSpread2$d({}, size), {}, {
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      });
      onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data2);
      if (onResize2) {
        Promise.resolve().then(function() {
          onResize2(sizeInfo, target);
        });
      }
    }
  }, []);
  React.useEffect(function() {
    var currentElement = findDOMNode$3(elementRef.current) || findDOMNode$3(wrapperRef.current);
    if (currentElement && !disabled) {
      observe$1(currentElement, onInternalResize);
    }
    return function() {
      return unobserve$1(currentElement, onInternalResize);
    };
  }, [elementRef.current, disabled]);
  return /* @__PURE__ */ React.createElement(DomWrapper$2, {
    ref: wrapperRef
  }, canRef ? /* @__PURE__ */ React.cloneElement(mergedChildren, {
    ref: mergedRef
  }) : mergedChildren);
}
var INTERNAL_PREFIX_KEY$1 = "rc-observer-key";
function ResizeObserver$2(props) {
  var children = props.children;
  var childNodes = typeof children === "function" ? [children] : toArray$b(children);
  return childNodes.map(function(child, index2) {
    var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY$1, "-").concat(index2);
    return /* @__PURE__ */ React.createElement(SingleObserver$1, _extends$3({}, props, {
      key
    }), child);
  });
}
ResizeObserver$2.Collection = Collection$1;
function omit$5(obj, fields) {
  var clone2 = _objectSpread2$d({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function(key) {
      delete clone2[key];
    });
  }
  return clone2;
}
function _arrayWithoutHoles(arr2) {
  if (Array.isArray(arr2))
    return _arrayLikeToArray$1(arr2);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr2) {
  return _arrayWithoutHoles(arr2) || _iterableToArray(arr2) || _unsupportedIterableToArray$1(arr2) || _nonIterableSpread();
}
function murmur2(str) {
  var h2 = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= k2 >>> 24;
    h2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
function useMemo$7(getValue2, condition, shouldUpdate) {
  var cacheRef = React.useRef({});
  if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue2();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
var warned$6 = {};
function warning$c(valid2, message) {
}
function call$6(method4, valid2, message) {
  if (!valid2 && !warned$6[message]) {
    method4(false, message);
    warned$6[message] = true;
  }
}
function warningOnce$6(valid2, message) {
  call$6(warning$c, valid2, message);
}
function isEqual$5(obj1, obj2) {
  var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var refSet = /* @__PURE__ */ new Set();
  function deepEqual(a, b2) {
    var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    var circular = refSet.has(a);
    warningOnce$6(!circular, "Warning: There may be circular references");
    if (circular) {
      return false;
    }
    if (a === b2) {
      return true;
    }
    if (shallow && level > 1) {
      return false;
    }
    refSet.add(a);
    var newLevel = level + 1;
    if (Array.isArray(a)) {
      if (!Array.isArray(b2) || a.length !== b2.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!deepEqual(a[i], b2[i], newLevel)) {
          return false;
        }
      }
      return true;
    }
    if (a && b2 && _typeof$8(a) === "object" && _typeof$8(b2) === "object") {
      var keys2 = Object.keys(a);
      if (keys2.length !== Object.keys(b2).length) {
        return false;
      }
      return keys2.every(function(key) {
        return deepEqual(a[key], b2[key], newLevel);
      });
    }
    return false;
  }
  return deepEqual(obj1, obj2);
}
var Entity = /* @__PURE__ */ function() {
  function Entity2() {
    _classCallCheck$2(this, Entity2);
    _defineProperty$3(this, "cache", /* @__PURE__ */ new Map());
  }
  _createClass$2(Entity2, [{
    key: "get",
    value: function get2(keys2) {
      return this.cache.get(keys2.join("%")) || null;
    }
  }, {
    key: "update",
    value: function update(keys2, valueFn) {
      var path2 = keys2.join("%");
      var prevValue = this.cache.get(path2);
      var nextValue = valueFn(prevValue);
      if (nextValue === null) {
        this.cache.delete(path2);
      } else {
        this.cache.set(path2, nextValue);
      }
    }
  }]);
  return Entity2;
}();
var _excluded$Q = ["children"];
var ATTR_TOKEN = "data-token-hash";
var ATTR_MARK = "data-css-hash";
var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
var CSS_IN_JS_INSTANCE_ID = Math.random().toString(12).slice(2);
function createCache2() {
  if (typeof document !== "undefined" && document.head && document.body) {
    var styles = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [];
    var firstChild = document.head.firstChild;
    Array.from(styles).forEach(function(style2) {
      style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || CSS_IN_JS_INSTANCE_ID;
      document.head.insertBefore(style2, firstChild);
    });
    var styleHash = {};
    Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function(style2) {
      var hash2 = style2.getAttribute(ATTR_MARK);
      if (styleHash[hash2]) {
        if (style2[CSS_IN_JS_INSTANCE] === CSS_IN_JS_INSTANCE_ID) {
          var _style$parentNode;
          (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
        }
      } else {
        styleHash[hash2] = true;
      }
    });
  }
  return new Entity();
}
var StyleContext = /* @__PURE__ */ React.createContext({
  hashPriority: "low",
  cache: createCache2(),
  defaultCache: true
});
var StyleProvider = function StyleProvider2(props) {
  var children = props.children, restProps = _objectWithoutProperties$1(props, _excluded$Q);
  var parentContext = React.useContext(StyleContext);
  var context2 = useMemo$7(function() {
    var mergedContext = _objectSpread2$d({}, parentContext);
    Object.keys(restProps).forEach(function(key) {
      var value = restProps[key];
      if (restProps[key] !== void 0) {
        mergedContext[key] = value;
      }
    });
    var cache2 = restProps.cache;
    mergedContext.cache = mergedContext.cache || createCache2();
    mergedContext.defaultCache = !cache2 && parentContext.defaultCache;
    return mergedContext;
  }, [parentContext, restProps], function(prev2, next2) {
    return !isEqual$5(prev2[0], next2[0], true) || !isEqual$5(prev2[1], next2[1], true);
  });
  return /* @__PURE__ */ React.createElement(StyleContext.Provider, {
    value: context2
  }, children);
};
var StyleContext$1 = StyleContext;
function useClientCache(prefix2, keyPath, cacheFn, onCacheRemove) {
  var _React$useContext = React.useContext(StyleContext$1), globalCache = _React$useContext.cache;
  var fullPath = [prefix2].concat(_toConsumableArray(keyPath));
  React.useMemo(
    function() {
      globalCache.update(fullPath, function(prevCache) {
        var _ref2 = prevCache || [], _ref22 = _slicedToArray$1(_ref2, 2), _ref2$ = _ref22[0], times = _ref2$ === void 0 ? 0 : _ref2$, cache2 = _ref22[1];
        var tmpCache = cache2;
        var mergedCache = tmpCache || cacheFn();
        return [times + 1, mergedCache];
      });
    },
    [fullPath.join("_")]
  );
  React.useEffect(function() {
    return function() {
      globalCache.update(fullPath, function(prevCache) {
        var _ref3 = prevCache || [], _ref4 = _slicedToArray$1(_ref3, 2), _ref4$ = _ref4[0], times = _ref4$ === void 0 ? 0 : _ref4$, cache2 = _ref4[1];
        var nextCount = times - 1;
        if (nextCount === 0) {
          onCacheRemove === null || onCacheRemove === void 0 ? void 0 : onCacheRemove(cache2, false);
          return null;
        }
        return [times - 1, cache2];
      });
    };
  }, fullPath);
  return globalCache.get(fullPath)[1];
}
function canUseDom$e() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function contains$9(root2, n2) {
  if (!root2) {
    return false;
  }
  if (root2.contains) {
    return root2.contains(n2);
  }
  var node2 = n2;
  while (node2) {
    if (node2 === root2) {
      return true;
    }
    node2 = node2.parentNode;
  }
  return false;
}
var APPEND_ORDER$5 = "data-rc-order";
var MARK_KEY$5 = "rc-util-key";
var containerCache$5 = /* @__PURE__ */ new Map();
function getMark$5() {
  var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark2 = _ref2.mark;
  if (mark2) {
    return mark2.startsWith("data-") ? mark2 : "data-".concat(mark2);
  }
  return MARK_KEY$5;
}
function getContainer$5(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function getOrder$5(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles$5(container) {
  return Array.from((containerCache$5.get(container) || container).children).filter(function(node2) {
    return node2.tagName === "STYLE";
  });
}
function injectCSS$5(css2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom$e()) {
    return null;
  }
  var csp = option.csp, prepend = option.prepend;
  var styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER$5, getOrder$5(prepend));
  if (csp !== null && csp !== void 0 && csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css2;
  var container = getContainer$5(option);
  var firstChild = container.firstChild;
  if (prepend) {
    if (prepend === "queue") {
      var existStyle = findStyles$5(container).filter(function(node2) {
        return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER$5));
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode$5(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer$5(option);
  return findStyles$5(container).find(function(node2) {
    return node2.getAttribute(getMark$5(option)) === key;
  });
}
function removeCSS$3(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var existNode = findExistNode$5(key, option);
  if (existNode) {
    var container = getContainer$5(option);
    container.removeChild(existNode);
  }
}
function syncRealContainer$5(container, option) {
  var cachedRealContainer = containerCache$5.get(container);
  if (!cachedRealContainer || !contains$9(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS$5("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache$5.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function updateCSS$5(css2, key) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer$5(option);
  syncRealContainer$5(container, option);
  var existNode = findExistNode$5(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  var newNode = injectCSS$5(css2, option);
  newNode.setAttribute(getMark$5(option), key);
  return newNode;
}
function flattenToken(token2) {
  var str = "";
  Object.keys(token2).forEach(function(key) {
    var value = token2[key];
    str += key;
    if (value && _typeof$8(value) === "object") {
      str += flattenToken(value);
    } else {
      str += value;
    }
  });
  return str;
}
function token2key(token2, salt) {
  return murmur2("".concat(salt, "_").concat(flattenToken(token2)));
}
var layerKey = "layer-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, "");
var layerWidth = "903px";
function supportSelector(styleStr, handleElement) {
  if (canUseDom$e()) {
    var _ele$parentNode;
    updateCSS$5(styleStr, layerKey);
    var _ele = document.createElement("div");
    _ele.style.position = "fixed";
    _ele.style.left = "0";
    _ele.style.top = "0";
    handleElement === null || handleElement === void 0 ? void 0 : handleElement(_ele);
    document.body.appendChild(_ele);
    var support = getComputedStyle(_ele).width === layerWidth;
    (_ele$parentNode = _ele.parentNode) === null || _ele$parentNode === void 0 ? void 0 : _ele$parentNode.removeChild(_ele);
    removeCSS$3(layerKey);
    return support;
  }
  return false;
}
var canLayer = void 0;
function supportLayer() {
  if (canLayer === void 0) {
    canLayer = supportSelector("@layer ".concat(layerKey, " { .").concat(layerKey, " { width: ").concat(layerWidth, "!important; } }"), function(ele) {
      ele.className = layerKey;
    });
  }
  return canLayer;
}
var EMPTY_OVERRIDE = {};
var hashPrefix = "css";
var tokenKeys = /* @__PURE__ */ new Map();
function recordCleanToken(tokenKey) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
}
function removeStyleTags(key) {
  if (typeof document !== "undefined") {
    var styles = document.querySelectorAll("style[".concat(ATTR_TOKEN, '="').concat(key, '"]'));
    styles.forEach(function(style2) {
      if (style2[CSS_IN_JS_INSTANCE] === CSS_IN_JS_INSTANCE_ID) {
        var _style$parentNode;
        (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
      }
    });
  }
}
function cleanTokenStyle(tokenKey) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
  var tokenKeyList = Array.from(tokenKeys.keys());
  var cleanableKeyList = tokenKeyList.filter(function(key) {
    var count = tokenKeys.get(key) || 0;
    return count <= 0;
  });
  if (cleanableKeyList.length < tokenKeyList.length) {
    cleanableKeyList.forEach(function(key) {
      removeStyleTags(key);
      tokenKeys.delete(key);
    });
  }
}
function useCacheToken(theme2, tokens) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _option$salt = option.salt, salt = _option$salt === void 0 ? "" : _option$salt, _option$override = option.override, override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override, formatToken2 = option.formatToken;
  var mergedToken = React.useMemo(function() {
    return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens)));
  }, [tokens]);
  var tokenStr = React.useMemo(function() {
    return flattenToken(mergedToken);
  }, [mergedToken]);
  var overrideTokenStr = React.useMemo(function() {
    return flattenToken(override);
  }, [override]);
  var cachedToken = useClientCache("token", [salt, theme2.id, tokenStr, overrideTokenStr], function() {
    var derivativeToken = theme2.getDerivativeToken(mergedToken);
    var mergedDerivativeToken = _objectSpread2$d(_objectSpread2$d({}, derivativeToken), override);
    if (formatToken2) {
      mergedDerivativeToken = formatToken2(mergedDerivativeToken);
    }
    var tokenKey = token2key(mergedDerivativeToken, salt);
    mergedDerivativeToken._tokenKey = tokenKey;
    recordCleanToken(tokenKey);
    var hashId = "".concat(hashPrefix, "-").concat(murmur2(tokenKey));
    mergedDerivativeToken._hashId = hashId;
    return [mergedDerivativeToken, hashId];
  }, function(cache2) {
    cleanTokenStyle(cache2[0]._tokenKey);
  });
  return cachedToken;
}
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var abs = Math.abs;
var from = String.fromCharCode;
function trim(value) {
  return value.trim();
}
function replace(value, pattern4, replacement) {
  return value.replace(pattern4, replacement);
}
function indexof(value, search2) {
  return value.indexOf(search2);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array4) {
  return array4.push(value), value;
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type4, props, children, length2) {
  return { value, root: root2, parent, type: type4, props, children, line, column, length: length2, return: "" };
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type4) {
  switch (type4) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type4) {
  return trim(slice(position - 1, delimiter(type4 === 91 ? type4 + 2 : type4 === 40 ? type4 + 1 : type4)));
}
function whitespace$1(type4) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type4) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type4) {
  while (next())
    switch (character) {
      case type4:
        return position;
      case 34:
      case 39:
        if (type4 !== 34 && type4 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type4 === 41)
          delimiter(type4);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type4, index2) {
  while (next())
    if (type4 + character === 47 + 10)
      break;
    else if (type4 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type4 === 47 ? type4 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root2, parent, rule, rules2, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous2 = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type4 = "";
  var props = rules2;
  var children = rulesets;
  var reference = rule;
  var characters2 = type4;
  while (scanning)
    switch (previous2 = character2, character2 = next()) {
      case 40:
        if (previous2 != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace$1(previous2);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset3:
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root2, parent, index2, offset3, rules2, points, type4, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type4, rules2, props = [], length2), children), rules2, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset3 = property = 0, variable = ampersand = 1, type4 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous2;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset3 = length2 = strlen(type4 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous2 === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset3, rules2, points, type4, props, children, length2) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules2 : [""];
  var size = sizeof(rule);
  for (var i = 0, j2 = 0, k2 = 0; i < index2; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i])), z2 = value; x2 < size; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root2, parent, offset3 === 0 ? RULESET : type4, props, children, length2);
}
function comment(value, root2, parent) {
  return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output2 = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output2 += callback(children[i], i, children, callback) || "";
  return output2;
}
function stringify$2(element2, index2, children, callback) {
  switch (element2.type) {
    case IMPORT:
    case DECLARATION:
      return element2.return = element2.return || element2.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element2.return = element2.value + "{" + serialize(element2.children, callback) + "}";
    case RULESET:
      element2.value = element2.props.join(",");
  }
  return strlen(children = serialize(element2.children, callback)) ? element2.return = element2.value + "{" + children + "}" : "";
}
function lintWarning(message, info) {
  var path2 = info.path, parentSelectors = info.parentSelectors;
  warningOnce$6(false, "[Ant Design CSS-in-JS] ".concat(path2 ? "Error in ".concat(path2, ": ") : "").concat(message).concat(parentSelectors.length ? " Selector: ".concat(parentSelectors.join(" | ")) : ""));
}
function isConcatSelector(selector) {
  var _selector$match;
  var notContent = ((_selector$match = selector.match(/:not\(([^)]*)\)/)) === null || _selector$match === void 0 ? void 0 : _selector$match[1]) || "";
  var splitCells = notContent.split(/(\[[^[]*])|(?=[.#])/).filter(function(str) {
    return str;
  });
  return splitCells.length > 1;
}
function parsePath(info) {
  return info.parentSelectors.reduce(function(prev2, cur) {
    if (!prev2) {
      return cur;
    }
    return cur.includes("&") ? cur.replace(/&/g, prev2) : "".concat(prev2, " ").concat(cur);
  }, "");
}
var linter$2 = function linter(key, value, info) {
  var parentSelectorPath = parsePath(info);
  var notList = parentSelectorPath.match(/:not\([^)]*\)/g) || [];
  if (notList.length > 0 && notList.some(isConcatSelector)) {
    lintWarning("Concat ':not' selector not support in legacy browsers.", info);
  }
};
var linter$1 = function linter2(key, value, info) {
  switch (key) {
    case "marginLeft":
    case "marginRight":
    case "paddingLeft":
    case "paddingRight":
    case "left":
    case "right":
    case "borderLeft":
    case "borderLeftWidth":
    case "borderLeftStyle":
    case "borderLeftColor":
    case "borderRight":
    case "borderRightWidth":
    case "borderRightStyle":
    case "borderRightColor":
    case "borderTopLeftRadius":
    case "borderTopRightRadius":
    case "borderBottomLeftRadius":
    case "borderBottomRightRadius":
      lintWarning("You seem to be using non-logical property '".concat(key, "' which is not compatible with RTL mode. Please use logical properties and values instead. For more information: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties."), info);
      return;
    case "margin":
    case "padding":
    case "borderWidth":
    case "borderStyle":
      if (typeof value === "string") {
        var valueArr = value.split(" ").map(function(item) {
          return item.trim();
        });
        if (valueArr.length === 4 && valueArr[1] !== valueArr[3]) {
          lintWarning("You seem to be using '".concat(key, "' property with different left ").concat(key, " and right ").concat(key, ", which is not compatible with RTL mode. Please use logical properties and values instead. For more information: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties."), info);
        }
      }
      return;
    case "clear":
    case "textAlign":
      if (value === "left" || value === "right") {
        lintWarning("You seem to be using non-logical value '".concat(value, "' of ").concat(key, ", which is not compatible with RTL mode. Please use logical properties and values instead. For more information: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties."), info);
      }
      return;
    case "borderRadius":
      if (typeof value === "string") {
        var radiusGroups = value.split("/").map(function(item) {
          return item.trim();
        });
        var invalid = radiusGroups.reduce(function(result, group2) {
          if (result) {
            return result;
          }
          var radiusArr = group2.split(" ").map(function(item) {
            return item.trim();
          });
          if (radiusArr.length >= 2 && radiusArr[0] !== radiusArr[1]) {
            return true;
          }
          if (radiusArr.length === 3 && radiusArr[1] !== radiusArr[2]) {
            return true;
          }
          if (radiusArr.length === 4 && radiusArr[2] !== radiusArr[3]) {
            return true;
          }
          return result;
        }, false);
        if (invalid) {
          lintWarning("You seem to be using non-logical value '".concat(value, "' of ").concat(key, ", which is not compatible with RTL mode. Please use logical properties and values instead. For more information: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties."), info);
        }
      }
      return;
  }
};
var linter3 = function linter4(key, value, info) {
  if (info.parentSelectors.some(function(selector) {
    var selectors = selector.split(",");
    return selectors.some(function(item) {
      return item.split("&").length > 2;
    });
  })) {
    lintWarning("Should not use more than one `&` in a selector.", info);
  }
};
var isClientSide = canUseDom$e();
var SKIP_CHECK = "_skip_check_";
function normalizeStyle(styleStr) {
  var serialized = serialize(compile(styleStr), stringify$2);
  return serialized.replace(/\{%%%\:[^;];}/g, ";");
}
function isCompoundCSSProperty(value) {
  return _typeof$8(value) === "object" && value && SKIP_CHECK in value;
}
function injectSelectorHash(key, hashId, hashPriority) {
  if (!hashId) {
    return key;
  }
  var hashClassName = ".".concat(hashId);
  var hashSelector = hashPriority === "low" ? ":where(".concat(hashClassName, ")") : hashClassName;
  var keys2 = key.split(",").map(function(k2) {
    var _firstPath$match;
    var fullPath = k2.trim().split(/\s+/);
    var firstPath = fullPath[0] || "";
    var htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || "";
    firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));
    return [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(" ");
  });
  return keys2.join(",");
}
var parseStyle = function parseStyle2(interpolation) {
  var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    root: true,
    parentSelectors: []
  }, root2 = _ref2.root, injectHash = _ref2.injectHash, parentSelectors = _ref2.parentSelectors;
  var hashId = config.hashId, layer = config.layer;
  config.path;
  var hashPriority = config.hashPriority, _config$transformers = config.transformers, transformers = _config$transformers === void 0 ? [] : _config$transformers;
  config.linters;
  var styleStr = "";
  var effectStyle = {};
  function parseKeyframes(keyframes) {
    var animationName = keyframes.getName(hashId);
    if (!effectStyle[animationName]) {
      var _parseStyle = parseStyle2(keyframes.style, config, {
        root: false,
        parentSelectors
      }), _parseStyle2 = _slicedToArray$1(_parseStyle, 1), _parsedStr = _parseStyle2[0];
      effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
    }
  }
  function flattenList(list2) {
    var fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    list2.forEach(function(item) {
      if (Array.isArray(item)) {
        flattenList(item, fullList);
      } else if (item) {
        fullList.push(item);
      }
    });
    return fullList;
  }
  var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
  flattenStyleList.forEach(function(originStyle) {
    var style2 = typeof originStyle === "string" && !root2 ? {} : originStyle;
    if (typeof style2 === "string") {
      styleStr += "".concat(style2, "\n");
    } else if (style2._keyframe) {
      parseKeyframes(style2);
    } else {
      var mergedStyle = transformers.reduce(function(prev2, trans) {
        var _trans$visit;
        return (trans === null || trans === void 0 ? void 0 : (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev2)) || prev2;
      }, style2);
      Object.keys(mergedStyle).forEach(function(key) {
        var value = mergedStyle[key];
        if (_typeof$8(value) === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
          var subInjectHash = false;
          var mergedKey = key.trim();
          var nextRoot = false;
          if ((root2 || injectHash) && hashId) {
            if (mergedKey.startsWith("@")) {
              subInjectHash = true;
            } else {
              mergedKey = injectSelectorHash(key, hashId, hashPriority);
            }
          } else if (root2 && !hashId && (mergedKey === "&" || mergedKey === "")) {
            mergedKey = "";
            nextRoot = true;
          }
          var _parseStyle3 = parseStyle2(value, config, {
            root: nextRoot,
            injectHash: subInjectHash,
            parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])
          }), _parseStyle4 = _slicedToArray$1(_parseStyle3, 2), _parsedStr2 = _parseStyle4[0], childEffectStyle = _parseStyle4[1];
          effectStyle = _objectSpread2$d(_objectSpread2$d({}, effectStyle), childEffectStyle);
          styleStr += "".concat(mergedKey).concat(_parsedStr2);
        } else {
          var _value;
          var actualValue = (_value = value === null || value === void 0 ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
          var styleName = key.replace(/[A-Z]/g, function(match2) {
            return "-".concat(match2.toLowerCase());
          });
          var formatValue2 = actualValue;
          if (!unitlessKeys[key] && typeof formatValue2 === "number" && formatValue2 !== 0) {
            formatValue2 = "".concat(formatValue2, "px");
          }
          if (key === "animationName" && value !== null && value !== void 0 && value._keyframe) {
            parseKeyframes(value);
            formatValue2 = value.getName(hashId);
          }
          styleStr += "".concat(styleName, ":").concat(formatValue2, ";");
        }
      });
    }
  });
  if (!root2) {
    styleStr = "{".concat(styleStr, "}");
  } else if (layer && supportLayer()) {
    var layerCells = layer.split(",");
    var layerName = layerCells[layerCells.length - 1].trim();
    styleStr = "@layer ".concat(layerName, " {").concat(styleStr, "}");
    if (layerCells.length > 1) {
      styleStr = "@layer ".concat(layer, "{%%%:%}").concat(styleStr);
    }
  }
  return [styleStr, effectStyle];
};
function uniqueHash(path2, styleStr) {
  return murmur2("".concat(path2.join("%")).concat(styleStr));
}
function Empty$3() {
  return null;
}
function useStyleRegister(info, styleFn) {
  var token2 = info.token, path2 = info.path, hashId = info.hashId, layer = info.layer, nonce = info.nonce;
  var _React$useContext = React.useContext(StyleContext$1), autoClear = _React$useContext.autoClear;
  _React$useContext.mock;
  var defaultCache = _React$useContext.defaultCache, hashPriority = _React$useContext.hashPriority, container = _React$useContext.container, ssrInline = _React$useContext.ssrInline, transformers = _React$useContext.transformers, linters = _React$useContext.linters;
  var tokenKey = token2._tokenKey;
  var fullPath = [tokenKey].concat(_toConsumableArray(path2));
  var isMergedClientSide = isClientSide;
  var _useGlobalCache = useClientCache(
    "style",
    fullPath,
    function() {
      var styleObj = styleFn();
      var _parseStyle5 = parseStyle(styleObj, {
        hashId,
        hashPriority,
        layer,
        path: path2.join("-"),
        transformers,
        linters
      }), _parseStyle6 = _slicedToArray$1(_parseStyle5, 2), parsedStyle = _parseStyle6[0], effectStyle = _parseStyle6[1];
      var styleStr = normalizeStyle(parsedStyle);
      var styleId = uniqueHash(fullPath, styleStr);
      if (isMergedClientSide) {
        var mergedCSSConfig = {
          mark: ATTR_MARK,
          prepend: "queue",
          attachTo: container
        };
        var nonceStr = typeof nonce === "function" ? nonce() : nonce;
        if (nonceStr) {
          mergedCSSConfig.csp = {
            nonce: nonceStr
          };
        }
        var style2 = updateCSS$5(styleStr, styleId, mergedCSSConfig);
        style2[CSS_IN_JS_INSTANCE] = CSS_IN_JS_INSTANCE_ID;
        style2.setAttribute(ATTR_TOKEN, tokenKey);
        Object.keys(effectStyle).forEach(function(effectKey) {
          updateCSS$5(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), mergedCSSConfig);
        });
      }
      return [styleStr, tokenKey, styleId];
    },
    function(_ref2, fromHMR) {
      var _ref3 = _slicedToArray$1(_ref2, 3), styleId = _ref3[2];
      if ((fromHMR || autoClear) && isClientSide) {
        removeCSS$3(styleId, {
          mark: ATTR_MARK
        });
      }
    }
  ), _useGlobalCache2 = _slicedToArray$1(_useGlobalCache, 3), cachedStyleStr = _useGlobalCache2[0], cachedTokenKey = _useGlobalCache2[1], cachedStyleId = _useGlobalCache2[2];
  return function(node2) {
    var styleNode;
    if (!ssrInline || isMergedClientSide || !defaultCache) {
      styleNode = /* @__PURE__ */ React.createElement(Empty$3, null);
    } else {
      var _ref4;
      styleNode = /* @__PURE__ */ React.createElement("style", _extends$3({}, (_ref4 = {}, _defineProperty$3(_ref4, ATTR_TOKEN, cachedTokenKey), _defineProperty$3(_ref4, ATTR_MARK, cachedStyleId), _ref4), {
        dangerouslySetInnerHTML: {
          __html: cachedStyleStr
        }
      }));
    }
    return /* @__PURE__ */ React.createElement(React.Fragment, null, styleNode, node2);
  };
}
function extractStyle(cache2) {
  var styleKeys = Array.from(cache2.cache.keys()).filter(function(key) {
    return key.startsWith("style%");
  });
  var styleText = "";
  styleKeys.forEach(function(key) {
    var _24 = _slicedToArray$1(cache2.cache.get(key)[1], 3), styleStr = _24[0], tokenKey = _24[1], styleId = _24[2];
    styleText += "<style ".concat(ATTR_TOKEN, '="').concat(tokenKey, '" ').concat(ATTR_MARK, '="').concat(styleId, '">').concat(styleStr, "</style>");
  });
  return styleText;
}
var Keyframe = /* @__PURE__ */ function() {
  function Keyframe2(name, style2) {
    _classCallCheck$2(this, Keyframe2);
    _defineProperty$3(this, "name", void 0);
    _defineProperty$3(this, "style", void 0);
    _defineProperty$3(this, "_keyframe", true);
    this.name = name;
    this.style = style2;
  }
  _createClass$2(Keyframe2, [{
    key: "getName",
    value: function getName() {
      var hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
    }
  }]);
  return Keyframe2;
}();
function sameDerivativeOption(left, right) {
  if (left.length !== right.length) {
    return false;
  }
  for (var i = 0; i < left.length; i++) {
    if (left[i] !== right[i]) {
      return false;
    }
  }
  return true;
}
var ThemeCache = /* @__PURE__ */ function() {
  function ThemeCache2() {
    _classCallCheck$2(this, ThemeCache2);
    _defineProperty$3(this, "cache", void 0);
    _defineProperty$3(this, "keys", void 0);
    _defineProperty$3(this, "cacheCallTimes", void 0);
    this.cache = /* @__PURE__ */ new Map();
    this.keys = [];
    this.cacheCallTimes = 0;
  }
  _createClass$2(ThemeCache2, [{
    key: "size",
    value: function size() {
      return this.keys.length;
    }
  }, {
    key: "internalGet",
    value: function internalGet(derivativeOption) {
      var _cache2, _cache3;
      var updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var cache2 = {
        map: this.cache
      };
      derivativeOption.forEach(function(derivative2) {
        if (!cache2) {
          cache2 = void 0;
        } else {
          var _cache, _cache$map;
          cache2 = (_cache = cache2) === null || _cache === void 0 ? void 0 : (_cache$map = _cache.map) === null || _cache$map === void 0 ? void 0 : _cache$map.get(derivative2);
        }
      });
      if ((_cache2 = cache2) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes) {
        cache2.value[1] = this.cacheCallTimes++;
      }
      return (_cache3 = cache2) === null || _cache3 === void 0 ? void 0 : _cache3.value;
    }
  }, {
    key: "get",
    value: function get2(derivativeOption) {
      var _this$internalGet;
      return (_this$internalGet = this.internalGet(derivativeOption, true)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
    }
  }, {
    key: "has",
    value: function has(derivativeOption) {
      return !!this.internalGet(derivativeOption);
    }
  }, {
    key: "set",
    value: function set2(derivativeOption, value) {
      var _this = this;
      if (!this.has(derivativeOption)) {
        if (this.size() + 1 > ThemeCache2.MAX_CACHE_SIZE + ThemeCache2.MAX_CACHE_OFFSET) {
          var _this$keys$reduce = this.keys.reduce(function(result, key) {
            var _result = _slicedToArray$1(result, 2), callTimes = _result[1];
            if (_this.internalGet(key)[1] < callTimes) {
              return [key, _this.internalGet(key)[1]];
            }
            return result;
          }, [this.keys[0], this.cacheCallTimes]), _this$keys$reduce2 = _slicedToArray$1(_this$keys$reduce, 1), targetKey = _this$keys$reduce2[0];
          this.delete(targetKey);
        }
        this.keys.push(derivativeOption);
      }
      var cache2 = this.cache;
      derivativeOption.forEach(function(derivative2, index2) {
        if (index2 === derivativeOption.length - 1) {
          cache2.set(derivative2, {
            value: [value, _this.cacheCallTimes++]
          });
        } else {
          var cacheValue = cache2.get(derivative2);
          if (!cacheValue) {
            cache2.set(derivative2, {
              map: /* @__PURE__ */ new Map()
            });
          } else if (!cacheValue.map) {
            cacheValue.map = /* @__PURE__ */ new Map();
          }
          cache2 = cache2.get(derivative2).map;
        }
      });
    }
  }, {
    key: "deleteByPath",
    value: function deleteByPath(currentCache, derivatives) {
      var cache2 = currentCache.get(derivatives[0]);
      if (derivatives.length === 1) {
        var _cache$value;
        if (!cache2.map) {
          currentCache.delete(derivatives[0]);
        } else {
          currentCache.set(derivatives[0], {
            map: cache2.map
          });
        }
        return (_cache$value = cache2.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
      }
      var result = this.deleteByPath(cache2.map, derivatives.slice(1));
      if ((!cache2.map || cache2.map.size === 0) && !cache2.value) {
        currentCache.delete(derivatives[0]);
      }
      return result;
    }
  }, {
    key: "delete",
    value: function _delete(derivativeOption) {
      if (this.has(derivativeOption)) {
        this.keys = this.keys.filter(function(item) {
          return !sameDerivativeOption(item, derivativeOption);
        });
        return this.deleteByPath(this.cache, derivativeOption);
      }
      return void 0;
    }
  }]);
  return ThemeCache2;
}();
_defineProperty$3(ThemeCache, "MAX_CACHE_SIZE", 20);
_defineProperty$3(ThemeCache, "MAX_CACHE_OFFSET", 5);
var uuid$8 = 0;
var Theme = /* @__PURE__ */ function() {
  function Theme2(derivatives) {
    _classCallCheck$2(this, Theme2);
    _defineProperty$3(this, "derivatives", void 0);
    _defineProperty$3(this, "id", void 0);
    this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
    this.id = uuid$8;
    if (derivatives.length === 0) {
      warning$c(derivatives.length > 0);
    }
    uuid$8 += 1;
  }
  _createClass$2(Theme2, [{
    key: "getDerivativeToken",
    value: function getDerivativeToken(token2) {
      return this.derivatives.reduce(function(result, derivative2) {
        return derivative2(token2, result);
      }, void 0);
    }
  }]);
  return Theme2;
}();
var cacheThemes = new ThemeCache();
function createTheme(derivatives) {
  var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
  if (!cacheThemes.has(derivativeArr)) {
    cacheThemes.set(derivativeArr, new Theme(derivativeArr));
  }
  return cacheThemes.get(derivativeArr);
}
function splitValues(value) {
  if (typeof value === "number") {
    return [[value], false];
  }
  var rawStyle = String(value).trim();
  var importantCells = rawStyle.match(/(.*)(!important)/);
  var splitStyle = (importantCells ? importantCells[1] : rawStyle).trim().split(/\s+/);
  var temp = "";
  var brackets = 0;
  return [splitStyle.reduce(function(list2, item) {
    if (item.includes("(")) {
      temp += item;
      brackets += item.split("(").length - 1;
    } else if (item.includes(")")) {
      temp += item;
      brackets -= item.split(")").length - 1;
      if (brackets === 0) {
        list2.push(temp);
        temp = "";
      }
    } else if (brackets > 0) {
      temp += item;
    } else {
      list2.push(item);
    }
    return list2;
  }, []), !!importantCells];
}
function noSplit(list2) {
  list2.notSplit = true;
  return list2;
}
var keyMap = {
  inset: ["top", "right", "bottom", "left"],
  insetBlock: ["top", "bottom"],
  insetBlockStart: ["top"],
  insetBlockEnd: ["bottom"],
  insetInline: ["left", "right"],
  insetInlineStart: ["left"],
  insetInlineEnd: ["right"],
  marginBlock: ["marginTop", "marginBottom"],
  marginBlockStart: ["marginTop"],
  marginBlockEnd: ["marginBottom"],
  marginInline: ["marginLeft", "marginRight"],
  marginInlineStart: ["marginLeft"],
  marginInlineEnd: ["marginRight"],
  paddingBlock: ["paddingTop", "paddingBottom"],
  paddingBlockStart: ["paddingTop"],
  paddingBlockEnd: ["paddingBottom"],
  paddingInline: ["paddingLeft", "paddingRight"],
  paddingInlineStart: ["paddingLeft"],
  paddingInlineEnd: ["paddingRight"],
  borderBlock: noSplit(["borderTop", "borderBottom"]),
  borderBlockStart: noSplit(["borderTop"]),
  borderBlockEnd: noSplit(["borderBottom"]),
  borderInline: noSplit(["borderLeft", "borderRight"]),
  borderInlineStart: noSplit(["borderLeft"]),
  borderInlineEnd: noSplit(["borderRight"]),
  borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
  borderBlockStartWidth: ["borderTopWidth"],
  borderBlockEndWidth: ["borderBottomWidth"],
  borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
  borderInlineStartWidth: ["borderLeftWidth"],
  borderInlineEndWidth: ["borderRightWidth"],
  borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
  borderBlockStartStyle: ["borderTopStyle"],
  borderBlockEndStyle: ["borderBottomStyle"],
  borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
  borderInlineStartStyle: ["borderLeftStyle"],
  borderInlineEndStyle: ["borderRightStyle"],
  borderBlockColor: ["borderTopColor", "borderBottomColor"],
  borderBlockStartColor: ["borderTopColor"],
  borderBlockEndColor: ["borderBottomColor"],
  borderInlineColor: ["borderLeftColor", "borderRightColor"],
  borderInlineStartColor: ["borderLeftColor"],
  borderInlineEndColor: ["borderRightColor"],
  borderStartStartRadius: ["borderTopLeftRadius"],
  borderStartEndRadius: ["borderTopRightRadius"],
  borderEndStartRadius: ["borderBottomLeftRadius"],
  borderEndEndRadius: ["borderBottomRightRadius"]
};
function wrapImportantAndSkipCheck(value, important) {
  var parsedValue = value;
  if (important) {
    parsedValue = "".concat(parsedValue, " !important");
  }
  return {
    _skip_check_: true,
    value: parsedValue
  };
}
var transform$1 = {
  visit: function visit2(cssObj) {
    var clone2 = {};
    Object.keys(cssObj).forEach(function(key) {
      var value = cssObj[key];
      var matchValue = keyMap[key];
      if (matchValue && (typeof value === "number" || typeof value === "string")) {
        var _splitValues = splitValues(value), _splitValues2 = _slicedToArray$1(_splitValues, 2), _values = _splitValues2[0], _important = _splitValues2[1];
        if (matchValue.length && matchValue.notSplit) {
          matchValue.forEach(function(matchKey) {
            clone2[matchKey] = wrapImportantAndSkipCheck(value, _important);
          });
        } else if (matchValue.length === 1) {
          clone2[matchValue[0]] = wrapImportantAndSkipCheck(value, _important);
        } else if (matchValue.length === 2) {
          matchValue.forEach(function(matchKey, index2) {
            var _values$index;
            clone2[matchKey] = wrapImportantAndSkipCheck((_values$index = _values[index2]) !== null && _values$index !== void 0 ? _values$index : _values[0], _important);
          });
        } else if (matchValue.length === 4) {
          matchValue.forEach(function(matchKey, index2) {
            var _ref2, _values$index2;
            clone2[matchKey] = wrapImportantAndSkipCheck((_ref2 = (_values$index2 = _values[index2]) !== null && _values$index2 !== void 0 ? _values$index2 : _values[index2 - 2]) !== null && _ref2 !== void 0 ? _ref2 : _values[0], _important);
          });
        } else {
          clone2[key] = value;
        }
      } else {
        clone2[key] = value;
      }
    });
    return clone2;
  }
};
var pxRegex = /url\([^)]+\)|var\([^)]+\)|(\d*\.?\d+)px/g;
function toFixed(number4, precision) {
  var multiplier = Math.pow(10, precision + 1), wholeNumber = Math.floor(number4 * multiplier);
  return Math.round(wholeNumber / 10) * 10 / multiplier;
}
var transform = function transform2() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _options$rootValue = options.rootValue, rootValue = _options$rootValue === void 0 ? 16 : _options$rootValue, _options$precision = options.precision, precision = _options$precision === void 0 ? 5 : _options$precision, _options$mediaQuery = options.mediaQuery, mediaQuery = _options$mediaQuery === void 0 ? false : _options$mediaQuery;
  var pxReplace = function pxReplace2(m2, $1) {
    if (!$1)
      return m2;
    var pixels = parseFloat($1);
    if (pixels <= 1)
      return m2;
    var fixedVal = toFixed(pixels / rootValue, precision);
    return "".concat(fixedVal, "rem");
  };
  var visit3 = function visit4(cssObj) {
    var clone2 = _objectSpread2$d({}, cssObj);
    Object.entries(cssObj).forEach(function(_ref2) {
      var _ref22 = _slicedToArray$1(_ref2, 2), key = _ref22[0], value = _ref22[1];
      if (typeof value === "string" && value.includes("px")) {
        var newValue = value.replace(pxRegex, pxReplace);
        clone2[key] = newValue;
      }
      if (!unitlessKeys[key] && typeof value === "number" && value !== 0) {
        clone2[key] = "".concat(value, "px").replace(pxRegex, pxReplace);
      }
      var mergedKey = key.trim();
      if (mergedKey.startsWith("@") && mergedKey.includes("px") && mediaQuery) {
        var newKey = key.replace(pxRegex, pxReplace);
        clone2[newKey] = clone2[key];
        delete clone2[key];
      }
    });
    return clone2;
  };
  return {
    visit: visit3
  };
};
var es$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Theme,
  createTheme,
  useStyleRegister,
  useCacheToken,
  createCache: createCache2,
  StyleProvider,
  Keyframes: Keyframe,
  extractStyle,
  legacyLogicalPropertiesTransformer: transform$1,
  px2remTransformer: transform,
  logicalPropertiesLinter: linter$1,
  legacyNotSelectorLinter: linter$2,
  parentSelectorLinter: linter3
}, Symbol.toStringTag, { value: "Module" }));
var IconContext$1 = /* @__PURE__ */ React.createContext({});
var Context$2 = IconContext$1;
var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
var warningFunc = function warningFunc2() {
  warningOnce$7(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
};
var Context$1 = /* @__PURE__ */ React.createContext({
  getFieldValue: warningFunc,
  getFieldsValue: warningFunc,
  getFieldError: warningFunc,
  getFieldWarning: warningFunc,
  getFieldsError: warningFunc,
  isFieldsTouched: warningFunc,
  isFieldTouched: warningFunc,
  isFieldValidating: warningFunc,
  isFieldsValidating: warningFunc,
  resetFields: warningFunc,
  setFields: warningFunc,
  setFieldValue: warningFunc,
  setFieldsValue: warningFunc,
  validateFields: warningFunc,
  submit: warningFunc,
  getInternalHooks: function getInternalHooks() {
    warningFunc();
    return {
      dispatch: warningFunc,
      initEntityValue: warningFunc,
      registerField: warningFunc,
      useSubscribe: warningFunc,
      setInitialValues: warningFunc,
      destroyForm: warningFunc,
      setCallbacks: warningFunc,
      registerWatch: warningFunc,
      getFields: warningFunc,
      setValidateMessages: warningFunc,
      setPreserve: warningFunc,
      getInitialValue: warningFunc
    };
  }
});
function toArray$a(value) {
  if (value === void 0 || value === null) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function isFormInstance$1(form) {
  return form && !!form._init;
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function _regeneratorRuntime3() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn2 = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function define2(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap2(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context2 = new Context2(tryLocsList || []);
    return generator._invoke = function(innerFn2, self3, context3) {
      var state = "suspendedStart";
      return function(method4, arg) {
        if ("executing" === state)
          throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method4)
            throw arg;
          return doneResult();
        }
        for (context3.method = method4, context3.arg = arg; ; ) {
          var delegate = context3.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context3);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if ("next" === context3.method)
            context3.sent = context3._sent = context3.arg;
          else if ("throw" === context3.method) {
            if ("suspendedStart" === state)
              throw state = "completed", context3.arg;
            context3.dispatchException(context3.arg);
          } else
            "return" === context3.method && context3.abrupt("return", context3.arg);
          state = "executing";
          var record = tryCatch(innerFn2, self3, context3);
          if ("normal" === record.type) {
            if (state = context3.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
              continue;
            return {
              value: record.arg,
              done: context3.done
            };
          }
          "throw" === record.type && (state = "completed", context3.method = "throw", context3.arg = record.arg);
        }
      };
    }(innerFn, self2, context2), generator;
  }
  function tryCatch(fn2, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn2.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap2;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn2.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype2) {
    ["next", "throw", "return"].forEach(function(method4) {
      define(prototype2, method4, function(arg) {
        return this._invoke(method4, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method4, arg, resolve, reject) {
      var record = tryCatch(generator[method4], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == _typeof$8(value) && hasOwn2.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error3) {
          return invoke("throw", error3, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    this._invoke = function(method4, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method4, arg, resolve, reject);
        });
      }
      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }
  function maybeInvokeDelegate(delegate, context2) {
    var method4 = delegate.iterator[context2.method];
    if (void 0 === method4) {
      if (context2.delegate = null, "throw" === context2.method) {
        if (delegate.iterator["return"] && (context2.method = "return", context2.arg = void 0, maybeInvokeDelegate(delegate, context2), "throw" === context2.method))
          return ContinueSentinel;
        context2.method = "throw", context2.arg = new TypeError("The iterator does not provide a 'throw' method");
      }
      return ContinueSentinel;
    }
    var record = tryCatch(method4, delegate.iterator, context2.arg);
    if ("throw" === record.type)
      return context2.method = "throw", context2.arg = record.arg, context2.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context2[delegate.resultName] = info.value, context2.next = delegate.nextLoc, "return" !== context2.method && (context2.method = "next", context2.arg = void 0), context2.delegate = null, ContinueSentinel) : info : (context2.method = "throw", context2.arg = new TypeError("iterator result is not an object"), context2.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context2(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next2 = function next3() {
          for (; ++i < iterable.length; ) {
            if (hasOwn2.call(iterable, i))
              return next3.value = iterable[i], next3.done = false, next3;
          }
          return next3.value = void 0, next3.done = true, next3;
        };
        return next2.next = next2;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap2(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
    return this;
  }), define(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(object4) {
    var keys2 = [];
    for (var key in object4) {
      keys2.push(key);
    }
    return keys2.reverse(), function next2() {
      for (; keys2.length; ) {
        var key2 = keys2.pop();
        if (key2 in object4)
          return next2.value = key2, next2.done = false, next2;
      }
      return next2.done = true, next2;
    };
  }, exports.values = values, Context2.prototype = {
    constructor: Context2,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this) {
          "t" === name.charAt(0) && hasOwn2.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        }
    },
    stop: function stop() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done)
        throw exception;
      var context2 = this;
      function handle2(loc, caught) {
        return record.type = "throw", record.arg = exception, context2.next = loc, caught && (context2.method = "next", context2.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle2("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn2.call(entry, "catchLoc"), hasFinally = hasOwn2.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle2(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle2(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle2(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle2(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type4, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn2.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type4 || "continue" === type4) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type4, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error3) {
    reject(error3);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn2) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn2.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$2(subClass, superClass);
}
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$2(o);
}
function _setPrototypeOf$2(o, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$2(o, p2);
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$2()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance2 = new Constructor();
      if (Class2)
        _setPrototypeOf$2(instance2, Class2.prototype);
      return instance2;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper2);
    }
    function Wrapper2() {
      return _construct(Class2, arguments, _getPrototypeOf$2(this).constructor);
    }
    Wrapper2.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper2,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf$2(Wrapper2, Class2);
  };
  return _wrapNativeSuper(Class);
}
var formatRegExp = /%[sdj%]/g;
var warning$b = function warning() {
};
if (typeof process !== "undefined" && process.env && false) {
  warning$b = function warning3(type4, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e2) {
        return typeof e2 === "string";
      })) {
        console.warn(type4, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error3) {
    var field = error3.field;
    fields[field] = fields[field] || [];
    fields[field].push(error3);
  });
  return fields;
}
function format(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i = 0;
  var len = args.length;
  if (typeof template === "function") {
    return template.apply(null, args);
  }
  if (typeof template === "string") {
    var str = template.replace(formatRegExp, function(x2) {
      if (x2 === "%%") {
        return "%";
      }
      if (i >= len) {
        return x2;
      }
      switch (x2) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_24) {
            return "[Circular]";
          }
          break;
        default:
          return x2;
      }
    });
    return str;
  }
  return template;
}
function isNativeStringType(type4) {
  return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
}
function isEmptyValue(value, type4) {
  if (value === void 0 || value === null) {
    return true;
  }
  if (type4 === "array" && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type4) && typeof value === "string" && !value) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr2, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr2.length;
  function count(errors) {
    results.push.apply(results, errors || []);
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }
  arr2.forEach(function(a) {
    func(a, count);
  });
}
function asyncSerialArray(arr2, func, callback) {
  var index2 = 0;
  var arrLength = arr2.length;
  function next2(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index2;
    index2 = index2 + 1;
    if (original < arrLength) {
      func(arr2[original], next2);
    } else {
      callback([]);
    }
  }
  next2([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k2) {
    ret.push.apply(ret, objArr[k2] || []);
  });
  return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(AsyncValidationError2, _Error);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _this = _Error.call(this, "Async Validation Error") || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return AsyncValidationError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
  if (option.first) {
    var _pending = new Promise(function(resolve, reject) {
      var next2 = function next3(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next2);
    });
    _pending["catch"](function(e2) {
      return e2;
    });
    return _pending;
  }
  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function(resolve, reject) {
    var next2 = function next3(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }
    objArrKeys.forEach(function(key) {
      var arr2 = objArr[key];
      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr2, func, next2);
      } else {
        asyncParallelArray(arr2, func, next2);
      }
    });
  });
  pending["catch"](function(e2) {
    return e2;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue$5(value, path2) {
  var v2 = value;
  for (var i = 0; i < path2.length; i++) {
    if (v2 == void 0) {
      return v2;
    }
    v2 = v2[path2[i]];
  }
  return v2;
}
function complementError(rule, source) {
  return function(oe2) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue$5(source, rule.fullFields);
    } else {
      fieldValue = source[oe2.field || rule.fullField];
    }
    if (isErrorObj(oe2)) {
      oe2.field = oe2.field || rule.fullField;
      oe2.fieldValue = fieldValue;
      return oe2;
    }
    return {
      message: typeof oe2 === "function" ? oe2() : oe2,
      fieldValue,
      field: oe2.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s2 in source) {
      if (source.hasOwnProperty(s2)) {
        var value = source[s2];
        if (typeof value === "object" && typeof target[s2] === "object") {
          target[s2] = _extends$2({}, target[s2], value);
        } else {
          target[s2] = value;
        }
      }
    }
  }
  return target;
}
var required$1 = function required(rule, value, source, errors, options, type4) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
    errors.push(format(options.messages.required, rule.fullField));
  }
};
var whitespace = function whitespace2(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === "") {
    errors.push(format(options.messages.whitespace, rule.fullField));
  }
};
var urlReg;
var getUrlRegex = function() {
  if (urlReg) {
    return urlReg;
  }
  var word = "[a-fA-F\\d:]";
  var b2 = function b3(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
  };
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6seg = "[a-fA-F\\d]{1,4}";
  var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
  var v4exact = new RegExp("^" + v4 + "$");
  var v6exact = new RegExp("^" + v6 + "$");
  var ip = function ip2(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
  };
  ip.v4 = function(options) {
    return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
  };
  ip.v6 = function(options) {
    return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
  };
  var protocol = "(?:(?:[a-z]+:)?//)";
  var auth = "(?:\\S+(?::\\S*)?@)?";
  var ipv4 = ip.v4().source;
  var ipv6 = ip.v6().source;
  var host2 = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain2 = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
  var port = "(?::\\d{2,5})?";
  var path2 = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host2 + domain2 + tld + ")" + port + path2;
  urlReg = new RegExp("(?:^" + regex + "$)", "i");
  return urlReg;
};
var pattern$2 = {
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e2) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === "number";
  },
  object: function object(value) {
    return typeof value === "object" && !types.array(value);
  },
  method: function method(value) {
    return typeof value === "function";
  },
  email: function email(value) {
    return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
  },
  url: function url(value) {
    return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
  },
  hex: function hex(value) {
    return typeof value === "string" && !!value.match(pattern$2.hex);
  }
};
var type$1 = function type(rule, value, source, errors, options) {
  if (rule.required && value === void 0) {
    required$1(rule, value, source, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var range = function range2(rule, value, source, errors, options) {
  var len = typeof rule.len === "number";
  var min = typeof rule.min === "number";
  var max = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === "number";
  var str = typeof value === "string";
  var arr2 = Array.isArray(value);
  if (num) {
    key = "number";
  } else if (str) {
    key = "string";
  } else if (arr2) {
    key = "array";
  }
  if (!key) {
    return false;
  }
  if (arr2) {
    val = value.length;
  }
  if (str) {
    val = value.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(format(options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(format(options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
};
var ENUM$1 = "enum";
var enumerable$1 = function enumerable(rule, value, source, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
  if (rule[ENUM$1].indexOf(value) === -1) {
    errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
  }
};
var pattern$1 = function pattern(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};
var rules = {
  required: required$1,
  whitespace,
  type: type$1,
  range,
  "enum": enumerable$1,
  pattern: pattern$1
};
var string = function string2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, "string");
    if (!isEmptyValue(value, "string")) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
      rules.pattern(rule, value, source, errors, options);
      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source, errors, options);
      }
    }
  }
  callback(errors);
};
var method2 = function method3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var number2 = function number3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "") {
      value = void 0;
    }
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var _boolean = function _boolean2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var regexp2 = function regexp3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value)) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var integer2 = function integer3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var floatFn = function floatFn2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var array2 = function array3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if ((value === void 0 || value === null) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, "array");
    if (value !== void 0 && value !== null) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var object2 = function object3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var ENUM = "enum";
var enumerable2 = function enumerable3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules[ENUM](rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var pattern2 = function pattern3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "string")) {
      rules.pattern(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var date2 = function date3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "date")) {
      var dateObject;
      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }
      rules.type(rule, dateObject, source, errors, options);
      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
};
var required2 = function required3(rule, value, callback, source, options) {
  var errors = [];
  var type4 = Array.isArray(value) ? "array" : typeof value;
  rules.required(rule, value, source, errors, options, type4);
  callback(errors);
};
var type2 = function type3(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, ruleType);
    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var any = function any2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
  }
  callback(errors);
};
var validators = {
  string,
  method: method2,
  number: number2,
  "boolean": _boolean,
  regexp: regexp2,
  integer: integer2,
  "float": floatFn,
  array: array2,
  object: object2,
  "enum": enumerable2,
  pattern: pattern2,
  date: date2,
  url: type2,
  hex: type2,
  email: type2,
  required: required2,
  any
};
function newMessages() {
  return {
    "default": "Validation error on field %s",
    required: "%s is required",
    "enum": "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      "boolean": "%s is not a %s",
      integer: "%s is not an %s",
      "float": "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone2() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();
var Schema = /* @__PURE__ */ function() {
  function Schema2(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }
  var _proto = Schema2.prototype;
  _proto.define = function define(rules2) {
    var _this = this;
    if (!rules2) {
      throw new Error("Cannot configure a schema with no rules");
    }
    if (typeof rules2 !== "object" || Array.isArray(rules2)) {
      throw new Error("Rules must be an object");
    }
    this.rules = {};
    Object.keys(rules2).forEach(function(name) {
      var item = rules2[name];
      _this.rules[name] = Array.isArray(item) ? item : [item];
    });
  };
  _proto.messages = function messages2(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }
    return this._messages;
  };
  _proto.validate = function validate(source_, o, oc) {
    var _this2 = this;
    if (o === void 0) {
      o = {};
    }
    if (oc === void 0) {
      oc = function oc2() {
      };
    }
    var source = source_;
    var options = o;
    var callback = oc;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source);
      }
      return Promise.resolve(source);
    }
    function complete(results) {
      var errors = [];
      var fields = {};
      function add(e2) {
        if (Array.isArray(e2)) {
          var _errors;
          errors = (_errors = errors).concat.apply(_errors, e2);
        } else {
          errors.push(e2);
        }
      }
      for (var i = 0; i < results.length; i++) {
        add(results[i]);
      }
      if (!errors.length) {
        callback(null, source);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }
    if (options.messages) {
      var messages$1 = this.messages();
      if (messages$1 === messages) {
        messages$1 = newMessages();
      }
      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }
    var series = {};
    var keys2 = options.keys || Object.keys(this.rules);
    keys2.forEach(function(z2) {
      var arr2 = _this2.rules[z2];
      var value = source[z2];
      arr2.forEach(function(r2) {
        var rule = r2;
        if (typeof rule.transform === "function") {
          if (source === source_) {
            source = _extends$2({}, source);
          }
          value = source[z2] = rule.transform(value);
        }
        if (typeof rule === "function") {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends$2({}, rule);
        }
        rule.validator = _this2.getValidationMethod(rule);
        if (!rule.validator) {
          return;
        }
        rule.field = z2;
        rule.fullField = rule.fullField || z2;
        rule.type = _this2.getType(rule);
        series[z2] = series[z2] || [];
        series[z2].push({
          rule,
          value,
          source,
          field: z2
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function(data2, doIt) {
      var rule = data2.rule;
      var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
      deep = deep && (rule.required || !rule.required && data2.value);
      rule.field = data2.field;
      function addFullField(key, schema) {
        return _extends$2({}, schema, {
          fullField: rule.fullField + "." + key,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
        });
      }
      function cb(e2) {
        if (e2 === void 0) {
          e2 = [];
        }
        var errorList = Array.isArray(e2) ? e2 : [e2];
        if (!options.suppressWarning && errorList.length) {
          Schema2.warning("async-validator:", errorList);
        }
        if (errorList.length && rule.message !== void 0) {
          errorList = [].concat(rule.message);
        }
        var filledErrors = errorList.map(complementError(rule, source));
        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }
        if (!deep) {
          doIt(filledErrors);
        } else {
          if (rule.required && !data2.value) {
            if (rule.message !== void 0) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source));
            } else if (options.error) {
              filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
            }
            return doIt(filledErrors);
          }
          var fieldsSchema = {};
          if (rule.defaultField) {
            Object.keys(data2.value).map(function(key) {
              fieldsSchema[key] = rule.defaultField;
            });
          }
          fieldsSchema = _extends$2({}, fieldsSchema, data2.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function(field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema = new Schema2(paredFieldsSchema);
          schema.messages(options.messages);
          if (data2.rule.options) {
            data2.rule.options.messages = options.messages;
            data2.rule.options.error = options.error;
          }
          schema.validate(data2.value, data2.rule.options || options, function(errs) {
            var finalErrors = [];
            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }
            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }
            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }
      var res;
      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data2.value, cb, data2.source, options);
      } else if (rule.validator) {
        try {
          res = rule.validator(rule, data2.value, cb, data2.source, options);
        } catch (error3) {
          console.error == null ? void 0 : console.error(error3);
          if (!options.suppressValidatorError) {
            setTimeout(function() {
              throw error3;
            }, 0);
          }
          cb(error3.message);
        }
        if (res === true) {
          cb();
        } else if (res === false) {
          cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }
      if (res && res.then) {
        res.then(function() {
          return cb();
        }, function(e2) {
          return cb(e2);
        });
      }
    }, function(results) {
      complete(results);
    }, source);
  };
  _proto.getType = function getType(rule) {
    if (rule.type === void 0 && rule.pattern instanceof RegExp) {
      rule.type = "pattern";
    }
    if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format("Unknown rule type %s", rule.type));
    }
    return rule.type || "string";
  };
  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === "function") {
      return rule.validator;
    }
    var keys2 = Object.keys(rule);
    var messageIndex = keys2.indexOf("message");
    if (messageIndex !== -1) {
      keys2.splice(messageIndex, 1);
    }
    if (keys2.length === 1 && keys2[0] === "required") {
      return validators.required;
    }
    return validators[this.getType(rule)] || void 0;
  };
  return Schema2;
}();
Schema.register = function register(type4, validator) {
  if (typeof validator !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validators[type4] = validator;
};
Schema.warning = warning$b;
Schema.messages = messages;
Schema.validators = validators;
var typeTemplate$2 = "'${name}' is not a valid ${type}";
var defaultValidateMessages = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: typeTemplate$2,
    method: typeTemplate$2,
    array: typeTemplate$2,
    object: typeTemplate$2,
    number: typeTemplate$2,
    date: typeTemplate$2,
    boolean: typeTemplate$2,
    integer: typeTemplate$2,
    float: typeTemplate$2,
    regexp: typeTemplate$2,
    email: typeTemplate$2,
    url: typeTemplate$2,
    hex: typeTemplate$2
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
};
function get$2(entity, path2) {
  var current = entity;
  for (var i = 0; i < path2.length; i += 1) {
    if (current === null || current === void 0) {
      return void 0;
    }
    current = current[path2[i]];
  }
  return current;
}
function internalSet$1(entity, paths, value, removeIfUndefined) {
  if (!paths.length) {
    return value;
  }
  var _paths = _toArray$1(paths), path2 = _paths[0], restPath = _paths.slice(1);
  var clone2;
  if (!entity && typeof path2 === "number") {
    clone2 = [];
  } else if (Array.isArray(entity)) {
    clone2 = _toConsumableArray(entity);
  } else {
    clone2 = _objectSpread2$d({}, entity);
  }
  if (removeIfUndefined && value === void 0 && restPath.length === 1) {
    delete clone2[path2][restPath[0]];
  } else {
    clone2[path2] = internalSet$1(clone2[path2], restPath, value, removeIfUndefined);
  }
  return clone2;
}
function set$2(entity, paths, value) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (paths.length && removeIfUndefined && value === void 0 && !get$2(entity, paths.slice(0, -1))) {
    return entity;
  }
  return internalSet$1(entity, paths, value, removeIfUndefined);
}
function cloneDeep$2(val) {
  if (Array.isArray(val)) {
    return cloneArrayDeep$1(val);
  } else if (_typeof$8(val) === "object" && val !== null) {
    return cloneObjectDeep$1(val);
  }
  return val;
}
function cloneObjectDeep$1(val) {
  if (Object.getPrototypeOf(val) === Object.prototype) {
    var res = {};
    for (var key in val) {
      res[key] = cloneDeep$2(val[key]);
    }
    return res;
  }
  return val;
}
function cloneArrayDeep$1(val) {
  return val.map(function(item) {
    return cloneDeep$2(item);
  });
}
function getNamePath$1(path2) {
  return toArray$a(path2);
}
function getValue$4(store, namePath) {
  var value = get$2(store, namePath);
  return value;
}
function setValue$1(store, namePath, value) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var newStore = set$2(store, namePath, value, removeIfUndefined);
  return newStore;
}
function cloneByNamePathList$1(store, namePathList) {
  var newStore = {};
  namePathList.forEach(function(namePath) {
    var value = getValue$4(store, namePath);
    newStore = setValue$1(newStore, namePath, value);
  });
  return newStore;
}
function containsNamePath$1(namePathList, namePath) {
  return namePathList && namePathList.some(function(path2) {
    return matchNamePath$1(path2, namePath);
  });
}
function isObject$4(obj) {
  return _typeof$8(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function internalSetValues$1(store, values) {
  var newStore = Array.isArray(store) ? _toConsumableArray(store) : _objectSpread2$d({}, store);
  if (!values) {
    return newStore;
  }
  Object.keys(values).forEach(function(key) {
    var prevValue = newStore[key];
    var value = values[key];
    var recursive = isObject$4(prevValue) && isObject$4(value);
    newStore[key] = recursive ? internalSetValues$1(prevValue, value || {}) : cloneDeep$2(value);
  });
  return newStore;
}
function setValues$1(store) {
  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    restValues[_key - 1] = arguments[_key];
  }
  return restValues.reduce(function(current, newStore) {
    return internalSetValues$1(current, newStore);
  }, store);
}
function matchNamePath$1(namePath, changedNamePath) {
  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
    return false;
  }
  return namePath.every(function(nameUnit, i) {
    return changedNamePath[i] === nameUnit;
  });
}
function isSimilar$1(source, target) {
  if (source === target) {
    return true;
  }
  if (!source && target || source && !target) {
    return false;
  }
  if (!source || !target || _typeof$8(source) !== "object" || _typeof$8(target) !== "object") {
    return false;
  }
  var sourceKeys = Object.keys(source);
  var targetKeys = Object.keys(target);
  var keys2 = new Set([].concat(sourceKeys, targetKeys));
  return _toConsumableArray(keys2).every(function(key) {
    var sourceValue = source[key];
    var targetValue = target[key];
    if (typeof sourceValue === "function" && typeof targetValue === "function") {
      return true;
    }
    return sourceValue === targetValue;
  });
}
function defaultGetValueFromEvent$1(valuePropName) {
  var event = arguments.length <= 1 ? void 0 : arguments[1];
  if (event && event.target && _typeof$8(event.target) === "object" && valuePropName in event.target) {
    return event.target[valuePropName];
  }
  return event;
}
function move$1(array4, moveIndex, toIndex) {
  var length2 = array4.length;
  if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
    return array4;
  }
  var item = array4[moveIndex];
  var diff = moveIndex - toIndex;
  if (diff > 0) {
    return [].concat(_toConsumableArray(array4.slice(0, toIndex)), [item], _toConsumableArray(array4.slice(toIndex, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, length2)));
  }
  if (diff < 0) {
    return [].concat(_toConsumableArray(array4.slice(0, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array4.slice(toIndex + 1, length2)));
  }
  return array4;
}
var AsyncValidator = Schema;
function replaceMessage(template, kv) {
  return template.replace(/\$\{\w+\}/g, function(str) {
    var key = str.slice(2, -1);
    return kv[key];
  });
}
var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
function validateRule(_x, _x2, _x3, _x4, _x5) {
  return _validateRule.apply(this, arguments);
}
function _validateRule() {
  _validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name, value, rule, options, messageVariables) {
    var cloneRule, originValidator, subRuleField, validator, messages2, result, subResults, kv, fillVariableResult;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1)
        switch (_context2.prev = _context2.next) {
          case 0:
            cloneRule = _objectSpread2$d({}, rule);
            delete cloneRule.ruleIndex;
            if (cloneRule.validator) {
              originValidator = cloneRule.validator;
              cloneRule.validator = function() {
                try {
                  return originValidator.apply(void 0, arguments);
                } catch (error3) {
                  console.error(error3);
                  return Promise.reject(CODE_LOGIC_ERROR);
                }
              };
            }
            subRuleField = null;
            if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
              subRuleField = cloneRule.defaultField;
              delete cloneRule.defaultField;
            }
            validator = new AsyncValidator(_defineProperty$3({}, name, [cloneRule]));
            messages2 = setValues$1({}, defaultValidateMessages, options.validateMessages);
            validator.messages(messages2);
            result = [];
            _context2.prev = 9;
            _context2.next = 12;
            return Promise.resolve(validator.validate(_defineProperty$3({}, name, value), _objectSpread2$d({}, options)));
          case 12:
            _context2.next = 17;
            break;
          case 14:
            _context2.prev = 14;
            _context2.t0 = _context2["catch"](9);
            if (_context2.t0.errors) {
              result = _context2.t0.errors.map(function(_ref4, index2) {
                var message = _ref4.message;
                var mergedMessage = message === CODE_LOGIC_ERROR ? messages2.default : message;
                return /* @__PURE__ */ React.isValidElement(mergedMessage) ? /* @__PURE__ */ React.cloneElement(mergedMessage, {
                  key: "error_".concat(index2)
                }) : mergedMessage;
              });
            }
          case 17:
            if (!(!result.length && subRuleField)) {
              _context2.next = 22;
              break;
            }
            _context2.next = 20;
            return Promise.all(value.map(function(subValue, i) {
              return validateRule("".concat(name, ".").concat(i), subValue, subRuleField, options, messageVariables);
            }));
          case 20:
            subResults = _context2.sent;
            return _context2.abrupt("return", subResults.reduce(function(prev2, errors) {
              return [].concat(_toConsumableArray(prev2), _toConsumableArray(errors));
            }, []));
          case 22:
            kv = _objectSpread2$d(_objectSpread2$d({}, rule), {}, {
              name,
              enum: (rule.enum || []).join(", ")
            }, messageVariables);
            fillVariableResult = result.map(function(error3) {
              if (typeof error3 === "string") {
                return replaceMessage(error3, kv);
              }
              return error3;
            });
            return _context2.abrupt("return", fillVariableResult);
          case 25:
          case "end":
            return _context2.stop();
        }
    }, _callee2, null, [[9, 14]]);
  }));
  return _validateRule.apply(this, arguments);
}
function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
  var name = namePath.join(".");
  var filledRules = rules2.map(function(currentRule, ruleIndex) {
    var originValidatorFunc = currentRule.validator;
    var cloneRule = _objectSpread2$d(_objectSpread2$d({}, currentRule), {}, {
      ruleIndex
    });
    if (originValidatorFunc) {
      cloneRule.validator = function(rule, val, callback) {
        var hasPromise = false;
        var wrappedCallback = function wrappedCallback2() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          Promise.resolve().then(function() {
            warningOnce$7(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
            if (!hasPromise) {
              callback.apply(void 0, args);
            }
          });
        };
        var promise = originValidatorFunc(rule, val, wrappedCallback);
        hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
        warningOnce$7(hasPromise, "`callback` is deprecated. Please return a promise instead.");
        if (hasPromise) {
          promise.then(function() {
            callback();
          }).catch(function(err) {
            callback(err || " ");
          });
        }
      };
    }
    return cloneRule;
  }).sort(function(_ref2, _ref22) {
    var w1 = _ref2.warningOnly, i1 = _ref2.ruleIndex;
    var w2 = _ref22.warningOnly, i2 = _ref22.ruleIndex;
    if (!!w1 === !!w2) {
      return i1 - i2;
    }
    if (w1) {
      return 1;
    }
    return -1;
  });
  var summaryPromise;
  if (validateFirst === true) {
    summaryPromise = new Promise(/* @__PURE__ */ function() {
      var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve, reject) {
        var i, rule, errors;
        return _regeneratorRuntime().wrap(function _callee$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                i = 0;
              case 1:
                if (!(i < filledRules.length)) {
                  _context2.next = 12;
                  break;
                }
                rule = filledRules[i];
                _context2.next = 5;
                return validateRule(name, value, rule, options, messageVariables);
              case 5:
                errors = _context2.sent;
                if (!errors.length) {
                  _context2.next = 9;
                  break;
                }
                reject([{
                  errors,
                  rule
                }]);
                return _context2.abrupt("return");
              case 9:
                i += 1;
                _context2.next = 1;
                break;
              case 12:
                resolve([]);
              case 13:
              case "end":
                return _context2.stop();
            }
        }, _callee);
      }));
      return function(_x6, _x7) {
        return _ref3.apply(this, arguments);
      };
    }());
  } else {
    var rulePromises = filledRules.map(function(rule) {
      return validateRule(name, value, rule, options, messageVariables).then(function(errors) {
        return {
          errors,
          rule
        };
      });
    });
    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
      return Promise.reject(errors);
    });
  }
  summaryPromise.catch(function(e2) {
    return e2;
  });
  return summaryPromise;
}
function finishOnAllFailed(_x8) {
  return _finishOnAllFailed.apply(this, arguments);
}
function _finishOnAllFailed() {
  _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(rulePromises) {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1)
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
              var _ref5;
              var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
              return errors;
            }));
          case 1:
          case "end":
            return _context3.stop();
        }
    }, _callee3);
  }));
  return _finishOnAllFailed.apply(this, arguments);
}
function finishOnFirstFailed(_x9) {
  return _finishOnFirstFailed.apply(this, arguments);
}
function _finishOnFirstFailed() {
  _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(rulePromises) {
    var count;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1)
        switch (_context4.prev = _context4.next) {
          case 0:
            count = 0;
            return _context4.abrupt("return", new Promise(function(resolve) {
              rulePromises.forEach(function(promise) {
                promise.then(function(ruleError) {
                  if (ruleError.errors.length) {
                    resolve([ruleError]);
                  }
                  count += 1;
                  if (count === rulePromises.length) {
                    resolve([]);
                  }
                });
              });
            }));
          case 2:
          case "end":
            return _context4.stop();
        }
    }, _callee4);
  }));
  return _finishOnFirstFailed.apply(this, arguments);
}
var _excluded$P = ["name"];
var EMPTY_ERRORS = [];
function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info) {
  if (typeof shouldUpdate === "function") {
    return shouldUpdate(prev2, next2, "source" in info ? {
      source: info.source
    } : {});
  }
  return prevValue !== nextValue;
}
var Field = /* @__PURE__ */ function(_React$Component) {
  _inherits$2(Field2, _React$Component);
  var _super = _createSuper$2(Field2);
  function Field2(props) {
    var _this;
    _classCallCheck$2(this, Field2);
    _this = _super.call(this, props);
    _this.state = {
      resetCount: 0
    };
    _this.cancelRegisterFunc = null;
    _this.mounted = false;
    _this.touched = false;
    _this.dirty = false;
    _this.validatePromise = void 0;
    _this.prevValidating = void 0;
    _this.errors = EMPTY_ERRORS;
    _this.warnings = EMPTY_ERRORS;
    _this.cancelRegister = function() {
      var _this$props = _this.props, preserve = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
      if (_this.cancelRegisterFunc) {
        _this.cancelRegisterFunc(isListField, preserve, getNamePath$1(name));
      }
      _this.cancelRegisterFunc = null;
    };
    _this.getNamePath = function() {
      var _this$props2 = _this.props, name = _this$props2.name, fieldContext = _this$props2.fieldContext;
      var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
      return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
    };
    _this.getRules = function() {
      var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
      return rules2.map(function(rule) {
        if (typeof rule === "function") {
          return rule(fieldContext);
        }
        return rule;
      });
    };
    _this.refresh = function() {
      if (!_this.mounted)
        return;
      _this.setState(function(_ref2) {
        var resetCount = _ref2.resetCount;
        return {
          resetCount: resetCount + 1
        };
      });
    };
    _this.triggerMetaEvent = function(destroy) {
      var onMetaChange = _this.props.onMetaChange;
      onMetaChange === null || onMetaChange === void 0 ? void 0 : onMetaChange(_objectSpread2$d(_objectSpread2$d({}, _this.getMeta()), {}, {
        destroy
      }));
    };
    _this.onStoreChange = function(prevStore, namePathList, info) {
      var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
      var store = info.store;
      var namePath = _this.getNamePath();
      var prevValue = _this.getValue(prevStore);
      var curValue = _this.getValue(store);
      var namePathMatch = namePathList && containsNamePath$1(namePathList, namePath);
      if (info.type === "valueUpdate" && info.source === "external" && prevValue !== curValue) {
        _this.touched = true;
        _this.dirty = true;
        _this.validatePromise = null;
        _this.errors = EMPTY_ERRORS;
        _this.warnings = EMPTY_ERRORS;
        _this.triggerMetaEvent();
      }
      switch (info.type) {
        case "reset":
          if (!namePathList || namePathMatch) {
            _this.touched = false;
            _this.dirty = false;
            _this.validatePromise = null;
            _this.errors = EMPTY_ERRORS;
            _this.warnings = EMPTY_ERRORS;
            _this.triggerMetaEvent();
            onReset === null || onReset === void 0 ? void 0 : onReset();
            _this.refresh();
            return;
          }
          break;
        case "remove": {
          if (shouldUpdate) {
            _this.reRender();
            return;
          }
          break;
        }
        case "setField": {
          if (namePathMatch) {
            var data2 = info.data;
            if ("touched" in data2) {
              _this.touched = data2.touched;
            }
            if ("validating" in data2 && !("originRCField" in data2)) {
              _this.validatePromise = data2.validating ? Promise.resolve([]) : null;
            }
            if ("errors" in data2) {
              _this.errors = data2.errors || EMPTY_ERRORS;
            }
            if ("warnings" in data2) {
              _this.warnings = data2.warnings || EMPTY_ERRORS;
            }
            _this.dirty = true;
            _this.triggerMetaEvent();
            _this.reRender();
            return;
          }
          if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
            _this.reRender();
            return;
          }
          break;
        }
        case "dependenciesUpdate": {
          var dependencyList = dependencies.map(getNamePath$1);
          if (dependencyList.some(function(dependency) {
            return containsNamePath$1(info.relatedFields, dependency);
          })) {
            _this.reRender();
            return;
          }
          break;
        }
        default:
          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
            _this.reRender();
            return;
          }
          break;
      }
      if (shouldUpdate === true) {
        _this.reRender();
      }
    };
    _this.validateRules = function(options) {
      var namePath = _this.getNamePath();
      var currentValue = _this.getValue();
      var rootPromise = Promise.resolve().then(function() {
        if (!_this.mounted) {
          return [];
        }
        var _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables;
        var _ref2 = options || {}, triggerName = _ref2.triggerName;
        var filteredRules = _this.getRules();
        if (triggerName) {
          filteredRules = filteredRules.filter(function(rule) {
            return rule;
          }).filter(function(rule) {
            var validateTrigger = rule.validateTrigger;
            if (!validateTrigger) {
              return true;
            }
            var triggerList = toArray$a(validateTrigger);
            return triggerList.includes(triggerName);
          });
        }
        var promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
        promise.catch(function(e2) {
          return e2;
        }).then(function() {
          var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
          if (_this.validatePromise === rootPromise) {
            var _ruleErrors$forEach;
            _this.validatePromise = null;
            var nextErrors = [];
            var nextWarnings = [];
            (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref3) {
              var warningOnly = _ref3.rule.warningOnly, _ref3$errors = _ref3.errors, errors = _ref3$errors === void 0 ? EMPTY_ERRORS : _ref3$errors;
              if (warningOnly) {
                nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
              } else {
                nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
              }
            });
            _this.errors = nextErrors;
            _this.warnings = nextWarnings;
            _this.triggerMetaEvent();
            _this.reRender();
          }
        });
        return promise;
      });
      _this.validatePromise = rootPromise;
      _this.dirty = true;
      _this.errors = EMPTY_ERRORS;
      _this.warnings = EMPTY_ERRORS;
      _this.triggerMetaEvent();
      _this.reRender();
      return rootPromise;
    };
    _this.isFieldValidating = function() {
      return !!_this.validatePromise;
    };
    _this.isFieldTouched = function() {
      return _this.touched;
    };
    _this.isFieldDirty = function() {
      if (_this.dirty || _this.props.initialValue !== void 0) {
        return true;
      }
      var fieldContext = _this.props.fieldContext;
      var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
      if (getInitialValue(_this.getNamePath()) !== void 0) {
        return true;
      }
      return false;
    };
    _this.getErrors = function() {
      return _this.errors;
    };
    _this.getWarnings = function() {
      return _this.warnings;
    };
    _this.isListField = function() {
      return _this.props.isListField;
    };
    _this.isList = function() {
      return _this.props.isList;
    };
    _this.isPreserve = function() {
      return _this.props.preserve;
    };
    _this.getMeta = function() {
      _this.prevValidating = _this.isFieldValidating();
      var meta = {
        touched: _this.isFieldTouched(),
        validating: _this.prevValidating,
        errors: _this.errors,
        warnings: _this.warnings,
        name: _this.getNamePath(),
        validated: _this.validatePromise === null
      };
      return meta;
    };
    _this.getOnlyChild = function(children) {
      if (typeof children === "function") {
        var meta = _this.getMeta();
        return _objectSpread2$d(_objectSpread2$d({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.props.fieldContext))), {}, {
          isFunction: true
        });
      }
      var childList = toArray$b(children);
      if (childList.length !== 1 || !/* @__PURE__ */ React.isValidElement(childList[0])) {
        return {
          child: childList,
          isFunction: false
        };
      }
      return {
        child: childList[0],
        isFunction: false
      };
    };
    _this.getValue = function(store) {
      var getFieldsValue = _this.props.fieldContext.getFieldsValue;
      var namePath = _this.getNamePath();
      return getValue$4(store || getFieldsValue(true), namePath);
    };
    _this.getControlled = function() {
      var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var _this$props6 = _this.props, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
      var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
      var namePath = _this.getNamePath();
      var getInternalHooks3 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
      var _getInternalHooks = getInternalHooks3(HOOK_MARK), dispatch = _getInternalHooks.dispatch;
      var value = _this.getValue();
      var mergedGetValueProps = getValueProps || function(val) {
        return _defineProperty$3({}, valuePropName, val);
      };
      var originTriggerFunc = childProps[trigger];
      var control = _objectSpread2$d(_objectSpread2$d({}, childProps), mergedGetValueProps(value));
      control[trigger] = function() {
        _this.touched = true;
        _this.dirty = true;
        _this.triggerMetaEvent();
        var newValue;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (getValueFromEvent) {
          newValue = getValueFromEvent.apply(void 0, args);
        } else {
          newValue = defaultGetValueFromEvent$1.apply(void 0, [valuePropName].concat(args));
        }
        if (normalize2) {
          newValue = normalize2(newValue, value, getFieldsValue(true));
        }
        dispatch({
          type: "updateValue",
          namePath,
          value: newValue
        });
        if (originTriggerFunc) {
          originTriggerFunc.apply(void 0, args);
        }
      };
      var validateTriggerList = toArray$a(mergedValidateTrigger || []);
      validateTriggerList.forEach(function(triggerName) {
        var originTrigger = control[triggerName];
        control[triggerName] = function() {
          if (originTrigger) {
            originTrigger.apply(void 0, arguments);
          }
          var rules2 = _this.props.rules;
          if (rules2 && rules2.length) {
            dispatch({
              type: "validateField",
              namePath,
              triggerName
            });
          }
        };
      });
      return control;
    };
    if (props.fieldContext) {
      var getInternalHooks2 = props.fieldContext.getInternalHooks;
      var _getInternalHooks2 = getInternalHooks2(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
      initEntityValue(_assertThisInitialized$2(_this));
    }
    return _this;
  }
  _createClass$2(Field2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
      this.mounted = true;
      if (fieldContext) {
        var getInternalHooks2 = fieldContext.getInternalHooks;
        var _getInternalHooks3 = getInternalHooks2(HOOK_MARK), registerField = _getInternalHooks3.registerField;
        this.cancelRegisterFunc = registerField(this);
      }
      if (shouldUpdate === true) {
        this.reRender();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.cancelRegister();
      this.triggerMetaEvent(true);
      this.mounted = false;
    }
  }, {
    key: "reRender",
    value: function reRender() {
      if (!this.mounted)
        return;
      this.forceUpdate();
    }
  }, {
    key: "render",
    value: function render2() {
      var resetCount = this.state.resetCount;
      var children = this.props.children;
      var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction2 = _this$getOnlyChild.isFunction;
      var returnChildNode;
      if (isFunction2) {
        returnChildNode = child;
      } else if (/* @__PURE__ */ React.isValidElement(child)) {
        returnChildNode = /* @__PURE__ */ React.cloneElement(child, this.getControlled(child.props));
      } else {
        warningOnce$7(!child, "`children` of Field is not validate ReactElement.");
        returnChildNode = child;
      }
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: resetCount
      }, returnChildNode);
    }
  }]);
  return Field2;
}(React.Component);
Field.contextType = Context$1;
Field.defaultProps = {
  trigger: "onChange",
  valuePropName: "value"
};
function WrapperField(_ref5) {
  var name = _ref5.name, restProps = _objectWithoutProperties$1(_ref5, _excluded$P);
  var fieldContext = React.useContext(Context$1);
  var namePath = name !== void 0 ? getNamePath$1(name) : void 0;
  var key = "keep";
  if (!restProps.isListField) {
    key = "_".concat((namePath || []).join("_"));
  }
  return /* @__PURE__ */ React.createElement(Field, _extends$3({
    key,
    name: namePath
  }, restProps, {
    fieldContext
  }));
}
var ListContext$1 = /* @__PURE__ */ React.createContext(null);
var List$2 = function List(_ref2) {
  var name = _ref2.name, initialValue = _ref2.initialValue, children = _ref2.children, rules2 = _ref2.rules, validateTrigger = _ref2.validateTrigger;
  var context2 = React.useContext(Context$1);
  var keyRef = React.useRef({
    keys: [],
    id: 0
  });
  var keyManager = keyRef.current;
  var prefixName = React.useMemo(function() {
    var parentPrefixName = getNamePath$1(context2.prefixName) || [];
    return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath$1(name)));
  }, [context2.prefixName, name]);
  var fieldContext = React.useMemo(function() {
    return _objectSpread2$d(_objectSpread2$d({}, context2), {}, {
      prefixName
    });
  }, [context2, prefixName]);
  var listContext = React.useMemo(function() {
    return {
      getKey: function getKey3(namePath) {
        var len = prefixName.length;
        var pathName = namePath[len];
        return [keyManager.keys[pathName], namePath.slice(len + 1)];
      }
    };
  }, [prefixName]);
  if (typeof children !== "function") {
    warningOnce$7(false, "Form.List only accepts function as children.");
    return null;
  }
  var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref22) {
    var source = _ref22.source;
    if (source === "internal") {
      return false;
    }
    return prevValue !== nextValue;
  };
  return /* @__PURE__ */ React.createElement(ListContext$1.Provider, {
    value: listContext
  }, /* @__PURE__ */ React.createElement(Context$1.Provider, {
    value: fieldContext
  }, /* @__PURE__ */ React.createElement(WrapperField, {
    name: [],
    shouldUpdate,
    rules: rules2,
    validateTrigger,
    initialValue,
    isList: true
  }, function(_ref3, meta) {
    var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange = _ref3.onChange;
    var getFieldValue = context2.getFieldValue;
    var getNewValue = function getNewValue2() {
      var values = getFieldValue(prefixName || []);
      return values || [];
    };
    var operations = {
      add: function add(defaultValue, index2) {
        var newValue = getNewValue();
        if (index2 >= 0 && index2 <= newValue.length) {
          keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2)));
          onChange([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))));
        } else {
          keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
          onChange([].concat(_toConsumableArray(newValue), [defaultValue]));
        }
        keyManager.id += 1;
      },
      remove: function remove3(index2) {
        var newValue = getNewValue();
        var indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
        if (indexSet.size <= 0) {
          return;
        }
        keyManager.keys = keyManager.keys.filter(function(_24, keysIndex) {
          return !indexSet.has(keysIndex);
        });
        onChange(newValue.filter(function(_24, valueIndex) {
          return !indexSet.has(valueIndex);
        }));
      },
      move: function move2(from2, to2) {
        if (from2 === to2) {
          return;
        }
        var newValue = getNewValue();
        if (from2 < 0 || from2 >= newValue.length || to2 < 0 || to2 >= newValue.length) {
          return;
        }
        keyManager.keys = move$1(keyManager.keys, from2, to2);
        onChange(move$1(newValue, from2, to2));
      }
    };
    var listValue = value || [];
    if (!Array.isArray(listValue)) {
      listValue = [];
    }
    return children(listValue.map(function(__2, index2) {
      var key = keyManager.keys[index2];
      if (key === void 0) {
        keyManager.keys[index2] = keyManager.id;
        key = keyManager.keys[index2];
        keyManager.id += 1;
      }
      return {
        name: index2,
        key,
        isListField: true
      };
    }), operations, meta);
  })));
};
function allPromiseFinish(promiseList) {
  var hasError = false;
  var count = promiseList.length;
  var results = [];
  if (!promiseList.length) {
    return Promise.resolve([]);
  }
  return new Promise(function(resolve, reject) {
    promiseList.forEach(function(promise, index2) {
      promise.catch(function(e2) {
        hasError = true;
        return e2;
      }).then(function(result) {
        count -= 1;
        results[index2] = result;
        if (count > 0) {
          return;
        }
        if (hasError) {
          reject(results);
        }
        resolve(results);
      });
    });
  });
}
var SPLIT = "__@field_split__";
function normalize(namePath) {
  return namePath.map(function(cell) {
    return "".concat(_typeof$8(cell), ":").concat(cell);
  }).join(SPLIT);
}
var NameMap = /* @__PURE__ */ function() {
  function NameMap2() {
    _classCallCheck$2(this, NameMap2);
    this.kvs = /* @__PURE__ */ new Map();
  }
  _createClass$2(NameMap2, [{
    key: "set",
    value: function set2(key, value) {
      this.kvs.set(normalize(key), value);
    }
  }, {
    key: "get",
    value: function get2(key) {
      return this.kvs.get(normalize(key));
    }
  }, {
    key: "update",
    value: function update(key, updater) {
      var origin = this.get(key);
      var next2 = updater(origin);
      if (!next2) {
        this.delete(key);
      } else {
        this.set(key, next2);
      }
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      this.kvs.delete(normalize(key));
    }
  }, {
    key: "map",
    value: function map(callback) {
      return _toConsumableArray(this.kvs.entries()).map(function(_ref2) {
        var _ref22 = _slicedToArray$1(_ref2, 2), key = _ref22[0], value = _ref22[1];
        var cells = key.split(SPLIT);
        return callback({
          key: cells.map(function(cell) {
            var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray$1(_cell$match, 3), type4 = _cell$match2[1], unit = _cell$match2[2];
            return type4 === "number" ? Number(unit) : unit;
          }),
          value
        });
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {};
      this.map(function(_ref3) {
        var key = _ref3.key, value = _ref3.value;
        json[key.join(".")] = value;
        return null;
      });
      return json;
    }
  }]);
  return NameMap2;
}();
var _excluded$O = ["name"];
var FormStore = /* @__PURE__ */ _createClass$2(function FormStore2(forceRootUpdate) {
  var _this = this;
  _classCallCheck$2(this, FormStore2);
  this.formHooked = false;
  this.forceRootUpdate = void 0;
  this.subscribable = true;
  this.store = {};
  this.fieldEntities = [];
  this.initialValues = {};
  this.callbacks = {};
  this.validateMessages = null;
  this.preserve = null;
  this.lastValidatePromise = null;
  this.getForm = function() {
    return {
      getFieldValue: _this.getFieldValue,
      getFieldsValue: _this.getFieldsValue,
      getFieldError: _this.getFieldError,
      getFieldWarning: _this.getFieldWarning,
      getFieldsError: _this.getFieldsError,
      isFieldsTouched: _this.isFieldsTouched,
      isFieldTouched: _this.isFieldTouched,
      isFieldValidating: _this.isFieldValidating,
      isFieldsValidating: _this.isFieldsValidating,
      resetFields: _this.resetFields,
      setFields: _this.setFields,
      setFieldValue: _this.setFieldValue,
      setFieldsValue: _this.setFieldsValue,
      validateFields: _this.validateFields,
      submit: _this.submit,
      _init: true,
      getInternalHooks: _this.getInternalHooks
    };
  };
  this.getInternalHooks = function(key) {
    if (key === HOOK_MARK) {
      _this.formHooked = true;
      return {
        dispatch: _this.dispatch,
        initEntityValue: _this.initEntityValue,
        registerField: _this.registerField,
        useSubscribe: _this.useSubscribe,
        setInitialValues: _this.setInitialValues,
        destroyForm: _this.destroyForm,
        setCallbacks: _this.setCallbacks,
        setValidateMessages: _this.setValidateMessages,
        getFields: _this.getFields,
        setPreserve: _this.setPreserve,
        getInitialValue: _this.getInitialValue,
        registerWatch: _this.registerWatch
      };
    }
    warningOnce$7(false, "`getInternalHooks` is internal usage. Should not call directly.");
    return null;
  };
  this.useSubscribe = function(subscribable) {
    _this.subscribable = subscribable;
  };
  this.prevWithoutPreserves = null;
  this.setInitialValues = function(initialValues, init2) {
    _this.initialValues = initialValues || {};
    if (init2) {
      var _this$prevWithoutPres;
      var nextStore = setValues$1({}, initialValues, _this.store);
      (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function(_ref2) {
        var namePath = _ref2.key;
        nextStore = setValue$1(nextStore, namePath, getValue$4(initialValues, namePath));
      });
      _this.prevWithoutPreserves = null;
      _this.updateStore(nextStore);
    }
  };
  this.destroyForm = function() {
    var prevWithoutPreserves = new NameMap();
    _this.getFieldEntities(true).forEach(function(entity) {
      if (!_this.isMergedPreserve(entity.isPreserve())) {
        prevWithoutPreserves.set(entity.getNamePath(), true);
      }
    });
    _this.prevWithoutPreserves = prevWithoutPreserves;
  };
  this.getInitialValue = function(namePath) {
    var initValue = getValue$4(_this.initialValues, namePath);
    return namePath.length ? cloneDeep$2(initValue) : initValue;
  };
  this.setCallbacks = function(callbacks) {
    _this.callbacks = callbacks;
  };
  this.setValidateMessages = function(validateMessages) {
    _this.validateMessages = validateMessages;
  };
  this.setPreserve = function(preserve) {
    _this.preserve = preserve;
  };
  this.watchList = [];
  this.registerWatch = function(callback) {
    _this.watchList.push(callback);
    return function() {
      _this.watchList = _this.watchList.filter(function(fn2) {
        return fn2 !== callback;
      });
    };
  };
  this.notifyWatch = function() {
    var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (_this.watchList.length) {
      var values = _this.getFieldsValue();
      var allValues = _this.getFieldsValue(true);
      _this.watchList.forEach(function(callback) {
        callback(values, allValues, namePath);
      });
    }
  };
  this.timeoutId = null;
  this.warningUnhooked = function() {
  };
  this.updateStore = function(nextStore) {
    _this.store = nextStore;
  };
  this.getFieldEntities = function() {
    var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (!pure) {
      return _this.fieldEntities;
    }
    return _this.fieldEntities.filter(function(field) {
      return field.getNamePath().length;
    });
  };
  this.getFieldsMap = function() {
    var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var cache2 = new NameMap();
    _this.getFieldEntities(pure).forEach(function(field) {
      var namePath = field.getNamePath();
      cache2.set(namePath, field);
    });
    return cache2;
  };
  this.getFieldEntitiesForNamePathList = function(nameList) {
    if (!nameList) {
      return _this.getFieldEntities(true);
    }
    var cache2 = _this.getFieldsMap(true);
    return nameList.map(function(name) {
      var namePath = getNamePath$1(name);
      return cache2.get(namePath) || {
        INVALIDATE_NAME_PATH: getNamePath$1(name)
      };
    });
  };
  this.getFieldsValue = function(nameList, filterFunc) {
    _this.warningUnhooked();
    if (nameList === true && !filterFunc) {
      return _this.store;
    }
    var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(nameList) ? nameList : null);
    var filteredNameList = [];
    fieldEntities.forEach(function(entity) {
      var _entity$isListField;
      var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
      if (!nameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {
        return;
      }
      if (!filterFunc) {
        filteredNameList.push(namePath);
      } else {
        var meta = "getMeta" in entity ? entity.getMeta() : null;
        if (filterFunc(meta)) {
          filteredNameList.push(namePath);
        }
      }
    });
    return cloneByNamePathList$1(_this.store, filteredNameList.map(getNamePath$1));
  };
  this.getFieldValue = function(name) {
    _this.warningUnhooked();
    var namePath = getNamePath$1(name);
    return getValue$4(_this.store, namePath);
  };
  this.getFieldsError = function(nameList) {
    _this.warningUnhooked();
    var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
    return fieldEntities.map(function(entity, index2) {
      if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
        return {
          name: entity.getNamePath(),
          errors: entity.getErrors(),
          warnings: entity.getWarnings()
        };
      }
      return {
        name: getNamePath$1(nameList[index2]),
        errors: [],
        warnings: []
      };
    });
  };
  this.getFieldError = function(name) {
    _this.warningUnhooked();
    var namePath = getNamePath$1(name);
    var fieldError = _this.getFieldsError([namePath])[0];
    return fieldError.errors;
  };
  this.getFieldWarning = function(name) {
    _this.warningUnhooked();
    var namePath = getNamePath$1(name);
    var fieldError = _this.getFieldsError([namePath])[0];
    return fieldError.warnings;
  };
  this.isFieldsTouched = function() {
    _this.warningUnhooked();
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var arg0 = args[0], arg1 = args[1];
    var namePathList;
    var isAllFieldsTouched = false;
    if (args.length === 0) {
      namePathList = null;
    } else if (args.length === 1) {
      if (Array.isArray(arg0)) {
        namePathList = arg0.map(getNamePath$1);
        isAllFieldsTouched = false;
      } else {
        namePathList = null;
        isAllFieldsTouched = arg0;
      }
    } else {
      namePathList = arg0.map(getNamePath$1);
      isAllFieldsTouched = arg1;
    }
    var fieldEntities = _this.getFieldEntities(true);
    var isFieldTouched = function isFieldTouched2(field) {
      return field.isFieldTouched();
    };
    if (!namePathList) {
      return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);
    }
    var map = new NameMap();
    namePathList.forEach(function(shortNamePath) {
      map.set(shortNamePath, []);
    });
    fieldEntities.forEach(function(field) {
      var fieldNamePath = field.getNamePath();
      namePathList.forEach(function(shortNamePath) {
        if (shortNamePath.every(function(nameUnit, i) {
          return fieldNamePath[i] === nameUnit;
        })) {
          map.update(shortNamePath, function(list2) {
            return [].concat(_toConsumableArray(list2), [field]);
          });
        }
      });
    });
    var isNamePathListTouched = function isNamePathListTouched2(entities) {
      return entities.some(isFieldTouched);
    };
    var namePathListEntities = map.map(function(_ref2) {
      var value = _ref2.value;
      return value;
    });
    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
  };
  this.isFieldTouched = function(name) {
    _this.warningUnhooked();
    return _this.isFieldsTouched([name]);
  };
  this.isFieldsValidating = function(nameList) {
    _this.warningUnhooked();
    var fieldEntities = _this.getFieldEntities();
    if (!nameList) {
      return fieldEntities.some(function(testField) {
        return testField.isFieldValidating();
      });
    }
    var namePathList = nameList.map(getNamePath$1);
    return fieldEntities.some(function(testField) {
      var fieldNamePath = testField.getNamePath();
      return containsNamePath$1(namePathList, fieldNamePath) && testField.isFieldValidating();
    });
  };
  this.isFieldValidating = function(name) {
    _this.warningUnhooked();
    return _this.isFieldsValidating([name]);
  };
  this.resetWithFieldInitialValue = function() {
    var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var cache2 = new NameMap();
    var fieldEntities = _this.getFieldEntities(true);
    fieldEntities.forEach(function(field) {
      var initialValue = field.props.initialValue;
      var namePath = field.getNamePath();
      if (initialValue !== void 0) {
        var records = cache2.get(namePath) || /* @__PURE__ */ new Set();
        records.add({
          entity: field,
          value: initialValue
        });
        cache2.set(namePath, records);
      }
    });
    var resetWithFields = function resetWithFields2(entities) {
      entities.forEach(function(field) {
        var initialValue = field.props.initialValue;
        if (initialValue !== void 0) {
          var namePath = field.getNamePath();
          var formInitialValue = _this.getInitialValue(namePath);
          if (formInitialValue !== void 0) {
            warningOnce$7(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
          } else {
            var records = cache2.get(namePath);
            if (records && records.size > 1) {
              warningOnce$7(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
            } else if (records) {
              var originValue = _this.getFieldValue(namePath);
              if (!info.skipExist || originValue === void 0) {
                _this.updateStore(setValue$1(_this.store, namePath, _toConsumableArray(records)[0].value));
              }
            }
          }
        }
      });
    };
    var requiredFieldEntities;
    if (info.entities) {
      requiredFieldEntities = info.entities;
    } else if (info.namePathList) {
      requiredFieldEntities = [];
      info.namePathList.forEach(function(namePath) {
        var records = cache2.get(namePath);
        if (records) {
          var _requiredFieldEntitie;
          (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {
            return r2.entity;
          })));
        }
      });
    } else {
      requiredFieldEntities = fieldEntities;
    }
    resetWithFields(requiredFieldEntities);
  };
  this.resetFields = function(nameList) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    if (!nameList) {
      _this.updateStore(setValues$1({}, _this.initialValues));
      _this.resetWithFieldInitialValue();
      _this.notifyObservers(prevStore, null, {
        type: "reset"
      });
      _this.notifyWatch();
      return;
    }
    var namePathList = nameList.map(getNamePath$1);
    namePathList.forEach(function(namePath) {
      var initialValue = _this.getInitialValue(namePath);
      _this.updateStore(setValue$1(_this.store, namePath, initialValue));
    });
    _this.resetWithFieldInitialValue({
      namePathList
    });
    _this.notifyObservers(prevStore, namePathList, {
      type: "reset"
    });
    _this.notifyWatch(namePathList);
  };
  this.setFields = function(fields) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    var namePathList = [];
    fields.forEach(function(fieldData) {
      var name = fieldData.name, data2 = _objectWithoutProperties$1(fieldData, _excluded$O);
      var namePath = getNamePath$1(name);
      namePathList.push(namePath);
      if ("value" in data2) {
        _this.updateStore(setValue$1(_this.store, namePath, data2.value));
      }
      _this.notifyObservers(prevStore, [namePath], {
        type: "setField",
        data: fieldData
      });
    });
    _this.notifyWatch(namePathList);
  };
  this.getFields = function() {
    var entities = _this.getFieldEntities(true);
    var fields = entities.map(function(field) {
      var namePath = field.getNamePath();
      var meta = field.getMeta();
      var fieldData = _objectSpread2$d(_objectSpread2$d({}, meta), {}, {
        name: namePath,
        value: _this.getFieldValue(namePath)
      });
      Object.defineProperty(fieldData, "originRCField", {
        value: true
      });
      return fieldData;
    });
    return fields;
  };
  this.initEntityValue = function(entity) {
    var initialValue = entity.props.initialValue;
    if (initialValue !== void 0) {
      var namePath = entity.getNamePath();
      var prevValue = getValue$4(_this.store, namePath);
      if (prevValue === void 0) {
        _this.updateStore(setValue$1(_this.store, namePath, initialValue));
      }
    }
  };
  this.isMergedPreserve = function(fieldPreserve) {
    var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
    return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
  };
  this.registerField = function(entity) {
    _this.fieldEntities.push(entity);
    var namePath = entity.getNamePath();
    _this.notifyWatch([namePath]);
    if (entity.props.initialValue !== void 0) {
      var prevStore = _this.store;
      _this.resetWithFieldInitialValue({
        entities: [entity],
        skipExist: true
      });
      _this.notifyObservers(prevStore, [entity.getNamePath()], {
        type: "valueUpdate",
        source: "internal"
      });
    }
    return function(isListField, preserve) {
      var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      _this.fieldEntities = _this.fieldEntities.filter(function(item) {
        return item !== entity;
      });
      if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {
        var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
        if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
          return !matchNamePath$1(field.getNamePath(), namePath);
        })) {
          var _prevStore = _this.store;
          _this.updateStore(setValue$1(_prevStore, namePath, defaultValue, true));
          _this.notifyObservers(_prevStore, [namePath], {
            type: "remove"
          });
          _this.triggerDependenciesUpdate(_prevStore, namePath);
        }
      }
      _this.notifyWatch([namePath]);
    };
  };
  this.dispatch = function(action) {
    switch (action.type) {
      case "updateValue": {
        var namePath = action.namePath, value = action.value;
        _this.updateValue(namePath, value);
        break;
      }
      case "validateField": {
        var _namePath = action.namePath, triggerName = action.triggerName;
        _this.validateFields([_namePath], {
          triggerName
        });
        break;
      }
    }
  };
  this.notifyObservers = function(prevStore, namePathList, info) {
    if (_this.subscribable) {
      var mergedInfo = _objectSpread2$d(_objectSpread2$d({}, info), {}, {
        store: _this.getFieldsValue(true)
      });
      _this.getFieldEntities().forEach(function(_ref3) {
        var onStoreChange = _ref3.onStoreChange;
        onStoreChange(prevStore, namePathList, mergedInfo);
      });
    } else {
      _this.forceRootUpdate();
    }
  };
  this.triggerDependenciesUpdate = function(prevStore, namePath) {
    var childrenFields = _this.getDependencyChildrenFields(namePath);
    if (childrenFields.length) {
      _this.validateFields(childrenFields);
    }
    _this.notifyObservers(prevStore, childrenFields, {
      type: "dependenciesUpdate",
      relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
    });
    return childrenFields;
  };
  this.updateValue = function(name, value) {
    var namePath = getNamePath$1(name);
    var prevStore = _this.store;
    _this.updateStore(setValue$1(_this.store, namePath, value));
    _this.notifyObservers(prevStore, [namePath], {
      type: "valueUpdate",
      source: "internal"
    });
    _this.notifyWatch([namePath]);
    var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
    var onValuesChange = _this.callbacks.onValuesChange;
    if (onValuesChange) {
      var changedValues = cloneByNamePathList$1(_this.store, [namePath]);
      onValuesChange(changedValues, _this.getFieldsValue());
    }
    _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
  };
  this.setFieldsValue = function(store) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    if (store) {
      var nextStore = setValues$1(_this.store, store);
      _this.updateStore(nextStore);
    }
    _this.notifyObservers(prevStore, null, {
      type: "valueUpdate",
      source: "external"
    });
    _this.notifyWatch();
  };
  this.setFieldValue = function(name, value) {
    _this.setFields([{
      name,
      value
    }]);
  };
  this.getDependencyChildrenFields = function(rootNamePath) {
    var children = /* @__PURE__ */ new Set();
    var childrenFields = [];
    var dependencies2fields = new NameMap();
    _this.getFieldEntities().forEach(function(field) {
      var dependencies = field.props.dependencies;
      (dependencies || []).forEach(function(dependency) {
        var dependencyNamePath = getNamePath$1(dependency);
        dependencies2fields.update(dependencyNamePath, function() {
          var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
          fields.add(field);
          return fields;
        });
      });
    });
    var fillChildren = function fillChildren2(namePath) {
      var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
      fields.forEach(function(field) {
        if (!children.has(field)) {
          children.add(field);
          var fieldNamePath = field.getNamePath();
          if (field.isFieldDirty() && fieldNamePath.length) {
            childrenFields.push(fieldNamePath);
            fillChildren2(fieldNamePath);
          }
        }
      });
    };
    fillChildren(rootNamePath);
    return childrenFields;
  };
  this.triggerOnFieldsChange = function(namePathList, filedErrors) {
    var onFieldsChange = _this.callbacks.onFieldsChange;
    if (onFieldsChange) {
      var fields = _this.getFields();
      if (filedErrors) {
        var cache2 = new NameMap();
        filedErrors.forEach(function(_ref4) {
          var name = _ref4.name, errors = _ref4.errors;
          cache2.set(name, errors);
        });
        fields.forEach(function(field) {
          field.errors = cache2.get(field.name) || field.errors;
        });
      }
      var changedFields = fields.filter(function(_ref5) {
        var fieldName = _ref5.name;
        return containsNamePath$1(namePathList, fieldName);
      });
      onFieldsChange(changedFields, fields);
    }
  };
  this.validateFields = function(nameList, options) {
    _this.warningUnhooked();
    var provideNameList = !!nameList;
    var namePathList = provideNameList ? nameList.map(getNamePath$1) : [];
    var promiseList = [];
    _this.getFieldEntities(true).forEach(function(field) {
      if (!provideNameList) {
        namePathList.push(field.getNamePath());
      }
      if ((options === null || options === void 0 ? void 0 : options.recursive) && provideNameList) {
        var namePath = field.getNamePath();
        if (namePath.every(function(nameUnit, i) {
          return nameList[i] === nameUnit || nameList[i] === void 0;
        })) {
          namePathList.push(namePath);
        }
      }
      if (!field.props.rules || !field.props.rules.length) {
        return;
      }
      var fieldNamePath = field.getNamePath();
      if (!provideNameList || containsNamePath$1(namePathList, fieldNamePath)) {
        var promise = field.validateRules(_objectSpread2$d({
          validateMessages: _objectSpread2$d(_objectSpread2$d({}, defaultValidateMessages), _this.validateMessages)
        }, options));
        promiseList.push(promise.then(function() {
          return {
            name: fieldNamePath,
            errors: [],
            warnings: []
          };
        }).catch(function(ruleErrors) {
          var _ruleErrors$forEach;
          var mergedErrors = [];
          var mergedWarnings = [];
          (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref6) {
            var warningOnly = _ref6.rule.warningOnly, errors = _ref6.errors;
            if (warningOnly) {
              mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
            } else {
              mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
            }
          });
          if (mergedErrors.length) {
            return Promise.reject({
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            });
          }
          return {
            name: fieldNamePath,
            errors: mergedErrors,
            warnings: mergedWarnings
          };
        }));
      }
    });
    var summaryPromise = allPromiseFinish(promiseList);
    _this.lastValidatePromise = summaryPromise;
    summaryPromise.catch(function(results) {
      return results;
    }).then(function(results) {
      var resultNamePathList = results.map(function(_ref7) {
        var name = _ref7.name;
        return name;
      });
      _this.notifyObservers(_this.store, resultNamePathList, {
        type: "validateFinish"
      });
      _this.triggerOnFieldsChange(resultNamePathList, results);
    });
    var returnPromise = summaryPromise.then(function() {
      if (_this.lastValidatePromise === summaryPromise) {
        return Promise.resolve(_this.getFieldsValue(namePathList));
      }
      return Promise.reject([]);
    }).catch(function(results) {
      var errorList = results.filter(function(result) {
        return result && result.errors.length;
      });
      return Promise.reject({
        values: _this.getFieldsValue(namePathList),
        errorFields: errorList,
        outOfDate: _this.lastValidatePromise !== summaryPromise
      });
    });
    returnPromise.catch(function(e2) {
      return e2;
    });
    _this.triggerOnFieldsChange(namePathList);
    return returnPromise;
  };
  this.submit = function() {
    _this.warningUnhooked();
    _this.validateFields().then(function(values) {
      var onFinish = _this.callbacks.onFinish;
      if (onFinish) {
        try {
          onFinish(values);
        } catch (err) {
          console.error(err);
        }
      }
    }).catch(function(e2) {
      var onFinishFailed = _this.callbacks.onFinishFailed;
      if (onFinishFailed) {
        onFinishFailed(e2);
      }
    });
  };
  this.forceRootUpdate = forceRootUpdate;
});
function useForm(form) {
  var formRef = React.useRef();
  var _React$useState = React.useState({}), _React$useState2 = _slicedToArray$1(_React$useState, 2), forceUpdate = _React$useState2[1];
  if (!formRef.current) {
    if (form) {
      formRef.current = form;
    } else {
      var forceReRender = function forceReRender2() {
        forceUpdate({});
      };
      var formStore = new FormStore(forceReRender);
      formRef.current = formStore.getForm();
    }
  }
  return [formRef.current];
}
var FormContext$1 = /* @__PURE__ */ React.createContext({
  triggerFormChange: function triggerFormChange() {
  },
  triggerFormFinish: function triggerFormFinish() {
  },
  registerForm: function registerForm() {
  },
  unregisterForm: function unregisterForm() {
  }
});
var FormProvider$1 = function FormProvider(_ref2) {
  var validateMessages = _ref2.validateMessages, onFormChange = _ref2.onFormChange, onFormFinish = _ref2.onFormFinish, children = _ref2.children;
  var formContext = React.useContext(FormContext$1);
  var formsRef = React.useRef({});
  return /* @__PURE__ */ React.createElement(FormContext$1.Provider, {
    value: _objectSpread2$d(_objectSpread2$d({}, formContext), {}, {
      validateMessages: _objectSpread2$d(_objectSpread2$d({}, formContext.validateMessages), validateMessages),
      triggerFormChange: function triggerFormChange2(name, changedFields) {
        if (onFormChange) {
          onFormChange(name, {
            changedFields,
            forms: formsRef.current
          });
        }
        formContext.triggerFormChange(name, changedFields);
      },
      triggerFormFinish: function triggerFormFinish2(name, values) {
        if (onFormFinish) {
          onFormFinish(name, {
            values,
            forms: formsRef.current
          });
        }
        formContext.triggerFormFinish(name, values);
      },
      registerForm: function registerForm2(name, form) {
        if (name) {
          formsRef.current = _objectSpread2$d(_objectSpread2$d({}, formsRef.current), {}, _defineProperty$3({}, name, form));
        }
        formContext.registerForm(name, form);
      },
      unregisterForm: function unregisterForm2(name) {
        var newForms = _objectSpread2$d({}, formsRef.current);
        delete newForms[name];
        formsRef.current = newForms;
        formContext.unregisterForm(name);
      }
    })
  }, children);
};
var _excluded$N = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"];
var Form = function Form2(_ref2, ref2) {
  var name = _ref2.name, initialValues = _ref2.initialValues, fields = _ref2.fields, form = _ref2.form, preserve = _ref2.preserve, children = _ref2.children, _ref$component = _ref2.component, Component = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref2.validateMessages, _ref$validateTrigger = _ref2.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref2.onValuesChange, _onFieldsChange = _ref2.onFieldsChange, _onFinish = _ref2.onFinish, onFinishFailed = _ref2.onFinishFailed, restProps = _objectWithoutProperties$1(_ref2, _excluded$N);
  var formContext = React.useContext(FormContext$1);
  var _useForm = useForm(form), _useForm2 = _slicedToArray$1(_useForm, 1), formInstance = _useForm2[0];
  var _formInstance$getInte = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _formInstance$getInte.useSubscribe, setInitialValues = _formInstance$getInte.setInitialValues, setCallbacks = _formInstance$getInte.setCallbacks, setValidateMessages = _formInstance$getInte.setValidateMessages, setPreserve = _formInstance$getInte.setPreserve, destroyForm = _formInstance$getInte.destroyForm;
  React.useImperativeHandle(ref2, function() {
    return formInstance;
  });
  React.useEffect(function() {
    formContext.registerForm(name, formInstance);
    return function() {
      formContext.unregisterForm(name);
    };
  }, [formContext, formInstance, name]);
  setValidateMessages(_objectSpread2$d(_objectSpread2$d({}, formContext.validateMessages), validateMessages));
  setCallbacks({
    onValuesChange,
    onFieldsChange: function onFieldsChange(changedFields) {
      formContext.triggerFormChange(name, changedFields);
      if (_onFieldsChange) {
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        _onFieldsChange.apply(void 0, [changedFields].concat(rest));
      }
    },
    onFinish: function onFinish(values2) {
      formContext.triggerFormFinish(name, values2);
      if (_onFinish) {
        _onFinish(values2);
      }
    },
    onFinishFailed
  });
  setPreserve(preserve);
  var mountRef = React.useRef(null);
  setInitialValues(initialValues, !mountRef.current);
  if (!mountRef.current) {
    mountRef.current = true;
  }
  React.useEffect(
    function() {
      return destroyForm;
    },
    []
  );
  var childrenNode;
  var childrenRenderProps = typeof children === "function";
  if (childrenRenderProps) {
    var values = formInstance.getFieldsValue(true);
    childrenNode = children(values, formInstance);
  } else {
    childrenNode = children;
  }
  useSubscribe(!childrenRenderProps);
  var prevFieldsRef = React.useRef();
  React.useEffect(function() {
    if (!isSimilar$1(prevFieldsRef.current || [], fields || [])) {
      formInstance.setFields(fields || []);
    }
    prevFieldsRef.current = fields;
  }, [fields, formInstance]);
  var formContextValue = React.useMemo(function() {
    return _objectSpread2$d(_objectSpread2$d({}, formInstance), {}, {
      validateTrigger
    });
  }, [formInstance, validateTrigger]);
  var wrapperNode = /* @__PURE__ */ React.createElement(Context$1.Provider, {
    value: formContextValue
  }, childrenNode);
  if (Component === false) {
    return wrapperNode;
  }
  return /* @__PURE__ */ React.createElement(Component, _extends$3({}, restProps, {
    onSubmit: function onSubmit(event) {
      event.preventDefault();
      event.stopPropagation();
      formInstance.submit();
    },
    onReset: function onReset(event) {
      var _restProps$onReset;
      event.preventDefault();
      formInstance.resetFields();
      (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 ? void 0 : _restProps$onReset.call(restProps, event);
    }
  }), wrapperNode);
};
function stringify$1(value) {
  try {
    return JSON.stringify(value);
  } catch (err) {
    return Math.random();
  }
}
function useWatch$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var _args$ = args[0], dependencies = _args$ === void 0 ? [] : _args$, _args$2 = args[1], _form = _args$2 === void 0 ? {} : _args$2;
  var options = isFormInstance$1(_form) ? {
    form: _form
  } : _form;
  var form = options.form;
  var _useState = React.useState(), _useState2 = _slicedToArray$1(_useState, 2), value = _useState2[0], setValue2 = _useState2[1];
  var valueStr = React.useMemo(function() {
    return stringify$1(value);
  }, [value]);
  var valueStrRef = React.useRef(valueStr);
  valueStrRef.current = valueStr;
  var fieldContext = React.useContext(Context$1);
  var formInstance = form || fieldContext;
  var isValidForm = formInstance && formInstance._init;
  var namePath = getNamePath$1(dependencies);
  var namePathRef = React.useRef(namePath);
  namePathRef.current = namePath;
  React.useEffect(
    function() {
      if (!isValidForm) {
        return;
      }
      var getFieldsValue = formInstance.getFieldsValue, getInternalHooks2 = formInstance.getInternalHooks;
      var _getInternalHooks = getInternalHooks2(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
      var cancelRegister = registerWatch(function(values, allValues) {
        var newValue = getValue$4(options.preserve ? allValues : values, namePathRef.current);
        var nextValueStr = stringify$1(newValue);
        if (valueStrRef.current !== nextValueStr) {
          valueStrRef.current = nextValueStr;
          setValue2(newValue);
        }
      });
      var initialValue = getValue$4(options.preserve ? getFieldsValue(true) : getFieldsValue(), namePathRef.current);
      setValue2(initialValue);
      return cancelRegister;
    },
    [isValidForm]
  );
  return value;
}
var InternalForm = /* @__PURE__ */ React.forwardRef(Form);
var RefForm = InternalForm;
RefForm.FormProvider = FormProvider$1;
RefForm.Field = WrapperField;
RefForm.List = List$2;
RefForm.useForm = useForm;
RefForm.useWatch = useWatch$1;
var es$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Field: WrapperField,
  List: List$2,
  useForm,
  FormProvider: FormProvider$1,
  FieldContext: Context$1,
  ListContext: ListContext$1,
  useWatch: useWatch$1,
  "default": RefForm
}, Symbol.toStringTag, { value: "Module" }));
function useMemo$6(getValue2, condition, shouldUpdate) {
  var cacheRef = React.useRef({});
  if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue2();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
var warned$5 = {};
function warning$a(valid2, message) {
}
function call$5(method4, valid2, message) {
  if (!valid2 && !warned$5[message]) {
    method4(false, message);
    warned$5[message] = true;
  }
}
function warningOnce$5(valid2, message) {
  call$5(warning$a, valid2, message);
}
var enUS$1 = {
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
};
var locale$7 = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: true,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
};
const locale$6 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
var TimePicker = locale$6;
const locale$5 = {
  lang: Object.assign({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, locale$7),
  timePickerLocale: Object.assign({}, TimePicker)
};
var enUS = locale$5;
const typeTemplate$1 = "${label} is not a valid ${type}";
const localeValues$1 = {
  locale: "en",
  Pagination: enUS$1,
  DatePicker: enUS,
  TimePicker,
  Calendar: enUS,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand"
  },
  PageHeader: {
    back: "Back"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate$1,
        method: typeTemplate$1,
        array: typeTemplate$1,
        object: typeTemplate$1,
        number: typeTemplate$1,
        date: typeTemplate$1,
        boolean: typeTemplate$1,
        integer: typeTemplate$1,
        float: typeTemplate$1,
        regexp: typeTemplate$1,
        email: typeTemplate$1,
        url: typeTemplate$1,
        hex: typeTemplate$1
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh"
  }
};
var defaultLocale = localeValues$1;
let runtimeLocale$1 = Object.assign({}, defaultLocale.Modal);
function changeConfirmLocale$1(newLocale) {
  if (newLocale) {
    runtimeLocale$1 = Object.assign(Object.assign({}, runtimeLocale$1), newLocale);
  } else {
    runtimeLocale$1 = Object.assign({}, defaultLocale.Modal);
  }
}
function getConfirmLocale$1() {
  return runtimeLocale$1;
}
const LocaleContext$1 = /* @__PURE__ */ React.createContext(void 0);
var LocaleContext$2 = LocaleContext$1;
const useLocale$2 = (componentName, defaultLocale$1) => {
  const fullLocale = React.useContext(LocaleContext$2);
  const getLocale = React.useMemo(() => {
    var _a2;
    const locale2 = defaultLocale$1 || defaultLocale[componentName];
    const localeFromContext = (_a2 = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale[componentName]) !== null && _a2 !== void 0 ? _a2 : {};
    return Object.assign(Object.assign({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {});
  }, [componentName, defaultLocale$1, fullLocale]);
  const getLocaleCode = React.useMemo(() => {
    const localeCode = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.locale;
    if ((fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.exist) && !localeCode) {
      return defaultLocale.locale;
    }
    return localeCode;
  }, [fullLocale]);
  return [getLocale, getLocaleCode];
};
var useLocale$3 = useLocale$2;
const ANT_MARK = "internalMark";
const LocaleProvider = (props) => {
  const {
    locale: locale2 = {},
    children,
    _ANT_MARK__
  } = props;
  React.useEffect(() => {
    changeConfirmLocale$1(locale2 && locale2.Modal);
    return () => {
      changeConfirmLocale$1();
    };
  }, [locale2]);
  const getMemoizedContextValue = React.useMemo(() => Object.assign(Object.assign({}, locale2), {
    exist: true
  }), [locale2]);
  return /* @__PURE__ */ React.createElement(LocaleContext$2.Provider, {
    value: getMemoizedContextValue
  }, children);
};
var LocaleProvider$1 = LocaleProvider;
var version$4 = "5.4.0";
const PresetColors$1 = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
function bound01$1(n2, max) {
  if (isOnePointZero$1(n2)) {
    n2 = "100%";
  }
  var isPercent = isPercentage$1(n2);
  n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
  if (isPercent) {
    n2 = parseInt(String(n2 * max), 10) / 100;
  }
  if (Math.abs(n2 - max) < 1e-6) {
    return 1;
  }
  if (max === 360) {
    n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
  } else {
    n2 = n2 % max / parseFloat(String(max));
  }
  return n2;
}
function isOnePointZero$1(n2) {
  return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
}
function isPercentage$1(n2) {
  return typeof n2 === "string" && n2.indexOf("%") !== -1;
}
function boundAlpha$1(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function convertToPercentage$1(n2) {
  if (n2 <= 1) {
    return "".concat(Number(n2) * 100, "%");
  }
  return n2;
}
function pad2$1(c2) {
  return c2.length === 1 ? "0" + c2 : String(c2);
}
function rgbToRgb$1(r2, g2, b2) {
  return {
    r: bound01$1(r2, 255) * 255,
    g: bound01$1(g2, 255) * 255,
    b: bound01$1(b2, 255) * 255
  };
}
function hue2rgb$1(p2, q2, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p2 + (q2 - p2) * (6 * t2);
  }
  if (t2 < 1 / 2) {
    return q2;
  }
  if (t2 < 2 / 3) {
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  }
  return p2;
}
function hslToRgb$1(h2, s2, l2) {
  var r2;
  var g2;
  var b2;
  h2 = bound01$1(h2, 360);
  s2 = bound01$1(s2, 100);
  l2 = bound01$1(l2, 100);
  if (s2 === 0) {
    g2 = l2;
    b2 = l2;
    r2 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q2;
    r2 = hue2rgb$1(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb$1(p2, q2, h2);
    b2 = hue2rgb$1(p2, q2, h2 - 1 / 3);
  }
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHsv$1(r2, g2, b2) {
  r2 = bound01$1(r2, 255);
  g2 = bound01$1(g2, 255);
  b2 = bound01$1(b2, 255);
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2 = 0;
  var v2 = max;
  var d2 = max - min;
  var s2 = max === 0 ? 0 : d2 / max;
  if (max === min) {
    h2 = 0;
  } else {
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, v: v2 };
}
function hsvToRgb$1(h2, s2, v2) {
  h2 = bound01$1(h2, 360) * 6;
  s2 = bound01$1(s2, 100);
  v2 = bound01$1(v2, 100);
  var i = Math.floor(h2);
  var f2 = h2 - i;
  var p2 = v2 * (1 - s2);
  var q2 = v2 * (1 - f2 * s2);
  var t2 = v2 * (1 - (1 - f2) * s2);
  var mod = i % 6;
  var r2 = [v2, q2, p2, p2, t2, v2][mod];
  var g2 = [t2, v2, v2, q2, p2, p2][mod];
  var b2 = [p2, p2, t2, v2, v2, q2][mod];
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHex$1(r2, g2, b2, allow3Char) {
  var hex2 = [
    pad2$1(Math.round(r2).toString(16)),
    pad2$1(Math.round(g2).toString(16)),
    pad2$1(Math.round(b2).toString(16))
  ];
  if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function convertHexToDecimal$1(h2) {
  return parseIntFromHex$1(h2) / 255;
}
function parseIntFromHex$1(val) {
  return parseInt(val, 16);
}
var names$1 = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB$1(color2) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok2 = false;
  var format2 = false;
  if (typeof color2 === "string") {
    color2 = stringInputToObject$1(color2);
  }
  if (typeof color2 === "object") {
    if (isValidCSSUnit$1(color2.r) && isValidCSSUnit$1(color2.g) && isValidCSSUnit$1(color2.b)) {
      rgb = rgbToRgb$1(color2.r, color2.g, color2.b);
      ok2 = true;
      format2 = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit$1(color2.h) && isValidCSSUnit$1(color2.s) && isValidCSSUnit$1(color2.v)) {
      s2 = convertToPercentage$1(color2.s);
      v2 = convertToPercentage$1(color2.v);
      rgb = hsvToRgb$1(color2.h, s2, v2);
      ok2 = true;
      format2 = "hsv";
    } else if (isValidCSSUnit$1(color2.h) && isValidCSSUnit$1(color2.s) && isValidCSSUnit$1(color2.l)) {
      s2 = convertToPercentage$1(color2.s);
      l2 = convertToPercentage$1(color2.l);
      rgb = hslToRgb$1(color2.h, s2, l2);
      ok2 = true;
      format2 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color2, "a")) {
      a = color2.a;
    }
  }
  a = boundAlpha$1(a);
  return {
    ok: ok2,
    format: color2.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
var CSS_INTEGER$1 = "[-\\+]?\\d+%?";
var CSS_NUMBER$1 = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT$1 = "(?:".concat(CSS_NUMBER$1, ")|(?:").concat(CSS_INTEGER$1, ")");
var PERMISSIVE_MATCH3$1 = "[\\s|\\(]+(".concat(CSS_UNIT$1, ")[,|\\s]+(").concat(CSS_UNIT$1, ")[,|\\s]+(").concat(CSS_UNIT$1, ")\\s*\\)?");
var PERMISSIVE_MATCH4$1 = "[\\s|\\(]+(".concat(CSS_UNIT$1, ")[,|\\s]+(").concat(CSS_UNIT$1, ")[,|\\s]+(").concat(CSS_UNIT$1, ")[,|\\s]+(").concat(CSS_UNIT$1, ")\\s*\\)?");
var matchers$1 = {
  CSS_UNIT: new RegExp(CSS_UNIT$1),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3$1),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4$1),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3$1),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4$1),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3$1),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4$1),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject$1(color2) {
  color2 = color2.trim().toLowerCase();
  if (color2.length === 0) {
    return false;
  }
  var named = false;
  if (names$1[color2]) {
    color2 = names$1[color2];
    named = true;
  } else if (color2 === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match2 = matchers$1.rgb.exec(color2);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3] };
  }
  match2 = matchers$1.rgba.exec(color2);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
  }
  match2 = matchers$1.hsl.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3] };
  }
  match2 = matchers$1.hsla.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
  }
  match2 = matchers$1.hsv.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3] };
  }
  match2 = matchers$1.hsva.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
  }
  match2 = matchers$1.hex8.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex$1(match2[1]),
      g: parseIntFromHex$1(match2[2]),
      b: parseIntFromHex$1(match2[3]),
      a: convertHexToDecimal$1(match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers$1.hex6.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex$1(match2[1]),
      g: parseIntFromHex$1(match2[2]),
      b: parseIntFromHex$1(match2[3]),
      format: named ? "name" : "hex"
    };
  }
  match2 = matchers$1.hex4.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex$1(match2[1] + match2[1]),
      g: parseIntFromHex$1(match2[2] + match2[2]),
      b: parseIntFromHex$1(match2[3] + match2[3]),
      a: convertHexToDecimal$1(match2[4] + match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers$1.hex3.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex$1(match2[1] + match2[1]),
      g: parseIntFromHex$1(match2[2] + match2[2]),
      b: parseIntFromHex$1(match2[3] + match2[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit$1(color2) {
  return Boolean(matchers$1.CSS_UNIT.exec(String(color2)));
}
var hueStep = 2;
var saturationStep = 0.16;
var saturationStep2 = 0.05;
var brightnessStep1 = 0.05;
var brightnessStep2 = 0.15;
var lightColorCount = 5;
var darkColorCount = 4;
var darkColorMap = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function toHsv(_ref2) {
  var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
  var hsv = rgbToHsv$1(r2, g2, b2);
  return {
    h: hsv.h * 360,
    s: hsv.s,
    v: hsv.v
  };
}
function toHex(_ref2) {
  var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
  return "#".concat(rgbToHex$1(r2, g2, b2, false));
}
function mix$1(rgb1, rgb2, amount) {
  var p2 = amount / 100;
  var rgb = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b
  };
  return rgb;
}
function getHue(hsv, i, light) {
  var hue;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}
function getSaturation(hsv, i, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep * i;
  } else if (i === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue$3(hsv, i, light) {
  var value;
  if (light) {
    value = hsv.v + brightnessStep1 * i;
  } else {
    value = hsv.v - brightnessStep2 * i;
  }
  if (value > 1) {
    value = 1;
  }
  return Number(value.toFixed(2));
}
function generate$2(color2) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = inputToRGB$1(color2);
  for (var i = lightColorCount; i > 0; i -= 1) {
    var hsv = toHsv(pColor);
    var colorString = toHex(inputToRGB$1({
      h: getHue(hsv, i, true),
      s: getSaturation(hsv, i, true),
      v: getValue$3(hsv, i, true)
    }));
    patterns.push(colorString);
  }
  patterns.push(toHex(pColor));
  for (var _i2 = 1; _i2 <= darkColorCount; _i2 += 1) {
    var _hsv = toHsv(pColor);
    var _colorString = toHex(inputToRGB$1({
      h: getHue(_hsv, _i2),
      s: getSaturation(_hsv, _i2),
      v: getValue$3(_hsv, _i2)
    }));
    patterns.push(_colorString);
  }
  if (opts.theme === "dark") {
    return darkColorMap.map(function(_ref3) {
      var index2 = _ref3.index, opacity = _ref3.opacity;
      var darkColorString = toHex(mix$1(inputToRGB$1(opts.backgroundColor || "#141414"), inputToRGB$1(patterns[index2]), opacity * 100));
      return darkColorString;
    });
  }
  return patterns;
}
var presetPrimaryColors = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1677FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
};
var presetPalettes = {};
var presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(key) {
  presetPalettes[key] = generate$2(presetPrimaryColors[key]);
  presetPalettes[key].primary = presetPalettes[key][5];
  presetDarkPalettes[key] = generate$2(presetPrimaryColors[key], {
    theme: "dark",
    backgroundColor: "#141414"
  });
  presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
});
var red = presetPalettes.red;
var volcano = presetPalettes.volcano;
var gold = presetPalettes.gold;
var orange = presetPalettes.orange;
var yellow = presetPalettes.yellow;
var lime = presetPalettes.lime;
var green = presetPalettes.green;
var cyan = presetPalettes.cyan;
var blue = presetPalettes.blue;
var geekblue = presetPalettes.geekblue;
var purple = presetPalettes.purple;
var magenta = presetPalettes.magenta;
var grey = presetPalettes.grey;
var gray = presetPalettes.grey;
var es$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$2,
  presetPalettes,
  presetDarkPalettes,
  presetPrimaryColors,
  red,
  volcano,
  orange,
  gold,
  yellow,
  lime,
  green,
  cyan,
  blue,
  geekblue,
  purple,
  magenta,
  grey,
  gray
}, Symbol.toStringTag, { value: "Module" }));
const genControlHeight$2 = (token2) => {
  const {
    controlHeight
  } = token2;
  return {
    controlHeightSM: controlHeight * 0.75,
    controlHeightXS: controlHeight * 0.5,
    controlHeightLG: controlHeight * 1.25
  };
};
var genControlHeight$3 = genControlHeight$2;
function genSizeMapToken$3(token2) {
  const {
    sizeUnit,
    sizeStep
  } = token2;
  return {
    sizeXXL: sizeUnit * (sizeStep + 8),
    sizeXL: sizeUnit * (sizeStep + 4),
    sizeLG: sizeUnit * (sizeStep + 2),
    sizeMD: sizeUnit * (sizeStep + 1),
    sizeMS: sizeUnit * sizeStep,
    size: sizeUnit * sizeStep,
    sizeSM: sizeUnit * (sizeStep - 1),
    sizeXS: sizeUnit * (sizeStep - 2),
    sizeXXS: sizeUnit * (sizeStep - 3)
  };
}
const defaultPresetColors$1 = {
  blue: "#1677ff",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  pink: "#eb2f96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
};
const seedToken$1 = Object.assign(Object.assign({}, defaultPresetColors$1), {
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorTextBase: "",
  colorBgBase: "",
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
  fontSize: 14,
  lineWidth: 1,
  lineType: "solid",
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  borderRadius: 6,
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  controlHeight: 32,
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  opacityImage: 1,
  wireframe: false
});
var defaultSeedToken = seedToken$1;
function bound01(n2, max) {
  if (isOnePointZero(n2)) {
    n2 = "100%";
  }
  var isPercent = isPercentage(n2);
  n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
  if (isPercent) {
    n2 = parseInt(String(n2 * max), 10) / 100;
  }
  if (Math.abs(n2 - max) < 1e-6) {
    return 1;
  }
  if (max === 360) {
    n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
  } else {
    n2 = n2 % max / parseFloat(String(max));
  }
  return n2;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n2) {
  return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") !== -1;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    return "".concat(Number(n2) * 100, "%");
  }
  return n2;
}
function pad2(c2) {
  return c2.length === 1 ? "0" + c2 : String(c2);
}
function rgbToRgb(r2, g2, b2) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g2, 255) * 255,
    b: bound01(b2, 255) * 255
  };
}
function rgbToHsl(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2 = 0;
  var s2 = 0;
  var l2 = (max + min) / 2;
  if (max === min) {
    s2 = 0;
    h2 = 0;
  } else {
    var d2 = max - min;
    s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, l: l2 };
}
function hue2rgb(p2, q2, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p2 + (q2 - p2) * (6 * t2);
  }
  if (t2 < 1 / 2) {
    return q2;
  }
  if (t2 < 2 / 3) {
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  }
  return p2;
}
function hslToRgb(h2, s2, l2) {
  var r2;
  var g2;
  var b2;
  h2 = bound01(h2, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  if (s2 === 0) {
    g2 = l2;
    b2 = l2;
    r2 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q2;
    r2 = hue2rgb(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb(p2, q2, h2);
    b2 = hue2rgb(p2, q2, h2 - 1 / 3);
  }
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHsv(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2 = 0;
  var v2 = max;
  var d2 = max - min;
  var s2 = max === 0 ? 0 : d2 / max;
  if (max === min) {
    h2 = 0;
  } else {
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, v: v2 };
}
function hsvToRgb(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  var i = Math.floor(h2);
  var f2 = h2 - i;
  var p2 = v2 * (1 - s2);
  var q2 = v2 * (1 - f2 * s2);
  var t2 = v2 * (1 - (1 - f2) * s2);
  var mod = i % 6;
  var r2 = [v2, q2, p2, p2, t2, v2][mod];
  var g2 = [t2, v2, v2, q2, p2, p2][mod];
  var b2 = [p2, p2, t2, v2, v2, q2][mod];
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHex(r2, g2, b2, allow3Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b2).toString(16))
  ];
  if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbaToHex(r2, g2, b2, a, allow4Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b2).toString(16)),
    pad2(convertDecimalToHex(a))
  ];
  if (allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
  }
  return hex2.join("");
}
function rgbaToArgbHex(r2, g2, b2, a) {
  var hex2 = [
    pad2(convertDecimalToHex(a)),
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b2).toString(16))
  ];
  return hex2.join("");
}
function convertDecimalToHex(d2) {
  return Math.round(parseFloat(d2) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color2) {
  return {
    r: color2 >> 16,
    g: (color2 & 65280) >> 8,
    b: color2 & 255
  };
}
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(color2) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok2 = false;
  var format2 = false;
  if (typeof color2 === "string") {
    color2 = stringInputToObject(color2);
  }
  if (typeof color2 === "object") {
    if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
      rgb = rgbToRgb(color2.r, color2.g, color2.b);
      ok2 = true;
      format2 = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
      s2 = convertToPercentage(color2.s);
      v2 = convertToPercentage(color2.v);
      rgb = hsvToRgb(color2.h, s2, v2);
      ok2 = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
      s2 = convertToPercentage(color2.s);
      l2 = convertToPercentage(color2.l);
      rgb = hslToRgb(color2.h, s2, l2);
      ok2 = true;
      format2 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color2, "a")) {
      a = color2.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok: ok2,
    format: color2.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color2) {
  color2 = color2.trim().toLowerCase();
  if (color2.length === 0) {
    return false;
  }
  var named = false;
  if (names[color2]) {
    color2 = names[color2];
    named = true;
  } else if (color2 === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match2 = matchers.rgb.exec(color2);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3] };
  }
  match2 = matchers.rgba.exec(color2);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
  }
  match2 = matchers.hsl.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3] };
  }
  match2 = matchers.hsla.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
  }
  match2 = matchers.hsv.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3] };
  }
  match2 = matchers.hsva.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
  }
  match2 = matchers.hex8.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      a: convertHexToDecimal(match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex6.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      format: named ? "name" : "hex"
    };
  }
  match2 = matchers.hex4.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      a: convertHexToDecimal(match2[4] + match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex3.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color2) {
  return Boolean(matchers.CSS_UNIT.exec(String(color2)));
}
var TinyColor = function() {
  function TinyColor2(color2, opts) {
    if (color2 === void 0) {
      color2 = "";
    }
    if (opts === void 0) {
      opts = {};
    }
    var _a2;
    if (color2 instanceof TinyColor2) {
      return color2;
    }
    if (typeof color2 === "number") {
      color2 = numberInputToObject(color2);
    }
    this.originalInput = color2;
    var rgb = inputToRGB(color2);
    this.originalInput = color2;
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = rgb.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
    this.gradientType = opts.gradientType;
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
    this.isValid = rgb.ok;
  }
  TinyColor2.prototype.isDark = function() {
    return this.getBrightness() < 128;
  };
  TinyColor2.prototype.isLight = function() {
    return !this.isDark();
  };
  TinyColor2.prototype.getBrightness = function() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  };
  TinyColor2.prototype.getLuminance = function() {
    var rgb = this.toRgb();
    var R2;
    var G2;
    var B2;
    var RsRGB = rgb.r / 255;
    var GsRGB = rgb.g / 255;
    var BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) {
      R2 = RsRGB / 12.92;
    } else {
      R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G2 = GsRGB / 12.92;
    } else {
      G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B2 = BsRGB / 12.92;
    } else {
      B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
  };
  TinyColor2.prototype.getAlpha = function() {
    return this.a;
  };
  TinyColor2.prototype.setAlpha = function(alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  };
  TinyColor2.prototype.isMonochrome = function() {
    var s2 = this.toHsl().s;
    return s2 === 0;
  };
  TinyColor2.prototype.toHsv = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
  };
  TinyColor2.prototype.toHsvString = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    var h2 = Math.round(hsv.h * 360);
    var s2 = Math.round(hsv.s * 100);
    var v2 = Math.round(hsv.v * 100);
    return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHsl = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
  };
  TinyColor2.prototype.toHslString = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    var h2 = Math.round(hsl.h * 360);
    var s2 = Math.round(hsl.s * 100);
    var l2 = Math.round(hsl.l * 100);
    return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHex = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return rgbToHex(this.r, this.g, this.b, allow3Char);
  };
  TinyColor2.prototype.toHexString = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return "#" + this.toHex(allow3Char);
  };
  TinyColor2.prototype.toHex8 = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  };
  TinyColor2.prototype.toHex8String = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return "#" + this.toHex8(allow4Char);
  };
  TinyColor2.prototype.toHexShortString = function(allowShortChar) {
    if (allowShortChar === void 0) {
      allowShortChar = false;
    }
    return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
  };
  TinyColor2.prototype.toRgb = function() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toRgbString = function() {
    var r2 = Math.round(this.r);
    var g2 = Math.round(this.g);
    var b2 = Math.round(this.b);
    return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toPercentageRgb = function() {
    var fmt = function(x2) {
      return "".concat(Math.round(bound01(x2, 255) * 100), "%");
    };
    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toPercentageRgbString = function() {
    var rnd = function(x2) {
      return Math.round(bound01(x2, 255) * 100);
    };
    return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toName = function() {
    if (this.a === 0) {
      return "transparent";
    }
    if (this.a < 1) {
      return false;
    }
    var hex2 = "#" + rgbToHex(this.r, this.g, this.b, false);
    for (var _i2 = 0, _a2 = Object.entries(names); _i2 < _a2.length; _i2++) {
      var _b = _a2[_i2], key = _b[0], value = _b[1];
      if (hex2 === value) {
        return key;
      }
    }
    return false;
  };
  TinyColor2.prototype.toString = function(format2) {
    var formatSet = Boolean(format2);
    format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
    var formattedString = false;
    var hasAlpha = this.a < 1 && this.a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this.a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  };
  TinyColor2.prototype.toNumber = function() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  };
  TinyColor2.prototype.clone = function() {
    return new TinyColor2(this.toString());
  };
  TinyColor2.prototype.lighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.brighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var rgb = this.toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return new TinyColor2(rgb);
  };
  TinyColor2.prototype.darken = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.tint = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("white", amount);
  };
  TinyColor2.prototype.shade = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("black", amount);
  };
  TinyColor2.prototype.desaturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.saturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.greyscale = function() {
    return this.desaturate(100);
  };
  TinyColor2.prototype.spin = function(amount) {
    var hsl = this.toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.mix = function(color2, amount) {
    if (amount === void 0) {
      amount = 50;
    }
    var rgb1 = this.toRgb();
    var rgb2 = new TinyColor2(color2).toRgb();
    var p2 = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
      a: (rgb2.a - rgb1.a) * p2 + rgb1.a
    };
    return new TinyColor2(rgba);
  };
  TinyColor2.prototype.analogous = function(results, slices) {
    if (results === void 0) {
      results = 6;
    }
    if (slices === void 0) {
      slices = 30;
    }
    var hsl = this.toHsl();
    var part = 360 / slices;
    var ret = [this];
    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(new TinyColor2(hsl));
    }
    return ret;
  };
  TinyColor2.prototype.complement = function() {
    var hsl = this.toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.monochromatic = function(results) {
    if (results === void 0) {
      results = 6;
    }
    var hsv = this.toHsv();
    var h2 = hsv.h;
    var s2 = hsv.s;
    var v2 = hsv.v;
    var res = [];
    var modification = 1 / results;
    while (results--) {
      res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
      v2 = (v2 + modification) % 1;
    }
    return res;
  };
  TinyColor2.prototype.splitcomplement = function() {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    return [
      this,
      new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
      new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
    ];
  };
  TinyColor2.prototype.onBackground = function(background) {
    var fg = this.toRgb();
    var bg = new TinyColor2(background).toRgb();
    var alpha = fg.a + bg.a * (1 - fg.a);
    return new TinyColor2({
      r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
      g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
      b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
      a: alpha
    });
  };
  TinyColor2.prototype.triad = function() {
    return this.polyad(3);
  };
  TinyColor2.prototype.tetrad = function() {
    return this.polyad(4);
  };
  TinyColor2.prototype.polyad = function(n2) {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    var result = [this];
    var increment2 = 360 / n2;
    for (var i = 1; i < n2; i++) {
      result.push(new TinyColor2({ h: (h2 + i * increment2) % 360, s: hsl.s, l: hsl.l }));
    }
    return result;
  };
  TinyColor2.prototype.equals = function(color2) {
    return this.toRgbString() === new TinyColor2(color2).toRgbString();
  };
  return TinyColor2;
}();
function tinycolor(color2, opts) {
  if (color2 === void 0) {
    color2 = "";
  }
  if (opts === void 0) {
    opts = {};
  }
  return new TinyColor(color2, opts);
}
function readability(color1, color2) {
  var c1 = new TinyColor(color1);
  var c2 = new TinyColor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
}
function isReadable(color1, color2, wcag2) {
  var _a2, _b;
  if (wcag2 === void 0) {
    wcag2 = { level: "AA", size: "small" };
  }
  var readabilityLevel = readability(color1, color2);
  switch (((_a2 = wcag2.level) !== null && _a2 !== void 0 ? _a2 : "AA") + ((_b = wcag2.size) !== null && _b !== void 0 ? _b : "small")) {
    case "AAsmall":
    case "AAAlarge":
      return readabilityLevel >= 4.5;
    case "AAlarge":
      return readabilityLevel >= 3;
    case "AAAsmall":
      return readabilityLevel >= 7;
    default:
      return false;
  }
}
function mostReadable(baseColor, colorList, args) {
  if (args === void 0) {
    args = { includeFallbackColors: false, level: "AA", size: "small" };
  }
  var bestColor = null;
  var bestScore = 0;
  var includeFallbackColors = args.includeFallbackColors, level = args.level, size = args.size;
  for (var _i2 = 0, colorList_1 = colorList; _i2 < colorList_1.length; _i2++) {
    var color2 = colorList_1[_i2];
    var score = readability(baseColor, color2);
    if (score > bestScore) {
      bestScore = score;
      bestColor = new TinyColor(color2);
    }
  }
  if (isReadable(baseColor, bestColor, { level, size }) || !includeFallbackColors) {
    return bestColor;
  }
  args.includeFallbackColors = false;
  return mostReadable(baseColor, ["#fff", "#000"], args);
}
function toMsFilter(firstColor, secondColor) {
  var color2 = new TinyColor(firstColor);
  var hex8String = "#" + rgbaToArgbHex(color2.r, color2.g, color2.b, color2.a);
  var secondHex8String = hex8String;
  var gradientType = color2.gradientType ? "GradientType = 1, " : "";
  if (secondColor) {
    var s2 = new TinyColor(secondColor);
    secondHex8String = "#" + rgbaToArgbHex(s2.r, s2.g, s2.b, s2.a);
  }
  return "progid:DXImageTransform.Microsoft.gradient(".concat(gradientType, "startColorstr=").concat(hex8String, ",endColorstr=").concat(secondHex8String, ")");
}
function fromRatio(ratio, opts) {
  var newColor = {
    r: convertToPercentage(ratio.r),
    g: convertToPercentage(ratio.g),
    b: convertToPercentage(ratio.b)
  };
  if (ratio.a !== void 0) {
    newColor.a = Number(ratio.a);
  }
  return new TinyColor(newColor, opts);
}
function legacyRandom() {
  return new TinyColor({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
}
function random(options) {
  if (options === void 0) {
    options = {};
  }
  if (options.count !== void 0 && options.count !== null) {
    var totalColors = options.count;
    var colors2 = [];
    options.count = void 0;
    while (totalColors > colors2.length) {
      options.count = null;
      if (options.seed) {
        options.seed += 1;
      }
      colors2.push(random(options));
    }
    options.count = totalColors;
    return colors2;
  }
  var h2 = pickHue(options.hue, options.seed);
  var s2 = pickSaturation(h2, options);
  var v2 = pickBrightness(h2, s2, options);
  var res = { h: h2, s: s2, v: v2 };
  if (options.alpha !== void 0) {
    res.a = options.alpha;
  }
  return new TinyColor(res);
}
function pickHue(hue, seed2) {
  var hueRange = getHueRange(hue);
  var res = randomWithin(hueRange, seed2);
  if (res < 0) {
    res = 360 + res;
  }
  return res;
}
function pickSaturation(hue, options) {
  if (options.hue === "monochrome") {
    return 0;
  }
  if (options.luminosity === "random") {
    return randomWithin([0, 100], options.seed);
  }
  var saturationRange = getColorInfo(hue).saturationRange;
  var sMin = saturationRange[0];
  var sMax = saturationRange[1];
  switch (options.luminosity) {
    case "bright":
      sMin = 55;
      break;
    case "dark":
      sMin = sMax - 10;
      break;
    case "light":
      sMax = 55;
      break;
  }
  return randomWithin([sMin, sMax], options.seed);
}
function pickBrightness(H2, S2, options) {
  var bMin = getMinimumBrightness(H2, S2);
  var bMax = 100;
  switch (options.luminosity) {
    case "dark":
      bMax = bMin + 20;
      break;
    case "light":
      bMin = (bMax + bMin) / 2;
      break;
    case "random":
      bMin = 0;
      bMax = 100;
      break;
  }
  return randomWithin([bMin, bMax], options.seed);
}
function getMinimumBrightness(H2, S2) {
  var lowerBounds = getColorInfo(H2).lowerBounds;
  for (var i = 0; i < lowerBounds.length - 1; i++) {
    var s1 = lowerBounds[i][0];
    var v1 = lowerBounds[i][1];
    var s2 = lowerBounds[i + 1][0];
    var v2 = lowerBounds[i + 1][1];
    if (S2 >= s1 && S2 <= s2) {
      var m2 = (v2 - v1) / (s2 - s1);
      var b2 = v1 - m2 * s1;
      return m2 * S2 + b2;
    }
  }
  return 0;
}
function getHueRange(colorInput) {
  var num = parseInt(colorInput, 10);
  if (!Number.isNaN(num) && num < 360 && num > 0) {
    return [num, num];
  }
  if (typeof colorInput === "string") {
    var namedColor = bounds.find(function(n2) {
      return n2.name === colorInput;
    });
    if (namedColor) {
      var color2 = defineColor(namedColor);
      if (color2.hueRange) {
        return color2.hueRange;
      }
    }
    var parsed = new TinyColor(colorInput);
    if (parsed.isValid) {
      var hue = parsed.toHsv().h;
      return [hue, hue];
    }
  }
  return [0, 360];
}
function getColorInfo(hue) {
  if (hue >= 334 && hue <= 360) {
    hue -= 360;
  }
  for (var _i2 = 0, bounds_1 = bounds; _i2 < bounds_1.length; _i2++) {
    var bound = bounds_1[_i2];
    var color2 = defineColor(bound);
    if (color2.hueRange && hue >= color2.hueRange[0] && hue <= color2.hueRange[1]) {
      return color2;
    }
  }
  throw Error("Color not found");
}
function randomWithin(range3, seed2) {
  if (seed2 === void 0) {
    return Math.floor(range3[0] + Math.random() * (range3[1] + 1 - range3[0]));
  }
  var max = range3[1] || 1;
  var min = range3[0] || 0;
  seed2 = (seed2 * 9301 + 49297) % 233280;
  var rnd = seed2 / 233280;
  return Math.floor(min + rnd * (max - min));
}
function defineColor(bound) {
  var sMin = bound.lowerBounds[0][0];
  var sMax = bound.lowerBounds[bound.lowerBounds.length - 1][0];
  var bMin = bound.lowerBounds[bound.lowerBounds.length - 1][1];
  var bMax = bound.lowerBounds[0][1];
  return {
    name: bound.name,
    hueRange: bound.hueRange,
    lowerBounds: bound.lowerBounds,
    saturationRange: [sMin, sMax],
    brightnessRange: [bMin, bMax]
  };
}
var bounds = [
  {
    name: "monochrome",
    hueRange: null,
    lowerBounds: [
      [0, 0],
      [100, 0]
    ]
  },
  {
    name: "red",
    hueRange: [-26, 18],
    lowerBounds: [
      [20, 100],
      [30, 92],
      [40, 89],
      [50, 85],
      [60, 78],
      [70, 70],
      [80, 60],
      [90, 55],
      [100, 50]
    ]
  },
  {
    name: "orange",
    hueRange: [19, 46],
    lowerBounds: [
      [20, 100],
      [30, 93],
      [40, 88],
      [50, 86],
      [60, 85],
      [70, 70],
      [100, 70]
    ]
  },
  {
    name: "yellow",
    hueRange: [47, 62],
    lowerBounds: [
      [25, 100],
      [40, 94],
      [50, 89],
      [60, 86],
      [70, 84],
      [80, 82],
      [90, 80],
      [100, 75]
    ]
  },
  {
    name: "green",
    hueRange: [63, 178],
    lowerBounds: [
      [30, 100],
      [40, 90],
      [50, 85],
      [60, 81],
      [70, 74],
      [80, 64],
      [90, 50],
      [100, 40]
    ]
  },
  {
    name: "blue",
    hueRange: [179, 257],
    lowerBounds: [
      [20, 100],
      [30, 86],
      [40, 80],
      [50, 74],
      [60, 60],
      [70, 52],
      [80, 44],
      [90, 39],
      [100, 35]
    ]
  },
  {
    name: "purple",
    hueRange: [258, 282],
    lowerBounds: [
      [20, 100],
      [30, 87],
      [40, 79],
      [50, 70],
      [60, 65],
      [70, 59],
      [80, 52],
      [90, 45],
      [100, 42]
    ]
  },
  {
    name: "pink",
    hueRange: [283, 334],
    lowerBounds: [
      [20, 100],
      [30, 90],
      [40, 86],
      [60, 84],
      [80, 80],
      [90, 75],
      [100, 73]
    ]
  }
];
var public_api = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": tinycolor,
  TinyColor,
  tinycolor,
  names,
  readability,
  isReadable,
  mostReadable,
  toMsFilter,
  fromRatio,
  legacyRandom,
  inputToRGB,
  stringInputToObject,
  isValidCSSUnit,
  random,
  bounds,
  rgbToRgb,
  rgbToHsl,
  hslToRgb,
  rgbToHsv,
  hsvToRgb,
  rgbToHex,
  rgbaToHex,
  rgbaToArgbHex,
  convertDecimalToHex,
  convertHexToDecimal,
  parseIntFromHex,
  numberInputToObject
}, Symbol.toStringTag, { value: "Module" }));
function genColorMapToken$2(seed2, _ref2) {
  let {
    generateColorPalettes: generateColorPalettes2,
    generateNeutralColorPalettes: generateNeutralColorPalettes2
  } = _ref2;
  const {
    colorSuccess: colorSuccessBase,
    colorWarning: colorWarningBase,
    colorError: colorErrorBase,
    colorInfo: colorInfoBase,
    colorPrimary: colorPrimaryBase,
    colorBgBase,
    colorTextBase
  } = seed2;
  const primaryColors = generateColorPalettes2(colorPrimaryBase);
  const successColors = generateColorPalettes2(colorSuccessBase);
  const warningColors = generateColorPalettes2(colorWarningBase);
  const errorColors = generateColorPalettes2(colorErrorBase);
  const infoColors = generateColorPalettes2(colorInfoBase);
  const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
  return Object.assign(Object.assign({}, neutralColors), {
    colorPrimaryBg: primaryColors[1],
    colorPrimaryBgHover: primaryColors[2],
    colorPrimaryBorder: primaryColors[3],
    colorPrimaryBorderHover: primaryColors[4],
    colorPrimaryHover: primaryColors[5],
    colorPrimary: primaryColors[6],
    colorPrimaryActive: primaryColors[7],
    colorPrimaryTextHover: primaryColors[8],
    colorPrimaryText: primaryColors[9],
    colorPrimaryTextActive: primaryColors[10],
    colorSuccessBg: successColors[1],
    colorSuccessBgHover: successColors[2],
    colorSuccessBorder: successColors[3],
    colorSuccessBorderHover: successColors[4],
    colorSuccessHover: successColors[4],
    colorSuccess: successColors[6],
    colorSuccessActive: successColors[7],
    colorSuccessTextHover: successColors[8],
    colorSuccessText: successColors[9],
    colorSuccessTextActive: successColors[10],
    colorErrorBg: errorColors[1],
    colorErrorBgHover: errorColors[2],
    colorErrorBorder: errorColors[3],
    colorErrorBorderHover: errorColors[4],
    colorErrorHover: errorColors[5],
    colorError: errorColors[6],
    colorErrorActive: errorColors[7],
    colorErrorTextHover: errorColors[8],
    colorErrorText: errorColors[9],
    colorErrorTextActive: errorColors[10],
    colorWarningBg: warningColors[1],
    colorWarningBgHover: warningColors[2],
    colorWarningBorder: warningColors[3],
    colorWarningBorderHover: warningColors[4],
    colorWarningHover: warningColors[4],
    colorWarning: warningColors[6],
    colorWarningActive: warningColors[7],
    colorWarningTextHover: warningColors[8],
    colorWarningText: warningColors[9],
    colorWarningTextActive: warningColors[10],
    colorInfoBg: infoColors[1],
    colorInfoBgHover: infoColors[2],
    colorInfoBorder: infoColors[3],
    colorInfoBorderHover: infoColors[4],
    colorInfoHover: infoColors[4],
    colorInfo: infoColors[6],
    colorInfoActive: infoColors[7],
    colorInfoTextHover: infoColors[8],
    colorInfoText: infoColors[9],
    colorInfoTextActive: infoColors[10],
    colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
const genRadius$2 = (radiusBase) => {
  let radiusLG = radiusBase;
  let radiusSM = radiusBase;
  let radiusXS = radiusBase;
  let radiusOuter = radiusBase;
  if (radiusBase < 6 && radiusBase >= 5) {
    radiusLG = radiusBase + 1;
  } else if (radiusBase < 16 && radiusBase >= 6) {
    radiusLG = radiusBase + 2;
  } else if (radiusBase >= 16) {
    radiusLG = 16;
  }
  if (radiusBase < 7 && radiusBase >= 5) {
    radiusSM = 4;
  } else if (radiusBase < 8 && radiusBase >= 7) {
    radiusSM = 5;
  } else if (radiusBase < 14 && radiusBase >= 8) {
    radiusSM = 6;
  } else if (radiusBase < 16 && radiusBase >= 14) {
    radiusSM = 7;
  } else if (radiusBase >= 16) {
    radiusSM = 8;
  }
  if (radiusBase < 6 && radiusBase >= 2) {
    radiusXS = 1;
  } else if (radiusBase >= 6) {
    radiusXS = 2;
  }
  if (radiusBase > 4 && radiusBase < 8) {
    radiusOuter = 4;
  } else if (radiusBase >= 8) {
    radiusOuter = 6;
  }
  return {
    borderRadius: radiusBase > 16 ? 16 : radiusBase,
    borderRadiusXS: radiusXS,
    borderRadiusSM: radiusSM,
    borderRadiusLG: radiusLG,
    borderRadiusOuter: radiusOuter
  };
};
var genRadius$3 = genRadius$2;
function genCommonMapToken$2(token2) {
  const {
    motionUnit,
    motionBase,
    borderRadius,
    lineWidth
  } = token2;
  return Object.assign({
    motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
    motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
    motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
    lineWidthBold: lineWidth + 1
  }, genRadius$3(borderRadius));
}
const getAlphaColor$5 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
const getSolidColor$2 = (baseColor, brightness) => {
  const instance2 = new TinyColor(baseColor);
  return instance2.darken(brightness).toHexString();
};
const generateColorPalettes$2 = (baseColor) => {
  const colors2 = generate$2(baseColor);
  return {
    1: colors2[0],
    2: colors2[1],
    3: colors2[2],
    4: colors2[3],
    5: colors2[4],
    6: colors2[5],
    7: colors2[6],
    8: colors2[4],
    9: colors2[5],
    10: colors2[6]
  };
};
const generateNeutralColorPalettes$2 = (bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#fff";
  const colorTextBase = textBaseColor || "#000";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor$5(colorTextBase, 0.88),
    colorTextSecondary: getAlphaColor$5(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor$5(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor$5(colorTextBase, 0.25),
    colorFill: getAlphaColor$5(colorTextBase, 0.15),
    colorFillSecondary: getAlphaColor$5(colorTextBase, 0.06),
    colorFillTertiary: getAlphaColor$5(colorTextBase, 0.04),
    colorFillQuaternary: getAlphaColor$5(colorTextBase, 0.02),
    colorBgLayout: getSolidColor$2(colorBgBase, 4),
    colorBgContainer: getSolidColor$2(colorBgBase, 0),
    colorBgElevated: getSolidColor$2(colorBgBase, 0),
    colorBgSpotlight: getAlphaColor$5(colorTextBase, 0.85),
    colorBorder: getSolidColor$2(colorBgBase, 15),
    colorBorderSecondary: getSolidColor$2(colorBgBase, 6)
  };
};
function getFontSizes$1(base2) {
  const fontSizes = new Array(10).fill(null).map((_24, index2) => {
    const i = index2 - 1;
    const baseSize = base2 * Math.pow(2.71828, i / 5);
    const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
    return Math.floor(intSize / 2) * 2;
  });
  fontSizes[1] = base2;
  return fontSizes.map((size) => {
    const height = size + 8;
    return {
      size,
      lineHeight: height / size
    };
  });
}
const genFontMapToken$2 = (fontSize) => {
  const fontSizePairs = getFontSizes$1(fontSize);
  const fontSizes = fontSizePairs.map((pair) => pair.size);
  const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
  return {
    fontSizeSM: fontSizes[0],
    fontSize: fontSizes[1],
    fontSizeLG: fontSizes[2],
    fontSizeXL: fontSizes[3],
    fontSizeHeading1: fontSizes[6],
    fontSizeHeading2: fontSizes[5],
    fontSizeHeading3: fontSizes[4],
    fontSizeHeading4: fontSizes[3],
    fontSizeHeading5: fontSizes[2],
    lineHeight: lineHeights[1],
    lineHeightLG: lineHeights[2],
    lineHeightSM: lineHeights[0],
    lineHeightHeading1: lineHeights[6],
    lineHeightHeading2: lineHeights[5],
    lineHeightHeading3: lineHeights[4],
    lineHeightHeading4: lineHeights[3],
    lineHeightHeading5: lineHeights[2]
  };
};
var genFontMapToken$3 = genFontMapToken$2;
function derivative$3(token2) {
  const colorPalettes = Object.keys(defaultPresetColors$1).map((colorKey) => {
    const colors2 = generate$2(token2[colorKey]);
    return new Array(10).fill(1).reduce((prev2, _24, i) => {
      prev2[`${colorKey}-${i + 1}`] = colors2[i];
      prev2[`${colorKey}${i + 1}`] = colors2[i];
      return prev2;
    }, {});
  }).reduce((prev2, cur) => {
    prev2 = Object.assign(Object.assign({}, prev2), cur);
    return prev2;
  }, {});
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token2), colorPalettes), genColorMapToken$2(token2, {
    generateColorPalettes: generateColorPalettes$2,
    generateNeutralColorPalettes: generateNeutralColorPalettes$2
  })), genFontMapToken$3(token2.fontSize)), genSizeMapToken$3(token2)), genControlHeight$3(token2)), genCommonMapToken$2(token2));
}
function isStableColor$1(color2) {
  return color2 >= 0 && color2 <= 255;
}
function getAlphaColor$4(frontColor, backgroundColor) {
  const {
    r: fR,
    g: fG,
    b: fB,
    a: originAlpha
  } = new TinyColor(frontColor).toRgb();
  if (originAlpha < 1) {
    return frontColor;
  }
  const {
    r: bR,
    g: bG,
    b: bB
  } = new TinyColor(backgroundColor).toRgb();
  for (let fA = 0.01; fA <= 1; fA += 0.01) {
    const r2 = Math.round((fR - bR * (1 - fA)) / fA);
    const g2 = Math.round((fG - bG * (1 - fA)) / fA);
    const b2 = Math.round((fB - bB * (1 - fA)) / fA);
    if (isStableColor$1(r2) && isStableColor$1(g2) && isStableColor$1(b2)) {
      return new TinyColor({
        r: r2,
        g: g2,
        b: b2,
        a: Math.round(fA * 100) / 100
      }).toRgbString();
    }
  }
  return new TinyColor({
    r: fR,
    g: fG,
    b: fB,
    a: 1
  }).toRgbString();
}
var __rest$F = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function formatToken$1(derivativeToken) {
  const {
    override
  } = derivativeToken, restToken = __rest$F(derivativeToken, ["override"]);
  const overrideTokens = Object.assign({}, override);
  Object.keys(defaultSeedToken).forEach((token2) => {
    delete overrideTokens[token2];
  });
  const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
  const screenXS = 480;
  const screenSM = 576;
  const screenMD = 768;
  const screenLG = 992;
  const screenXL = 1200;
  const screenXXL = 1600;
  const aliasToken = Object.assign(Object.assign(Object.assign({}, mergedToken), {
    colorLink: mergedToken.colorInfoText,
    colorLinkHover: mergedToken.colorInfoHover,
    colorLinkActive: mergedToken.colorInfoActive,
    colorFillContent: mergedToken.colorFillSecondary,
    colorFillContentHover: mergedToken.colorFill,
    colorFillAlter: mergedToken.colorFillQuaternary,
    colorBgContainerDisabled: mergedToken.colorFillTertiary,
    colorBorderBg: mergedToken.colorBgContainer,
    colorSplit: getAlphaColor$4(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
    colorTextPlaceholder: mergedToken.colorTextQuaternary,
    colorTextDisabled: mergedToken.colorTextQuaternary,
    colorTextHeading: mergedToken.colorText,
    colorTextLabel: mergedToken.colorTextSecondary,
    colorTextDescription: mergedToken.colorTextTertiary,
    colorTextLightSolid: mergedToken.colorWhite,
    colorHighlight: mergedToken.colorError,
    colorBgTextHover: mergedToken.colorFillSecondary,
    colorBgTextActive: mergedToken.colorFill,
    colorIcon: mergedToken.colorTextTertiary,
    colorIconHover: mergedToken.colorText,
    colorErrorOutline: getAlphaColor$4(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
    colorWarningOutline: getAlphaColor$4(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
    fontSizeIcon: mergedToken.fontSizeSM,
    lineWidthFocus: mergedToken.lineWidth * 4,
    lineWidth: mergedToken.lineWidth,
    controlOutlineWidth: mergedToken.lineWidth * 2,
    controlInteractiveSize: mergedToken.controlHeight / 2,
    controlItemBgHover: mergedToken.colorFillTertiary,
    controlItemBgActive: mergedToken.colorPrimaryBg,
    controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
    controlItemBgActiveDisabled: mergedToken.colorFill,
    controlTmpOutline: mergedToken.colorFillQuaternary,
    controlOutline: getAlphaColor$4(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
    lineType: mergedToken.lineType,
    borderRadius: mergedToken.borderRadius,
    borderRadiusXS: mergedToken.borderRadiusXS,
    borderRadiusSM: mergedToken.borderRadiusSM,
    borderRadiusLG: mergedToken.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: mergedToken.sizeXXS,
    paddingXS: mergedToken.sizeXS,
    paddingSM: mergedToken.sizeSM,
    padding: mergedToken.size,
    paddingMD: mergedToken.sizeMD,
    paddingLG: mergedToken.sizeLG,
    paddingXL: mergedToken.sizeXL,
    paddingContentHorizontalLG: mergedToken.sizeLG,
    paddingContentVerticalLG: mergedToken.sizeMS,
    paddingContentHorizontal: mergedToken.sizeMS,
    paddingContentVertical: mergedToken.sizeSM,
    paddingContentHorizontalSM: mergedToken.size,
    paddingContentVerticalSM: mergedToken.sizeXS,
    marginXXS: mergedToken.sizeXXS,
    marginXS: mergedToken.sizeXS,
    marginSM: mergedToken.sizeSM,
    margin: mergedToken.size,
    marginMD: mergedToken.sizeMD,
    marginLG: mergedToken.sizeLG,
    marginXL: mergedToken.sizeXL,
    marginXXL: mergedToken.sizeXXL,
    boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS,
    screenXSMin: screenXS,
    screenXSMax: screenSM - 1,
    screenSM,
    screenSMMin: screenSM,
    screenSMMax: screenMD - 1,
    screenMD,
    screenMDMin: screenMD,
    screenMDMax: screenLG - 1,
    screenLG,
    screenLGMin: screenLG,
    screenLGMax: screenXL - 1,
    screenXL,
    screenXLMin: screenXL,
    screenXLMax: screenXXL - 1,
    screenXXL,
    screenXXLMin: screenXXL,
    boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
    boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), overrideTokens);
  return aliasToken;
}
const defaultIconPrefixCls$1 = "anticon";
const defaultGetPrefixCls$1 = (suffixCls, customizePrefixCls) => {
  if (customizePrefixCls)
    return customizePrefixCls;
  return suffixCls ? `ant-${suffixCls}` : "ant";
};
const ConfigContext$1 = /* @__PURE__ */ React.createContext({
  getPrefixCls: defaultGetPrefixCls$1,
  iconPrefixCls: defaultIconPrefixCls$1
});
const roundedArrow$2 = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
  const unitWidth = width / 2;
  const ax = 0;
  const ay = unitWidth;
  const bx = outerRadius * 1 / Math.sqrt(2);
  const by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2));
  const cx = unitWidth - innerRadius * (1 / Math.sqrt(2));
  const cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2));
  const dx = 2 * unitWidth - cx;
  const dy = cy;
  const ex = 2 * unitWidth - bx;
  const ey = by;
  const fx = 2 * unitWidth - ax;
  const fy = ay;
  const shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2);
  return {
    pointerEvents: "none",
    width,
    height: width,
    overflow: "hidden",
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width,
      height: width / 2,
      background: bgColor,
      clipPath: `path('M ${ax} ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')`,
      content: '""'
    },
    "&::after": {
      content: '""',
      position: "absolute",
      width: shadowWidth,
      height: shadowWidth,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: true,
        value: `0 0 ${innerRadius}px 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow,
      zIndex: 0,
      background: "transparent"
    }
  };
};
const textEllipsis = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
};
const resetComponent = (token2) => ({
  boxSizing: "border-box",
  margin: 0,
  padding: 0,
  color: token2.colorText,
  fontSize: token2.fontSize,
  lineHeight: token2.lineHeight,
  listStyle: "none",
  fontFamily: token2.fontFamily
});
const resetIcon = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
});
const clearFix = () => ({
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    display: "table",
    clear: "both",
    content: '""'
  }
});
const genLinkStyle = (token2) => ({
  a: {
    color: token2.colorLink,
    textDecoration: token2.linkDecoration,
    backgroundColor: "transparent",
    outline: "none",
    cursor: "pointer",
    transition: `color ${token2.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    "&:hover": {
      color: token2.colorLinkHover
    },
    "&:active": {
      color: token2.colorLinkActive
    },
    [`&:active,
  &:hover`]: {
      textDecoration: token2.linkHoverDecoration,
      outline: 0
    },
    "&:focus": {
      textDecoration: token2.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: token2.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
});
const genCommonStyle = (token2, componentPrefixCls) => {
  const {
    fontFamily,
    fontSize
  } = token2;
  const rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
  return {
    [rootPrefixSelector]: {
      fontFamily,
      fontSize,
      boxSizing: "border-box",
      "&::before, &::after": {
        boxSizing: "border-box"
      },
      [rootPrefixSelector]: {
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        }
      }
    }
  };
};
const genFocusOutline = (token2) => ({
  outline: `${token2.lineWidthFocus}px solid ${token2.colorPrimaryBorder}`,
  outlineOffset: 1,
  transition: "outline-offset 0s, outline 0s"
});
const genFocusStyle = (token2) => ({
  "&:focus-visible": Object.assign({}, genFocusOutline(token2))
});
function genComponentStyleHook$2(component, styleFn, getDefaultToken) {
  return (prefixCls) => {
    const [theme2, token2, hashId] = useToken$2();
    const {
      getPrefixCls,
      iconPrefixCls,
      csp
    } = React.useContext(ConfigContext$1);
    const rootPrefixCls = getPrefixCls();
    const sharedConfig = {
      theme: theme2,
      token: token2,
      hashId,
      nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce
    };
    useStyleRegister(Object.assign(Object.assign({}, sharedConfig), {
      path: ["Shared", rootPrefixCls]
    }), () => [{
      "&": genLinkStyle(token2)
    }]);
    return [useStyleRegister(Object.assign(Object.assign({}, sharedConfig), {
      path: [component, prefixCls, iconPrefixCls]
    }), () => {
      const {
        token: proxyToken,
        flush
      } = statisticToken$1(token2);
      const defaultComponentToken = typeof getDefaultToken === "function" ? getDefaultToken(proxyToken) : getDefaultToken;
      const mergedComponentToken = Object.assign(Object.assign({}, defaultComponentToken), token2[component]);
      const componentCls = `.${prefixCls}`;
      const mergedToken = merge$1(proxyToken, {
        componentCls,
        prefixCls,
        iconCls: `.${iconPrefixCls}`,
        antCls: `.${rootPrefixCls}`
      }, mergedComponentToken);
      const styleInterpolation = styleFn(mergedToken, {
        hashId,
        prefixCls,
        rootPrefixCls,
        iconPrefixCls,
        overrideComponentToken: token2[component]
      });
      flush(component, mergedComponentToken);
      return [genCommonStyle(token2, prefixCls), styleInterpolation];
    }), hashId];
  };
}
const enableStatistic$1 = typeof CSSINJS_STATISTIC !== "undefined";
let recording$1 = true;
function merge$1() {
  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
    objs[_key] = arguments[_key];
  }
  if (!enableStatistic$1) {
    return Object.assign.apply(Object, [{}].concat(objs));
  }
  recording$1 = false;
  const ret = {};
  objs.forEach((obj) => {
    const keys2 = Object.keys(obj);
    keys2.forEach((key) => {
      Object.defineProperty(ret, key, {
        configurable: true,
        enumerable: true,
        get: () => obj[key]
      });
    });
  });
  recording$1 = true;
  return ret;
}
function noop$4() {
}
function statisticToken$1(token2) {
  let tokenKeys2;
  let proxy = token2;
  let flush = noop$4;
  if (enableStatistic$1) {
    tokenKeys2 = /* @__PURE__ */ new Set();
    proxy = new Proxy(token2, {
      get(obj, prop) {
        if (recording$1) {
          tokenKeys2.add(prop);
        }
        return obj[prop];
      }
    });
    flush = (componentName, componentToken) => {
      ({
        global: Array.from(tokenKeys2),
        component: componentToken
      });
    };
  }
  return {
    token: proxy,
    keys: tokenKeys2,
    flush
  };
}
function genPresetColor$2(token2, genCss) {
  return PresetColors$1.reduce((prev2, colorKey) => {
    const lightColor = token2[`${colorKey}1`];
    const lightBorderColor = token2[`${colorKey}3`];
    const darkColor = token2[`${colorKey}6`];
    const textColor = token2[`${colorKey}7`];
    return Object.assign(Object.assign({}, prev2), genCss(colorKey, {
      lightColor,
      lightBorderColor,
      darkColor,
      textColor
    }));
  }, {});
}
const defaultTheme = createTheme(derivative$3);
const defaultConfig = {
  token: defaultSeedToken,
  hashed: true
};
const DesignTokenContext = /* @__PURE__ */ React.createContext(defaultConfig);
function useToken$2() {
  const {
    token: rootDesignToken,
    hashed,
    theme: theme2,
    components
  } = React.useContext(DesignTokenContext);
  const salt = `${version$4}-${hashed || ""}`;
  const mergedTheme = theme2 || defaultTheme;
  const [token2, hashId] = useCacheToken(mergedTheme, [defaultSeedToken, rootDesignToken], {
    salt,
    override: Object.assign({
      override: rootDesignToken
    }, components),
    formatToken: formatToken$1
  });
  return [mergedTheme, token2, hashed ? hashId : ""];
}
function canUseDom$d() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function contains$8(root2, n2) {
  if (!root2) {
    return false;
  }
  if (root2.contains) {
    return root2.contains(n2);
  }
  var node2 = n2;
  while (node2) {
    if (node2 === root2) {
      return true;
    }
    node2 = node2.parentNode;
  }
  return false;
}
var APPEND_ORDER$4 = "data-rc-order";
var MARK_KEY$4 = "rc-util-key";
var containerCache$4 = /* @__PURE__ */ new Map();
function getMark$4() {
  var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark2 = _ref2.mark;
  if (mark2) {
    return mark2.startsWith("data-") ? mark2 : "data-".concat(mark2);
  }
  return MARK_KEY$4;
}
function getContainer$4(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function getOrder$4(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles$4(container) {
  return Array.from((containerCache$4.get(container) || container).children).filter(function(node2) {
    return node2.tagName === "STYLE";
  });
}
function injectCSS$4(css2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom$d()) {
    return null;
  }
  var csp = option.csp, prepend = option.prepend;
  var styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER$4, getOrder$4(prepend));
  if (csp !== null && csp !== void 0 && csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css2;
  var container = getContainer$4(option);
  var firstChild = container.firstChild;
  if (prepend) {
    if (prepend === "queue") {
      var existStyle = findStyles$4(container).filter(function(node2) {
        return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER$4));
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode$4(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer$4(option);
  return findStyles$4(container).find(function(node2) {
    return node2.getAttribute(getMark$4(option)) === key;
  });
}
function syncRealContainer$4(container, option) {
  var cachedRealContainer = containerCache$4.get(container);
  if (!cachedRealContainer || !contains$8(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS$4("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache$4.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function updateCSS$4(css2, key) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer$4(option);
  syncRealContainer$4(container, option);
  var existNode = findExistNode$4(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  var newNode = injectCSS$4(css2, option);
  newNode.setAttribute(getMark$4(option), key);
  return newNode;
}
const dynamicStyleMark$1 = `-ant-${Date.now()}-${Math.random()}`;
function getStyle$1(globalPrefixCls2, theme2) {
  const variables = {};
  const formatColor = (color2, updater) => {
    let clone2 = color2.clone();
    clone2 = (updater === null || updater === void 0 ? void 0 : updater(clone2)) || clone2;
    return clone2.toRgbString();
  };
  const fillColor = (colorVal, type4) => {
    const baseColor = new TinyColor(colorVal);
    const colorPalettes = generate$2(baseColor.toRgbString());
    variables[`${type4}-color`] = formatColor(baseColor);
    variables[`${type4}-color-disabled`] = colorPalettes[1];
    variables[`${type4}-color-hover`] = colorPalettes[4];
    variables[`${type4}-color-active`] = colorPalettes[6];
    variables[`${type4}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString();
    variables[`${type4}-color-deprecated-bg`] = colorPalettes[0];
    variables[`${type4}-color-deprecated-border`] = colorPalettes[2];
  };
  if (theme2.primaryColor) {
    fillColor(theme2.primaryColor, "primary");
    const primaryColor = new TinyColor(theme2.primaryColor);
    const primaryColors = generate$2(primaryColor.toRgbString());
    primaryColors.forEach((color2, index2) => {
      variables[`primary-${index2 + 1}`] = color2;
    });
    variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2) => c2.lighten(35));
    variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2) => c2.lighten(20));
    variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2) => c2.tint(20));
    variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2) => c2.tint(50));
    variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.12));
    const primaryActiveColor = new TinyColor(primaryColors[0]);
    variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.3));
    variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2) => c2.darken(2));
  }
  if (theme2.successColor) {
    fillColor(theme2.successColor, "success");
  }
  if (theme2.warningColor) {
    fillColor(theme2.warningColor, "warning");
  }
  if (theme2.errorColor) {
    fillColor(theme2.errorColor, "error");
  }
  if (theme2.infoColor) {
    fillColor(theme2.infoColor, "info");
  }
  const cssList = Object.keys(variables).map((key) => `--${globalPrefixCls2}-${key}: ${variables[key]};`);
  return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
}
function registerTheme$1(globalPrefixCls2, theme2) {
  const style2 = getStyle$1(globalPrefixCls2, theme2);
  if (canUseDom$d()) {
    updateCSS$4(style2, `${dynamicStyleMark$1}-dynamic-theme`);
  }
}
const DisabledContext$2 = /* @__PURE__ */ React.createContext(false);
const DisabledContextProvider$1 = (_ref2) => {
  let {
    children,
    disabled
  } = _ref2;
  const originDisabled = React.useContext(DisabledContext$2);
  return /* @__PURE__ */ React.createElement(DisabledContext$2.Provider, {
    value: disabled !== null && disabled !== void 0 ? disabled : originDisabled
  }, children);
};
var DisabledContext$3 = DisabledContext$2;
const SizeContext$2 = /* @__PURE__ */ React.createContext(void 0);
const SizeContextProvider$1 = (_ref2) => {
  let {
    children,
    size
  } = _ref2;
  const originSize = React.useContext(SizeContext$2);
  return /* @__PURE__ */ React.createElement(SizeContext$2.Provider, {
    value: size || originSize
  }, children);
};
var SizeContext$3 = SizeContext$2;
function useConfig$2() {
  const componentDisabled = React.useContext(DisabledContext$3);
  const componentSize = React.useContext(SizeContext$3);
  return {
    componentDisabled,
    componentSize
  };
}
function isEqual$4(obj1, obj2) {
  var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var refSet = /* @__PURE__ */ new Set();
  function deepEqual(a, b2) {
    var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    var circular = refSet.has(a);
    warningOnce$5(!circular, "Warning: There may be circular references");
    if (circular) {
      return false;
    }
    if (a === b2) {
      return true;
    }
    if (shallow && level > 1) {
      return false;
    }
    refSet.add(a);
    var newLevel = level + 1;
    if (Array.isArray(a)) {
      if (!Array.isArray(b2) || a.length !== b2.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!deepEqual(a[i], b2[i], newLevel)) {
          return false;
        }
      }
      return true;
    }
    if (a && b2 && _typeof$8(a) === "object" && _typeof$8(b2) === "object") {
      var keys2 = Object.keys(a);
      if (keys2.length !== Object.keys(b2).length) {
        return false;
      }
      return keys2.every(function(key) {
        return deepEqual(a[key], b2[key], newLevel);
      });
    }
    return false;
  }
  return deepEqual(obj1, obj2);
}
function useTheme$2(theme2, parentTheme) {
  const themeConfig = theme2 || {};
  const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? defaultConfig : parentTheme;
  const mergedTheme = useMemo$6(() => {
    if (!theme2) {
      return parentTheme;
    }
    const mergedComponents = Object.assign({}, parentThemeConfig.components);
    Object.keys(theme2.components || {}).forEach((componentName) => {
      mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme2.components[componentName]);
    });
    return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
      token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
      components: mergedComponents
    });
  }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index2) => {
    const nextTheme = next2[index2];
    return !isEqual$4(prevTheme, nextTheme, true);
  }));
  return mergedTheme;
}
const useStyle$j = (iconPrefixCls, csp) => {
  const [theme2, token2] = useToken$2();
  return useStyleRegister({
    theme: theme2,
    token: token2,
    hashId: "",
    path: ["ant-design-icons", iconPrefixCls],
    nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce
  }, () => [{
    [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, resetIcon()), {
      [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
        display: "block"
      }
    })
  }]);
};
var useStyle$k = useStyle$j;
var __rest$E = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "pageHeader", "input", "pagination", "form", "select"];
const defaultPrefixCls = "ant";
let globalPrefixCls;
let globalIconPrefixCls;
function getGlobalPrefixCls() {
  return globalPrefixCls || defaultPrefixCls;
}
function getGlobalIconPrefixCls() {
  return globalIconPrefixCls || defaultIconPrefixCls$1;
}
const setGlobalConfig = (_ref2) => {
  let {
    prefixCls,
    iconPrefixCls,
    theme: theme2
  } = _ref2;
  if (prefixCls !== void 0) {
    globalPrefixCls = prefixCls;
  }
  if (iconPrefixCls !== void 0) {
    globalIconPrefixCls = iconPrefixCls;
  }
  if (theme2) {
    registerTheme$1(getGlobalPrefixCls(), theme2);
  }
};
const globalConfig = () => ({
  getPrefixCls: (suffixCls, customizePrefixCls) => {
    if (customizePrefixCls)
      return customizePrefixCls;
    return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
  },
  getIconPrefixCls: getGlobalIconPrefixCls,
  getRootPrefixCls: () => {
    if (globalPrefixCls) {
      return globalPrefixCls;
    }
    return getGlobalPrefixCls();
  }
});
const ProviderChildren = (props) => {
  const {
    children,
    csp: customCsp,
    autoInsertSpaceInButton,
    form,
    locale: locale2,
    componentSize,
    direction,
    space: space2,
    virtual,
    dropdownMatchSelectWidth,
    legacyLocale,
    parentContext,
    iconPrefixCls: customIconPrefixCls,
    theme: theme2,
    componentDisabled
  } = props;
  const getPrefixCls = React.useCallback((suffixCls, customizePrefixCls) => {
    const {
      prefixCls
    } = props;
    if (customizePrefixCls)
      return customizePrefixCls;
    const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
    return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
  }, [parentContext.getPrefixCls, props.prefixCls]);
  const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls$1;
  const shouldWrapSSR = iconPrefixCls !== parentContext.iconPrefixCls;
  const csp = customCsp || parentContext.csp;
  const wrapSSR = useStyle$k(iconPrefixCls, csp);
  const mergedTheme = useTheme$2(theme2, parentContext.theme);
  const baseConfig = {
    csp,
    autoInsertSpaceInButton,
    locale: locale2 || legacyLocale,
    direction,
    space: space2,
    virtual,
    dropdownMatchSelectWidth,
    getPrefixCls,
    iconPrefixCls,
    theme: mergedTheme
  };
  const config = Object.assign({}, parentContext);
  Object.keys(baseConfig).forEach((key) => {
    if (baseConfig[key] !== void 0) {
      config[key] = baseConfig[key];
    }
  });
  PASSED_PROPS.forEach((propName) => {
    const propValue = props[propName];
    if (propValue) {
      config[propName] = propValue;
    }
  });
  const memoedConfig = useMemo$6(() => config, config, (prevConfig, currentConfig) => {
    const prevKeys = Object.keys(prevConfig);
    const currentKeys = Object.keys(currentConfig);
    return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
  });
  const memoIconContextValue = React.useMemo(() => ({
    prefixCls: iconPrefixCls,
    csp
  }), [iconPrefixCls, csp]);
  let childNode = shouldWrapSSR ? wrapSSR(children) : children;
  const validateMessages = React.useMemo(() => {
    var _a2, _b, _c;
    return setValues$1({}, ((_a2 = defaultLocale.Form) === null || _a2 === void 0 ? void 0 : _a2.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, (form === null || form === void 0 ? void 0 : form.validateMessages) || {});
  }, [memoedConfig, form === null || form === void 0 ? void 0 : form.validateMessages]);
  if (Object.keys(validateMessages).length > 0) {
    childNode = /* @__PURE__ */ React.createElement(FormProvider$1, {
      validateMessages
    }, children);
  }
  if (locale2) {
    childNode = /* @__PURE__ */ React.createElement(LocaleProvider$1, {
      locale: locale2,
      _ANT_MARK__: ANT_MARK
    }, childNode);
  }
  if (iconPrefixCls || csp) {
    childNode = /* @__PURE__ */ React.createElement(Context$2.Provider, {
      value: memoIconContextValue
    }, childNode);
  }
  if (componentSize) {
    childNode = /* @__PURE__ */ React.createElement(SizeContextProvider$1, {
      size: componentSize
    }, childNode);
  }
  const memoTheme = React.useMemo(() => {
    const _a2 = mergedTheme || {}, {
      algorithm,
      token: token2
    } = _a2, rest = __rest$E(_a2, ["algorithm", "token"]);
    const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : void 0;
    return Object.assign(Object.assign({}, rest), {
      theme: themeObj,
      token: Object.assign(Object.assign({}, defaultSeedToken), token2)
    });
  }, [mergedTheme]);
  if (theme2) {
    childNode = /* @__PURE__ */ React.createElement(DesignTokenContext.Provider, {
      value: memoTheme
    }, childNode);
  }
  if (componentDisabled !== void 0) {
    childNode = /* @__PURE__ */ React.createElement(DisabledContextProvider$1, {
      disabled: componentDisabled
    }, childNode);
  }
  return /* @__PURE__ */ React.createElement(ConfigContext$1.Provider, {
    value: memoedConfig
  }, childNode);
};
const ConfigProvider = (props) => {
  const context2 = React.useContext(ConfigContext$1);
  const antLocale = React.useContext(LocaleContext$2);
  return /* @__PURE__ */ React.createElement(ProviderChildren, Object.assign({
    parentContext: context2,
    legacyLocale: antLocale
  }, props));
};
ConfigProvider.ConfigContext = ConfigContext$1;
ConfigProvider.SizeContext = SizeContext$3;
ConfigProvider.config = setGlobalConfig;
ConfigProvider.useConfig = useConfig$2;
Object.defineProperty(ConfigProvider, "SizeContext", {
  get: () => {
    return SizeContext$3;
  }
});
var raf$8 = function raf(callback) {
  return +setTimeout(callback, 16);
};
var caf$7 = function caf(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf$8 = function raf10(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf$7 = function caf10(handle2) {
    return window.cancelAnimationFrame(handle2);
  };
}
var rafUUID$7 = 0;
var rafIds$7 = /* @__PURE__ */ new Map();
function cleanup$7(id) {
  rafIds$7.delete(id);
}
var wrapperRaf$7 = function wrapperRaf(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID$7 += 1;
  var id = rafUUID$7;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup$7(id);
      callback();
    } else {
      var realId = raf$8(function() {
        callRef(leftTimes - 1);
      });
      rafIds$7.set(id, realId);
    }
  }
  callRef(times);
  return id;
};
wrapperRaf$7.cancel = function(id) {
  var realId = rafIds$7.get(id);
  cleanup$7(realId);
  return caf$7(realId);
};
var warned$4 = {};
function warning$9(valid2, message) {
}
function call$4(method4, valid2, message) {
  if (!valid2 && !warned$4[message]) {
    method4(false, message);
    warned$4[message] = true;
  }
}
function warningOnce$4(valid2, message) {
  call$4(warning$9, valid2, message);
}
function canUseDom$c() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function contains$7(root2, n2) {
  if (!root2) {
    return false;
  }
  if (root2.contains) {
    return root2.contains(n2);
  }
  var node2 = n2;
  while (node2) {
    if (node2 === root2) {
      return true;
    }
    node2 = node2.parentNode;
  }
  return false;
}
var APPEND_ORDER$3 = "data-rc-order";
var MARK_KEY$3 = "rc-util-key";
var containerCache$3 = /* @__PURE__ */ new Map();
function getMark$3() {
  var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark2 = _ref2.mark;
  if (mark2) {
    return mark2.startsWith("data-") ? mark2 : "data-".concat(mark2);
  }
  return MARK_KEY$3;
}
function getContainer$3(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function getOrder$3(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles$3(container) {
  return Array.from((containerCache$3.get(container) || container).children).filter(function(node2) {
    return node2.tagName === "STYLE";
  });
}
function injectCSS$3(css2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom$c()) {
    return null;
  }
  var csp = option.csp, prepend = option.prepend;
  var styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER$3, getOrder$3(prepend));
  if (csp === null || csp === void 0 ? void 0 : csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css2;
  var container = getContainer$3(option);
  var firstChild = container.firstChild;
  if (prepend) {
    if (prepend === "queue") {
      var existStyle = findStyles$3(container).filter(function(node2) {
        return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER$3));
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode$3(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer$3(option);
  return findStyles$3(container).find(function(node2) {
    return node2.getAttribute(getMark$3(option)) === key;
  });
}
function syncRealContainer$3(container, option) {
  var cachedRealContainer = containerCache$3.get(container);
  if (!cachedRealContainer || !contains$7(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS$3("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache$3.set(container, parentNode);
    parentNode.removeChild(placeholderStyle);
  }
}
function updateCSS$3(css2, key) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer$3(option);
  syncRealContainer$3(container, option);
  var existNode = findExistNode$3(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if (((_option$csp = option.csp) === null || _option$csp === void 0 ? void 0 : _option$csp.nonce) && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  var newNode = injectCSS$3(css2, option);
  newNode.setAttribute(getMark$3(option), key);
  return newNode;
}
function warning$8(valid2, message) {
  warningOnce$4(valid2, "[@ant-design/icons] ".concat(message));
}
function isIconDefinition$1(target) {
  return _typeof$8(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof$8(target.icon) === "object" || typeof target.icon === "function");
}
function normalizeAttrs$1() {
  var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(attrs).reduce(function(acc, key) {
    var val = attrs[key];
    switch (key) {
      case "class":
        acc.className = val;
        delete acc.class;
        break;
      default:
        acc[key] = val;
    }
    return acc;
  }, {});
}
function generate$1(node2, key, rootProps) {
  if (!rootProps) {
    return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2$d({
      key
    }, normalizeAttrs$1(node2.attrs)), (node2.children || []).map(function(child, index2) {
      return generate$1(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
    }));
  }
  return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2$d(_objectSpread2$d({
    key
  }, normalizeAttrs$1(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
    return generate$1(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
  }));
}
function getSecondaryColor$1(primaryColor) {
  return generate$2(primaryColor)[0];
}
function normalizeTwoToneColors$1(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }
  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var iconStyles$1 = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var useInsertStyles$1 = function useInsertStyles2() {
  var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles$1;
  var _useContext = React.useContext(Context$2), csp = _useContext.csp, prefixCls = _useContext.prefixCls;
  var mergedStyleStr = styleStr;
  if (prefixCls) {
    mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
  }
  React.useEffect(function() {
    updateCSS$3(mergedStyleStr, "@ant-design-icons", {
      prepend: true,
      csp
    });
  }, []);
};
var _excluded$M = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
var twoToneColorPalette$1 = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: false
};
function setTwoToneColors$1(_ref2) {
  var primaryColor = _ref2.primaryColor, secondaryColor = _ref2.secondaryColor;
  twoToneColorPalette$1.primaryColor = primaryColor;
  twoToneColorPalette$1.secondaryColor = secondaryColor || getSecondaryColor$1(primaryColor);
  twoToneColorPalette$1.calculated = !!secondaryColor;
}
function getTwoToneColors$1() {
  return _objectSpread2$d({}, twoToneColorPalette$1);
}
var IconBase$2 = function IconBase2(props) {
  var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties$1(props, _excluded$M);
  var colors2 = twoToneColorPalette$1;
  if (primaryColor) {
    colors2 = {
      primaryColor,
      secondaryColor: secondaryColor || getSecondaryColor$1(primaryColor)
    };
  }
  useInsertStyles$1();
  warning$8(isIconDefinition$1(icon), "icon should be icon definiton, but got ".concat(icon));
  if (!isIconDefinition$1(icon)) {
    return null;
  }
  var target = icon;
  if (target && typeof target.icon === "function") {
    target = _objectSpread2$d(_objectSpread2$d({}, target), {}, {
      icon: target.icon(colors2.primaryColor, colors2.secondaryColor)
    });
  }
  return generate$1(target.icon, "svg-".concat(target.name), _objectSpread2$d({
    className,
    onClick,
    style: style2,
    "data-icon": target.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, restProps));
};
IconBase$2.displayName = "IconReact";
IconBase$2.getTwoToneColors = getTwoToneColors$1;
IconBase$2.setTwoToneColors = setTwoToneColors$1;
var ReactIcon = IconBase$2;
function setTwoToneColor$1(twoToneColor) {
  var _normalizeTwoToneColo = normalizeTwoToneColors$1(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$1(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return ReactIcon.setTwoToneColors({
    primaryColor,
    secondaryColor
  });
}
function getTwoToneColor$1() {
  var colors2 = ReactIcon.getTwoToneColors();
  if (!colors2.calculated) {
    return colors2.primaryColor;
  }
  return [colors2.primaryColor, colors2.secondaryColor];
}
var _excluded$L = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
setTwoToneColor$1("#1890ff");
var Icon$3 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var _classNames;
  var className = props.className, icon = props.icon, spin2 = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties$1(props, _excluded$L);
  var _React$useContext = React.useContext(Context$2), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
  var classString = classNames(rootClassName, prefixCls, (_classNames = {}, _defineProperty$3(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty$3(_classNames, "".concat(prefixCls, "-spin"), !!spin2 || icon.name === "loading"), _classNames), className);
  var iconTabIndex = tabIndex;
  if (iconTabIndex === void 0 && onClick) {
    iconTabIndex = -1;
  }
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : void 0;
  var _normalizeTwoToneColo = normalizeTwoToneColors$1(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$1(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return /* @__PURE__ */ React.createElement("span", _objectSpread2$d(_objectSpread2$d({
    role: "img",
    "aria-label": icon.name
  }, restProps), {}, {
    ref: ref2,
    tabIndex: iconTabIndex,
    onClick,
    className: classString
  }), /* @__PURE__ */ React.createElement(ReactIcon, {
    icon,
    primaryColor,
    secondaryColor,
    style: svgStyle
  }));
});
Icon$3.displayName = "AntdIcon";
Icon$3.getTwoToneColor = getTwoToneColor$1;
Icon$3.setTwoToneColor = setTwoToneColor$1;
var AntdIcon$1 = Icon$3;
var CheckCircleFilled2 = function CheckCircleFilled3(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: CheckCircleFilledSvg
  }));
};
CheckCircleFilled2.displayName = "CheckCircleFilled";
var CheckCircleFilled$1 = /* @__PURE__ */ React.forwardRef(CheckCircleFilled2);
var CloseCircleFilled$5 = function CloseCircleFilled(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: CloseCircleFilledSvg
  }));
};
CloseCircleFilled$5.displayName = "CloseCircleFilled";
var CloseCircleFilled$6 = /* @__PURE__ */ React.forwardRef(CloseCircleFilled$5);
var CloseOutlined = function CloseOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: CloseOutlinedSvg
  }));
};
CloseOutlined.displayName = "CloseOutlined";
var CloseOutlined$1 = /* @__PURE__ */ React.forwardRef(CloseOutlined);
var ExclamationCircleFilled = function ExclamationCircleFilled2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: ExclamationCircleFilledSvg
  }));
};
ExclamationCircleFilled.displayName = "ExclamationCircleFilled";
var ExclamationCircleFilled$1 = /* @__PURE__ */ React.forwardRef(ExclamationCircleFilled);
var InfoCircleFilled = function InfoCircleFilled2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: InfoCircleFilledSvg
  }));
};
InfoCircleFilled.displayName = "InfoCircleFilled";
var InfoCircleFilled$1 = /* @__PURE__ */ React.forwardRef(InfoCircleFilled);
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
  prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
  prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
  prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
  return prefixes;
}
function getVendorPrefixes(domSupport, win) {
  var prefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  };
  if (domSupport) {
    if (!("AnimationEvent" in win)) {
      delete prefixes.animationend.animation;
    }
    if (!("TransitionEvent" in win)) {
      delete prefixes.transitionend.transition;
    }
  }
  return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDom$f(), typeof window !== "undefined" ? window : {});
var style$7 = {};
if (canUseDom$f()) {
  var _document$createEleme = document.createElement("div");
  style$7 = _document$createEleme.style;
}
var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  }
  var prefixMap = vendorPrefixes[eventName];
  if (prefixMap) {
    var stylePropList = Object.keys(prefixMap);
    var len = stylePropList.length;
    for (var i = 0; i < len; i += 1) {
      var styleProp = stylePropList[i];
      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style$7) {
        prefixedEventNames[eventName] = prefixMap[styleProp];
        return prefixedEventNames[eventName];
      }
    }
  }
  return "";
}
var internalAnimationEndName = getVendorPrefixedEventName("animationend");
var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
var animationEndName = internalAnimationEndName || "animationend";
var transitionEndName = internalTransitionEndName || "transitionend";
function getTransitionName$2(transitionName, transitionType) {
  if (!transitionName)
    return null;
  if (_typeof$8(transitionName) === "object") {
    var type4 = transitionType.replace(/-\w/g, function(match2) {
      return match2[1].toUpperCase();
    });
    return transitionName[type4];
  }
  return "".concat(transitionName, "-").concat(transitionType);
}
var STATUS_NONE = "none";
var STATUS_APPEAR = "appear";
var STATUS_ENTER = "enter";
var STATUS_LEAVE = "leave";
var STEP_NONE = "none";
var STEP_PREPARE = "prepare";
var STEP_START = "start";
var STEP_ACTIVE = "active";
var STEP_ACTIVATED = "end";
function useSafeState$4(defaultValue) {
  var destroyRef = React.useRef(false);
  var _React$useState = React.useState(defaultValue), _React$useState2 = _slicedToArray$1(_React$useState, 2), value = _React$useState2[0], setValue2 = _React$useState2[1];
  React.useEffect(function() {
    destroyRef.current = false;
    return function() {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue2(updater);
  }
  return [value, safeSetState];
}
var raf$7 = function raf2(callback) {
  return +setTimeout(callback, 16);
};
var caf$6 = function caf2(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf$7 = function raf10(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf$6 = function caf10(handle2) {
    return window.cancelAnimationFrame(handle2);
  };
}
var rafUUID$6 = 0;
var rafIds$6 = /* @__PURE__ */ new Map();
function cleanup$6(id) {
  rafIds$6.delete(id);
}
function wrapperRaf$6(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID$6 += 1;
  var id = rafUUID$6;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup$6(id);
      callback();
    } else {
      var realId = raf$7(function() {
        callRef(leftTimes - 1);
      });
      rafIds$6.set(id, realId);
    }
  }
  callRef(times);
  return id;
}
wrapperRaf$6.cancel = function(id) {
  var realId = rafIds$6.get(id);
  cleanup$6(realId);
  return caf$6(realId);
};
var useNextFrame = function() {
  var nextFrameRef = React.useRef(null);
  function cancelNextFrame() {
    wrapperRaf$6.cancel(nextFrameRef.current);
  }
  function nextFrame(callback) {
    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    cancelNextFrame();
    var nextFrameId = wrapperRaf$6(function() {
      if (delay <= 1) {
        callback({
          isCanceled: function isCanceled() {
            return nextFrameId !== nextFrameRef.current;
          }
        });
      } else {
        nextFrame(callback, delay - 1);
      }
    });
    nextFrameRef.current = nextFrameId;
  }
  React.useEffect(function() {
    return function() {
      cancelNextFrame();
    };
  }, []);
  return [nextFrame, cancelNextFrame];
};
var useIsomorphicLayoutEffect = canUseDom$f() ? React.useLayoutEffect : React.useEffect;
var STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
var SkipStep = false;
var DoStep = true;
function isActive(step) {
  return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
var useStepQueue = function(status, callback) {
  var _useState = useSafeState$4(STEP_NONE), _useState2 = _slicedToArray$1(_useState, 2), step = _useState2[0], setStep = _useState2[1];
  var _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray$1(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
  function startQueue() {
    setStep(STEP_PREPARE, true);
  }
  useIsomorphicLayoutEffect(function() {
    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
      var index2 = STEP_QUEUE.indexOf(step);
      var nextStep = STEP_QUEUE[index2 + 1];
      var result = callback(step);
      if (result === SkipStep) {
        setStep(nextStep, true);
      } else {
        nextFrame(function(info) {
          function doNext() {
            if (info.isCanceled())
              return;
            setStep(nextStep, true);
          }
          if (result === true) {
            doNext();
          } else {
            Promise.resolve(result).then(doNext);
          }
        });
      }
    }
  }, [status, step]);
  React.useEffect(function() {
    return function() {
      cancelNextFrame();
    };
  }, []);
  return [startQueue, step];
};
var useDomMotionEvents = function(callback) {
  var cacheElementRef = React.useRef();
  var callbackRef = React.useRef(callback);
  callbackRef.current = callback;
  var onInternalMotionEnd = React.useCallback(function(event) {
    callbackRef.current(event);
  }, []);
  function removeMotionEvents(element2) {
    if (element2) {
      element2.removeEventListener(transitionEndName, onInternalMotionEnd);
      element2.removeEventListener(animationEndName, onInternalMotionEnd);
    }
  }
  function patchMotionEvents(element2) {
    if (cacheElementRef.current && cacheElementRef.current !== element2) {
      removeMotionEvents(cacheElementRef.current);
    }
    if (element2 && element2 !== cacheElementRef.current) {
      element2.addEventListener(transitionEndName, onInternalMotionEnd);
      element2.addEventListener(animationEndName, onInternalMotionEnd);
      cacheElementRef.current = element2;
    }
  }
  React.useEffect(function() {
    return function() {
      removeMotionEvents(cacheElementRef.current);
    };
  }, []);
  return [patchMotionEvents, removeMotionEvents];
};
function useStatus(supportMotion, visible, getElement2, _ref2) {
  var _ref$motionEnter = _ref2.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref2.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref2.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref2.motionDeadline, motionLeaveImmediately = _ref2.motionLeaveImmediately, onAppearPrepare = _ref2.onAppearPrepare, onEnterPrepare = _ref2.onEnterPrepare, onLeavePrepare = _ref2.onLeavePrepare, onAppearStart = _ref2.onAppearStart, onEnterStart = _ref2.onEnterStart, onLeaveStart = _ref2.onLeaveStart, onAppearActive = _ref2.onAppearActive, onEnterActive = _ref2.onEnterActive, onLeaveActive = _ref2.onLeaveActive, onAppearEnd = _ref2.onAppearEnd, onEnterEnd = _ref2.onEnterEnd, onLeaveEnd = _ref2.onLeaveEnd, onVisibleChanged = _ref2.onVisibleChanged;
  var _useState = useSafeState$4(), _useState2 = _slicedToArray$1(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
  var _useState3 = useSafeState$4(STATUS_NONE), _useState4 = _slicedToArray$1(_useState3, 2), status = _useState4[0], setStatus = _useState4[1];
  var _useState5 = useSafeState$4(null), _useState6 = _slicedToArray$1(_useState5, 2), style2 = _useState6[0], setStyle = _useState6[1];
  var mountedRef = React.useRef(false);
  var deadlineRef = React.useRef(null);
  function getDomElement() {
    return getElement2();
  }
  var activeRef = React.useRef(false);
  function onInternalMotionEnd(event) {
    var element2 = getDomElement();
    if (event && !event.deadline && event.target !== element2) {
      return;
    }
    var currentActive = activeRef.current;
    var canEnd;
    if (status === STATUS_APPEAR && currentActive) {
      canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element2, event);
    } else if (status === STATUS_ENTER && currentActive) {
      canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element2, event);
    } else if (status === STATUS_LEAVE && currentActive) {
      canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element2, event);
    }
    if (status !== STATUS_NONE && currentActive && canEnd !== false) {
      setStatus(STATUS_NONE, true);
      setStyle(null, true);
    }
  }
  var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray$1(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
  var eventHandlers = React.useMemo(function() {
    var _ref22, _ref3, _ref4;
    switch (status) {
      case STATUS_APPEAR:
        return _ref22 = {}, _defineProperty$3(_ref22, STEP_PREPARE, onAppearPrepare), _defineProperty$3(_ref22, STEP_START, onAppearStart), _defineProperty$3(_ref22, STEP_ACTIVE, onAppearActive), _ref22;
      case STATUS_ENTER:
        return _ref3 = {}, _defineProperty$3(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty$3(_ref3, STEP_START, onEnterStart), _defineProperty$3(_ref3, STEP_ACTIVE, onEnterActive), _ref3;
      case STATUS_LEAVE:
        return _ref4 = {}, _defineProperty$3(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty$3(_ref4, STEP_START, onLeaveStart), _defineProperty$3(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;
      default:
        return {};
    }
  }, [status]);
  var _useStepQueue = useStepQueue(status, function(newStep) {
    if (newStep === STEP_PREPARE) {
      var onPrepare = eventHandlers[STEP_PREPARE];
      if (!onPrepare) {
        return SkipStep;
      }
      return onPrepare(getDomElement());
    }
    if (step in eventHandlers) {
      var _eventHandlers$step;
      setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
    }
    if (step === STEP_ACTIVE) {
      patchMotionEvents(getDomElement());
      if (motionDeadline > 0) {
        clearTimeout(deadlineRef.current);
        deadlineRef.current = setTimeout(function() {
          onInternalMotionEnd({
            deadline: true
          });
        }, motionDeadline);
      }
    }
    return DoStep;
  }), _useStepQueue2 = _slicedToArray$1(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
  var active = isActive(step);
  activeRef.current = active;
  useIsomorphicLayoutEffect(function() {
    setAsyncVisible(visible);
    var isMounted = mountedRef.current;
    mountedRef.current = true;
    if (!supportMotion) {
      return;
    }
    var nextStatus;
    if (!isMounted && visible && motionAppear) {
      nextStatus = STATUS_APPEAR;
    }
    if (isMounted && visible && motionEnter) {
      nextStatus = STATUS_ENTER;
    }
    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
      nextStatus = STATUS_LEAVE;
    }
    if (nextStatus) {
      setStatus(nextStatus);
      startStep();
    }
  }, [visible]);
  React.useEffect(function() {
    if (status === STATUS_APPEAR && !motionAppear || status === STATUS_ENTER && !motionEnter || status === STATUS_LEAVE && !motionLeave) {
      setStatus(STATUS_NONE);
    }
  }, [motionAppear, motionEnter, motionLeave]);
  React.useEffect(function() {
    return function() {
      mountedRef.current = false;
      clearTimeout(deadlineRef.current);
    };
  }, []);
  var firstMountChangeRef = React.useRef(false);
  React.useEffect(function() {
    if (asyncVisible) {
      firstMountChangeRef.current = true;
    }
    if (asyncVisible !== void 0 && status === STATUS_NONE) {
      if (firstMountChangeRef.current || asyncVisible) {
        onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
      }
      firstMountChangeRef.current = true;
    }
  }, [asyncVisible, status]);
  var mergedStyle = style2;
  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
    mergedStyle = _objectSpread2$d({
      transition: "none"
    }, mergedStyle);
  }
  return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
}
var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
  _inherits$2(DomWrapper2, _React$Component);
  var _super = _createSuper$2(DomWrapper2);
  function DomWrapper2() {
    _classCallCheck$2(this, DomWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass$2(DomWrapper2, [{
    key: "render",
    value: function render2() {
      return this.props.children;
    }
  }]);
  return DomWrapper2;
}(React.Component);
function genCSSMotion(config) {
  var transitionSupport = config;
  if (_typeof$8(config) === "object") {
    transitionSupport = config.transitionSupport;
  }
  function isSupportTransition(props) {
    return !!(props.motionName && transitionSupport);
  }
  var CSSMotion2 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
    var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
    var supportMotion = isSupportTransition(props);
    var nodeRef = React.useRef();
    var wrapperNodeRef = React.useRef();
    function getDomElement() {
      try {
        return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode$3(wrapperNodeRef.current);
      } catch (e2) {
        return null;
      }
    }
    var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray$1(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
    var renderedRef = React.useRef(mergedVisible);
    if (mergedVisible) {
      renderedRef.current = true;
    }
    var setNodeRef = React.useCallback(function(node2) {
      nodeRef.current = node2;
      fillRef$7(ref2, node2);
    }, [ref2]);
    var motionChildren;
    var mergedProps = _objectSpread2$d(_objectSpread2$d({}, eventProps), {}, {
      visible
    });
    if (!children) {
      motionChildren = null;
    } else if (status === STATUS_NONE || !isSupportTransition(props)) {
      if (mergedVisible) {
        motionChildren = children(_objectSpread2$d({}, mergedProps), setNodeRef);
      } else if (!removeOnLeave && renderedRef.current) {
        motionChildren = children(_objectSpread2$d(_objectSpread2$d({}, mergedProps), {}, {
          className: leavedClassName
        }), setNodeRef);
      } else if (forceRender) {
        motionChildren = children(_objectSpread2$d(_objectSpread2$d({}, mergedProps), {}, {
          style: {
            display: "none"
          }
        }), setNodeRef);
      } else {
        motionChildren = null;
      }
    } else {
      var _classNames;
      var statusSuffix;
      if (statusStep === STEP_PREPARE) {
        statusSuffix = "prepare";
      } else if (isActive(statusStep)) {
        statusSuffix = "active";
      } else if (statusStep === STEP_START) {
        statusSuffix = "start";
      }
      motionChildren = children(_objectSpread2$d(_objectSpread2$d({}, mergedProps), {}, {
        className: classNames(getTransitionName$2(motionName, status), (_classNames = {}, _defineProperty$3(_classNames, getTransitionName$2(motionName, "".concat(status, "-").concat(statusSuffix)), statusSuffix), _defineProperty$3(_classNames, motionName, typeof motionName === "string"), _classNames)),
        style: statusStyle
      }), setNodeRef);
    }
    if (/* @__PURE__ */ React.isValidElement(motionChildren) && supportRef$5(motionChildren)) {
      var _motionChildren = motionChildren, originNodeRef = _motionChildren.ref;
      if (!originNodeRef) {
        motionChildren = /* @__PURE__ */ React.cloneElement(motionChildren, {
          ref: setNodeRef
        });
      }
    }
    return /* @__PURE__ */ React.createElement(DomWrapper$1, {
      ref: wrapperNodeRef
    }, motionChildren);
  });
  CSSMotion2.displayName = "CSSMotion";
  return CSSMotion2;
}
var CSSMotion = genCSSMotion(supportTransition);
var STATUS_ADD = "add";
var STATUS_KEEP = "keep";
var STATUS_REMOVE = "remove";
var STATUS_REMOVED = "removed";
function wrapKeyToObject(key) {
  var keyObj;
  if (key && _typeof$8(key) === "object" && "key" in key) {
    keyObj = key;
  } else {
    keyObj = {
      key
    };
  }
  return _objectSpread2$d(_objectSpread2$d({}, keyObj), {}, {
    key: String(keyObj.key)
  });
}
function parseKeys() {
  var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return keys2.map(wrapKeyToObject);
}
function diffKeys() {
  var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var list2 = [];
  var currentIndex = 0;
  var currentLen = currentKeys.length;
  var prevKeyObjects = parseKeys(prevKeys);
  var currentKeyObjects = parseKeys(currentKeys);
  prevKeyObjects.forEach(function(keyObj) {
    var hit = false;
    for (var i = currentIndex; i < currentLen; i += 1) {
      var currentKeyObj = currentKeyObjects[i];
      if (currentKeyObj.key === keyObj.key) {
        if (currentIndex < i) {
          list2 = list2.concat(currentKeyObjects.slice(currentIndex, i).map(function(obj) {
            return _objectSpread2$d(_objectSpread2$d({}, obj), {}, {
              status: STATUS_ADD
            });
          }));
          currentIndex = i;
        }
        list2.push(_objectSpread2$d(_objectSpread2$d({}, currentKeyObj), {}, {
          status: STATUS_KEEP
        }));
        currentIndex += 1;
        hit = true;
        break;
      }
    }
    if (!hit) {
      list2.push(_objectSpread2$d(_objectSpread2$d({}, keyObj), {}, {
        status: STATUS_REMOVE
      }));
    }
  });
  if (currentIndex < currentLen) {
    list2 = list2.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
      return _objectSpread2$d(_objectSpread2$d({}, obj), {}, {
        status: STATUS_ADD
      });
    }));
  }
  var keys2 = {};
  list2.forEach(function(_ref2) {
    var key = _ref2.key;
    keys2[key] = (keys2[key] || 0) + 1;
  });
  var duplicatedKeys = Object.keys(keys2).filter(function(key) {
    return keys2[key] > 1;
  });
  duplicatedKeys.forEach(function(matchKey) {
    list2 = list2.filter(function(_ref2) {
      var key = _ref2.key, status = _ref2.status;
      return key !== matchKey || status !== STATUS_REMOVE;
    });
    list2.forEach(function(node2) {
      if (node2.key === matchKey) {
        node2.status = STATUS_KEEP;
      }
    });
  });
  return list2;
}
var _excluded$K = ["component", "children", "onVisibleChanged", "onAllRemoved"], _excluded2$c = ["status"];
var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function genCSSMotionList(transitionSupport) {
  var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion;
  var CSSMotionList2 = /* @__PURE__ */ function(_React$Component) {
    _inherits$2(CSSMotionList3, _React$Component);
    var _super = _createSuper$2(CSSMotionList3);
    function CSSMotionList3() {
      var _this;
      _classCallCheck$2(this, CSSMotionList3);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        keyEntities: []
      };
      _this.removeKey = function(removeKey) {
        var keyEntities = _this.state.keyEntities;
        var nextKeyEntities = keyEntities.map(function(entity) {
          if (entity.key !== removeKey)
            return entity;
          return _objectSpread2$d(_objectSpread2$d({}, entity), {}, {
            status: STATUS_REMOVED
          });
        });
        _this.setState({
          keyEntities: nextKeyEntities
        });
        return nextKeyEntities.filter(function(_ref2) {
          var status = _ref2.status;
          return status !== STATUS_REMOVED;
        }).length;
      };
      return _this;
    }
    _createClass$2(CSSMotionList3, [{
      key: "render",
      value: function render2() {
        var _this2 = this;
        var keyEntities = this.state.keyEntities;
        var _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, onAllRemoved = _this$props.onAllRemoved, restProps = _objectWithoutProperties$1(_this$props, _excluded$K);
        var Component = component || React.Fragment;
        var motionProps = {};
        MOTION_PROP_NAMES.forEach(function(prop) {
          motionProps[prop] = restProps[prop];
          delete restProps[prop];
        });
        delete restProps.keys;
        return /* @__PURE__ */ React.createElement(Component, restProps, keyEntities.map(function(_ref2) {
          var status = _ref2.status, eventProps = _objectWithoutProperties$1(_ref2, _excluded2$c);
          var visible = status === STATUS_ADD || status === STATUS_KEEP;
          return /* @__PURE__ */ React.createElement(CSSMotion$1, _extends$3({}, motionProps, {
            key: eventProps.key,
            visible,
            eventProps,
            onVisibleChanged: function onVisibleChanged(changedVisible) {
              _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                key: eventProps.key
              });
              if (!changedVisible) {
                var restKeysCount = _this2.removeKey(eventProps.key);
                if (restKeysCount === 0 && onAllRemoved) {
                  onAllRemoved();
                }
              }
            }
          }), children);
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref3, _ref4) {
        var keys2 = _ref3.keys;
        var keyEntities = _ref4.keyEntities;
        var parsedKeyObjects = parseKeys(keys2);
        var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
        return {
          keyEntities: mixedKeyEntities.filter(function(entity) {
            var prevEntity = keyEntities.find(function(_ref5) {
              var key = _ref5.key;
              return entity.key === key;
            });
            if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
              return false;
            }
            return true;
          })
        };
      }
    }]);
    return CSSMotionList3;
  }(React.Component);
  CSSMotionList2.defaultProps = {
    component: "div"
  };
  return CSSMotionList2;
}
var CSSMotionList = genCSSMotionList(supportTransition);
var es$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CSSMotionList,
  "default": CSSMotion
}, Symbol.toStringTag, { value: "Module" }));
const {
  isValidElement: isValidElement$1
} = React;
function isFragment$1(child) {
  return child && isValidElement$1(child) && child.type === React.Fragment;
}
function replaceElement$1(element2, replacement, props) {
  if (!isValidElement$1(element2)) {
    return replacement;
  }
  return /* @__PURE__ */ React.cloneElement(element2, typeof props === "function" ? props(element2.props || {}) : props);
}
function cloneElement$1(element2, props) {
  return replaceElement$1(element2, element2, props);
}
function useEvent$6(callback) {
  var fnRef = React.useRef();
  fnRef.current = callback;
  var memoFn = React.useCallback(function() {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
var KeyCode$5 = {
  MAC_ENTER: 3,
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  PRINT_SCREEN: 44,
  INSERT: 45,
  DELETE: 46,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  QUESTION_MARK: 63,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  META: 91,
  WIN_KEY_RIGHT: 92,
  CONTEXT_MENU: 93,
  NUM_ZERO: 96,
  NUM_ONE: 97,
  NUM_TWO: 98,
  NUM_THREE: 99,
  NUM_FOUR: 100,
  NUM_FIVE: 101,
  NUM_SIX: 102,
  NUM_SEVEN: 103,
  NUM_EIGHT: 104,
  NUM_NINE: 105,
  NUM_MULTIPLY: 106,
  NUM_PLUS: 107,
  NUM_MINUS: 109,
  NUM_PERIOD: 110,
  NUM_DIVISION: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SEMICOLON: 186,
  DASH: 189,
  EQUALS: 187,
  COMMA: 188,
  PERIOD: 190,
  SLASH: 191,
  APOSTROPHE: 192,
  SINGLE_QUOTE: 222,
  OPEN_SQUARE_BRACKET: 219,
  BACKSLASH: 220,
  CLOSE_SQUARE_BRACKET: 221,
  WIN_KEY: 224,
  MAC_FF_META: 224,
  WIN_IME: 229,
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
    var keyCode = e2.keyCode;
    if (e2.altKey && !e2.ctrlKey || e2.metaKey || keyCode >= KeyCode$5.F1 && keyCode <= KeyCode$5.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode$5.ALT:
      case KeyCode$5.CAPS_LOCK:
      case KeyCode$5.CONTEXT_MENU:
      case KeyCode$5.CTRL:
      case KeyCode$5.DOWN:
      case KeyCode$5.END:
      case KeyCode$5.ESC:
      case KeyCode$5.HOME:
      case KeyCode$5.INSERT:
      case KeyCode$5.LEFT:
      case KeyCode$5.MAC_FF_META:
      case KeyCode$5.META:
      case KeyCode$5.NUMLOCK:
      case KeyCode$5.NUM_CENTER:
      case KeyCode$5.PAGE_DOWN:
      case KeyCode$5.PAGE_UP:
      case KeyCode$5.PAUSE:
      case KeyCode$5.PRINT_SCREEN:
      case KeyCode$5.RIGHT:
      case KeyCode$5.SHIFT:
      case KeyCode$5.UP:
      case KeyCode$5.WIN_KEY:
      case KeyCode$5.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode$5.ZERO && keyCode <= KeyCode$5.NINE) {
      return true;
    }
    if (keyCode >= KeyCode$5.NUM_ZERO && keyCode <= KeyCode$5.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode$5.A && keyCode <= KeyCode$5.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode$5.SPACE:
      case KeyCode$5.QUESTION_MARK:
      case KeyCode$5.NUM_PLUS:
      case KeyCode$5.NUM_MINUS:
      case KeyCode$5.NUM_PERIOD:
      case KeyCode$5.NUM_DIVISION:
      case KeyCode$5.SEMICOLON:
      case KeyCode$5.DASH:
      case KeyCode$5.EQUALS:
      case KeyCode$5.COMMA:
      case KeyCode$5.PERIOD:
      case KeyCode$5.SLASH:
      case KeyCode$5.APOSTROPHE:
      case KeyCode$5.SINGLE_QUOTE:
      case KeyCode$5.OPEN_SQUARE_BRACKET:
      case KeyCode$5.BACKSLASH:
      case KeyCode$5.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
var LoadingOutlined$5 = function LoadingOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: LoadingOutlinedSvg
  }));
};
LoadingOutlined$5.displayName = "LoadingOutlined";
var LoadingOutlined$6 = /* @__PURE__ */ React.forwardRef(LoadingOutlined$5);
function usePatchElement() {
  const [elements, setElements] = React.useState([]);
  const patchElement = React.useCallback((element2) => {
    setElements((originElements) => [].concat(_toConsumableArray(originElements), [element2]));
    return () => {
      setElements((originElements) => originElements.filter((ele) => ele !== element2));
    };
  }, []);
  return [elements, patchElement];
}
var fullClone$1 = _objectSpread2$d({}, ReactDOM);
var version$3 = fullClone$1.version, reactRender$1 = fullClone$1.render, unmountComponentAtNode$1 = fullClone$1.unmountComponentAtNode;
var createRoot$1;
try {
  var mainVersion$1 = Number((version$3 || "").split(".")[0]);
  if (mainVersion$1 >= 18) {
    createRoot$1 = fullClone$1.createRoot;
  }
} catch (e2) {
}
function toggleWarning$1(skip) {
  var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof$8(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
  }
}
var MARK$1 = "__rc_react_root__";
function modernRender$1(node2, container) {
  toggleWarning$1(true);
  var root2 = container[MARK$1] || createRoot$1(container);
  toggleWarning$1(false);
  root2.render(node2);
  container[MARK$1] = root2;
}
function legacyRender$1(node2, container) {
  reactRender$1(node2, container);
}
function render$2(node2, container) {
  if (createRoot$1) {
    modernRender$1(node2, container);
    return;
  }
  legacyRender$1(node2, container);
}
function modernUnmount$1(_x) {
  return _modernUnmount$1.apply(this, arguments);
}
function _modernUnmount$1() {
  _modernUnmount$1 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(container) {
    return _regeneratorRuntime().wrap(function _callee$(_context2) {
      while (1)
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", Promise.resolve().then(function() {
              var _container$MARK;
              (_container$MARK = container[MARK$1]) === null || _container$MARK === void 0 ? void 0 : _container$MARK.unmount();
              delete container[MARK$1];
            }));
          case 1:
          case "end":
            return _context2.stop();
        }
    }, _callee);
  }));
  return _modernUnmount$1.apply(this, arguments);
}
function legacyUnmount$1(container) {
  unmountComponentAtNode$1(container);
}
function unmount$1(_x2) {
  return _unmount$1.apply(this, arguments);
}
function _unmount$1() {
  _unmount$1 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(container) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1)
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(createRoot$1 !== void 0)) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return", modernUnmount$1(container));
          case 2:
            legacyUnmount$1(container);
          case 3:
          case "end":
            return _context2.stop();
        }
    }, _callee2);
  }));
  return _unmount$1.apply(this, arguments);
}
function useSafeState$3(defaultValue) {
  var destroyRef = React.useRef(false);
  var _React$useState = React.useState(defaultValue), _React$useState2 = _slicedToArray$1(_React$useState, 2), value = _React$useState2[0], setValue2 = _React$useState2[1];
  React.useEffect(function() {
    destroyRef.current = false;
    return function() {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue2(updater);
  }
  return [value, safeSetState];
}
function toArray$9(children) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var ret = [];
  React.Children.forEach(children, function(child) {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray$9(child));
    } else if (reactIs$2.exports.isFragment(child) && child.props) {
      ret = ret.concat(toArray$9(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}
const genSpaceCompactStyle$1 = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-block": {
        display: "flex",
        width: "100%"
      },
      "&-vertical": {
        flexDirection: "column"
      }
    }
  };
};
var genSpaceCompactStyle$2 = genSpaceCompactStyle$1;
const genSpaceStyle$1 = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-align": {
        flexDirection: "column",
        "&-center": {
          alignItems: "center"
        },
        "&-start": {
          alignItems: "flex-start"
        },
        "&-end": {
          alignItems: "flex-end"
        },
        "&-baseline": {
          alignItems: "baseline"
        }
      },
      [`${componentCls}-item`]: {
        "&:empty": {
          display: "none"
        }
      }
    }
  };
};
var useStyle$i = genComponentStyleHook$2("Space", (token2) => [genSpaceStyle$1(token2), genSpaceCompactStyle$2(token2)]);
var __rest$D = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const SpaceCompactItemContext$1 = /* @__PURE__ */ React.createContext(null);
const useCompactItemContext$1 = (prefixCls, direction) => {
  const compactItemContext = React.useContext(SpaceCompactItemContext$1);
  const compactItemClassnames = React.useMemo(() => {
    if (!compactItemContext)
      return "";
    const {
      compactDirection,
      isFirstItem,
      isLastItem
    } = compactItemContext;
    const separator = compactDirection === "vertical" ? "-vertical-" : "-";
    return classNames({
      [`${prefixCls}-compact${separator}item`]: true,
      [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
      [`${prefixCls}-compact${separator}last-item`]: isLastItem,
      [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
    });
  }, [prefixCls, direction, compactItemContext]);
  return {
    compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
    compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
    compactItemClassnames
  };
};
const NoCompactStyle$1 = (_ref2) => {
  let {
    children
  } = _ref2;
  return /* @__PURE__ */ React.createElement(SpaceCompactItemContext$1.Provider, {
    value: null
  }, children);
};
const CompactItem$1 = (_a2) => {
  var {
    children
  } = _a2, otherProps = __rest$D(_a2, ["children"]);
  return /* @__PURE__ */ React.createElement(SpaceCompactItemContext$1.Provider, {
    value: otherProps
  }, children);
};
const Compact$2 = (props) => {
  const {
    getPrefixCls,
    direction: directionConfig
  } = React.useContext(ConfigContext$1);
  const {
    size = "middle",
    direction,
    block: block2,
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children
  } = props, restProps = __rest$D(props, ["size", "direction", "block", "prefixCls", "className", "rootClassName", "children"]);
  const prefixCls = getPrefixCls("space-compact", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$i(prefixCls);
  const clx = classNames(prefixCls, hashId, {
    [`${prefixCls}-rtl`]: directionConfig === "rtl",
    [`${prefixCls}-block`]: block2,
    [`${prefixCls}-vertical`]: direction === "vertical"
  }, className, rootClassName);
  const compactItemContext = React.useContext(SpaceCompactItemContext$1);
  const childNodes = toArray$9(children);
  const nodes = React.useMemo(() => childNodes.map((child, i) => {
    const key = child && child.key || `${prefixCls}-item-${i}`;
    return /* @__PURE__ */ React.createElement(CompactItem$1, {
      key,
      compactSize: size,
      compactDirection: direction,
      isFirstItem: i === 0 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isFirstItem)),
      isLastItem: i === childNodes.length - 1 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isLastItem))
    }, child);
  }), [size, childNodes, compactItemContext]);
  if (childNodes.length === 0) {
    return null;
  }
  return wrapSSR(/* @__PURE__ */ React.createElement("div", Object.assign({
    className: clx
  }, restProps), nodes));
};
var Compact$3 = Compact$2;
function fillRef$6(ref2, node2) {
  if (typeof ref2 === "function") {
    ref2(node2);
  } else if (_typeof$8(ref2) === "object" && ref2 && "current" in ref2) {
    ref2.current = node2;
  }
}
function composeRef$6() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function(ref2) {
    return ref2;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function(node2) {
    refs.forEach(function(ref2) {
      fillRef$6(ref2, node2);
    });
  };
}
function useComposeRef$5() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }
  return useMemo$6(function() {
    return composeRef$6.apply(void 0, refs);
  }, refs, function(prev2, next2) {
    return prev2.length === next2.length && prev2.every(function(ref2, i) {
      return ref2 === next2[i];
    });
  });
}
function supportRef$4(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type4 = reactIs$2.exports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  if (typeof type4 === "function" && !((_type$prototype = type4.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
    return false;
  }
  if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
    return false;
  }
  return true;
}
var isVisible$4 = function(element2) {
  if (!element2) {
    return false;
  }
  if (element2 instanceof Element) {
    if (element2.offsetParent) {
      return true;
    }
    if (element2.getBBox) {
      var _getBBox = element2.getBBox(), width = _getBBox.width, height = _getBBox.height;
      if (width || height) {
        return true;
      }
    }
    if (element2.getBoundingClientRect) {
      var _element$getBoundingC = element2.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
      if (_width || _height) {
        return true;
      }
    }
  }
  return false;
};
const genWaveStyle$1 = (token2) => {
  const {
    componentCls,
    colorPrimary
  } = token2;
  return {
    [componentCls]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${colorPrimary})`,
      boxShadow: `0 0 0 0 currentcolor`,
      opacity: 0.2,
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: `0 0 0 6px currentcolor`,
          opacity: 0
        }
      }
    }
  };
};
var useStyle$h = genComponentStyleHook$2("Wave", (token2) => [genWaveStyle$1(token2)]);
function isNotGrey$1(color2) {
  const match2 = (color2 || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  if (match2 && match2[1] && match2[2] && match2[3]) {
    return !(match2[1] === match2[2] && match2[2] === match2[3]);
  }
  return true;
}
function isValidWaveColor$1(color2) {
  return color2 && color2 !== "#fff" && color2 !== "#ffffff" && color2 !== "rgb(255, 255, 255)" && color2 !== "rgba(255, 255, 255, 1)" && isNotGrey$1(color2) && !/rgba\((?:\d*, ){3}0\)/.test(color2) && color2 !== "transparent";
}
function getTargetWaveColor$1(node2) {
  const {
    borderTopColor,
    borderColor,
    backgroundColor
  } = getComputedStyle(node2);
  if (isValidWaveColor$1(borderTopColor)) {
    return borderTopColor;
  }
  if (isValidWaveColor$1(borderColor)) {
    return borderColor;
  }
  if (isValidWaveColor$1(backgroundColor)) {
    return backgroundColor;
  }
  return null;
}
function validateNum$1(value) {
  return Number.isNaN(value) ? 0 : value;
}
const WaveEffect$2 = (props) => {
  const {
    className,
    target
  } = props;
  const divRef = React.useRef(null);
  const [color2, setWaveColor] = React.useState(null);
  const [borderRadius, setBorderRadius] = React.useState([]);
  const [left, setLeft] = React.useState(0);
  const [top, setTop] = React.useState(0);
  const [width, setWidth] = React.useState(0);
  const [height, setHeight] = React.useState(0);
  const [enabled, setEnabled] = React.useState(false);
  const waveStyle = {
    left,
    top,
    width,
    height,
    borderRadius: borderRadius.map((radius) => `${radius}px`).join(" ")
  };
  if (color2) {
    waveStyle["--wave-color"] = color2;
  }
  function syncPos() {
    const nodeStyle = getComputedStyle(target);
    setWaveColor(getTargetWaveColor$1(target));
    const isStatic = nodeStyle.position === "static";
    const {
      borderLeftWidth,
      borderTopWidth
    } = nodeStyle;
    setLeft(isStatic ? target.offsetLeft : validateNum$1(-parseFloat(borderLeftWidth)));
    setTop(isStatic ? target.offsetTop : validateNum$1(-parseFloat(borderTopWidth)));
    setWidth(target.offsetWidth);
    setHeight(target.offsetHeight);
    const {
      borderTopLeftRadius,
      borderTopRightRadius,
      borderBottomLeftRadius,
      borderBottomRightRadius
    } = nodeStyle;
    setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius) => validateNum$1(parseFloat(radius))));
  }
  React.useEffect(() => {
    if (target) {
      const id = wrapperRaf$7(() => {
        syncPos();
        setEnabled(true);
      });
      let resizeObserver2;
      if (typeof ResizeObserver !== "undefined") {
        resizeObserver2 = new ResizeObserver(syncPos);
        resizeObserver2.observe(target);
      }
      return () => {
        wrapperRaf$7.cancel(id);
        resizeObserver2 === null || resizeObserver2 === void 0 ? void 0 : resizeObserver2.disconnect();
      };
    }
  }, []);
  if (!enabled) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(CSSMotion, {
    visible: true,
    motionAppear: true,
    motionName: "wave-motion",
    motionDeadline: 5e3,
    onAppearEnd: (_24, event) => {
      var _a2;
      if (event.deadline || event.propertyName === "opacity") {
        const holder = (_a2 = divRef.current) === null || _a2 === void 0 ? void 0 : _a2.parentElement;
        unmount$1(holder).then(() => {
          var _a3;
          (_a3 = holder.parentElement) === null || _a3 === void 0 ? void 0 : _a3.removeChild(holder);
        });
      }
      return false;
    }
  }, (_ref2) => {
    let {
      className: motionClassName
    } = _ref2;
    return /* @__PURE__ */ React.createElement("div", {
      ref: divRef,
      className: classNames(className, motionClassName),
      style: waveStyle
    });
  });
};
function showWaveEffect$1(node2, className) {
  const holder = document.createElement("div");
  holder.style.position = "absolute";
  holder.style.left = `0px`;
  holder.style.top = `0px`;
  node2 === null || node2 === void 0 ? void 0 : node2.insertBefore(holder, node2 === null || node2 === void 0 ? void 0 : node2.firstChild);
  render$2(/* @__PURE__ */ React.createElement(WaveEffect$2, {
    target: node2,
    className
  }), holder);
}
function useWave$2(nodeRef, className) {
  function showWave() {
    const node2 = nodeRef.current;
    showWaveEffect$1(node2, className);
  }
  return showWave;
}
const Wave$1 = (props) => {
  const {
    children,
    disabled
  } = props;
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const containerRef = React.useRef(null);
  const prefixCls = getPrefixCls("wave");
  const [, hashId] = useStyle$h(prefixCls);
  const showWave = useWave$2(containerRef, classNames(prefixCls, hashId));
  React.useEffect(() => {
    const node2 = containerRef.current;
    if (!node2 || node2.nodeType !== 1 || disabled) {
      return;
    }
    const onClick = (e2) => {
      if (e2.target.tagName === "INPUT" || !isVisible$4(e2.target) || !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
        return;
      }
      showWave();
    };
    node2.addEventListener("click", onClick, true);
    return () => {
      node2.removeEventListener("click", onClick, true);
    };
  }, [disabled]);
  if (!/* @__PURE__ */ React.isValidElement(children)) {
    return children !== null && children !== void 0 ? children : null;
  }
  const ref2 = supportRef$4(children) ? composeRef$6(children.ref, containerRef) : containerRef;
  return cloneElement$1(children, {
    ref: ref2
  });
};
var Wave$2 = Wave$1;
var __rest$C = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const GroupSizeContext$1 = /* @__PURE__ */ React.createContext(void 0);
const ButtonGroup$1 = (props) => {
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext$1);
  const {
    prefixCls: customizePrefixCls,
    size,
    className
  } = props, others = __rest$C(props, ["prefixCls", "size", "className"]);
  const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
  const [, , hashId] = useToken$2();
  let sizeCls = "";
  switch (size) {
    case "large":
      sizeCls = "lg";
      break;
    case "small":
      sizeCls = "sm";
      break;
  }
  const classes = classNames(prefixCls, {
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, hashId);
  return /* @__PURE__ */ React.createElement(GroupSizeContext$1.Provider, {
    value: size
  }, /* @__PURE__ */ React.createElement("div", Object.assign({}, others, {
    className: classes
  })));
};
var Group$1 = ButtonGroup$1;
const rxTwoCNChar$1 = /^[\u4e00-\u9fa5]{2}$/;
const isTwoCNChar$1 = rxTwoCNChar$1.test.bind(rxTwoCNChar$1);
function isString$1(str) {
  return typeof str === "string";
}
function isUnBorderedButtonType$1(type4) {
  return type4 === "text" || type4 === "link";
}
function splitCNCharsBySpace$1(child, needInserted) {
  if (child === null || child === void 0) {
    return;
  }
  const SPACE = needInserted ? " " : "";
  if (typeof child !== "string" && typeof child !== "number" && isString$1(child.type) && isTwoCNChar$1(child.props.children)) {
    return cloneElement$1(child, {
      children: child.props.children.split("").join(SPACE)
    });
  }
  if (typeof child === "string") {
    return isTwoCNChar$1(child) ? /* @__PURE__ */ React.createElement("span", null, child.split("").join(SPACE)) : /* @__PURE__ */ React.createElement("span", null, child);
  }
  if (isFragment$1(child)) {
    return /* @__PURE__ */ React.createElement("span", null, child);
  }
  return child;
}
function spaceChildren$1(children, needInserted) {
  let isPrevChildPure = false;
  const childList = [];
  React.Children.forEach(children, (child) => {
    const type4 = typeof child;
    const isCurrentChildPure = type4 === "string" || type4 === "number";
    if (isPrevChildPure && isCurrentChildPure) {
      const lastIndex = childList.length - 1;
      const lastChild = childList[lastIndex];
      childList[lastIndex] = `${lastChild}${child}`;
    } else {
      childList.push(child);
    }
    isPrevChildPure = isCurrentChildPure;
  });
  return React.Children.map(childList, (child) => splitCNCharsBySpace$1(child, needInserted));
}
const getCollapsedWidth$1 = () => ({
  width: 0,
  opacity: 0,
  transform: "scale(0)"
});
const getRealWidth$1 = (node2) => ({
  width: node2.scrollWidth,
  opacity: 1,
  transform: "scale(1)"
});
const LoadingIcon$3 = (_ref2) => {
  let {
    prefixCls,
    loading,
    existIcon
  } = _ref2;
  const visible = !!loading;
  if (existIcon) {
    return /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-loading-icon`
    }, /* @__PURE__ */ React.createElement(LoadingOutlined$6, null));
  }
  return /* @__PURE__ */ React.createElement(CSSMotion, {
    visible,
    motionName: `${prefixCls}-loading-icon-motion`,
    removeOnLeave: true,
    onAppearStart: getCollapsedWidth$1,
    onAppearActive: getRealWidth$1,
    onEnterStart: getCollapsedWidth$1,
    onEnterActive: getRealWidth$1,
    onLeaveStart: getRealWidth$1,
    onLeaveActive: getCollapsedWidth$1
  }, (_ref22, ref2) => {
    let {
      className,
      style: style2
    } = _ref22;
    return /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-loading-icon`,
      style: style2,
      ref: ref2
    }, /* @__PURE__ */ React.createElement(LoadingOutlined$6, {
      className
    }));
  });
};
var LoadingIcon$4 = LoadingIcon$3;
const genButtonBorderStyle$1 = (buttonTypeCls, borderColor) => ({
  [`> span, > ${buttonTypeCls}`]: {
    "&:not(:last-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: borderColor
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: borderColor
        }
      }
    }
  }
});
const genGroupStyle$2 = (token2) => {
  const {
    componentCls,
    fontSize,
    lineWidth,
    colorPrimaryHover,
    colorErrorHover
  } = token2;
  return {
    [`${componentCls}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        [`> span, > ${componentCls}`]: {
          "&:not(:last-child)": {
            [`&, & > ${componentCls}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: -lineWidth,
            [`&, & > ${componentCls}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [componentCls]: {
          position: "relative",
          zIndex: 1,
          [`&:hover,
          &:focus,
          &:active`]: {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${componentCls}-icon-only`]: {
          fontSize
        }
      },
      genButtonBorderStyle$1(`${componentCls}-primary`, colorPrimaryHover),
      genButtonBorderStyle$1(`${componentCls}-danger`, colorErrorHover)
    ]
  };
};
var genGroupStyle$3 = genGroupStyle$2;
function compactItemBorder$1(token2, parentCls, options) {
  const {
    focusElCls,
    focus,
    borderElCls
  } = options;
  const childCombinator = borderElCls ? "> *" : "";
  const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
  return {
    [`&-item:not(${parentCls}-last-item)`]: {
      marginInlineEnd: -token2.lineWidth
    },
    "&-item": Object.assign(Object.assign({
      [hoverEffects]: {
        zIndex: 2
      }
    }, focusElCls ? {
      [`&${focusElCls}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${childCombinator}`]: {
        zIndex: 0
      }
    })
  };
}
function compactItemBorderRadius$1(prefixCls, parentCls, options) {
  const {
    borderElCls
  } = options;
  const childCombinator = borderElCls ? `> ${borderElCls}` : "";
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
      borderRadius: 0
    },
    [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function genCompactItemStyle$1(token2) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: true
  };
  const {
    componentCls
  } = token2;
  const compactCls = `${componentCls}-compact`;
  return {
    [compactCls]: Object.assign(Object.assign({}, compactItemBorder$1(token2, compactCls, options)), compactItemBorderRadius$1(componentCls, compactCls, options))
  };
}
function compactItemVerticalBorder$1(token2, parentCls) {
  return {
    [`&-item:not(${parentCls}-last-item)`]: {
      marginBottom: -token2.lineWidth
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function compactItemBorderVerticalRadius$1(prefixCls, parentCls) {
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function genCompactItemVerticalStyle$1(token2) {
  const compactCls = `${token2.componentCls}-compact-vertical`;
  return {
    [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder$1(token2, compactCls)), compactItemBorderVerticalRadius$1(token2.componentCls, compactCls))
  };
}
const genSharedButtonStyle$1 = (token2) => {
  const {
    componentCls,
    iconCls
  } = token2;
  return {
    [componentCls]: {
      outline: "none",
      position: "relative",
      display: "inline-block",
      fontWeight: 400,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      backgroundColor: "transparent",
      border: `${token2.lineWidth}px ${token2.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      lineHeight: token2.lineHeight,
      color: token2.colorText,
      "> span": {
        display: "inline-block"
      },
      [`> ${iconCls} + span, > span + ${iconCls}`]: {
        marginInlineStart: token2.marginXS
      },
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": Object.assign({}, genFocusStyle(token2)),
      [`&-icon-only${componentCls}-compact-item`]: {
        flex: "none"
      },
      [`&-compact-item${componentCls}-primary`]: {
        [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
          position: "relative",
          "&:before": {
            position: "absolute",
            top: -token2.lineWidth,
            insetInlineStart: -token2.lineWidth,
            display: "inline-block",
            width: token2.lineWidth,
            height: `calc(100% + ${token2.lineWidth * 2}px)`,
            backgroundColor: token2.colorPrimaryHover,
            content: '""'
          }
        }
      },
      "&-compact-vertical-item": {
        [`&${componentCls}-primary`]: {
          [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: -token2.lineWidth,
              insetInlineStart: -token2.lineWidth,
              display: "inline-block",
              width: `calc(100% + ${token2.lineWidth * 2}px)`,
              height: token2.lineWidth,
              backgroundColor: token2.colorPrimaryHover,
              content: '""'
            }
          }
        }
      }
    }
  };
};
const genHoverActiveButtonStyle$1 = (hoverStyle, activeStyle) => ({
  "&:not(:disabled)": {
    "&:hover": hoverStyle,
    "&:active": activeStyle
  }
});
const genCircleButtonStyle$1 = (token2) => ({
  minWidth: token2.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
});
const genRoundButtonStyle$1 = (token2) => ({
  borderRadius: token2.controlHeight,
  paddingInlineStart: token2.controlHeight / 2,
  paddingInlineEnd: token2.controlHeight / 2
});
const genDisabledStyle$3 = (token2) => ({
  cursor: "not-allowed",
  borderColor: token2.colorBorder,
  color: token2.colorTextDisabled,
  backgroundColor: token2.colorBgContainerDisabled,
  boxShadow: "none"
});
const genGhostButtonStyle$1 = (btnCls, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
  [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
    color: textColor || void 0,
    backgroundColor: "transparent",
    borderColor: borderColor || void 0,
    boxShadow: "none"
  }, genHoverActiveButtonStyle$1(Object.assign({
    backgroundColor: "transparent"
  }, hoverStyle), Object.assign({
    backgroundColor: "transparent"
  }, activeStyle))), {
    "&:disabled": {
      cursor: "not-allowed",
      color: textColorDisabled || void 0,
      borderColor: borderColorDisabled || void 0
    }
  })
});
const genSolidDisabledButtonStyle$1 = (token2) => ({
  "&:disabled": Object.assign({}, genDisabledStyle$3(token2))
});
const genSolidButtonStyle$1 = (token2) => Object.assign({}, genSolidDisabledButtonStyle$1(token2));
const genPureDisabledButtonStyle$1 = (token2) => ({
  "&:disabled": {
    cursor: "not-allowed",
    color: token2.colorTextDisabled
  }
});
const genDefaultButtonStyle$1 = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle$1(token2)), {
  backgroundColor: token2.colorBgContainer,
  borderColor: token2.colorBorder,
  boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`
}), genHoverActiveButtonStyle$1({
  color: token2.colorPrimaryHover,
  borderColor: token2.colorPrimaryHover
}, {
  color: token2.colorPrimaryActive,
  borderColor: token2.colorPrimaryActive
})), genGhostButtonStyle$1(token2.componentCls, token2.colorBgContainer, token2.colorBgContainer, token2.colorTextDisabled, token2.colorBorder)), {
  [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    color: token2.colorError,
    borderColor: token2.colorError
  }, genHoverActiveButtonStyle$1({
    color: token2.colorErrorHover,
    borderColor: token2.colorErrorBorderHover
  }, {
    color: token2.colorErrorActive,
    borderColor: token2.colorErrorActive
  })), genGhostButtonStyle$1(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder)), genSolidDisabledButtonStyle$1(token2))
});
const genPrimaryButtonStyle$1 = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle$1(token2)), {
  color: token2.colorTextLightSolid,
  backgroundColor: token2.colorPrimary,
  boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`
}), genHoverActiveButtonStyle$1({
  color: token2.colorTextLightSolid,
  backgroundColor: token2.colorPrimaryHover
}, {
  color: token2.colorTextLightSolid,
  backgroundColor: token2.colorPrimaryActive
})), genGhostButtonStyle$1(token2.componentCls, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
  color: token2.colorPrimaryHover,
  borderColor: token2.colorPrimaryHover
}, {
  color: token2.colorPrimaryActive,
  borderColor: token2.colorPrimaryActive
})), {
  [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    backgroundColor: token2.colorError,
    boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`
  }, genHoverActiveButtonStyle$1({
    backgroundColor: token2.colorErrorHover
  }, {
    backgroundColor: token2.colorErrorActive
  })), genGhostButtonStyle$1(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
    color: token2.colorErrorHover,
    borderColor: token2.colorErrorHover
  }, {
    color: token2.colorErrorActive,
    borderColor: token2.colorErrorActive
  })), genSolidDisabledButtonStyle$1(token2))
});
const genDashedButtonStyle$1 = (token2) => Object.assign(Object.assign({}, genDefaultButtonStyle$1(token2)), {
  borderStyle: "dashed"
});
const genLinkButtonStyle$1 = (token2) => Object.assign(Object.assign(Object.assign({
  color: token2.colorLink
}, genHoverActiveButtonStyle$1({
  color: token2.colorLinkHover
}, {
  color: token2.colorLinkActive
})), genPureDisabledButtonStyle$1(token2)), {
  [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: token2.colorError
  }, genHoverActiveButtonStyle$1({
    color: token2.colorErrorHover
  }, {
    color: token2.colorErrorActive
  })), genPureDisabledButtonStyle$1(token2))
});
const genTextButtonStyle$1 = (token2) => Object.assign(Object.assign(Object.assign({}, genHoverActiveButtonStyle$1({
  color: token2.colorText,
  backgroundColor: token2.colorBgTextHover
}, {
  color: token2.colorText,
  backgroundColor: token2.colorBgTextActive
})), genPureDisabledButtonStyle$1(token2)), {
  [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: token2.colorError
  }, genPureDisabledButtonStyle$1(token2)), genHoverActiveButtonStyle$1({
    color: token2.colorErrorHover,
    backgroundColor: token2.colorErrorBg
  }, {
    color: token2.colorErrorHover,
    backgroundColor: token2.colorErrorBg
  }))
});
const genDisabledButtonStyle$1 = (token2) => Object.assign(Object.assign({}, genDisabledStyle$3(token2)), {
  [`&${token2.componentCls}:hover`]: Object.assign({}, genDisabledStyle$3(token2))
});
const genTypeButtonStyle$1 = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-default`]: genDefaultButtonStyle$1(token2),
    [`${componentCls}-primary`]: genPrimaryButtonStyle$1(token2),
    [`${componentCls}-dashed`]: genDashedButtonStyle$1(token2),
    [`${componentCls}-link`]: genLinkButtonStyle$1(token2),
    [`${componentCls}-text`]: genTextButtonStyle$1(token2),
    [`${componentCls}-disabled`]: genDisabledButtonStyle$1(token2)
  };
};
const genSizeButtonStyle$1 = function(token2) {
  let sizePrefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const {
    componentCls,
    iconCls,
    controlHeight,
    fontSize,
    lineHeight,
    lineWidth,
    borderRadius,
    buttonPaddingHorizontal
  } = token2;
  const paddingVertical = Math.max(0, (controlHeight - fontSize * lineHeight) / 2 - lineWidth);
  const paddingHorizontal = buttonPaddingHorizontal - lineWidth;
  const iconOnlyCls = `${componentCls}-icon-only`;
  return [
    {
      [`${componentCls}${sizePrefixCls}`]: {
        fontSize,
        height: controlHeight,
        padding: `${paddingVertical}px ${paddingHorizontal}px`,
        borderRadius,
        [`&${iconOnlyCls}`]: {
          width: controlHeight,
          paddingInlineStart: 0,
          paddingInlineEnd: 0,
          [`&${componentCls}-round`]: {
            width: "auto"
          },
          "> span": {
            transform: "scale(1.143)"
          }
        },
        [`&${componentCls}-loading`]: {
          opacity: token2.opacityLoading,
          cursor: "default"
        },
        [`${componentCls}-loading-icon`]: {
          transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
        },
        [`&:not(${iconOnlyCls}) ${componentCls}-loading-icon > ${iconCls}`]: {
          marginInlineEnd: token2.marginXS
        }
      }
    },
    {
      [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle$1(token2)
    },
    {
      [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle$1(token2)
    }
  ];
};
const genSizeBaseButtonStyle$1 = (token2) => genSizeButtonStyle$1(token2);
const genSizeSmallButtonStyle$1 = (token2) => {
  const smallToken = merge$1(token2, {
    controlHeight: token2.controlHeightSM,
    padding: token2.paddingXS,
    buttonPaddingHorizontal: 8,
    borderRadius: token2.borderRadiusSM
  });
  return genSizeButtonStyle$1(smallToken, `${token2.componentCls}-sm`);
};
const genSizeLargeButtonStyle$1 = (token2) => {
  const largeToken = merge$1(token2, {
    controlHeight: token2.controlHeightLG,
    fontSize: token2.fontSizeLG,
    borderRadius: token2.borderRadiusLG
  });
  return genSizeButtonStyle$1(largeToken, `${token2.componentCls}-lg`);
};
const genBlockButtonStyle$1 = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      [`&${componentCls}-block`]: {
        width: "100%"
      }
    }
  };
};
var useStyle$g = genComponentStyleHook$2("Button", (token2) => {
  const {
    controlTmpOutline,
    paddingContentHorizontal
  } = token2;
  const buttonToken = merge$1(token2, {
    colorOutlineDefault: controlTmpOutline,
    buttonPaddingHorizontal: paddingContentHorizontal
  });
  return [
    genSharedButtonStyle$1(buttonToken),
    genSizeSmallButtonStyle$1(buttonToken),
    genSizeBaseButtonStyle$1(buttonToken),
    genSizeLargeButtonStyle$1(buttonToken),
    genBlockButtonStyle$1(buttonToken),
    genTypeButtonStyle$1(buttonToken),
    genGroupStyle$3(buttonToken),
    genCompactItemStyle$1(token2),
    genCompactItemVerticalStyle$1(token2)
  ];
});
var __rest$B = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function convertLegacyProps$1(type4) {
  if (type4 === "danger") {
    return {
      danger: true
    };
  }
  return {
    type: type4
  };
}
function getLoadingConfig$1(loading) {
  if (typeof loading === "object" && loading) {
    const delay = loading === null || loading === void 0 ? void 0 : loading.delay;
    const isDelay = !Number.isNaN(delay) && typeof delay === "number";
    return {
      loading: false,
      delay: isDelay ? delay : 0
    };
  }
  return {
    loading: !!loading,
    delay: 0
  };
}
const InternalButton$1 = (props, ref2) => {
  const {
    loading = false,
    prefixCls: customizePrefixCls,
    type: type4 = "default",
    danger,
    shape = "default",
    size: customizeSize,
    disabled: customDisabled,
    className,
    rootClassName,
    children,
    icon,
    ghost = false,
    block: block2 = false,
    htmlType = "button"
  } = props, rest = __rest$B(props, ["loading", "prefixCls", "type", "danger", "shape", "size", "disabled", "className", "rootClassName", "children", "icon", "ghost", "block", "htmlType"]);
  const {
    getPrefixCls,
    autoInsertSpaceInButton,
    direction
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("btn", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$g(prefixCls);
  const size = React.useContext(SizeContext$3);
  const disabled = React.useContext(DisabledContext$3);
  const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  const groupSize = React.useContext(GroupSizeContext$1);
  const loadingOrDelay = React.useMemo(() => getLoadingConfig$1(loading), [loading]);
  const [innerLoading, setLoading] = React.useState(loadingOrDelay.loading);
  const [hasTwoCNChar, setHasTwoCNChar] = React.useState(false);
  const buttonRef = ref2 || /* @__PURE__ */ React.createRef();
  const isNeedInserted = () => React.Children.count(children) === 1 && !icon && !isUnBorderedButtonType$1(type4);
  const fixTwoCNChar = () => {
    if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
      return;
    }
    const buttonText = buttonRef.current.textContent;
    if (isNeedInserted() && isTwoCNChar$1(buttonText)) {
      if (!hasTwoCNChar) {
        setHasTwoCNChar(true);
      }
    } else if (hasTwoCNChar) {
      setHasTwoCNChar(false);
    }
  };
  React.useEffect(() => {
    let delayTimer = null;
    if (loadingOrDelay.delay > 0) {
      delayTimer = window.setTimeout(() => {
        delayTimer = null;
        setLoading(true);
      }, loadingOrDelay.delay);
    } else {
      setLoading(loadingOrDelay.loading);
    }
    function cleanupTimer() {
      if (delayTimer) {
        window.clearTimeout(delayTimer);
        delayTimer = null;
      }
    }
    return cleanupTimer;
  }, [loadingOrDelay]);
  React.useEffect(fixTwoCNChar, [buttonRef]);
  const handleClick = (e2) => {
    const {
      onClick
    } = props;
    if (innerLoading || mergedDisabled) {
      e2.preventDefault();
      return;
    }
    onClick === null || onClick === void 0 ? void 0 : onClick(e2);
  };
  const autoInsertSpace = autoInsertSpaceInButton !== false;
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext$1(prefixCls, direction);
  const sizeClassNameMap = {
    large: "lg",
    small: "sm",
    middle: void 0
  };
  const sizeFullname = compactSize || groupSize || customizeSize || size;
  const sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || "" : "";
  const iconType = innerLoading ? "loading" : icon;
  const linkButtonRestProps = omit$5(rest, ["navigate"]);
  const hrefAndDisabled = linkButtonRestProps.href !== void 0 && mergedDisabled;
  const classes = classNames(prefixCls, hashId, {
    [`${prefixCls}-${shape}`]: shape !== "default" && shape,
    [`${prefixCls}-${type4}`]: type4,
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
    [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonType$1(type4),
    [`${prefixCls}-loading`]: innerLoading,
    [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && autoInsertSpace && !innerLoading,
    [`${prefixCls}-block`]: block2,
    [`${prefixCls}-dangerous`]: !!danger,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-disabled`]: hrefAndDisabled
  }, compactItemClassnames, className, rootClassName);
  const iconNode = icon && !innerLoading ? icon : /* @__PURE__ */ React.createElement(LoadingIcon$4, {
    existIcon: !!icon,
    prefixCls,
    loading: !!innerLoading
  });
  const kids = children || children === 0 ? spaceChildren$1(children, isNeedInserted() && autoInsertSpace) : null;
  if (linkButtonRestProps.href !== void 0) {
    return wrapSSR(/* @__PURE__ */ React.createElement("a", Object.assign({}, linkButtonRestProps, {
      className: classes,
      onClick: handleClick,
      ref: buttonRef
    }), iconNode, kids));
  }
  let buttonNode = /* @__PURE__ */ React.createElement("button", Object.assign({}, rest, {
    type: htmlType,
    className: classes,
    onClick: handleClick,
    disabled: mergedDisabled,
    ref: buttonRef
  }), iconNode, kids);
  if (!isUnBorderedButtonType$1(type4)) {
    buttonNode = /* @__PURE__ */ React.createElement(Wave$2, {
      disabled: !!innerLoading
    }, buttonNode);
  }
  return wrapSSR(buttonNode);
};
const Button$1 = /* @__PURE__ */ React.forwardRef(InternalButton$1);
Button$1.Group = Group$1;
Button$1.__ANT_BUTTON = true;
var Button$2 = Button$1;
function isThenable(thing) {
  return !!(thing && thing.then);
}
const ActionButton = (props) => {
  const {
    type: type4,
    children,
    prefixCls,
    buttonProps,
    close,
    autoFocus,
    emitEvent,
    quitOnNullishReturnValue,
    actionFn
  } = props;
  const clickedRef = React.useRef(false);
  const buttonRef = React.useRef(null);
  const [loading, setLoading] = useSafeState$3(false);
  const onInternalClose = function() {
    close === null || close === void 0 ? void 0 : close.apply(void 0, arguments);
  };
  React.useEffect(() => {
    let timeoutId = null;
    if (autoFocus) {
      timeoutId = setTimeout(() => {
        var _a2;
        (_a2 = buttonRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
      });
    }
    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, []);
  const handlePromiseOnOk = (returnValueOfOnOk) => {
    if (!isThenable(returnValueOfOnOk)) {
      return;
    }
    setLoading(true);
    returnValueOfOnOk.then(function() {
      setLoading(false, true);
      onInternalClose.apply(void 0, arguments);
      clickedRef.current = false;
    }, (e2) => {
      setLoading(false, true);
      clickedRef.current = false;
      return Promise.reject(e2);
    });
  };
  const onClick = (e2) => {
    if (clickedRef.current) {
      return;
    }
    clickedRef.current = true;
    if (!actionFn) {
      onInternalClose();
      return;
    }
    let returnValueOfOnOk;
    if (emitEvent) {
      returnValueOfOnOk = actionFn(e2);
      if (quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
        clickedRef.current = false;
        onInternalClose(e2);
        return;
      }
    } else if (actionFn.length) {
      returnValueOfOnOk = actionFn(close);
      clickedRef.current = false;
    } else {
      returnValueOfOnOk = actionFn();
      if (!returnValueOfOnOk) {
        onInternalClose();
        return;
      }
    }
    handlePromiseOnOk(returnValueOfOnOk);
  };
  return /* @__PURE__ */ React.createElement(Button$2, Object.assign({}, convertLegacyProps$1(type4), {
    onClick,
    loading,
    prefixCls
  }, buttonProps, {
    ref: buttonRef
  }), children);
};
var ActionButton$1 = ActionButton;
const getCollapsedHeight = () => ({
  height: 0,
  opacity: 0
});
const getRealHeight = (node2) => {
  const {
    scrollHeight
  } = node2;
  return {
    height: scrollHeight,
    opacity: 1
  };
};
const getCurrentHeight = (node2) => ({
  height: node2 ? node2.offsetHeight : 0
});
const skipOpacityTransition = (_24, event) => (event === null || event === void 0 ? void 0 : event.deadline) === true || event.propertyName === "height";
const initCollapseMotion = function() {
  let rootCls = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant";
  return {
    motionName: `${rootCls}-motion-collapse`,
    onAppearStart: getCollapsedHeight,
    onEnterStart: getCollapsedHeight,
    onAppearActive: getRealHeight,
    onEnterActive: getRealHeight,
    onLeaveStart: getCurrentHeight,
    onLeaveActive: getCollapsedHeight,
    onAppearEnd: skipOpacityTransition,
    onEnterEnd: skipOpacityTransition,
    onLeaveEnd: skipOpacityTransition,
    motionDeadline: 500
  };
};
const getTransitionDirection = (placement) => {
  if (placement !== void 0 && (placement === "topLeft" || placement === "topRight")) {
    return `slide-down`;
  }
  return `slide-up`;
};
const getTransitionName$1 = (rootPrefixCls, motion2, transitionName) => {
  if (transitionName !== void 0) {
    return transitionName;
  }
  return `${rootPrefixCls}-${motion2}`;
};
function canUseDom$b() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function useMemo$5(getValue2, condition, shouldUpdate) {
  var cacheRef = React.useRef({});
  if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue2();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
function fillRef$5(ref2, node2) {
  if (typeof ref2 === "function") {
    ref2(node2);
  } else if (_typeof$8(ref2) === "object" && ref2 && "current" in ref2) {
    ref2.current = node2;
  }
}
function composeRef$5() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function(ref2) {
    return ref2;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function(node2) {
    refs.forEach(function(ref2) {
      fillRef$5(ref2, node2);
    });
  };
}
function useComposeRef$4() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }
  return useMemo$5(function() {
    return composeRef$5.apply(void 0, refs);
  }, refs, function(prev2, next2) {
    return prev2.length === next2.length && prev2.every(function(ref2, i) {
      return ref2 === next2[i];
    });
  });
}
function supportRef$3(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type4 = reactIs$2.exports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  if (typeof type4 === "function" && !((_type$prototype = type4.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
    return false;
  }
  if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
    return false;
  }
  return true;
}
var OrderContext = /* @__PURE__ */ React.createContext(null);
var useLayoutEffect$a = canUseDom$b() ? React.useLayoutEffect : React.useEffect;
var EMPTY_LIST$2 = [];
function useDom(render2, debug) {
  var _React$useState = React.useState(function() {
    if (!canUseDom$b()) {
      return null;
    }
    var defaultEle = document.createElement("div");
    return defaultEle;
  }), _React$useState2 = _slicedToArray$1(_React$useState, 1), ele = _React$useState2[0];
  var appendedRef = React.useRef(false);
  var queueCreate = React.useContext(OrderContext);
  var _React$useState3 = React.useState(EMPTY_LIST$2), _React$useState4 = _slicedToArray$1(_React$useState3, 2), queue = _React$useState4[0], setQueue = _React$useState4[1];
  var mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
    setQueue(function(origin) {
      var newQueue = [appendFn].concat(_toConsumableArray(origin));
      return newQueue;
    });
  });
  function append2() {
    if (!ele.parentElement) {
      document.body.appendChild(ele);
    }
    appendedRef.current = true;
  }
  function cleanup2() {
    var _ele$parentElement;
    (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 ? void 0 : _ele$parentElement.removeChild(ele);
    appendedRef.current = false;
  }
  useLayoutEffect$a(function() {
    if (render2) {
      if (queueCreate) {
        queueCreate(append2);
      } else {
        append2();
      }
    } else {
      cleanup2();
    }
    return cleanup2;
  }, [render2]);
  useLayoutEffect$a(function() {
    if (queue.length) {
      queue.forEach(function(appendFn) {
        return appendFn();
      });
      setQueue(EMPTY_LIST$2);
    }
  }, [queue]);
  return [ele, mergedQueueCreate];
}
function contains$6(root2, n2) {
  if (!root2) {
    return false;
  }
  if (root2.contains) {
    return root2.contains(n2);
  }
  var node2 = n2;
  while (node2) {
    if (node2 === root2) {
      return true;
    }
    node2 = node2.parentNode;
  }
  return false;
}
var APPEND_ORDER$2 = "data-rc-order";
var MARK_KEY$2 = "rc-util-key";
var containerCache$2 = /* @__PURE__ */ new Map();
function getMark$2() {
  var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark2 = _ref2.mark;
  if (mark2) {
    return mark2.startsWith("data-") ? mark2 : "data-".concat(mark2);
  }
  return MARK_KEY$2;
}
function getContainer$2(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function getOrder$2(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles$2(container) {
  return Array.from((containerCache$2.get(container) || container).children).filter(function(node2) {
    return node2.tagName === "STYLE";
  });
}
function injectCSS$2(css2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom$b()) {
    return null;
  }
  var csp = option.csp, prepend = option.prepend;
  var styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER$2, getOrder$2(prepend));
  if (csp !== null && csp !== void 0 && csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css2;
  var container = getContainer$2(option);
  var firstChild = container.firstChild;
  if (prepend) {
    if (prepend === "queue") {
      var existStyle = findStyles$2(container).filter(function(node2) {
        return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER$2));
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode$2(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer$2(option);
  return findStyles$2(container).find(function(node2) {
    return node2.getAttribute(getMark$2(option)) === key;
  });
}
function removeCSS$2(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var existNode = findExistNode$2(key, option);
  if (existNode) {
    var container = getContainer$2(option);
    container.removeChild(existNode);
  }
}
function syncRealContainer$2(container, option) {
  var cachedRealContainer = containerCache$2.get(container);
  if (!cachedRealContainer || !contains$6(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS$2("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache$2.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function updateCSS$2(css2, key) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer$2(option);
  syncRealContainer$2(container, option);
  var existNode = findExistNode$2(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  var newNode = injectCSS$2(css2, option);
  newNode.setAttribute(getMark$2(option), key);
  return newNode;
}
var cached;
function getScrollBarSize(fresh) {
  if (typeof document === "undefined") {
    return 0;
  }
  if (fresh || cached === void 0) {
    var inner = document.createElement("div");
    inner.style.width = "100%";
    inner.style.height = "200px";
    var outer = document.createElement("div");
    var outerStyle = outer.style;
    outerStyle.position = "absolute";
    outerStyle.top = "0";
    outerStyle.left = "0";
    outerStyle.pointerEvents = "none";
    outerStyle.visibility = "hidden";
    outerStyle.width = "200px";
    outerStyle.height = "150px";
    outerStyle.overflow = "hidden";
    outer.appendChild(inner);
    document.body.appendChild(outer);
    var widthContained = inner.offsetWidth;
    outer.style.overflow = "scroll";
    var widthScroll = inner.offsetWidth;
    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }
    document.body.removeChild(outer);
    cached = widthContained - widthScroll;
  }
  return cached;
}
function isBodyOverflowing() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
var UNIQUE_ID = "rc-util-locker-".concat(Date.now());
var uuid$7 = 0;
function useScrollLocker(lock) {
  var mergedLock = !!lock;
  var _React$useState = React.useState(function() {
    uuid$7 += 1;
    return "".concat(UNIQUE_ID, "_").concat(uuid$7);
  }), _React$useState2 = _slicedToArray$1(_React$useState, 1), id = _React$useState2[0];
  useLayoutEffect$a(function() {
    if (mergedLock) {
      var scrollbarSize = getScrollBarSize();
      var isOverflow = isBodyOverflowing();
      updateCSS$2("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id);
    } else {
      removeCSS$2(id);
    }
    return function() {
      removeCSS$2(id);
    };
  }, [mergedLock, id]);
}
var inline = false;
function inlineMock(nextInline) {
  if (typeof nextInline === "boolean") {
    inline = nextInline;
  }
  return inline;
}
var getPortalContainer = function getPortalContainer2(getContainer2) {
  if (getContainer2 === false) {
    return false;
  }
  if (!canUseDom$b() || !getContainer2) {
    return null;
  }
  if (typeof getContainer2 === "string") {
    return document.querySelector(getContainer2);
  }
  if (typeof getContainer2 === "function") {
    return getContainer2();
  }
  return getContainer2;
};
var Portal$2 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var open = props.open, autoLock = props.autoLock, getContainer2 = props.getContainer;
  props.debug;
  var _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy, children = props.children;
  var _React$useState = React.useState(open), _React$useState2 = _slicedToArray$1(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1];
  var mergedRender = shouldRender || open;
  React.useEffect(function() {
    if (autoDestroy || open) {
      setShouldRender(open);
    }
  }, [open, autoDestroy]);
  var _React$useState3 = React.useState(function() {
    return getPortalContainer(getContainer2);
  }), _React$useState4 = _slicedToArray$1(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
  React.useEffect(function() {
    var customizeContainer = getPortalContainer(getContainer2);
    setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
  });
  var _useDom = useDom(mergedRender && !innerContainer), _useDom2 = _slicedToArray$1(_useDom, 2), defaultContainer = _useDom2[0], queueCreate = _useDom2[1];
  var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer;
  useScrollLocker(autoLock && open && canUseDom$b() && (mergedContainer === defaultContainer || mergedContainer === document.body));
  var childRef = null;
  if (children && supportRef$3(children) && ref2) {
    var _ref2 = children;
    childRef = _ref2.ref;
  }
  var mergedRef = useComposeRef$4(childRef, ref2);
  if (!mergedRender || !canUseDom$b() || innerContainer === void 0) {
    return null;
  }
  var renderInline = mergedContainer === false || inlineMock();
  var reffedChildren = children;
  if (ref2) {
    reffedChildren = /* @__PURE__ */ React.cloneElement(children, {
      ref: mergedRef
    });
  }
  return /* @__PURE__ */ React.createElement(OrderContext.Provider, {
    value: queueCreate
  }, renderInline ? reffedChildren : /* @__PURE__ */ ReactDOM.createPortal(reffedChildren, mergedContainer));
});
function contains$5(root2, n2) {
  if (!root2) {
    return false;
  }
  if (root2.contains) {
    return root2.contains(n2);
  }
  var node2 = n2;
  while (node2) {
    if (node2 === root2) {
      return true;
    }
    node2 = node2.parentNode;
  }
  return false;
}
function getUseId$2() {
  var fullClone2 = _objectSpread2$d({}, React);
  return fullClone2.useId;
}
var uuid$6 = 0;
function useId$3(id) {
  var _React$useState = React.useState("ssr-id"), _React$useState2 = _slicedToArray$1(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
  var useOriginId = getUseId$2();
  var reactNativeId = useOriginId === null || useOriginId === void 0 ? void 0 : useOriginId();
  React.useEffect(function() {
    if (!useOriginId) {
      var nextId = uuid$6;
      uuid$6 += 1;
      setInnerId("rc_unique_".concat(nextId));
    }
  }, []);
  if (id) {
    return id;
  }
  return reactNativeId || innerId;
}
var KeyCode$4 = {
  MAC_ENTER: 3,
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  PRINT_SCREEN: 44,
  INSERT: 45,
  DELETE: 46,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  QUESTION_MARK: 63,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  META: 91,
  WIN_KEY_RIGHT: 92,
  CONTEXT_MENU: 93,
  NUM_ZERO: 96,
  NUM_ONE: 97,
  NUM_TWO: 98,
  NUM_THREE: 99,
  NUM_FOUR: 100,
  NUM_FIVE: 101,
  NUM_SIX: 102,
  NUM_SEVEN: 103,
  NUM_EIGHT: 104,
  NUM_NINE: 105,
  NUM_MULTIPLY: 106,
  NUM_PLUS: 107,
  NUM_MINUS: 109,
  NUM_PERIOD: 110,
  NUM_DIVISION: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SEMICOLON: 186,
  DASH: 189,
  EQUALS: 187,
  COMMA: 188,
  PERIOD: 190,
  SLASH: 191,
  APOSTROPHE: 192,
  SINGLE_QUOTE: 222,
  OPEN_SQUARE_BRACKET: 219,
  BACKSLASH: 220,
  CLOSE_SQUARE_BRACKET: 221,
  WIN_KEY: 224,
  MAC_FF_META: 224,
  WIN_IME: 229,
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent2(e2) {
    var keyCode = e2.keyCode;
    if (e2.altKey && !e2.ctrlKey || e2.metaKey || keyCode >= KeyCode$4.F1 && keyCode <= KeyCode$4.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode$4.ALT:
      case KeyCode$4.CAPS_LOCK:
      case KeyCode$4.CONTEXT_MENU:
      case KeyCode$4.CTRL:
      case KeyCode$4.DOWN:
      case KeyCode$4.END:
      case KeyCode$4.ESC:
      case KeyCode$4.HOME:
      case KeyCode$4.INSERT:
      case KeyCode$4.LEFT:
      case KeyCode$4.MAC_FF_META:
      case KeyCode$4.META:
      case KeyCode$4.NUMLOCK:
      case KeyCode$4.NUM_CENTER:
      case KeyCode$4.PAGE_DOWN:
      case KeyCode$4.PAGE_UP:
      case KeyCode$4.PAUSE:
      case KeyCode$4.PRINT_SCREEN:
      case KeyCode$4.RIGHT:
      case KeyCode$4.SHIFT:
      case KeyCode$4.UP:
      case KeyCode$4.WIN_KEY:
      case KeyCode$4.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  isCharacterKey: function isCharacterKey2(keyCode) {
    if (keyCode >= KeyCode$4.ZERO && keyCode <= KeyCode$4.NINE) {
      return true;
    }
    if (keyCode >= KeyCode$4.NUM_ZERO && keyCode <= KeyCode$4.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode$4.A && keyCode <= KeyCode$4.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode$4.SPACE:
      case KeyCode$4.QUESTION_MARK:
      case KeyCode$4.NUM_PLUS:
      case KeyCode$4.NUM_MINUS:
      case KeyCode$4.NUM_PERIOD:
      case KeyCode$4.NUM_DIVISION:
      case KeyCode$4.SEMICOLON:
      case KeyCode$4.DASH:
      case KeyCode$4.EQUALS:
      case KeyCode$4.COMMA:
      case KeyCode$4.PERIOD:
      case KeyCode$4.SLASH:
      case KeyCode$4.APOSTROPHE:
      case KeyCode$4.SINGLE_QUOTE:
      case KeyCode$4.OPEN_SQUARE_BRACKET:
      case KeyCode$4.BACKSLASH:
      case KeyCode$4.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
var attributes$3 = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
var eventsName$3 = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
var propList$3 = "".concat(attributes$3, " ").concat(eventsName$3).split(/[\s\n]+/);
var ariaPrefix$3 = "aria-";
var dataPrefix$3 = "data-";
function match$3(key, prefix2) {
  return key.indexOf(prefix2) === 0;
}
function pickAttrs$3(props) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _objectSpread2$d({}, ariaOnly);
  }
  var attrs = {};
  Object.keys(props).forEach(function(key) {
    if (mergedConfig.aria && (key === "role" || match$3(key, ariaPrefix$3)) || mergedConfig.data && match$3(key, dataPrefix$3) || mergedConfig.attr && propList$3.includes(key)) {
      attrs[key] = props[key];
    }
  });
  return attrs;
}
function getMotionName$1(prefixCls, transitionName, animationName) {
  var motionName = transitionName;
  if (!motionName && animationName) {
    motionName = "".concat(prefixCls, "-").concat(animationName);
  }
  return motionName;
}
function getScroll$2(w2, top) {
  var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
  var method4 = "scroll".concat(top ? "Top" : "Left");
  if (typeof ret !== "number") {
    var d2 = w2.document;
    ret = d2.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d2.body[method4];
    }
  }
  return ret;
}
function offset$1(el) {
  var rect = el.getBoundingClientRect();
  var pos = {
    left: rect.left,
    top: rect.top
  };
  var doc = el.ownerDocument;
  var w2 = doc.defaultView || doc.parentWindow;
  pos.left += getScroll$2(w2);
  pos.top += getScroll$2(w2, true);
  return pos;
}
var MemoChildren$1 = /* @__PURE__ */ React.memo(function(_ref2) {
  var children = _ref2.children;
  return children;
}, function(_24, _ref2) {
  var shouldUpdate = _ref2.shouldUpdate;
  return !shouldUpdate;
});
var sentinelStyle$1 = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
};
var Panel$1 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var prefixCls = props.prefixCls, className = props.className, style2 = props.style, title = props.title, ariaId = props.ariaId, footer2 = props.footer, closable = props.closable, closeIcon = props.closeIcon, onClose = props.onClose, children = props.children, bodyStyle = props.bodyStyle, bodyProps = props.bodyProps, modalRender = props.modalRender, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, holderRef = props.holderRef, visible = props.visible, forceRender = props.forceRender, width = props.width, height = props.height;
  var sentinelStartRef = React.useRef();
  var sentinelEndRef = React.useRef();
  React.useImperativeHandle(ref2, function() {
    return {
      focus: function focus() {
        var _sentinelStartRef$cur;
        (_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 ? void 0 : _sentinelStartRef$cur.focus();
      },
      changeActive: function changeActive(next2) {
        var _document = document, activeElement = _document.activeElement;
        if (next2 && activeElement === sentinelEndRef.current) {
          sentinelStartRef.current.focus();
        } else if (!next2 && activeElement === sentinelStartRef.current) {
          sentinelEndRef.current.focus();
        }
      }
    };
  });
  var contentStyle = {};
  if (width !== void 0) {
    contentStyle.width = width;
  }
  if (height !== void 0) {
    contentStyle.height = height;
  }
  var footerNode;
  if (footer2) {
    footerNode = /* @__PURE__ */ React.createElement("div", {
      className: "".concat(prefixCls, "-footer")
    }, footer2);
  }
  var headerNode;
  if (title) {
    headerNode = /* @__PURE__ */ React.createElement("div", {
      className: "".concat(prefixCls, "-header")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(prefixCls, "-title"),
      id: ariaId
    }, title));
  }
  var closer;
  if (closable) {
    closer = /* @__PURE__ */ React.createElement("button", {
      type: "button",
      onClick: onClose,
      "aria-label": "Close",
      className: "".concat(prefixCls, "-close")
    }, closeIcon || /* @__PURE__ */ React.createElement("span", {
      className: "".concat(prefixCls, "-close-x")
    }));
  }
  var content2 = /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-content")
  }, closer, headerNode, /* @__PURE__ */ React.createElement("div", _extends$3({
    className: "".concat(prefixCls, "-body"),
    style: bodyStyle
  }, bodyProps), children), footerNode);
  return /* @__PURE__ */ React.createElement("div", {
    key: "dialog-element",
    role: "dialog",
    "aria-labelledby": title ? ariaId : null,
    "aria-modal": "true",
    ref: holderRef,
    style: _objectSpread2$d(_objectSpread2$d({}, style2), contentStyle),
    className: classNames(prefixCls, className),
    onMouseDown,
    onMouseUp
  }, /* @__PURE__ */ React.createElement("div", {
    tabIndex: 0,
    ref: sentinelStartRef,
    style: sentinelStyle$1,
    "aria-hidden": "true"
  }), /* @__PURE__ */ React.createElement(MemoChildren$1, {
    shouldUpdate: visible || forceRender
  }, modalRender ? modalRender(content2) : content2), /* @__PURE__ */ React.createElement("div", {
    tabIndex: 0,
    ref: sentinelEndRef,
    style: sentinelStyle$1,
    "aria-hidden": "true"
  }));
});
var Content$1 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var prefixCls = props.prefixCls, title = props.title, style2 = props.style, className = props.className, visible = props.visible, forceRender = props.forceRender, destroyOnClose = props.destroyOnClose, motionName = props.motionName, ariaId = props.ariaId, onVisibleChanged = props.onVisibleChanged, mousePosition2 = props.mousePosition;
  var dialogRef = React.useRef();
  var _React$useState = React.useState(), _React$useState2 = _slicedToArray$1(_React$useState, 2), transformOrigin = _React$useState2[0], setTransformOrigin = _React$useState2[1];
  var contentStyle = {};
  if (transformOrigin) {
    contentStyle.transformOrigin = transformOrigin;
  }
  function onPrepare() {
    var elementOffset = offset$1(dialogRef.current);
    setTransformOrigin(mousePosition2 ? "".concat(mousePosition2.x - elementOffset.left, "px ").concat(mousePosition2.y - elementOffset.top, "px") : "");
  }
  return /* @__PURE__ */ React.createElement(CSSMotion, {
    visible,
    onVisibleChanged,
    onAppearPrepare: onPrepare,
    onEnterPrepare: onPrepare,
    forceRender,
    motionName,
    removeOnLeave: destroyOnClose,
    ref: dialogRef
  }, function(_ref2, motionRef) {
    var motionClassName = _ref2.className, motionStyle = _ref2.style;
    return /* @__PURE__ */ React.createElement(Panel$1, _extends$3({}, props, {
      ref: ref2,
      title,
      ariaId,
      prefixCls,
      holderRef: motionRef,
      style: _objectSpread2$d(_objectSpread2$d(_objectSpread2$d({}, motionStyle), style2), contentStyle),
      className: classNames(className, motionClassName)
    }));
  });
});
Content$1.displayName = "Content";
function Mask$4(props) {
  var prefixCls = props.prefixCls, style2 = props.style, visible = props.visible, maskProps = props.maskProps, motionName = props.motionName;
  return /* @__PURE__ */ React.createElement(CSSMotion, {
    key: "mask",
    visible,
    motionName,
    leavedClassName: "".concat(prefixCls, "-mask-hidden")
  }, function(_ref2, ref2) {
    var motionClassName = _ref2.className, motionStyle = _ref2.style;
    return /* @__PURE__ */ React.createElement("div", _extends$3({
      ref: ref2,
      style: _objectSpread2$d(_objectSpread2$d({}, motionStyle), style2),
      className: classNames("".concat(prefixCls, "-mask"), motionClassName)
    }, maskProps));
  });
}
function Dialog$1(props) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dialog" : _props$prefixCls, zIndex = props.zIndex, _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$focusTriggerAf = props.focusTriggerAfterClose, focusTriggerAfterClose = _props$focusTriggerAf === void 0 ? true : _props$focusTriggerAf, wrapStyle = props.wrapStyle, wrapClassName = props.wrapClassName, wrapProps = props.wrapProps, onClose = props.onClose, afterOpenChange = props.afterOpenChange, afterClose = props.afterClose, transitionName = props.transitionName, animation = props.animation, _props$closable = props.closable, closable = _props$closable === void 0 ? true : _props$closable, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, maskStyle = props.maskStyle, maskProps = props.maskProps, rootClassName = props.rootClassName;
  var lastOutSideActiveElementRef = React.useRef();
  var wrapperRef = React.useRef();
  var contentRef = React.useRef();
  var _React$useState = React.useState(visible), _React$useState2 = _slicedToArray$1(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
  var ariaId = useId$3();
  function saveLastOutSideActiveElementRef() {
    if (!contains$5(wrapperRef.current, document.activeElement)) {
      lastOutSideActiveElementRef.current = document.activeElement;
    }
  }
  function focusDialogContent() {
    if (!contains$5(wrapperRef.current, document.activeElement)) {
      var _contentRef$current;
      (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 ? void 0 : _contentRef$current.focus();
    }
  }
  function onDialogVisibleChanged(newVisible) {
    if (newVisible) {
      focusDialogContent();
    } else {
      setAnimatedVisible(false);
      if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
        try {
          lastOutSideActiveElementRef.current.focus({
            preventScroll: true
          });
        } catch (e2) {
        }
        lastOutSideActiveElementRef.current = null;
      }
      if (animatedVisible) {
        afterClose === null || afterClose === void 0 ? void 0 : afterClose();
      }
    }
    afterOpenChange === null || afterOpenChange === void 0 ? void 0 : afterOpenChange(newVisible);
  }
  function onInternalClose(e2) {
    onClose === null || onClose === void 0 ? void 0 : onClose(e2);
  }
  var contentClickRef = React.useRef(false);
  var contentTimeoutRef = React.useRef();
  var onContentMouseDown = function onContentMouseDown2() {
    clearTimeout(contentTimeoutRef.current);
    contentClickRef.current = true;
  };
  var onContentMouseUp = function onContentMouseUp2() {
    contentTimeoutRef.current = setTimeout(function() {
      contentClickRef.current = false;
    });
  };
  var onWrapperClick = null;
  if (maskClosable) {
    onWrapperClick = function onWrapperClick2(e2) {
      if (contentClickRef.current) {
        contentClickRef.current = false;
      } else if (wrapperRef.current === e2.target) {
        onInternalClose(e2);
      }
    };
  }
  function onWrapperKeyDown(e2) {
    if (keyboard && e2.keyCode === KeyCode$4.ESC) {
      e2.stopPropagation();
      onInternalClose(e2);
      return;
    }
    if (visible) {
      if (e2.keyCode === KeyCode$4.TAB) {
        contentRef.current.changeActive(!e2.shiftKey);
      }
    }
  }
  React.useEffect(function() {
    if (visible) {
      setAnimatedVisible(true);
      saveLastOutSideActiveElementRef();
    }
  }, [visible]);
  React.useEffect(function() {
    return function() {
      clearTimeout(contentTimeoutRef.current);
    };
  }, []);
  return /* @__PURE__ */ React.createElement("div", _extends$3({
    className: classNames("".concat(prefixCls, "-root"), rootClassName)
  }, pickAttrs$3(props, {
    data: true
  })), /* @__PURE__ */ React.createElement(Mask$4, {
    prefixCls,
    visible: mask && visible,
    motionName: getMotionName$1(prefixCls, maskTransitionName, maskAnimation),
    style: _objectSpread2$d({
      zIndex
    }, maskStyle),
    maskProps
  }), /* @__PURE__ */ React.createElement("div", _extends$3({
    tabIndex: -1,
    onKeyDown: onWrapperKeyDown,
    className: classNames("".concat(prefixCls, "-wrap"), wrapClassName),
    ref: wrapperRef,
    onClick: onWrapperClick,
    style: _objectSpread2$d(_objectSpread2$d({
      zIndex
    }, wrapStyle), {}, {
      display: !animatedVisible ? "none" : null
    })
  }, wrapProps), /* @__PURE__ */ React.createElement(Content$1, _extends$3({}, props, {
    onMouseDown: onContentMouseDown,
    onMouseUp: onContentMouseUp,
    ref: contentRef,
    closable,
    ariaId,
    prefixCls,
    visible: visible && animatedVisible,
    onClose: onInternalClose,
    onVisibleChanged: onDialogVisibleChanged,
    motionName: getMotionName$1(prefixCls, transitionName, animation)
  }))));
}
var DialogWrap$1 = function DialogWrap(props) {
  var visible = props.visible, getContainer2 = props.getContainer, forceRender = props.forceRender, _props$destroyOnClose = props.destroyOnClose, destroyOnClose = _props$destroyOnClose === void 0 ? false : _props$destroyOnClose, _afterClose = props.afterClose;
  var _React$useState = React.useState(visible), _React$useState2 = _slicedToArray$1(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
  React.useEffect(function() {
    if (visible) {
      setAnimatedVisible(true);
    }
  }, [visible]);
  if (!forceRender && destroyOnClose && !animatedVisible) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(Portal$2, {
    open: visible || forceRender || animatedVisible,
    autoDestroy: false,
    getContainer: getContainer2,
    autoLock: visible || animatedVisible
  }, /* @__PURE__ */ React.createElement(Dialog$1, _extends$3({}, props, {
    destroyOnClose,
    afterClose: function afterClose() {
      _afterClose === null || _afterClose === void 0 ? void 0 : _afterClose();
      setAnimatedVisible(false);
    }
  })));
};
DialogWrap$1.displayName = "Dialog";
const FormItemInputContext$1 = /* @__PURE__ */ React.createContext({});
const NoFormStyle$1 = (_ref2) => {
  let {
    children,
    status,
    override
  } = _ref2;
  const formItemInputContext = React.useContext(FormItemInputContext$1);
  const newFormItemInputContext = React.useMemo(() => {
    const newContext = Object.assign({}, formItemInputContext);
    if (override) {
      delete newContext.isFormItemInput;
    }
    if (status) {
      delete newContext.status;
      delete newContext.hasFeedback;
      delete newContext.feedbackIcon;
    }
    return newContext;
  }, [status, override, formItemInputContext]);
  return /* @__PURE__ */ React.createElement(FormItemInputContext$1.Provider, {
    value: newFormItemInputContext
  }, children);
};
const canUseDocElement = () => canUseDom$d() && window.document.documentElement;
let flexGapSupported;
const detectFlexGapSupported = () => {
  if (!canUseDocElement()) {
    return false;
  }
  if (flexGapSupported !== void 0) {
    return flexGapSupported;
  }
  const flex = document.createElement("div");
  flex.style.display = "flex";
  flex.style.flexDirection = "column";
  flex.style.rowGap = "1px";
  flex.appendChild(document.createElement("div"));
  flex.appendChild(document.createElement("div"));
  document.body.appendChild(flex);
  flexGapSupported = flex.scrollHeight === 1;
  document.body.removeChild(flex);
  return flexGapSupported;
};
const initMotionCommon = (duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
});
const initMotionCommonLeave = (duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
});
const initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
  let sameLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  const sameLevelPrefix = sameLevel ? "&" : "";
  return {
    [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: Object.assign(Object.assign({}, initMotionCommon(duration)), {
      animationPlayState: "paused"
    }),
    [`${sameLevelPrefix}${motionCls}-leave`]: Object.assign(Object.assign({}, initMotionCommonLeave(duration)), {
      animationPlayState: "paused"
    }),
    [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
      animationName: inKeyframes,
      animationPlayState: "running"
    },
    [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
      animationName: outKeyframes,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
};
const fadeIn = new Keyframe("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
});
const fadeOut = new Keyframe("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
});
const initFadeMotion = function(token2) {
  let sameLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-fade`;
  const sameLevelPrefix = sameLevel ? "&" : "";
  return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
    [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: "linear"
    },
    [`${sameLevelPrefix}${motionCls}-leave`]: {
      animationTimingFunction: "linear"
    }
  }];
};
const moveDownIn = new Keyframe("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
const moveDownOut = new Keyframe("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
const moveLeftIn = new Keyframe("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
const moveLeftOut = new Keyframe("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
const moveRightIn = new Keyframe("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
const moveRightOut = new Keyframe("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
const moveUpIn = new Keyframe("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
const moveUpOut = new Keyframe("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
const moveMotion = {
  "move-up": {
    inKeyframes: moveUpIn,
    outKeyframes: moveUpOut
  },
  "move-down": {
    inKeyframes: moveDownIn,
    outKeyframes: moveDownOut
  },
  "move-left": {
    inKeyframes: moveLeftIn,
    outKeyframes: moveLeftOut
  },
  "move-right": {
    inKeyframes: moveRightIn,
    outKeyframes: moveRightOut
  }
};
const initMoveMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = moveMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
    [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutCirc
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInOutCirc
    }
  }];
};
const slideUpIn = new Keyframe("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
});
const slideUpOut = new Keyframe("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
});
const slideDownIn = new Keyframe("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
});
const slideDownOut = new Keyframe("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
});
const slideLeftIn = new Keyframe("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
});
const slideLeftOut = new Keyframe("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
});
const slideRightIn = new Keyframe("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
});
const slideRightOut = new Keyframe("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
});
const slideMotion = {
  "slide-up": {
    inKeyframes: slideUpIn,
    outKeyframes: slideUpOut
  },
  "slide-down": {
    inKeyframes: slideDownIn,
    outKeyframes: slideDownOut
  },
  "slide-left": {
    inKeyframes: slideLeftIn,
    outKeyframes: slideLeftOut
  },
  "slide-right": {
    inKeyframes: slideRightIn,
    outKeyframes: slideRightOut
  }
};
const initSlideMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = slideMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
    [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutQuint,
      [`&-prepare`]: {
        transform: "scale(1)"
      }
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInQuint
    }
  }];
};
const zoomIn = new Keyframe("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
});
const zoomOut = new Keyframe("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
});
const zoomBigIn = new Keyframe("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
});
const zoomBigOut = new Keyframe("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
});
const zoomUpIn = new Keyframe("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
});
const zoomUpOut = new Keyframe("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
});
const zoomLeftIn = new Keyframe("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
});
const zoomLeftOut = new Keyframe("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
});
const zoomRightIn = new Keyframe("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
});
const zoomRightOut = new Keyframe("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
});
const zoomDownIn = new Keyframe("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
});
const zoomDownOut = new Keyframe("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
});
const zoomMotion = {
  zoom: {
    inKeyframes: zoomIn,
    outKeyframes: zoomOut
  },
  "zoom-big": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-big-fast": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-left": {
    inKeyframes: zoomLeftIn,
    outKeyframes: zoomLeftOut
  },
  "zoom-right": {
    inKeyframes: zoomRightIn,
    outKeyframes: zoomRightOut
  },
  "zoom-up": {
    inKeyframes: zoomUpIn,
    outKeyframes: zoomUpOut
  },
  "zoom-down": {
    inKeyframes: zoomDownIn,
    outKeyframes: zoomDownOut
  }
};
const initZoomMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = zoomMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
    [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInOutCirc
    }
  }];
};
const genCollapseMotion = (token2) => ({
  [token2.componentCls]: {
    [`${token2.antCls}-motion-collapse-legacy`]: {
      overflow: "hidden",
      "&-active": {
        transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
      }
    },
    [`${token2.antCls}-motion-collapse`]: {
      overflow: "hidden",
      transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
    }
  }
});
var genCollapseMotion$1 = genCollapseMotion;
function box(position2) {
  return {
    position: position2,
    top: 0,
    insetInlineEnd: 0,
    bottom: 0,
    insetInlineStart: 0
  };
}
const genModalMaskStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return [{
    [`${componentCls}-root`]: {
      [`${componentCls}${antCls}-zoom-enter, ${componentCls}${antCls}-zoom-appear`]: {
        transform: "none",
        opacity: 0,
        animationDuration: token2.motionDurationSlow,
        userSelect: "none"
      },
      [`${componentCls}${antCls}-zoom-leave ${componentCls}-content`]: {
        pointerEvents: "none"
      },
      [`${componentCls}-mask`]: Object.assign(Object.assign({}, box("fixed")), {
        zIndex: token2.zIndexPopupBase,
        height: "100%",
        backgroundColor: token2.colorBgMask,
        [`${componentCls}-hidden`]: {
          display: "none"
        }
      }),
      [`${componentCls}-wrap`]: Object.assign(Object.assign({}, box("fixed")), {
        overflow: "auto",
        outline: 0,
        WebkitOverflowScrolling: "touch"
      })
    }
  }, {
    [`${componentCls}-root`]: initFadeMotion(token2)
  }];
};
const genModalStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return [
    {
      [`${componentCls}-root`]: {
        [`${componentCls}-wrap`]: {
          zIndex: token2.zIndexPopupBase,
          position: "fixed",
          inset: 0,
          overflow: "auto",
          outline: 0,
          WebkitOverflowScrolling: "touch"
        },
        [`${componentCls}-wrap-rtl`]: {
          direction: "rtl"
        },
        [`${componentCls}-centered`]: {
          textAlign: "center",
          "&::before": {
            display: "inline-block",
            width: 0,
            height: "100%",
            verticalAlign: "middle",
            content: '""'
          },
          [componentCls]: {
            top: 0,
            display: "inline-block",
            paddingBottom: 0,
            textAlign: "start",
            verticalAlign: "middle"
          }
        },
        [`@media (max-width: ${token2.screenSMMax})`]: {
          [componentCls]: {
            maxWidth: "calc(100vw - 16px)",
            margin: `${token2.marginXS} auto`
          },
          [`${componentCls}-centered`]: {
            [componentCls]: {
              flex: 1
            }
          }
        }
      }
    },
    {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        pointerEvents: "none",
        position: "relative",
        top: 100,
        width: "auto",
        maxWidth: `calc(100vw - ${token2.margin * 2}px)`,
        margin: "0 auto",
        paddingBottom: token2.paddingLG,
        [`${componentCls}-title`]: {
          margin: 0,
          color: token2.modalHeadingColor,
          fontWeight: token2.fontWeightStrong,
          fontSize: token2.modalHeaderTitleFontSize,
          lineHeight: token2.modalHeaderTitleLineHeight,
          wordWrap: "break-word"
        },
        [`${componentCls}-content`]: {
          position: "relative",
          backgroundColor: token2.modalContentBg,
          backgroundClip: "padding-box",
          border: 0,
          borderRadius: token2.borderRadiusLG,
          boxShadow: token2.boxShadow,
          pointerEvents: "auto",
          padding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`
        },
        [`${componentCls}-close`]: Object.assign({
          position: "absolute",
          top: (token2.modalHeaderCloseSize - token2.modalCloseBtnSize) / 2,
          insetInlineEnd: (token2.modalHeaderCloseSize - token2.modalCloseBtnSize) / 2,
          zIndex: token2.zIndexPopupBase + 10,
          padding: 0,
          color: token2.modalCloseColor,
          fontWeight: token2.fontWeightStrong,
          lineHeight: 1,
          textDecoration: "none",
          background: "transparent",
          borderRadius: token2.borderRadiusSM,
          width: token2.modalConfirmIconSize,
          height: token2.modalConfirmIconSize,
          border: 0,
          outline: 0,
          cursor: "pointer",
          transition: `color ${token2.motionDurationMid}, background-color ${token2.motionDurationMid}`,
          "&-x": {
            display: "block",
            fontSize: token2.fontSizeLG,
            fontStyle: "normal",
            lineHeight: `${token2.modalCloseBtnSize}px`,
            textAlign: "center",
            textTransform: "none",
            textRendering: "auto"
          },
          "&:hover": {
            color: token2.modalIconHoverColor,
            backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContent,
            textDecoration: "none"
          },
          "&:active": {
            backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContentHover
          }
        }, genFocusStyle(token2)),
        [`${componentCls}-header`]: {
          color: token2.colorText,
          background: token2.modalHeaderBg,
          borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`,
          marginBottom: token2.marginXS
        },
        [`${componentCls}-body`]: {
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight,
          wordWrap: "break-word"
        },
        [`${componentCls}-footer`]: {
          textAlign: "end",
          background: token2.modalFooterBg,
          marginTop: token2.marginSM,
          [`${token2.antCls}-btn + ${token2.antCls}-btn:not(${token2.antCls}-dropdown-trigger)`]: {
            marginBottom: 0,
            marginInlineStart: token2.marginXS
          }
        },
        [`${componentCls}-open`]: {
          overflow: "hidden"
        }
      })
    },
    {
      [`${componentCls}-pure-panel`]: {
        top: "auto",
        padding: 0,
        display: "flex",
        flexDirection: "column",
        [`${componentCls}-content,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
          display: "flex",
          flexDirection: "column",
          flex: "auto"
        },
        [`${componentCls}-confirm-body`]: {
          marginBottom: "auto"
        }
      }
    }
  ];
};
const genModalConfirmStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const confirmComponentCls = `${componentCls}-confirm`;
  return {
    [confirmComponentCls]: {
      "&-rtl": {
        direction: "rtl"
      },
      [`${token2.antCls}-modal-header`]: {
        display: "none"
      },
      [`${confirmComponentCls}-body-wrapper`]: Object.assign({}, clearFix()),
      [`${confirmComponentCls}-body`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        [`${confirmComponentCls}-title`]: {
          flex: "0 0 100%",
          display: "block",
          overflow: "hidden",
          color: token2.colorTextHeading,
          fontWeight: token2.fontWeightStrong,
          fontSize: token2.modalHeaderTitleFontSize,
          lineHeight: token2.modalHeaderTitleLineHeight,
          [`+ ${confirmComponentCls}-content`]: {
            marginBlockStart: token2.marginXS,
            flexBasis: "100%",
            maxWidth: `calc(100% - ${token2.modalConfirmIconSize + token2.marginSM}px)`
          }
        },
        [`${confirmComponentCls}-content`]: {
          color: token2.colorText,
          fontSize: token2.fontSize
        },
        [`> ${token2.iconCls}`]: {
          flex: "none",
          marginInlineEnd: token2.marginSM,
          fontSize: token2.modalConfirmIconSize,
          [`+ ${confirmComponentCls}-title`]: {
            flex: 1
          },
          [`+ ${confirmComponentCls}-title + ${confirmComponentCls}-content`]: {
            marginInlineStart: token2.modalConfirmIconSize + token2.marginSM
          }
        }
      },
      [`${confirmComponentCls}-btns`]: {
        textAlign: "end",
        marginTop: token2.marginSM,
        [`${token2.antCls}-btn + ${token2.antCls}-btn`]: {
          marginBottom: 0,
          marginInlineStart: token2.marginXS
        }
      }
    },
    [`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorError
    },
    [`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token2.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorWarning
    },
    [`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorInfo
    },
    [`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorSuccess
    }
  };
};
const genRTLStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-root`]: {
      [`${componentCls}-wrap-rtl`]: {
        direction: "rtl",
        [`${componentCls}-confirm-body`]: {
          direction: "rtl"
        }
      }
    }
  };
};
const genWireframeStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  const confirmComponentCls = `${componentCls}-confirm`;
  return {
    [componentCls]: {
      [`${componentCls}-content`]: {
        padding: 0
      },
      [`${componentCls}-header`]: {
        padding: token2.modalHeaderPadding,
        borderBottom: `${token2.modalHeaderBorderWidth}px ${token2.modalHeaderBorderStyle} ${token2.modalHeaderBorderColorSplit}`,
        marginBottom: 0
      },
      [`${componentCls}-body`]: {
        padding: token2.modalBodyPadding
      },
      [`${componentCls}-footer`]: {
        padding: `${token2.modalFooterPaddingVertical}px ${token2.modalFooterPaddingHorizontal}px`,
        borderTop: `${token2.modalFooterBorderWidth}px ${token2.modalFooterBorderStyle} ${token2.modalFooterBorderColorSplit}`,
        borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`,
        marginTop: 0
      }
    },
    [confirmComponentCls]: {
      [`${antCls}-modal-body`]: {
        padding: `${token2.padding * 2}px ${token2.padding * 2}px ${token2.paddingLG}px`
      },
      [`${confirmComponentCls}-body`]: {
        [`> ${token2.iconCls}`]: {
          marginInlineEnd: token2.margin,
          [`+ ${confirmComponentCls}-title + ${confirmComponentCls}-content`]: {
            marginInlineStart: token2.modalConfirmIconSize + token2.margin
          }
        }
      },
      [`${confirmComponentCls}-btns`]: {
        marginTop: token2.marginLG
      }
    }
  };
};
var useStyle$f = genComponentStyleHook$2("Modal", (token2) => {
  const headerPaddingVertical = token2.padding;
  const headerFontSize = token2.fontSizeHeading5;
  const headerLineHeight = token2.lineHeightHeading5;
  const modalToken = merge$1(token2, {
    modalBodyPadding: token2.paddingLG,
    modalHeaderBg: token2.colorBgElevated,
    modalHeaderPadding: `${headerPaddingVertical}px ${token2.paddingLG}px`,
    modalHeaderBorderWidth: token2.lineWidth,
    modalHeaderBorderStyle: token2.lineType,
    modalHeaderTitleLineHeight: headerLineHeight,
    modalHeaderTitleFontSize: headerFontSize,
    modalHeaderBorderColorSplit: token2.colorSplit,
    modalHeaderCloseSize: headerLineHeight * headerFontSize + headerPaddingVertical * 2,
    modalContentBg: token2.colorBgElevated,
    modalHeadingColor: token2.colorTextHeading,
    modalCloseColor: token2.colorTextDescription,
    modalFooterBg: "transparent",
    modalFooterBorderColorSplit: token2.colorSplit,
    modalFooterBorderStyle: token2.lineType,
    modalFooterPaddingVertical: token2.paddingXS,
    modalFooterPaddingHorizontal: token2.padding,
    modalFooterBorderWidth: token2.lineWidth,
    modalConfirmTitleFontSize: token2.fontSizeLG,
    modalIconHoverColor: token2.colorIconHover,
    modalConfirmIconSize: token2.fontSize * token2.lineHeight,
    modalCloseBtnSize: token2.controlHeightLG * 0.55
  });
  return [genModalStyle(modalToken), genModalConfirmStyle(modalToken), genRTLStyle(modalToken), genModalMaskStyle(modalToken), token2.wireframe && genWireframeStyle(modalToken), initZoomMotion(modalToken, "zoom")];
});
var __rest$A = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function renderCloseIcon(prefixCls, closeIcon) {
  return /* @__PURE__ */ React.createElement("span", {
    className: `${prefixCls}-close-x`
  }, closeIcon || /* @__PURE__ */ React.createElement(CloseOutlined$1, {
    className: `${prefixCls}-close-icon`
  }));
}
const Footer = (props) => {
  const {
    okText,
    okType = "primary",
    cancelText,
    confirmLoading,
    onOk,
    onCancel,
    okButtonProps,
    cancelButtonProps
  } = props;
  const [locale2] = useLocale$3("Modal", getConfirmLocale$1());
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Button$2, Object.assign({
    onClick: onCancel
  }, cancelButtonProps), cancelText || (locale2 === null || locale2 === void 0 ? void 0 : locale2.cancelText)), /* @__PURE__ */ React.createElement(Button$2, Object.assign({}, convertLegacyProps$1(okType), {
    loading: confirmLoading,
    onClick: onOk
  }, okButtonProps), okText || (locale2 === null || locale2 === void 0 ? void 0 : locale2.okText)));
};
const PurePanel$3 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    closeIcon,
    closable,
    type: type4,
    title,
    children
  } = props, restProps = __rest$A(props, ["prefixCls", "className", "closeIcon", "closable", "type", "title", "children"]);
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const rootPrefixCls = getPrefixCls();
  const prefixCls = customizePrefixCls || getPrefixCls("modal");
  const [, hashId] = useStyle$f(prefixCls);
  const confirmPrefixCls = `${prefixCls}-confirm`;
  let additionalProps = {};
  if (type4) {
    additionalProps = {
      closable: closable !== null && closable !== void 0 ? closable : false,
      title: "",
      footer: "",
      children: /* @__PURE__ */ React.createElement(ConfirmContent, Object.assign({}, props, {
        confirmPrefixCls,
        rootPrefixCls,
        content: children
      }))
    };
  } else {
    additionalProps = {
      closable: closable !== null && closable !== void 0 ? closable : true,
      title,
      footer: props.footer === void 0 ? /* @__PURE__ */ React.createElement(Footer, Object.assign({}, props)) : props.footer,
      children
    };
  }
  return /* @__PURE__ */ React.createElement(Panel$1, Object.assign({
    prefixCls,
    className: classNames(hashId, `${prefixCls}-pure-panel`, type4 && confirmPrefixCls, type4 && `${confirmPrefixCls}-${type4}`, className)
  }, restProps, {
    closeIcon: renderCloseIcon(prefixCls, closeIcon),
    closable
  }, additionalProps));
};
var PurePanel$4 = PurePanel$3;
var __rest$z = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
let mousePosition;
const getClickPosition = (e2) => {
  mousePosition = {
    x: e2.pageX,
    y: e2.pageY
  };
  setTimeout(() => {
    mousePosition = null;
  }, 100);
};
if (canUseDocElement()) {
  document.documentElement.addEventListener("click", getClickPosition, true);
}
const Modal$2 = (props) => {
  var _a2;
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext$1);
  const handleCancel = (e2) => {
    const {
      onCancel
    } = props;
    onCancel === null || onCancel === void 0 ? void 0 : onCancel(e2);
  };
  const handleOk = (e2) => {
    const {
      onOk
    } = props;
    onOk === null || onOk === void 0 ? void 0 : onOk(e2);
  };
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    open,
    wrapClassName,
    centered,
    getContainer: getContainer2,
    closeIcon,
    focusTriggerAfterClose = true,
    visible,
    width = 520,
    footer: footer2
  } = props, restProps = __rest$z(props, ["prefixCls", "className", "rootClassName", "open", "wrapClassName", "centered", "getContainer", "closeIcon", "focusTriggerAfterClose", "visible", "width", "footer"]);
  const prefixCls = getPrefixCls("modal", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const [wrapSSR, hashId] = useStyle$f(prefixCls);
  const wrapClassNameExtended = classNames(wrapClassName, {
    [`${prefixCls}-centered`]: !!centered,
    [`${prefixCls}-wrap-rtl`]: direction === "rtl"
  });
  const dialogFooter = footer2 === void 0 ? /* @__PURE__ */ React.createElement(Footer, Object.assign({}, props, {
    onOk: handleOk,
    onCancel: handleCancel
  })) : footer2;
  return wrapSSR(/* @__PURE__ */ React.createElement(NoCompactStyle$1, null, /* @__PURE__ */ React.createElement(NoFormStyle$1, {
    status: true,
    override: true
  }, /* @__PURE__ */ React.createElement(DialogWrap$1, Object.assign({
    width
  }, restProps, {
    getContainer: getContainer2 === void 0 ? getContextPopupContainer : getContainer2,
    prefixCls,
    rootClassName: classNames(hashId, rootClassName),
    wrapClassName: wrapClassNameExtended,
    footer: dialogFooter,
    visible: open !== null && open !== void 0 ? open : visible,
    mousePosition: (_a2 = restProps.mousePosition) !== null && _a2 !== void 0 ? _a2 : mousePosition,
    onClose: handleCancel,
    closeIcon: renderCloseIcon(prefixCls, closeIcon),
    focusTriggerAfterClose,
    transitionName: getTransitionName$1(rootPrefixCls, "zoom", props.transitionName),
    maskTransitionName: getTransitionName$1(rootPrefixCls, "fade", props.maskTransitionName),
    className: classNames(hashId, className)
  })))));
};
var OriginModal = Modal$2;
function ConfirmContent(props) {
  const {
    icon,
    onCancel,
    onOk,
    close,
    okText,
    okButtonProps,
    cancelText,
    cancelButtonProps,
    confirmPrefixCls,
    rootPrefixCls,
    type: type4,
    okCancel,
    footer: footer2,
    locale: staticLocale
  } = props;
  let mergedIcon = icon;
  if (!icon && icon !== null) {
    switch (type4) {
      case "info":
        mergedIcon = /* @__PURE__ */ React.createElement(InfoCircleFilled$1, null);
        break;
      case "success":
        mergedIcon = /* @__PURE__ */ React.createElement(CheckCircleFilled$1, null);
        break;
      case "error":
        mergedIcon = /* @__PURE__ */ React.createElement(CloseCircleFilled$6, null);
        break;
      default:
        mergedIcon = /* @__PURE__ */ React.createElement(ExclamationCircleFilled$1, null);
    }
  }
  const okType = props.okType || "primary";
  const mergedOkCancel = okCancel !== null && okCancel !== void 0 ? okCancel : type4 === "confirm";
  const autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || "ok";
  const [locale2] = useLocale$3("Modal");
  const mergedLocale = staticLocale || locale2;
  const cancelButton = mergedOkCancel && /* @__PURE__ */ React.createElement(ActionButton$1, {
    actionFn: onCancel,
    close,
    autoFocus: autoFocusButton === "cancel",
    buttonProps: cancelButtonProps,
    prefixCls: `${rootPrefixCls}-btn`
  }, cancelText || (mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.cancelText));
  return /* @__PURE__ */ React.createElement("div", {
    className: `${confirmPrefixCls}-body-wrapper`
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${confirmPrefixCls}-body`
  }, mergedIcon, props.title === void 0 ? null : /* @__PURE__ */ React.createElement("span", {
    className: `${confirmPrefixCls}-title`
  }, props.title), /* @__PURE__ */ React.createElement("div", {
    className: `${confirmPrefixCls}-content`
  }, props.content)), footer2 === void 0 ? /* @__PURE__ */ React.createElement("div", {
    className: `${confirmPrefixCls}-btns`
  }, cancelButton, /* @__PURE__ */ React.createElement(ActionButton$1, {
    type: okType,
    actionFn: onOk,
    close,
    autoFocus: autoFocusButton === "ok",
    buttonProps: okButtonProps,
    prefixCls: `${rootPrefixCls}-btn`
  }, okText || (mergedOkCancel ? mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.okText : mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.justOkText))) : footer2);
}
const ConfirmDialog = (props) => {
  const {
    close,
    zIndex,
    afterClose,
    visible,
    open,
    keyboard,
    centered,
    getContainer: getContainer2,
    maskStyle,
    direction,
    prefixCls,
    wrapClassName,
    rootPrefixCls,
    iconPrefixCls,
    bodyStyle,
    closable = false,
    closeIcon,
    modalRender,
    focusTriggerAfterClose
  } = props;
  const confirmPrefixCls = `${prefixCls}-confirm`;
  const width = props.width || 416;
  const style2 = props.style || {};
  const mask = props.mask === void 0 ? true : props.mask;
  const maskClosable = props.maskClosable === void 0 ? false : props.maskClosable;
  const classString = classNames(confirmPrefixCls, `${confirmPrefixCls}-${props.type}`, {
    [`${confirmPrefixCls}-rtl`]: direction === "rtl"
  }, props.className);
  return /* @__PURE__ */ React.createElement(ConfigProvider, {
    prefixCls: rootPrefixCls,
    iconPrefixCls,
    direction
  }, /* @__PURE__ */ React.createElement(OriginModal, {
    prefixCls,
    className: classString,
    wrapClassName: classNames({
      [`${confirmPrefixCls}-centered`]: !!props.centered
    }, wrapClassName),
    onCancel: () => close === null || close === void 0 ? void 0 : close({
      triggerCancel: true
    }),
    open,
    title: "",
    footer: null,
    transitionName: getTransitionName$1(rootPrefixCls, "zoom", props.transitionName),
    maskTransitionName: getTransitionName$1(rootPrefixCls, "fade", props.maskTransitionName),
    mask,
    maskClosable,
    maskStyle,
    style: style2,
    bodyStyle,
    width,
    zIndex,
    afterClose,
    keyboard,
    centered,
    getContainer: getContainer2,
    closable,
    closeIcon,
    modalRender,
    focusTriggerAfterClose
  }, /* @__PURE__ */ React.createElement(ConfirmContent, Object.assign({}, props, {
    confirmPrefixCls
  }))));
};
const destroyFns = [];
var destroyFns$1 = destroyFns;
var __rest$y = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
let defaultRootPrefixCls = "";
function getRootPrefixCls() {
  return defaultRootPrefixCls;
}
function confirm(config) {
  const container = document.createDocumentFragment();
  let currentConfig = Object.assign(Object.assign({}, config), {
    close,
    open: true
  });
  let timeoutId;
  function destroy() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const triggerCancel = args.some((param) => param && param.triggerCancel);
    if (config.onCancel && triggerCancel) {
      config.onCancel.apply(config, [() => {
      }].concat(_toConsumableArray(args.slice(1))));
    }
    for (let i = 0; i < destroyFns$1.length; i++) {
      const fn2 = destroyFns$1[i];
      if (fn2 === close) {
        destroyFns$1.splice(i, 1);
        break;
      }
    }
    unmount$1(container);
  }
  function render2(_a2) {
    var {
      okText,
      cancelText,
      prefixCls: customizePrefixCls
    } = _a2, props = __rest$y(_a2, ["okText", "cancelText", "prefixCls"]);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      const runtimeLocale2 = getConfirmLocale$1();
      const {
        getPrefixCls,
        getIconPrefixCls
      } = globalConfig();
      const rootPrefixCls = getPrefixCls(void 0, getRootPrefixCls());
      const prefixCls = customizePrefixCls || `${rootPrefixCls}-modal`;
      const iconPrefixCls = getIconPrefixCls();
      render$2(/* @__PURE__ */ React.createElement(ConfirmDialog, Object.assign({}, props, {
        prefixCls,
        rootPrefixCls,
        iconPrefixCls,
        okText,
        locale: runtimeLocale2,
        cancelText: cancelText || runtimeLocale2.cancelText
      })), container);
    });
  }
  function close() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    currentConfig = Object.assign(Object.assign({}, currentConfig), {
      open: false,
      afterClose: () => {
        if (typeof config.afterClose === "function") {
          config.afterClose();
        }
        destroy.apply(this, args);
      }
    });
    if (currentConfig.visible) {
      delete currentConfig.visible;
    }
    render2(currentConfig);
  }
  function update(configUpdate) {
    if (typeof configUpdate === "function") {
      currentConfig = configUpdate(currentConfig);
    } else {
      currentConfig = Object.assign(Object.assign({}, currentConfig), configUpdate);
    }
    render2(currentConfig);
  }
  render2(currentConfig);
  destroyFns$1.push(close);
  return {
    destroy: close,
    update
  };
}
function withWarn(props) {
  return Object.assign(Object.assign({}, props), {
    type: "warning"
  });
}
function withInfo(props) {
  return Object.assign(Object.assign({}, props), {
    type: "info"
  });
}
function withSuccess(props) {
  return Object.assign(Object.assign({}, props), {
    type: "success"
  });
}
function withError(props) {
  return Object.assign(Object.assign({}, props), {
    type: "error"
  });
}
function withConfirm(props) {
  return Object.assign(Object.assign({}, props), {
    type: "confirm"
  });
}
function modalGlobalConfig(_ref2) {
  let {
    rootPrefixCls
  } = _ref2;
  defaultRootPrefixCls = rootPrefixCls;
}
const HookModal = (_ref2, ref2) => {
  let {
    afterClose: hookAfterClose,
    config
  } = _ref2;
  var _a2;
  const [open, setOpen] = React.useState(true);
  const [innerConfig, setInnerConfig] = React.useState(config);
  const {
    direction,
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("modal");
  const rootPrefixCls = getPrefixCls();
  const afterClose = () => {
    var _a3;
    hookAfterClose();
    (_a3 = innerConfig.afterClose) === null || _a3 === void 0 ? void 0 : _a3.call(innerConfig);
  };
  const close = function() {
    setOpen(false);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const triggerCancel = args.some((param) => param && param.triggerCancel);
    if (innerConfig.onCancel && triggerCancel) {
      innerConfig.onCancel.apply(innerConfig, [() => {
      }].concat(_toConsumableArray(args.slice(1))));
    }
  };
  React.useImperativeHandle(ref2, () => ({
    destroy: close,
    update: (newConfig) => {
      setInnerConfig((originConfig) => Object.assign(Object.assign({}, originConfig), newConfig));
    }
  }));
  const mergedOkCancel = (_a2 = innerConfig.okCancel) !== null && _a2 !== void 0 ? _a2 : innerConfig.type === "confirm";
  const [contextLocale] = useLocale$3("Modal", defaultLocale.Modal);
  return /* @__PURE__ */ React.createElement(ConfirmDialog, Object.assign({
    prefixCls,
    rootPrefixCls
  }, innerConfig, {
    close,
    open,
    afterClose,
    okText: innerConfig.okText || (mergedOkCancel ? contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.okText : contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.justOkText),
    direction: innerConfig.direction || direction,
    cancelText: innerConfig.cancelText || (contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.cancelText)
  }));
};
var HookModal$1 = /* @__PURE__ */ React.forwardRef(HookModal);
let uuid$5 = 0;
const ElementsHolder = /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef((_props, ref2) => {
  const [elements, patchElement] = usePatchElement();
  React.useImperativeHandle(ref2, () => ({
    patchElement
  }), []);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, elements);
}));
function useModal() {
  const holderRef = React.useRef(null);
  const [actionQueue, setActionQueue] = React.useState([]);
  React.useEffect(() => {
    if (actionQueue.length) {
      const cloneQueue = _toConsumableArray(actionQueue);
      cloneQueue.forEach((action) => {
        action();
      });
      setActionQueue([]);
    }
  }, [actionQueue]);
  const getConfirmFunc = React.useCallback((withFunc) => function hookConfirm(config) {
    var _a2;
    uuid$5 += 1;
    const modalRef = /* @__PURE__ */ React.createRef();
    let closeFunc;
    const modal = /* @__PURE__ */ React.createElement(HookModal$1, {
      key: `modal-${uuid$5}`,
      config: withFunc(config),
      ref: modalRef,
      afterClose: () => {
        closeFunc === null || closeFunc === void 0 ? void 0 : closeFunc();
      }
    });
    closeFunc = (_a2 = holderRef.current) === null || _a2 === void 0 ? void 0 : _a2.patchElement(modal);
    if (closeFunc) {
      destroyFns$1.push(closeFunc);
    }
    return {
      destroy: () => {
        function destroyAction() {
          var _a3;
          (_a3 = modalRef.current) === null || _a3 === void 0 ? void 0 : _a3.destroy();
        }
        if (modalRef.current) {
          destroyAction();
        } else {
          setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [destroyAction]));
        }
      },
      update: (newConfig) => {
        function updateAction() {
          var _a3;
          (_a3 = modalRef.current) === null || _a3 === void 0 ? void 0 : _a3.update(newConfig);
        }
        if (modalRef.current) {
          updateAction();
        } else {
          setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [updateAction]));
        }
      }
    };
  }, []);
  const fns = React.useMemo(() => ({
    info: getConfirmFunc(withInfo),
    success: getConfirmFunc(withSuccess),
    error: getConfirmFunc(withError),
    warning: getConfirmFunc(withWarn),
    confirm: getConfirmFunc(withConfirm)
  }), []);
  return [fns, /* @__PURE__ */ React.createElement(ElementsHolder, {
    key: "modal-holder",
    ref: holderRef
  })];
}
function useEvent$5(callback) {
  var fnRef = React.useRef();
  fnRef.current = callback;
  var memoFn = React.useCallback(function() {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
function canUseDom$a() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var useLayoutEffect$9 = canUseDom$a() ? React.useLayoutEffect : React.useEffect;
var useLayoutUpdateEffect$3 = function useLayoutUpdateEffect(callback, deps) {
  var firstMountRef = React.useRef(true);
  useLayoutEffect$9(function() {
    if (!firstMountRef.current) {
      return callback();
    }
  }, deps);
  useLayoutEffect$9(function() {
    firstMountRef.current = false;
    return function() {
      firstMountRef.current = true;
    };
  }, []);
};
function useSafeState$2(defaultValue) {
  var destroyRef = React.useRef(false);
  var _React$useState = React.useState(defaultValue), _React$useState2 = _slicedToArray$1(_React$useState, 2), value = _React$useState2[0], setValue2 = _React$useState2[1];
  React.useEffect(function() {
    destroyRef.current = false;
    return function() {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue2(updater);
  }
  return [value, safeSetState];
}
var Source$1;
(function(Source2) {
  Source2[Source2["INNER"] = 0] = "INNER";
  Source2[Source2["PROP"] = 1] = "PROP";
})(Source$1 || (Source$1 = {}));
function hasValue$4(value) {
  return value !== void 0;
}
function useMergedState$3(defaultStateValue, option) {
  var _ref2 = option || {}, defaultValue = _ref2.defaultValue, value = _ref2.value, onChange = _ref2.onChange, postState = _ref2.postState;
  var _useState = useSafeState$2(function() {
    var finalValue = void 0;
    var source;
    if (hasValue$4(value)) {
      finalValue = value;
      source = Source$1.PROP;
    } else if (hasValue$4(defaultValue)) {
      finalValue = typeof defaultValue === "function" ? defaultValue() : defaultValue;
      source = Source$1.PROP;
    } else {
      finalValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
      source = Source$1.INNER;
    }
    return [finalValue, source, finalValue];
  }), _useState2 = _slicedToArray$1(_useState, 2), mergedValue = _useState2[0], setMergedValue = _useState2[1];
  var chosenValue = hasValue$4(value) ? value : mergedValue[0];
  var postMergedValue = postState ? postState(chosenValue) : chosenValue;
  useLayoutUpdateEffect$3(function() {
    setMergedValue(function(_ref22) {
      var _ref3 = _slicedToArray$1(_ref22, 1), prevValue = _ref3[0];
      return [value, Source$1.PROP, prevValue];
    });
  }, [value]);
  var changeEventPrevRef = React.useRef();
  var triggerChange = useEvent$5(function(updater, ignoreDestroy) {
    setMergedValue(function(prev2) {
      var _prev = _slicedToArray$1(prev2, 3), prevValue = _prev[0], prevSource = _prev[1], prevPrevValue = _prev[2];
      var nextValue = typeof updater === "function" ? updater(prevValue) : updater;
      if (nextValue === prevValue) {
        return prev2;
      }
      var overridePrevValue = prevSource === Source$1.INNER && changeEventPrevRef.current !== prevPrevValue ? prevPrevValue : prevValue;
      return [nextValue, Source$1.INNER, overridePrevValue];
    }, ignoreDestroy);
  });
  var onChangeFn = useEvent$5(onChange);
  useLayoutEffect$9(function() {
    var _mergedValue = _slicedToArray$1(mergedValue, 3), current = _mergedValue[0], source = _mergedValue[1], prev2 = _mergedValue[2];
    if (current !== prev2 && source === Source$1.INNER) {
      onChangeFn(current, prev2);
      changeEventPrevRef.current = prev2;
    }
  }, [mergedValue]);
  return [postMergedValue, triggerChange];
}
var warned$3 = {};
function warning$7(valid2, message) {
}
function call$3(method4, valid2, message) {
  if (!valid2 && !warned$3[message]) {
    method4(false, message);
    warned$3[message] = true;
  }
}
function warningOnce$3(valid2, message) {
  call$3(warning$7, valid2, message);
}
var isMobile$4 = function() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
};
var KeyCode$3 = {
  MAC_ENTER: 3,
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  PRINT_SCREEN: 44,
  INSERT: 45,
  DELETE: 46,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  QUESTION_MARK: 63,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  META: 91,
  WIN_KEY_RIGHT: 92,
  CONTEXT_MENU: 93,
  NUM_ZERO: 96,
  NUM_ONE: 97,
  NUM_TWO: 98,
  NUM_THREE: 99,
  NUM_FOUR: 100,
  NUM_FIVE: 101,
  NUM_SIX: 102,
  NUM_SEVEN: 103,
  NUM_EIGHT: 104,
  NUM_NINE: 105,
  NUM_MULTIPLY: 106,
  NUM_PLUS: 107,
  NUM_MINUS: 109,
  NUM_PERIOD: 110,
  NUM_DIVISION: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SEMICOLON: 186,
  DASH: 189,
  EQUALS: 187,
  COMMA: 188,
  PERIOD: 190,
  SLASH: 191,
  APOSTROPHE: 192,
  SINGLE_QUOTE: 222,
  OPEN_SQUARE_BRACKET: 219,
  BACKSLASH: 220,
  CLOSE_SQUARE_BRACKET: 221,
  WIN_KEY: 224,
  MAC_FF_META: 224,
  WIN_IME: 229,
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent3(e2) {
    var keyCode = e2.keyCode;
    if (e2.altKey && !e2.ctrlKey || e2.metaKey || keyCode >= KeyCode$3.F1 && keyCode <= KeyCode$3.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode$3.ALT:
      case KeyCode$3.CAPS_LOCK:
      case KeyCode$3.CONTEXT_MENU:
      case KeyCode$3.CTRL:
      case KeyCode$3.DOWN:
      case KeyCode$3.END:
      case KeyCode$3.ESC:
      case KeyCode$3.HOME:
      case KeyCode$3.INSERT:
      case KeyCode$3.LEFT:
      case KeyCode$3.MAC_FF_META:
      case KeyCode$3.META:
      case KeyCode$3.NUMLOCK:
      case KeyCode$3.NUM_CENTER:
      case KeyCode$3.PAGE_DOWN:
      case KeyCode$3.PAGE_UP:
      case KeyCode$3.PAUSE:
      case KeyCode$3.PRINT_SCREEN:
      case KeyCode$3.RIGHT:
      case KeyCode$3.SHIFT:
      case KeyCode$3.UP:
      case KeyCode$3.WIN_KEY:
      case KeyCode$3.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  isCharacterKey: function isCharacterKey3(keyCode) {
    if (keyCode >= KeyCode$3.ZERO && keyCode <= KeyCode$3.NINE) {
      return true;
    }
    if (keyCode >= KeyCode$3.NUM_ZERO && keyCode <= KeyCode$3.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode$3.A && keyCode <= KeyCode$3.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode$3.SPACE:
      case KeyCode$3.QUESTION_MARK:
      case KeyCode$3.NUM_PLUS:
      case KeyCode$3.NUM_MINUS:
      case KeyCode$3.NUM_PERIOD:
      case KeyCode$3.NUM_DIVISION:
      case KeyCode$3.SEMICOLON:
      case KeyCode$3.DASH:
      case KeyCode$3.EQUALS:
      case KeyCode$3.COMMA:
      case KeyCode$3.PERIOD:
      case KeyCode$3.SLASH:
      case KeyCode$3.APOSTROPHE:
      case KeyCode$3.SINGLE_QUOTE:
      case KeyCode$3.OPEN_SQUARE_BRACKET:
      case KeyCode$3.BACKSLASH:
      case KeyCode$3.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
function useMemo$4(getValue2, condition, shouldUpdate) {
  var cacheRef = React.useRef({});
  if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue2();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
function fillRef$4(ref2, node2) {
  if (typeof ref2 === "function") {
    ref2(node2);
  } else if (_typeof$8(ref2) === "object" && ref2 && "current" in ref2) {
    ref2.current = node2;
  }
}
function composeRef$4() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function(ref2) {
    return ref2;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function(node2) {
    refs.forEach(function(ref2) {
      fillRef$4(ref2, node2);
    });
  };
}
function useComposeRef$3() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }
  return useMemo$4(function() {
    return composeRef$4.apply(void 0, refs);
  }, refs, function(prev2, next2) {
    return prev2.length === next2.length && prev2.every(function(ref2, i) {
      return ref2 === next2[i];
    });
  });
}
var BaseSelectContext = /* @__PURE__ */ React.createContext(null);
function useBaseProps() {
  return React.useContext(BaseSelectContext);
}
function useDelayReset() {
  var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
  var _React$useState = React.useState(false), _React$useState2 = _slicedToArray$1(_React$useState, 2), bool = _React$useState2[0], setBool = _React$useState2[1];
  var delayRef = React.useRef(null);
  var cancelLatest = function cancelLatest2() {
    window.clearTimeout(delayRef.current);
  };
  React.useEffect(function() {
    return cancelLatest;
  }, []);
  var delaySetBool = function delaySetBool2(value, callback) {
    cancelLatest();
    delayRef.current = window.setTimeout(function() {
      setBool(value);
      if (callback) {
        callback();
      }
    }, timeout);
  };
  return [bool, delaySetBool, cancelLatest];
}
function useLock() {
  var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
  var lockRef = React.useRef(null);
  var timeoutRef = React.useRef(null);
  React.useEffect(function() {
    return function() {
      window.clearTimeout(timeoutRef.current);
    };
  }, []);
  function doLock(locked) {
    if (locked || lockRef.current === null) {
      lockRef.current = locked;
    }
    window.clearTimeout(timeoutRef.current);
    timeoutRef.current = window.setTimeout(function() {
      lockRef.current = null;
    }, duration);
  }
  return [function() {
    return lockRef.current;
  }, doLock];
}
function useSelectTriggerControl(elements, open, triggerOpen, customizedTrigger) {
  var propsRef = React.useRef(null);
  propsRef.current = {
    open,
    triggerOpen,
    customizedTrigger
  };
  React.useEffect(function() {
    function onGlobalMouseDown(event) {
      var _propsRef$current;
      if ((_propsRef$current = propsRef.current) !== null && _propsRef$current !== void 0 && _propsRef$current.customizedTrigger) {
        return;
      }
      var target = event.target;
      if (target.shadowRoot && event.composed) {
        target = event.composedPath()[0] || target;
      }
      if (propsRef.current.open && elements().filter(function(element2) {
        return element2;
      }).every(function(element2) {
        return !element2.contains(target) && element2 !== target;
      })) {
        propsRef.current.triggerOpen(false);
      }
    }
    window.addEventListener("mousedown", onGlobalMouseDown);
    return function() {
      return window.removeEventListener("mousedown", onGlobalMouseDown);
    };
  }, []);
}
var attributes$2 = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
var eventsName$2 = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
var propList$2 = "".concat(attributes$2, " ").concat(eventsName$2).split(/[\s\n]+/);
var ariaPrefix$2 = "aria-";
var dataPrefix$2 = "data-";
function match$2(key, prefix2) {
  return key.indexOf(prefix2) === 0;
}
function pickAttrs$2(props) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _objectSpread2$d({}, ariaOnly);
  }
  var attrs = {};
  Object.keys(props).forEach(function(key) {
    if (mergedConfig.aria && (key === "role" || match$2(key, ariaPrefix$2)) || mergedConfig.data && match$2(key, dataPrefix$2) || mergedConfig.attr && propList$2.includes(key)) {
      attrs[key] = props[key];
    }
  });
  return attrs;
}
var useLayoutEffect$8 = canUseDom$f() ? React.useLayoutEffect : React.useEffect;
var useLayoutUpdateEffect$2 = function useLayoutUpdateEffect2(callback, deps) {
  var firstMountRef = React.useRef(true);
  useLayoutEffect$8(function() {
    if (!firstMountRef.current) {
      return callback();
    }
  }, deps);
  useLayoutEffect$8(function() {
    firstMountRef.current = false;
    return function() {
      firstMountRef.current = true;
    };
  }, []);
};
var _excluded$J = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];
var UNDEFINED$2 = void 0;
function InternalItem$3(props, ref2) {
  var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey2 = props.itemKey, className = props.className, style2 = props.style, children = props.children, display = props.display, order2 = props.order, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties$1(props, _excluded$J);
  var mergedHidden = responsive && !display;
  function internalRegisterSize(width) {
    registerSize(itemKey2, width);
  }
  React.useEffect(function() {
    return function() {
      internalRegisterSize(null);
    };
  }, []);
  var childNode = renderItem && item !== UNDEFINED$2 ? renderItem(item) : children;
  var overflowStyle;
  if (!invalidate) {
    overflowStyle = {
      opacity: mergedHidden ? 0 : 1,
      height: mergedHidden ? 0 : UNDEFINED$2,
      overflowY: mergedHidden ? "hidden" : UNDEFINED$2,
      order: responsive ? order2 : UNDEFINED$2,
      pointerEvents: mergedHidden ? "none" : UNDEFINED$2,
      position: mergedHidden ? "absolute" : UNDEFINED$2
    };
  }
  var overflowProps = {};
  if (mergedHidden) {
    overflowProps["aria-hidden"] = true;
  }
  var itemNode = /* @__PURE__ */ React.createElement(Component, _extends$3({
    className: classNames(!invalidate && prefixCls, className),
    style: _objectSpread2$d(_objectSpread2$d({}, overflowStyle), style2)
  }, overflowProps, restProps, {
    ref: ref2
  }), childNode);
  if (responsive) {
    itemNode = /* @__PURE__ */ React.createElement(ResizeObserver$2, {
      onResize: function onResize2(_ref2) {
        var offsetWidth = _ref2.offsetWidth;
        internalRegisterSize(offsetWidth);
      },
      disabled: responsiveDisabled
    }, itemNode);
  }
  return itemNode;
}
var Item$8 = /* @__PURE__ */ React.forwardRef(InternalItem$3);
Item$8.displayName = "Item";
function useBatchFrameState() {
  var _useState = useSafeState$4({}), _useState2 = _slicedToArray$1(_useState, 2), forceUpdate = _useState2[1];
  var statesRef = React.useRef([]);
  var walkingIndex = 0;
  var beforeFrameId = 0;
  function createState(defaultValue) {
    var myIndex = walkingIndex;
    walkingIndex += 1;
    if (statesRef.current.length < myIndex + 1) {
      statesRef.current[myIndex] = defaultValue;
    }
    var value = statesRef.current[myIndex];
    function setValue2(val) {
      statesRef.current[myIndex] = typeof val === "function" ? val(statesRef.current[myIndex]) : val;
      wrapperRaf$6.cancel(beforeFrameId);
      beforeFrameId = wrapperRaf$6(function() {
        forceUpdate({}, true);
      });
    }
    return [value, setValue2];
  }
  return createState;
}
var _excluded$I = ["component"], _excluded2$b = ["className"], _excluded3$4 = ["className"];
var InternalRawItem$2 = function InternalRawItem(props, ref2) {
  var context2 = React.useContext(OverflowContext$2);
  if (!context2) {
    var _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties$1(props, _excluded$I);
    return /* @__PURE__ */ React.createElement(Component, _extends$3({}, _restProps, {
      ref: ref2
    }));
  }
  var contextClassName = context2.className, restContext = _objectWithoutProperties$1(context2, _excluded2$b);
  var className = props.className, restProps = _objectWithoutProperties$1(props, _excluded3$4);
  return /* @__PURE__ */ React.createElement(OverflowContext$2.Provider, {
    value: null
  }, /* @__PURE__ */ React.createElement(Item$8, _extends$3({
    ref: ref2,
    className: classNames(contextClassName, className)
  }, restContext, restProps)));
};
var RawItem$2 = /* @__PURE__ */ React.forwardRef(InternalRawItem$2);
RawItem$2.displayName = "RawItem";
var _excluded$H = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];
var OverflowContext$2 = /* @__PURE__ */ React.createContext(null);
var RESPONSIVE$2 = "responsive";
var INVALIDATE$2 = "invalidate";
function defaultRenderRest$2(omittedItems) {
  return "+ ".concat(omittedItems.length, " ...");
}
function Overflow$2(props, ref2) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data2 = _props$data === void 0 ? [] : _props$data, renderItem = props.renderItem, renderRawItem = props.renderRawItem, itemKey2 = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style2 = props.style, className = props.className, maxCount = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix = props.suffix, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties$1(props, _excluded$H);
  var createUseState = useBatchFrameState();
  var fullySSR = ssr === "full";
  var _createUseState = createUseState(null), _createUseState2 = _slicedToArray$1(_createUseState, 2), containerWidth = _createUseState2[0], setContainerWidth = _createUseState2[1];
  var mergedContainerWidth = containerWidth || 0;
  var _createUseState3 = createUseState(/* @__PURE__ */ new Map()), _createUseState4 = _slicedToArray$1(_createUseState3, 2), itemWidths = _createUseState4[0], setItemWidths = _createUseState4[1];
  var _createUseState5 = createUseState(0), _createUseState6 = _slicedToArray$1(_createUseState5, 2), prevRestWidth = _createUseState6[0], setPrevRestWidth = _createUseState6[1];
  var _createUseState7 = createUseState(0), _createUseState8 = _slicedToArray$1(_createUseState7, 2), restWidth = _createUseState8[0], setRestWidth = _createUseState8[1];
  var _createUseState9 = createUseState(0), _createUseState10 = _slicedToArray$1(_createUseState9, 2), suffixWidth = _createUseState10[0], setSuffixWidth = _createUseState10[1];
  var _useState = React.useState(null), _useState2 = _slicedToArray$1(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1];
  var _useState3 = React.useState(null), _useState4 = _slicedToArray$1(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1];
  var mergedDisplayCount = React.useMemo(function() {
    if (displayCount === null && fullySSR) {
      return Number.MAX_SAFE_INTEGER;
    }
    return displayCount || 0;
  }, [displayCount, containerWidth]);
  var _useState5 = React.useState(false), _useState6 = _slicedToArray$1(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1];
  var itemPrefixCls = "".concat(prefixCls, "-item");
  var mergedRestWidth = Math.max(prevRestWidth, restWidth);
  var isResponsive = maxCount === RESPONSIVE$2;
  var shouldResponsive = data2.length && isResponsive;
  var invalidate = maxCount === INVALIDATE$2;
  var showRest = shouldResponsive || typeof maxCount === "number" && data2.length > maxCount;
  var mergedData = React.useMemo(function() {
    var items = data2;
    if (shouldResponsive) {
      if (containerWidth === null && fullySSR) {
        items = data2;
      } else {
        items = data2.slice(0, Math.min(data2.length, mergedContainerWidth / itemWidth));
      }
    } else if (typeof maxCount === "number") {
      items = data2.slice(0, maxCount);
    }
    return items;
  }, [data2, itemWidth, containerWidth, maxCount, shouldResponsive]);
  var omittedItems = React.useMemo(function() {
    if (shouldResponsive) {
      return data2.slice(mergedDisplayCount + 1);
    }
    return data2.slice(mergedData.length);
  }, [data2, mergedData, shouldResponsive, mergedDisplayCount]);
  var getKey3 = React.useCallback(function(item, index2) {
    var _ref2;
    if (typeof itemKey2 === "function") {
      return itemKey2(item);
    }
    return (_ref2 = itemKey2 && (item === null || item === void 0 ? void 0 : item[itemKey2])) !== null && _ref2 !== void 0 ? _ref2 : index2;
  }, [itemKey2]);
  var mergedRenderItem = React.useCallback(renderItem || function(item) {
    return item;
  }, [renderItem]);
  function updateDisplayCount(count, suffixFixedStartVal, notReady) {
    if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
      return;
    }
    setDisplayCount(count);
    if (!notReady) {
      setRestReady(count < data2.length - 1);
      onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(count);
    }
    if (suffixFixedStartVal !== void 0) {
      setSuffixFixedStart(suffixFixedStartVal);
    }
  }
  function onOverflowResize(_24, element2) {
    setContainerWidth(element2.clientWidth);
  }
  function registerSize(key, width) {
    setItemWidths(function(origin) {
      var clone2 = new Map(origin);
      if (width === null) {
        clone2.delete(key);
      } else {
        clone2.set(key, width);
      }
      return clone2;
    });
  }
  function registerOverflowSize(_24, width) {
    setRestWidth(width);
    setPrevRestWidth(restWidth);
  }
  function registerSuffixSize(_24, width) {
    setSuffixWidth(width);
  }
  function getItemWidth(index2) {
    return itemWidths.get(getKey3(mergedData[index2], index2));
  }
  useLayoutEffect$8(function() {
    if (mergedContainerWidth && mergedRestWidth && mergedData) {
      var totalWidth = suffixWidth;
      var len = mergedData.length;
      var lastIndex = len - 1;
      if (!len) {
        updateDisplayCount(0, null);
        return;
      }
      for (var i = 0; i < len; i += 1) {
        var currentItemWidth = getItemWidth(i);
        if (fullySSR) {
          currentItemWidth = currentItemWidth || 0;
        }
        if (currentItemWidth === void 0) {
          updateDisplayCount(i - 1, void 0, true);
          break;
        }
        totalWidth += currentItemWidth;
        if (lastIndex === 0 && totalWidth <= mergedContainerWidth || i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth) {
          updateDisplayCount(lastIndex, null);
          break;
        } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
          updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
          break;
        }
      }
      if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
        setSuffixFixedStart(null);
      }
    }
  }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey3, mergedData]);
  var displayRest = restReady && !!omittedItems.length;
  var suffixStyle = {};
  if (suffixFixedStart !== null && shouldResponsive) {
    suffixStyle = {
      position: "absolute",
      left: suffixFixedStart,
      top: 0
    };
  }
  var itemSharedProps = {
    prefixCls: itemPrefixCls,
    responsive: shouldResponsive,
    component: itemComponent,
    invalidate
  };
  var internalRenderItemNode = renderRawItem ? function(item, index2) {
    var key = getKey3(item, index2);
    return /* @__PURE__ */ React.createElement(OverflowContext$2.Provider, {
      key,
      value: _objectSpread2$d(_objectSpread2$d({}, itemSharedProps), {}, {
        order: index2,
        item,
        itemKey: key,
        registerSize,
        display: index2 <= mergedDisplayCount
      })
    }, renderRawItem(item, index2));
  } : function(item, index2) {
    var key = getKey3(item, index2);
    return /* @__PURE__ */ React.createElement(Item$8, _extends$3({}, itemSharedProps, {
      order: index2,
      key,
      item,
      renderItem: mergedRenderItem,
      itemKey: key,
      registerSize,
      display: index2 <= mergedDisplayCount
    }));
  };
  var restNode;
  var restContextProps = {
    order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
    className: "".concat(itemPrefixCls, "-rest"),
    registerSize: registerOverflowSize,
    display: displayRest
  };
  if (!renderRawRest) {
    var mergedRenderRest = renderRest || defaultRenderRest$2;
    restNode = /* @__PURE__ */ React.createElement(Item$8, _extends$3({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
  } else if (renderRawRest) {
    restNode = /* @__PURE__ */ React.createElement(OverflowContext$2.Provider, {
      value: _objectSpread2$d(_objectSpread2$d({}, itemSharedProps), restContextProps)
    }, renderRawRest(omittedItems));
  }
  var overflowNode = /* @__PURE__ */ React.createElement(Component, _extends$3({
    className: classNames(!invalidate && prefixCls, className),
    style: style2,
    ref: ref2
  }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ React.createElement(Item$8, _extends$3({}, itemSharedProps, {
    responsive: isResponsive,
    responsiveDisabled: !shouldResponsive,
    order: mergedDisplayCount,
    className: "".concat(itemPrefixCls, "-suffix"),
    registerSize: registerSuffixSize,
    display: true,
    style: suffixStyle
  }), suffix));
  if (isResponsive) {
    overflowNode = /* @__PURE__ */ React.createElement(ResizeObserver$2, {
      onResize: onOverflowResize,
      disabled: !shouldResponsive
    }, overflowNode);
  }
  return overflowNode;
}
var ForwardOverflow$2 = /* @__PURE__ */ React.forwardRef(Overflow$2);
ForwardOverflow$2.displayName = "Overflow";
ForwardOverflow$2.Item = RawItem$2;
ForwardOverflow$2.RESPONSIVE = RESPONSIVE$2;
ForwardOverflow$2.INVALIDATE = INVALIDATE$2;
var TransBtn = function TransBtn2(_ref2) {
  var className = _ref2.className, customizeIcon = _ref2.customizeIcon, customizeIconProps = _ref2.customizeIconProps, _onMouseDown = _ref2.onMouseDown, onClick = _ref2.onClick, children = _ref2.children;
  var icon;
  if (typeof customizeIcon === "function") {
    icon = customizeIcon(customizeIconProps);
  } else {
    icon = customizeIcon;
  }
  return /* @__PURE__ */ React.createElement("span", {
    className,
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      if (_onMouseDown) {
        _onMouseDown(event);
      }
    },
    style: {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    unselectable: "on",
    onClick,
    "aria-hidden": true
  }, icon !== void 0 ? icon : /* @__PURE__ */ React.createElement("span", {
    className: classNames(className.split(/\s+/).map(function(cls) {
      return "".concat(cls, "-icon");
    }))
  }, children));
};
var Input$3 = function Input(_ref2, ref2) {
  var _inputNode2, _inputNode2$props;
  var prefixCls = _ref2.prefixCls, id = _ref2.id, inputElement = _ref2.inputElement, disabled = _ref2.disabled, tabIndex = _ref2.tabIndex, autoFocus = _ref2.autoFocus, autoComplete = _ref2.autoComplete, editable = _ref2.editable, activeDescendantId = _ref2.activeDescendantId, value = _ref2.value, maxLength = _ref2.maxLength, _onKeyDown = _ref2.onKeyDown, _onMouseDown = _ref2.onMouseDown, _onChange = _ref2.onChange, onPaste = _ref2.onPaste, _onCompositionStart = _ref2.onCompositionStart, _onCompositionEnd = _ref2.onCompositionEnd, open = _ref2.open, attrs = _ref2.attrs;
  var inputNode = inputElement || /* @__PURE__ */ React.createElement("input", null);
  var _inputNode = inputNode, originRef = _inputNode.ref, originProps = _inputNode.props;
  var onOriginKeyDown = originProps.onKeyDown, onOriginChange = originProps.onChange, onOriginMouseDown = originProps.onMouseDown, onOriginCompositionStart = originProps.onCompositionStart, onOriginCompositionEnd = originProps.onCompositionEnd, style2 = originProps.style;
  warning$7(!("maxLength" in inputNode.props));
  inputNode = /* @__PURE__ */ React.cloneElement(inputNode, _objectSpread2$d(_objectSpread2$d(_objectSpread2$d({
    type: "search"
  }, originProps), {}, {
    id,
    ref: composeRef$4(ref2, originRef),
    disabled,
    tabIndex,
    autoComplete: autoComplete || "off",
    autoFocus,
    className: classNames("".concat(prefixCls, "-selection-search-input"), (_inputNode2 = inputNode) === null || _inputNode2 === void 0 ? void 0 : (_inputNode2$props = _inputNode2.props) === null || _inputNode2$props === void 0 ? void 0 : _inputNode2$props.className),
    role: "combobox",
    "aria-expanded": open,
    "aria-haspopup": "listbox",
    "aria-owns": "".concat(id, "_list"),
    "aria-autocomplete": "list",
    "aria-controls": "".concat(id, "_list"),
    "aria-activedescendant": activeDescendantId
  }, attrs), {}, {
    value: editable ? value : "",
    maxLength,
    readOnly: !editable,
    unselectable: !editable ? "on" : null,
    style: _objectSpread2$d(_objectSpread2$d({}, style2), {}, {
      opacity: editable ? null : 0
    }),
    onKeyDown: function onKeyDown(event) {
      _onKeyDown(event);
      if (onOriginKeyDown) {
        onOriginKeyDown(event);
      }
    },
    onMouseDown: function onMouseDown(event) {
      _onMouseDown(event);
      if (onOriginMouseDown) {
        onOriginMouseDown(event);
      }
    },
    onChange: function onChange(event) {
      _onChange(event);
      if (onOriginChange) {
        onOriginChange(event);
      }
    },
    onCompositionStart: function onCompositionStart(event) {
      _onCompositionStart(event);
      if (onOriginCompositionStart) {
        onOriginCompositionStart(event);
      }
    },
    onCompositionEnd: function onCompositionEnd(event) {
      _onCompositionEnd(event);
      if (onOriginCompositionEnd) {
        onOriginCompositionEnd(event);
      }
    },
    onPaste
  }));
  return inputNode;
};
var RefInput = /* @__PURE__ */ React.forwardRef(Input$3);
RefInput.displayName = "Input";
function toArray$8(value) {
  if (Array.isArray(value)) {
    return value;
  }
  return value !== void 0 ? [value] : [];
}
var isClient = typeof window !== "undefined" && window.document && window.document.documentElement;
var isBrowserClient$1 = isClient;
function hasValue$3(value) {
  return value !== void 0 && value !== null;
}
function isTitleType$1(title) {
  return ["string", "number"].includes(_typeof$8(title));
}
function getTitle(item) {
  var title = void 0;
  if (item) {
    if (isTitleType$1(item.title)) {
      title = item.title.toString();
    } else if (isTitleType$1(item.label)) {
      title = item.label.toString();
    }
  }
  return title;
}
function useLayoutEffect$7(effect, deps) {
  if (isBrowserClient$1) {
    React.useLayoutEffect(effect, deps);
  } else {
    React.useEffect(effect, deps);
  }
}
function itemKey(value) {
  var _value$key;
  return (_value$key = value.key) !== null && _value$key !== void 0 ? _value$key : value.value;
}
var onPreventMouseDown = function onPreventMouseDown2(event) {
  event.preventDefault();
  event.stopPropagation();
};
var SelectSelector = function SelectSelector2(props) {
  var id = props.id, prefixCls = props.prefixCls, values = props.values, open = props.open, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, inputRef = props.inputRef, placeholder = props.placeholder, disabled = props.disabled, mode = props.mode, showSearch = props.showSearch, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, tabIndex = props.tabIndex, removeIcon = props.removeIcon, maxTagCount = props.maxTagCount, maxTagTextLength = props.maxTagTextLength, _props$maxTagPlacehol = props.maxTagPlaceholder, maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function(omittedValues) {
    return "+ ".concat(omittedValues.length, " ...");
  } : _props$maxTagPlacehol, tagRender = props.tagRender, onToggleOpen = props.onToggleOpen, onRemove = props.onRemove, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd;
  var measureRef = React.useRef(null);
  var _useState = React.useState(0), _useState2 = _slicedToArray$1(_useState, 2), inputWidth = _useState2[0], setInputWidth = _useState2[1];
  var _useState3 = React.useState(false), _useState4 = _slicedToArray$1(_useState3, 2), focused = _useState4[0], setFocused = _useState4[1];
  var selectionPrefixCls = "".concat(prefixCls, "-selection");
  var inputValue = open || mode === "multiple" && autoClearSearchValue === false || mode === "tags" ? searchValue : "";
  var inputEditable = mode === "tags" || mode === "multiple" && autoClearSearchValue === false || showSearch && (open || focused);
  useLayoutEffect$7(function() {
    setInputWidth(measureRef.current.scrollWidth);
  }, [inputValue]);
  function defaultRenderSelector(item, content2, itemDisabled, closable, onClose) {
    return /* @__PURE__ */ React.createElement("span", {
      className: classNames("".concat(selectionPrefixCls, "-item"), _defineProperty$3({}, "".concat(selectionPrefixCls, "-item-disabled"), itemDisabled)),
      title: getTitle(item)
    }, /* @__PURE__ */ React.createElement("span", {
      className: "".concat(selectionPrefixCls, "-item-content")
    }, content2), closable && /* @__PURE__ */ React.createElement(TransBtn, {
      className: "".concat(selectionPrefixCls, "-item-remove"),
      onMouseDown: onPreventMouseDown,
      onClick: onClose,
      customizeIcon: removeIcon
    }, "\xD7"));
  }
  function customizeRenderSelector(value, content2, itemDisabled, closable, onClose) {
    var onMouseDown = function onMouseDown2(e2) {
      onPreventMouseDown(e2);
      onToggleOpen(!open);
    };
    return /* @__PURE__ */ React.createElement("span", {
      onMouseDown
    }, tagRender({
      label: content2,
      value,
      disabled: itemDisabled,
      closable,
      onClose
    }));
  }
  function renderItem(valueItem) {
    var itemDisabled = valueItem.disabled, label = valueItem.label, value = valueItem.value;
    var closable = !disabled && !itemDisabled;
    var displayLabel = label;
    if (typeof maxTagTextLength === "number") {
      if (typeof label === "string" || typeof label === "number") {
        var strLabel = String(displayLabel);
        if (strLabel.length > maxTagTextLength) {
          displayLabel = "".concat(strLabel.slice(0, maxTagTextLength), "...");
        }
      }
    }
    var onClose = function onClose2(event) {
      if (event)
        event.stopPropagation();
      onRemove(valueItem);
    };
    return typeof tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
  }
  function renderRest(omittedValues) {
    var content2 = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
    return defaultRenderSelector({
      title: content2
    }, content2, false);
  }
  var inputNode = /* @__PURE__ */ React.createElement("div", {
    className: "".concat(selectionPrefixCls, "-search"),
    style: {
      width: inputWidth
    },
    onFocus: function onFocus() {
      setFocused(true);
    },
    onBlur: function onBlur() {
      setFocused(false);
    }
  }, /* @__PURE__ */ React.createElement(RefInput, {
    ref: inputRef,
    open,
    prefixCls,
    id,
    inputElement: null,
    disabled,
    autoFocus,
    autoComplete,
    editable: inputEditable,
    activeDescendantId,
    value: inputValue,
    onKeyDown: onInputKeyDown,
    onMouseDown: onInputMouseDown,
    onChange: onInputChange,
    onPaste: onInputPaste,
    onCompositionStart: onInputCompositionStart,
    onCompositionEnd: onInputCompositionEnd,
    tabIndex,
    attrs: pickAttrs$2(props, true)
  }), /* @__PURE__ */ React.createElement("span", {
    ref: measureRef,
    className: "".concat(selectionPrefixCls, "-search-mirror"),
    "aria-hidden": true
  }, inputValue, "\xA0"));
  var selectionNode = /* @__PURE__ */ React.createElement(ForwardOverflow$2, {
    prefixCls: "".concat(selectionPrefixCls, "-overflow"),
    data: values,
    renderItem,
    renderRest,
    suffix: inputNode,
    itemKey,
    maxCount: maxTagCount
  });
  return /* @__PURE__ */ React.createElement(React.Fragment, null, selectionNode, !values.length && !inputValue && /* @__PURE__ */ React.createElement("span", {
    className: "".concat(selectionPrefixCls, "-placeholder")
  }, placeholder));
};
var SingleSelector = function SingleSelector2(props) {
  var inputElement = props.inputElement, prefixCls = props.prefixCls, id = props.id, inputRef = props.inputRef, disabled = props.disabled, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, mode = props.mode, open = props.open, values = props.values, placeholder = props.placeholder, tabIndex = props.tabIndex, showSearch = props.showSearch, searchValue = props.searchValue, activeValue = props.activeValue, maxLength = props.maxLength, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd, title = props.title;
  var _React$useState = React.useState(false), _React$useState2 = _slicedToArray$1(_React$useState, 2), inputChanged = _React$useState2[0], setInputChanged = _React$useState2[1];
  var combobox = mode === "combobox";
  var inputEditable = combobox || showSearch;
  var item = values[0];
  var inputValue = searchValue || "";
  if (combobox && activeValue && !inputChanged) {
    inputValue = activeValue;
  }
  React.useEffect(function() {
    if (combobox) {
      setInputChanged(false);
    }
  }, [combobox, activeValue]);
  var hasTextInput = mode !== "combobox" && !open && !showSearch ? false : !!inputValue;
  var selectionTitle = title === void 0 ? getTitle(item) : title;
  var renderPlaceholder = function renderPlaceholder2() {
    if (item) {
      return null;
    }
    var hiddenStyle = hasTextInput ? {
      visibility: "hidden"
    } : void 0;
    return /* @__PURE__ */ React.createElement("span", {
      className: "".concat(prefixCls, "-selection-placeholder"),
      style: hiddenStyle
    }, placeholder);
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", {
    className: "".concat(prefixCls, "-selection-search")
  }, /* @__PURE__ */ React.createElement(RefInput, {
    ref: inputRef,
    prefixCls,
    id,
    open,
    inputElement,
    disabled,
    autoFocus,
    autoComplete,
    editable: inputEditable,
    activeDescendantId,
    value: inputValue,
    onKeyDown: onInputKeyDown,
    onMouseDown: onInputMouseDown,
    onChange: function onChange(e2) {
      setInputChanged(true);
      onInputChange(e2);
    },
    onPaste: onInputPaste,
    onCompositionStart: onInputCompositionStart,
    onCompositionEnd: onInputCompositionEnd,
    tabIndex,
    attrs: pickAttrs$2(props, true),
    maxLength: combobox ? maxLength : void 0
  })), !combobox && item && !hasTextInput && /* @__PURE__ */ React.createElement("span", {
    className: "".concat(prefixCls, "-selection-item"),
    title: selectionTitle
  }, item.label), renderPlaceholder());
};
function isValidateOpenKey(currentKeyCode) {
  return ![
    KeyCode$3.ESC,
    KeyCode$3.SHIFT,
    KeyCode$3.BACKSPACE,
    KeyCode$3.TAB,
    KeyCode$3.WIN_KEY,
    KeyCode$3.ALT,
    KeyCode$3.META,
    KeyCode$3.WIN_KEY_RIGHT,
    KeyCode$3.CTRL,
    KeyCode$3.SEMICOLON,
    KeyCode$3.EQUALS,
    KeyCode$3.CAPS_LOCK,
    KeyCode$3.CONTEXT_MENU,
    KeyCode$3.F1,
    KeyCode$3.F2,
    KeyCode$3.F3,
    KeyCode$3.F4,
    KeyCode$3.F5,
    KeyCode$3.F6,
    KeyCode$3.F7,
    KeyCode$3.F8,
    KeyCode$3.F9,
    KeyCode$3.F10,
    KeyCode$3.F11,
    KeyCode$3.F12
  ].includes(currentKeyCode);
}
var Selector = function Selector2(props, ref2) {
  var inputRef = React.useRef(null);
  var compositionStatusRef = React.useRef(false);
  var prefixCls = props.prefixCls, open = props.open, mode = props.mode, showSearch = props.showSearch, tokenWithEnter = props.tokenWithEnter, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSubmit = props.onSearchSubmit, onToggleOpen = props.onToggleOpen, onInputKeyDown = props.onInputKeyDown, domRef = props.domRef;
  React.useImperativeHandle(ref2, function() {
    return {
      focus: function focus() {
        inputRef.current.focus();
      },
      blur: function blur() {
        inputRef.current.blur();
      }
    };
  });
  var _useLock = useLock(0), _useLock2 = _slicedToArray$1(_useLock, 2), getInputMouseDown = _useLock2[0], setInputMouseDown = _useLock2[1];
  var onInternalInputKeyDown = function onInternalInputKeyDown2(event) {
    var which = event.which;
    if (which === KeyCode$3.UP || which === KeyCode$3.DOWN) {
      event.preventDefault();
    }
    if (onInputKeyDown) {
      onInputKeyDown(event);
    }
    if (which === KeyCode$3.ENTER && mode === "tags" && !compositionStatusRef.current && !open) {
      onSearchSubmit === null || onSearchSubmit === void 0 ? void 0 : onSearchSubmit(event.target.value);
    }
    if (isValidateOpenKey(which)) {
      onToggleOpen(true);
    }
  };
  var onInternalInputMouseDown = function onInternalInputMouseDown2() {
    setInputMouseDown(true);
  };
  var pastedTextRef = React.useRef(null);
  var triggerOnSearch = function triggerOnSearch2(value) {
    if (onSearch(value, true, compositionStatusRef.current) !== false) {
      onToggleOpen(true);
    }
  };
  var onInputCompositionStart = function onInputCompositionStart2() {
    compositionStatusRef.current = true;
  };
  var onInputCompositionEnd = function onInputCompositionEnd2(e2) {
    compositionStatusRef.current = false;
    if (mode !== "combobox") {
      triggerOnSearch(e2.target.value);
    }
  };
  var onInputChange = function onInputChange2(event) {
    var value = event.target.value;
    if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
      var replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
      value = value.replace(replacedText, pastedTextRef.current);
    }
    pastedTextRef.current = null;
    triggerOnSearch(value);
  };
  var onInputPaste = function onInputPaste2(e2) {
    var clipboardData = e2.clipboardData;
    var value = clipboardData.getData("text");
    pastedTextRef.current = value;
  };
  var onClick = function onClick2(_ref2) {
    var target = _ref2.target;
    if (target !== inputRef.current) {
      var isIE = document.body.style.msTouchAction !== void 0;
      if (isIE) {
        setTimeout(function() {
          inputRef.current.focus();
        });
      } else {
        inputRef.current.focus();
      }
    }
  };
  var onMouseDown = function onMouseDown2(event) {
    var inputMouseDown = getInputMouseDown();
    if (event.target !== inputRef.current && !inputMouseDown && mode !== "combobox") {
      event.preventDefault();
    }
    if (mode !== "combobox" && (!showSearch || !inputMouseDown) || !open) {
      if (open && autoClearSearchValue !== false) {
        onSearch("", true, false);
      }
      onToggleOpen();
    }
  };
  var sharedProps = {
    inputRef,
    onInputKeyDown: onInternalInputKeyDown,
    onInputMouseDown: onInternalInputMouseDown,
    onInputChange,
    onInputPaste,
    onInputCompositionStart,
    onInputCompositionEnd
  };
  var selectNode = mode === "multiple" || mode === "tags" ? /* @__PURE__ */ React.createElement(SelectSelector, _extends$3({}, props, sharedProps)) : /* @__PURE__ */ React.createElement(SingleSelector, _extends$3({}, props, sharedProps));
  return /* @__PURE__ */ React.createElement("div", {
    ref: domRef,
    className: "".concat(prefixCls, "-selector"),
    onClick,
    onMouseDown
  }, selectNode);
};
var ForwardSelector = /* @__PURE__ */ React.forwardRef(Selector);
ForwardSelector.displayName = "Selector";
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function toArray$7(children) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var ret = [];
  React.Children.forEach(children, function(child) {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray$7(child));
    } else if (reactIs$2.exports.isFragment(child) && child.props) {
      ret = ret.concat(toArray$7(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}
function _typeof$7(obj) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$7(obj);
}
function _toPrimitive$1(input, hint) {
  if (_typeof$7(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$7(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey$1(arg) {
  var key = _toPrimitive$1(arg, "string");
  return _typeof$7(key) === "symbol" ? key : String(key);
}
function _defineProperty$2(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys$2(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$c(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function useMemo$3(getValue2, condition, shouldUpdate) {
  var cacheRef = React.useRef({});
  if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue2();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
function fillRef$3(ref2, node2) {
  if (typeof ref2 === "function") {
    ref2(node2);
  } else if (_typeof$8(ref2) === "object" && ref2 && "current" in ref2) {
    ref2.current = node2;
  }
}
function composeRef$3() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function(ref2) {
    return ref2;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function(node2) {
    refs.forEach(function(ref2) {
      fillRef$3(ref2, node2);
    });
  };
}
function useComposeRef$2() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }
  return useMemo$3(function() {
    return composeRef$3.apply(void 0, refs);
  }, refs, function(prev2, next2) {
    return prev2.length === next2.length && prev2.every(function(ref2, i) {
      return ref2 === next2[i];
    });
  });
}
function supportRef$2(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type4 = reactIs$2.exports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  if (typeof type4 === "function" && !((_type$prototype = type4.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
    return false;
  }
  if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
    return false;
  }
  return true;
}
function isDOM(node2) {
  return node2 instanceof HTMLElement || node2 instanceof SVGElement;
}
function findDOMNode$2(node2) {
  if (isDOM(node2)) {
    return node2;
  }
  if (node2 instanceof React.Component) {
    return ReactDOM.findDOMNode(node2);
  }
  return null;
}
var elementListeners = /* @__PURE__ */ new Map();
function onResize(entities) {
  entities.forEach(function(entity) {
    var _elementListeners$get;
    var target = entity.target;
    (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 ? void 0 : _elementListeners$get.forEach(function(listener) {
      return listener(target);
    });
  });
}
var resizeObserver = new index(onResize);
function observe(element2, callback) {
  if (!elementListeners.has(element2)) {
    elementListeners.set(element2, /* @__PURE__ */ new Set());
    resizeObserver.observe(element2);
  }
  elementListeners.get(element2).add(callback);
}
function unobserve(element2, callback) {
  if (elementListeners.has(element2)) {
    elementListeners.get(element2).delete(callback);
    if (!elementListeners.get(element2).size) {
      resizeObserver.unobserve(element2);
      elementListeners.delete(element2);
    }
  }
}
function _classCallCheck$1(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _setPrototypeOf$1(o, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1(o, p2);
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn$1(self2, call2) {
  if (call2 && (_typeof$7(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
var DomWrapper = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(DomWrapper2, _React$Component);
  var _super = _createSuper$1(DomWrapper2);
  function DomWrapper2() {
    _classCallCheck$1(this, DomWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass$1(DomWrapper2, [{
    key: "render",
    value: function render2() {
      return this.props.children;
    }
  }]);
  return DomWrapper2;
}(React.Component);
var CollectionContext = /* @__PURE__ */ React.createContext(null);
function Collection(_ref2) {
  var children = _ref2.children, onBatchResize = _ref2.onBatchResize;
  var resizeIdRef = React.useRef(0);
  var resizeInfosRef = React.useRef([]);
  var onCollectionResize = React.useContext(CollectionContext);
  var onResize2 = React.useCallback(function(size, element2, data2) {
    resizeIdRef.current += 1;
    var currentId = resizeIdRef.current;
    resizeInfosRef.current.push({
      size,
      element: element2,
      data: data2
    });
    Promise.resolve().then(function() {
      if (currentId === resizeIdRef.current) {
        onBatchResize === null || onBatchResize === void 0 ? void 0 : onBatchResize(resizeInfosRef.current);
        resizeInfosRef.current = [];
      }
    });
    onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(size, element2, data2);
  }, [onBatchResize, onCollectionResize]);
  return /* @__PURE__ */ React.createElement(CollectionContext.Provider, {
    value: onResize2
  }, children);
}
function SingleObserver(props, ref2) {
  var children = props.children, disabled = props.disabled;
  var elementRef = React.useRef(null);
  var wrapperRef = React.useRef(null);
  var onCollectionResize = React.useContext(CollectionContext);
  var isRenderProps = typeof children === "function";
  var mergedChildren = isRenderProps ? children(elementRef) : children;
  var sizeRef = React.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  });
  var canRef = !isRenderProps && /* @__PURE__ */ React.isValidElement(mergedChildren) && supportRef$2(mergedChildren);
  var originRef = canRef ? mergedChildren.ref : null;
  var mergedRef = React.useMemo(function() {
    return composeRef$3(originRef, elementRef);
  }, [originRef, elementRef]);
  var getDom = function getDom2() {
    return findDOMNode$2(elementRef.current) || findDOMNode$2(wrapperRef.current);
  };
  React.useImperativeHandle(ref2, function() {
    return getDom();
  });
  var propsRef = React.useRef(props);
  propsRef.current = props;
  var onInternalResize = React.useCallback(function(target) {
    var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data2 = _propsRef$current.data;
    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
    var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      var size = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth,
        offsetHeight
      };
      sizeRef.current = size;
      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
      var sizeInfo = _objectSpread2$c(_objectSpread2$c({}, size), {}, {
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      });
      onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data2);
      if (onResize2) {
        Promise.resolve().then(function() {
          onResize2(sizeInfo, target);
        });
      }
    }
  }, []);
  React.useEffect(function() {
    var currentElement = getDom();
    if (currentElement && !disabled) {
      observe(currentElement, onInternalResize);
    }
    return function() {
      return unobserve(currentElement, onInternalResize);
    };
  }, [elementRef.current, disabled]);
  return /* @__PURE__ */ React.createElement(DomWrapper, {
    ref: wrapperRef
  }, canRef ? /* @__PURE__ */ React.cloneElement(mergedChildren, {
    ref: mergedRef
  }) : mergedChildren);
}
var RefSingleObserver = /* @__PURE__ */ React.forwardRef(SingleObserver);
var INTERNAL_PREFIX_KEY = "rc-observer-key";
function ResizeObserver$1(props, ref2) {
  var children = props.children;
  var childNodes = typeof children === "function" ? [children] : toArray$7(children);
  return childNodes.map(function(child, index2) {
    var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index2);
    return /* @__PURE__ */ React.createElement(RefSingleObserver, _extends$1({}, props, {
      key,
      ref: index2 === 0 ? ref2 : void 0
    }), child);
  });
}
var RefResizeObserver = /* @__PURE__ */ React.forwardRef(ResizeObserver$1);
RefResizeObserver.Collection = Collection;
function useEvent$4(callback) {
  var fnRef = React.useRef();
  fnRef.current = callback;
  var memoFn = React.useCallback(function() {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
function getUseId$1() {
  var fullClone2 = _objectSpread2$d({}, React);
  return fullClone2.useId;
}
var uuid$4 = 0;
function useId$2(id) {
  var _React$useState = React.useState("ssr-id"), _React$useState2 = _slicedToArray$1(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
  var useOriginId = getUseId$1();
  var reactNativeId = useOriginId === null || useOriginId === void 0 ? void 0 : useOriginId();
  React.useEffect(function() {
    if (!useOriginId) {
      var nextId = uuid$4;
      uuid$4 += 1;
      setInnerId("rc_unique_".concat(nextId));
    }
  }, []);
  if (id) {
    return id;
  }
  return reactNativeId || innerId;
}
function canUseDom$9() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var useLayoutEffect$6 = canUseDom$9() ? React.useLayoutEffect : React.useEffect;
var isMobile$3 = function() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
};
var TriggerContext$2 = /* @__PURE__ */ React.createContext(null);
function toArray$6(val) {
  return val ? Array.isArray(val) ? val : [val] : [];
}
function useAction(mobile, action, showAction, hideAction) {
  return React.useMemo(function() {
    var mergedShowAction = toArray$6(showAction !== null && showAction !== void 0 ? showAction : action);
    var mergedHideAction = toArray$6(hideAction !== null && hideAction !== void 0 ? hideAction : action);
    var showActionSet = new Set(mergedShowAction);
    var hideActionSet = new Set(mergedHideAction);
    if (mobile) {
      if (showActionSet.has("hover")) {
        showActionSet.delete("hover");
        showActionSet.add("click");
      }
      if (hideActionSet.has("hover")) {
        hideActionSet.delete("hover");
        hideActionSet.add("click");
      }
    }
    return [showActionSet, hideActionSet];
  }, [mobile, action, showAction, hideAction]);
}
var isVisible$3 = function(element2) {
  if (!element2) {
    return false;
  }
  if (element2 instanceof Element) {
    if (element2.offsetParent) {
      return true;
    }
    if (element2.getBBox) {
      var _getBBox = element2.getBBox(), width = _getBBox.width, height = _getBBox.height;
      if (width || height) {
        return true;
      }
    }
    if (element2.getBoundingClientRect) {
      var _element$getBoundingC = element2.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
      if (_width || _height) {
        return true;
      }
    }
  }
  return false;
};
function isPointsEq$2() {
  var a1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var a2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var isAlignPoint = arguments.length > 2 ? arguments[2] : void 0;
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }
  return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignPopupClassName$2(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;
  var placements2 = Object.keys(builtinPlacements);
  for (var i = 0; i < placements2.length; i += 1) {
    var _builtinPlacements$pl;
    var placement = placements2[i];
    if (isPointsEq$2((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {
      return "".concat(prefixCls, "-placement-").concat(placement);
    }
  }
  return "";
}
function getMotion$4(prefixCls, motion2, animation, transitionName) {
  if (motion2) {
    return motion2;
  }
  if (animation) {
    return {
      motionName: "".concat(prefixCls, "-").concat(animation)
    };
  }
  if (transitionName) {
    return {
      motionName: transitionName
    };
  }
  return null;
}
function getWin(ele) {
  return ele.ownerDocument.defaultView;
}
function collectScroller(ele) {
  var scrollerList = [];
  var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;
  var scrollStyle = ["hidden", "scroll", "auto"];
  while (current) {
    var _getWin$getComputedSt = getWin(current).getComputedStyle(current), overflowX = _getWin$getComputedSt.overflowX, overflowY = _getWin$getComputedSt.overflowY;
    if (scrollStyle.includes(overflowX) || scrollStyle.includes(overflowY)) {
      scrollerList.push(current);
    }
    current = current.parentElement;
  }
  return scrollerList;
}
function toNum(num) {
  return Number.isNaN(num) ? 1 : num;
}
function getVisibleArea(initArea, scrollerList) {
  var visibleArea = _objectSpread2$d({}, initArea);
  (scrollerList || []).forEach(function(ele) {
    if (ele instanceof HTMLBodyElement) {
      return;
    }
    var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele), position2 = _getWin$getComputedSt2.position;
    if (position2 === "static") {
      return;
    }
    var eleRect = ele.getBoundingClientRect();
    var eleOutHeight = ele.offsetHeight, eleInnerHeight = ele.clientHeight, eleOutWidth = ele.offsetWidth, eleInnerWidth = ele.clientWidth;
    var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
    var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
    var eleScrollWidth = (eleOutWidth - eleInnerWidth) * scaleX;
    var eleScrollHeight = (eleOutHeight - eleInnerHeight) * scaleY;
    var eleRight = eleRect.x + eleRect.width - eleScrollWidth;
    var eleBottom = eleRect.y + eleRect.height - eleScrollHeight;
    visibleArea.left = Math.max(visibleArea.left, eleRect.x);
    visibleArea.top = Math.max(visibleArea.top, eleRect.y);
    visibleArea.right = Math.min(visibleArea.right, eleRight);
    visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
  });
  return visibleArea;
}
function splitPoints() {
  var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  return [points[0], points[1]];
}
function getAlignPoint(rect, points) {
  var topBottom = points[0];
  var leftRight = points[1];
  var x2;
  var y2;
  if (topBottom === "t") {
    y2 = rect.y;
  } else if (topBottom === "b") {
    y2 = rect.y + rect.height;
  } else {
    y2 = rect.y + rect.height / 2;
  }
  if (leftRight === "l") {
    x2 = rect.x;
  } else if (leftRight === "r") {
    x2 = rect.x + rect.width;
  } else {
    x2 = rect.x + rect.width / 2;
  }
  return {
    x: x2,
    y: y2
  };
}
function reversePoints(points, index2) {
  var reverseMap = {
    t: "b",
    b: "t",
    l: "r",
    r: "l"
  };
  return points.map(function(point2, i) {
    if (i === index2) {
      return reverseMap[point2] || "c";
    }
    return point2;
  }).join("");
}
function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
  var _React$useState = React.useState({
    ready: false,
    offsetX: 0,
    offsetY: 0,
    arrowX: 0,
    arrowY: 0,
    scaleX: 1,
    scaleY: 1,
    align: builtinPlacements[placement] || {}
  }), _React$useState2 = _slicedToArray$1(_React$useState, 2), offsetInfo = _React$useState2[0], setOffsetInfo = _React$useState2[1];
  var alignCountRef = React.useRef(0);
  var scrollerList = React.useMemo(function() {
    if (!popupEle) {
      return [];
    }
    return collectScroller(popupEle);
  }, [popupEle]);
  var onAlign = useEvent$4(function() {
    if (popupEle && target && open) {
      let getIntersectionVisibleArea = function(offsetX, offsetY) {
        var l2 = popupRect.x + offsetX;
        var t2 = popupRect.y + offsetY;
        var r2 = l2 + popupWidth;
        var b2 = t2 + popupHeight;
        var visibleL = Math.max(l2, visibleArea.left);
        var visibleT = Math.max(t2, visibleArea.top);
        var visibleR = Math.min(r2, visibleArea.right);
        var visibleB = Math.min(b2, visibleArea.bottom);
        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
      }, syncNextPopupPosition = function() {
        nextPopupY = popupRect.y + nextOffsetY;
        nextPopupBottom = nextPopupY + popupHeight;
        nextPopupX = popupRect.x + nextOffsetX;
        nextPopupRight = nextPopupX + popupWidth;
      };
      var popupElement = popupEle;
      var originLeft = popupElement.style.left;
      var originTop = popupElement.style.top;
      var doc = popupElement.ownerDocument;
      var win = getWin(popupElement);
      var placementInfo = _objectSpread2$d(_objectSpread2$d({}, builtinPlacements[placement]), popupAlign);
      popupElement.style.left = "0";
      popupElement.style.top = "0";
      var targetRect;
      if (Array.isArray(target)) {
        targetRect = {
          x: target[0],
          y: target[1],
          width: 0,
          height: 0
        };
      } else {
        var rect = target.getBoundingClientRect();
        targetRect = {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        };
      }
      var popupRect = popupElement.getBoundingClientRect();
      var _win$getComputedStyle = win.getComputedStyle(popupElement), width = _win$getComputedStyle.width, height = _win$getComputedStyle.height;
      var _doc$documentElement = doc.documentElement, clientWidth = _doc$documentElement.clientWidth, clientHeight = _doc$documentElement.clientHeight, scrollWidth = _doc$documentElement.scrollWidth, scrollHeight = _doc$documentElement.scrollHeight, scrollTop = _doc$documentElement.scrollTop, scrollLeft = _doc$documentElement.scrollLeft;
      var popupHeight = popupRect.height;
      var popupWidth = popupRect.width;
      var targetHeight = targetRect.height;
      var targetWidth = targetRect.width;
      var visibleArea = placementInfo.htmlRegion === "scroll" ? {
        left: -scrollLeft,
        top: -scrollTop,
        right: scrollWidth - scrollLeft,
        bottom: scrollHeight - scrollTop
      } : {
        left: 0,
        top: 0,
        right: clientWidth,
        bottom: clientHeight
      };
      visibleArea = getVisibleArea(visibleArea, scrollerList);
      popupElement.style.left = originLeft;
      popupElement.style.top = originTop;
      var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
      var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
      if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible$3(target)) {
        return;
      }
      var offset3 = placementInfo.offset, targetOffset2 = placementInfo.targetOffset;
      var _ref2 = offset3 || [], _ref22 = _slicedToArray$1(_ref2, 2), _ref2$ = _ref22[0], popupOffsetX = _ref2$ === void 0 ? 0 : _ref2$, _ref2$2 = _ref22[1], popupOffsetY = _ref2$2 === void 0 ? 0 : _ref2$2;
      var _ref3 = targetOffset2 || [], _ref4 = _slicedToArray$1(_ref3, 2), _ref4$ = _ref4[0], targetOffsetX = _ref4$ === void 0 ? 0 : _ref4$, _ref4$2 = _ref4[1], targetOffsetY = _ref4$2 === void 0 ? 0 : _ref4$2;
      targetRect.x += targetOffsetX;
      targetRect.y += targetOffsetY;
      var _ref5 = placementInfo.points || [], _ref6 = _slicedToArray$1(_ref5, 2), popupPoint = _ref6[0], targetPoint = _ref6[1];
      var targetPoints = splitPoints(targetPoint);
      var popupPoints = splitPoints(popupPoint);
      var targetAlignPoint = getAlignPoint(targetRect, targetPoints);
      var popupAlignPoint = getAlignPoint(popupRect, popupPoints);
      var nextAlignInfo = _objectSpread2$d({}, placementInfo);
      var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
      var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
      var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);
      var targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
      var popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
      var targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
      var popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
      var overflow = placementInfo.overflow || {};
      var adjustX = overflow.adjustX, adjustY = overflow.adjustY, shiftX = overflow.shiftX, shiftY = overflow.shiftY;
      var supportAdjust = function supportAdjust2(val) {
        if (typeof val === "boolean") {
          return val;
        }
        return val >= 0;
      };
      var nextPopupY;
      var nextPopupBottom;
      var nextPopupX;
      var nextPopupRight;
      syncNextPopupPosition();
      var needAdjustY = supportAdjust(adjustY);
      var sameTB = popupPoints[0] === targetPoints[0];
      if (needAdjustY && popupPoints[0] === "t" && nextPopupBottom > visibleArea.bottom) {
        var tmpNextOffsetY = nextOffsetY;
        if (sameTB) {
          tmpNextOffsetY -= popupHeight - targetHeight;
        } else {
          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
        }
        if (getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY) >= originIntersectionVisibleArea) {
          nextOffsetY = tmpNextOffsetY;
          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
        }
      }
      if (needAdjustY && popupPoints[0] === "b" && nextPopupY < visibleArea.top) {
        var _tmpNextOffsetY = nextOffsetY;
        if (sameTB) {
          _tmpNextOffsetY += popupHeight - targetHeight;
        } else {
          _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
        }
        if (getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY) >= originIntersectionVisibleArea) {
          nextOffsetY = _tmpNextOffsetY;
          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
        }
      }
      var needAdjustX = supportAdjust(adjustX);
      var sameLR = popupPoints[1] === targetPoints[1];
      if (needAdjustX && popupPoints[1] === "l" && nextPopupRight > visibleArea.right) {
        var tmpNextOffsetX = nextOffsetX;
        if (sameLR) {
          tmpNextOffsetX -= popupWidth - targetWidth;
        } else {
          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
        }
        if (getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY) >= originIntersectionVisibleArea) {
          nextOffsetX = tmpNextOffsetX;
          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
        }
      }
      if (needAdjustX && popupPoints[1] === "r" && nextPopupX < visibleArea.left) {
        var _tmpNextOffsetX = nextOffsetX;
        if (sameLR) {
          _tmpNextOffsetX += popupWidth - targetWidth;
        } else {
          _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
        }
        if (getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY) >= originIntersectionVisibleArea) {
          nextOffsetX = _tmpNextOffsetX;
          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
        }
      }
      syncNextPopupPosition();
      var numShiftX = shiftX === true ? 0 : shiftX;
      if (typeof numShiftX === "number") {
        if (nextPopupX < visibleArea.left) {
          nextOffsetX -= nextPopupX - visibleArea.left;
          if (targetRect.x + targetWidth < visibleArea.left + numShiftX) {
            nextOffsetX += targetRect.x - visibleArea.left + targetWidth - numShiftX;
          }
        }
        if (nextPopupRight > visibleArea.right) {
          nextOffsetX -= nextPopupRight - visibleArea.right;
          if (targetRect.x > visibleArea.right - numShiftX) {
            nextOffsetX += targetRect.x - visibleArea.right + numShiftX;
          }
        }
      }
      var numShiftY = shiftY === true ? 0 : shiftY;
      if (typeof numShiftY === "number") {
        if (nextPopupY < visibleArea.top) {
          nextOffsetY -= nextPopupY - visibleArea.top;
          if (targetRect.y + targetHeight < visibleArea.top + numShiftY) {
            nextOffsetY += targetRect.y - visibleArea.top + targetHeight - numShiftY;
          }
        }
        if (nextPopupBottom > visibleArea.bottom) {
          nextOffsetY -= nextPopupBottom - visibleArea.bottom;
          if (targetRect.y > visibleArea.bottom - numShiftY) {
            nextOffsetY += targetRect.y - visibleArea.bottom + numShiftY;
          }
        }
      }
      var popupLeft = popupRect.x + nextOffsetX;
      var popupRight = popupLeft + popupWidth;
      var popupTop = popupRect.y + nextOffsetY;
      var popupBottom = popupTop + popupHeight;
      var targetLeft = targetRect.x;
      var targetRight = targetLeft + targetWidth;
      var targetTop = targetRect.y;
      var targetBottom = targetTop + targetHeight;
      var maxLeft = Math.max(popupLeft, targetLeft);
      var minRight = Math.min(popupRight, targetRight);
      var xCenter = (maxLeft + minRight) / 2;
      var nextArrowX = xCenter - popupLeft;
      var maxTop = Math.max(popupTop, targetTop);
      var minBottom = Math.min(popupBottom, targetBottom);
      var yCenter = (maxTop + minBottom) / 2;
      var nextArrowY = yCenter - popupTop;
      onPopupAlign === null || onPopupAlign === void 0 ? void 0 : onPopupAlign(popupEle, nextAlignInfo);
      setOffsetInfo({
        ready: true,
        offsetX: nextOffsetX / _scaleX,
        offsetY: nextOffsetY / _scaleY,
        arrowX: nextArrowX / _scaleX,
        arrowY: nextArrowY / _scaleY,
        scaleX: _scaleX,
        scaleY: _scaleY,
        align: nextAlignInfo
      });
    }
  });
  var triggerAlign = function triggerAlign2() {
    alignCountRef.current += 1;
    var id = alignCountRef.current;
    Promise.resolve().then(function() {
      if (alignCountRef.current === id) {
        onAlign();
      }
    });
  };
  var resetReady = function resetReady2() {
    setOffsetInfo(function(ori) {
      return _objectSpread2$d(_objectSpread2$d({}, ori), {}, {
        ready: false
      });
    });
  };
  useLayoutEffect$6(resetReady, [placement]);
  useLayoutEffect$6(function() {
    if (!open) {
      resetReady();
    }
  }, [open]);
  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
}
function useWatch(open, target, popup, onAlign) {
  useLayoutEffect$6(function() {
    if (open && target && popup) {
      let notifyScroll = function() {
        onAlign();
      };
      var targetElement = target;
      var popupElement = popup;
      var targetScrollList = collectScroller(targetElement);
      var popupScrollList = collectScroller(popupElement);
      var win = getWin(popupElement);
      var mergedList = new Set([win].concat(_toConsumableArray(targetScrollList), _toConsumableArray(popupScrollList)));
      mergedList.forEach(function(scroller) {
        scroller.addEventListener("scroll", notifyScroll, {
          passive: true
        });
      });
      win.addEventListener("resize", notifyScroll, {
        passive: true
      });
      onAlign();
      return function() {
        mergedList.forEach(function(scroller) {
          scroller.removeEventListener("scroll", notifyScroll);
          win.removeEventListener("resize", notifyScroll);
        });
      };
    }
  }, [open, target, popup]);
}
function Arrow(props) {
  var prefixCls = props.prefixCls, align = props.align, _props$arrowX = props.arrowX, arrowX = _props$arrowX === void 0 ? 0 : _props$arrowX, _props$arrowY = props.arrowY, arrowY = _props$arrowY === void 0 ? 0 : _props$arrowY;
  var arrowRef = React.useRef();
  if (!align || !align.points) {
    return null;
  }
  var alignStyle = {
    position: "absolute"
  };
  if (align.autoArrow !== false) {
    var popupPoints = align.points[0];
    var targetPoints = align.points[1];
    var popupTB = popupPoints[0];
    var popupLR = popupPoints[1];
    var targetTB = targetPoints[0];
    var targetLR = targetPoints[1];
    if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
      alignStyle.top = arrowY;
    } else if (popupTB === "t") {
      alignStyle.top = 0;
    } else {
      alignStyle.bottom = 0;
    }
    if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
      alignStyle.left = arrowX;
    } else if (popupLR === "l") {
      alignStyle.left = 0;
    } else {
      alignStyle.right = 0;
    }
  }
  return /* @__PURE__ */ React.createElement("div", {
    ref: arrowRef,
    className: "".concat(prefixCls, "-arrow"),
    style: alignStyle
  });
}
function Mask$3(props) {
  var prefixCls = props.prefixCls, open = props.open, zIndex = props.zIndex, mask = props.mask, motion2 = props.motion;
  if (!mask) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(CSSMotion, _extends$3({}, motion2, {
    motionAppear: true,
    visible: open,
    removeOnLeave: true
  }), function(_ref2) {
    var className = _ref2.className;
    return /* @__PURE__ */ React.createElement("div", {
      style: {
        zIndex
      },
      className: classNames("".concat(prefixCls, "-mask"), className)
    });
  });
}
var Popup$3 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var popup = props.popup, className = props.className, prefixCls = props.prefixCls, style2 = props.style, target = props.target, _onVisibleChanged = props.onVisibleChanged, open = props.open, keepDom = props.keepDom, onClick = props.onClick, mask = props.mask, arrow = props.arrow, align = props.align, arrowX = props.arrowX, arrowY = props.arrowY, motion2 = props.motion, maskMotion = props.maskMotion, forceRender = props.forceRender, getPopupContainer = props.getPopupContainer, autoDestroy = props.autoDestroy, Portal2 = props.portal, zIndex = props.zIndex, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, ready = props.ready, offsetX = props.offsetX, offsetY = props.offsetY, onAlign = props.onAlign, onPrepare = props.onPrepare, stretch = props.stretch, targetWidth = props.targetWidth, targetHeight = props.targetHeight;
  var childNode = typeof popup === "function" ? popup() : popup;
  var isNodeVisible = open || keepDom;
  var getPopupContainerNeedParams = (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.length) > 0;
  var _React$useState = React.useState(!getPopupContainer || !getPopupContainerNeedParams), _React$useState2 = _slicedToArray$1(_React$useState, 2), show = _React$useState2[0], setShow = _React$useState2[1];
  useLayoutEffect$6(function() {
    if (!show && getPopupContainerNeedParams && target) {
      setShow(true);
    }
  }, [show, getPopupContainerNeedParams, target]);
  if (!show) {
    return null;
  }
  var offsetStyle = ready || !open ? {
    left: offsetX,
    top: offsetY
  } : {
    left: "-1000vw",
    top: "-1000vh"
  };
  var miscStyle = {};
  if (stretch) {
    if (stretch.includes("height") && targetHeight) {
      miscStyle.height = targetHeight;
    } else if (stretch.includes("minHeight") && targetHeight) {
      miscStyle.minHeight = targetHeight;
    }
    if (stretch.includes("width") && targetWidth) {
      miscStyle.width = targetWidth;
    } else if (stretch.includes("minWidth") && targetWidth) {
      miscStyle.minWidth = targetWidth;
    }
  }
  if (!open) {
    miscStyle.pointerEvents = "none";
  }
  return /* @__PURE__ */ React.createElement(Portal2, {
    open: forceRender || isNodeVisible,
    getContainer: getPopupContainer && function() {
      return getPopupContainer(target);
    },
    autoDestroy
  }, /* @__PURE__ */ React.createElement(Mask$3, {
    prefixCls,
    open,
    zIndex,
    mask,
    motion: maskMotion
  }), /* @__PURE__ */ React.createElement(RefResizeObserver, {
    onResize: onAlign,
    disabled: !open
  }, function(resizeObserverRef) {
    return /* @__PURE__ */ React.createElement(CSSMotion, _extends$3({
      motionAppear: true,
      motionEnter: true,
      motionLeave: true,
      removeOnLeave: false,
      forceRender,
      leavedClassName: "".concat(prefixCls, "-hidden")
    }, motion2, {
      onAppearPrepare: onPrepare,
      onEnterPrepare: onPrepare,
      visible: open,
      onVisibleChanged: function onVisibleChanged(nextVisible) {
        var _motion$onVisibleChan;
        motion2 === null || motion2 === void 0 ? void 0 : (_motion$onVisibleChan = motion2.onVisibleChanged) === null || _motion$onVisibleChan === void 0 ? void 0 : _motion$onVisibleChan.call(motion2, nextVisible);
        _onVisibleChanged(nextVisible);
      }
    }), function(_ref2, motionRef) {
      var motionClassName = _ref2.className, motionStyle = _ref2.style;
      var cls = classNames(prefixCls, motionClassName, className);
      return /* @__PURE__ */ React.createElement("div", {
        ref: composeRef$3(resizeObserverRef, ref2, motionRef),
        className: cls,
        style: _objectSpread2$d(_objectSpread2$d(_objectSpread2$d(_objectSpread2$d({}, offsetStyle), miscStyle), motionStyle), {}, {
          boxSizing: "border-box",
          zIndex
        }, style2),
        onMouseEnter,
        onMouseLeave,
        onClick
      }, arrow && /* @__PURE__ */ React.createElement(Arrow, {
        prefixCls,
        align,
        arrowX,
        arrowY
      }), childNode);
    });
  }));
});
var TriggerWrapper = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var children = props.children, getTriggerDOMNode = props.getTriggerDOMNode;
  var canUseRef = supportRef$2(children);
  var setRef = React.useCallback(function(node2) {
    fillRef$3(ref2, getTriggerDOMNode ? getTriggerDOMNode(node2) : node2);
  }, [getTriggerDOMNode]);
  var mergedRef = useComposeRef$2(setRef, children.ref);
  return canUseRef ? /* @__PURE__ */ React.cloneElement(children, {
    ref: mergedRef
  }) : children;
});
var _excluded$G = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
function generateTrigger$2() {
  var PortalComponent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Portal$2;
  var Trigger2 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-trigger-popup" : _props$prefixCls, children = props.children, _props$action = props.action, action = _props$action === void 0 ? "hover" : _props$action, showAction = props.showAction, hideAction = props.hideAction, popupVisible = props.popupVisible, defaultPopupVisible = props.defaultPopupVisible, onPopupVisibleChange = props.onPopupVisibleChange, afterPopupVisibleChange = props.afterPopupVisibleChange, mouseEnterDelay = props.mouseEnterDelay, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, focusDelay = props.focusDelay, blurDelay = props.blurDelay, mask = props.mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getPopupContainer = props.getPopupContainer, forceRender = props.forceRender, autoDestroy = props.autoDestroy, destroyPopupOnHide = props.destroyPopupOnHide, popup = props.popup, popupClassName = props.popupClassName, popupStyle = props.popupStyle, popupPlacement = props.popupPlacement, _props$builtinPlaceme = props.builtinPlacements, builtinPlacements = _props$builtinPlaceme === void 0 ? {} : _props$builtinPlaceme, popupAlign = props.popupAlign, zIndex = props.zIndex, stretch = props.stretch, getPopupClassNameFromAlign = props.getPopupClassNameFromAlign, alignPoint2 = props.alignPoint, onPopupClick = props.onPopupClick, onPopupAlign = props.onPopupAlign, arrow = props.arrow, popupMotion = props.popupMotion, maskMotion = props.maskMotion, popupTransitionName = props.popupTransitionName, popupAnimation = props.popupAnimation, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, className = props.className, getTriggerDOMNode = props.getTriggerDOMNode, restProps = _objectWithoutProperties$1(props, _excluded$G);
    var mergedAutoDestroy = autoDestroy || destroyPopupOnHide || false;
    var _React$useState = React.useState(false), _React$useState2 = _slicedToArray$1(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
    useLayoutEffect$6(function() {
      setMobile(isMobile$3());
    }, []);
    var subPopupElements = React.useRef({});
    var parentContext = React.useContext(TriggerContext$2);
    var context2 = React.useMemo(function() {
      return {
        registerSubPopup: function registerSubPopup(id2, subPopupEle) {
          subPopupElements.current[id2] = subPopupEle;
          parentContext === null || parentContext === void 0 ? void 0 : parentContext.registerSubPopup(id2, subPopupEle);
        }
      };
    }, [parentContext]);
    var id = useId$2();
    var _React$useState3 = React.useState(null), _React$useState4 = _slicedToArray$1(_React$useState3, 2), popupEle = _React$useState4[0], setPopupEle = _React$useState4[1];
    var setPopupRef = useEvent$4(function(node2) {
      if (isDOM(node2) && popupEle !== node2) {
        setPopupEle(node2);
      }
      parentContext === null || parentContext === void 0 ? void 0 : parentContext.registerSubPopup(id, node2);
    });
    var _React$useState5 = React.useState(null), _React$useState6 = _slicedToArray$1(_React$useState5, 2), targetEle = _React$useState6[0], setTargetEle = _React$useState6[1];
    var setTargetRef = useEvent$4(function(node2) {
      if (isDOM(node2) && targetEle !== node2) {
        setTargetEle(node2);
      }
    });
    var child = React.Children.only(children);
    var originChildProps = (child === null || child === void 0 ? void 0 : child.props) || {};
    var cloneProps = {};
    var inPopupOrChild = useEvent$4(function(ele) {
      var _childDOM$getRootNode, _popupEle$getRootNode;
      var childDOM = targetEle;
      return (childDOM === null || childDOM === void 0 ? void 0 : childDOM.contains(ele)) || (childDOM === null || childDOM === void 0 ? void 0 : (_childDOM$getRootNode = childDOM.getRootNode()) === null || _childDOM$getRootNode === void 0 ? void 0 : _childDOM$getRootNode.host) === ele || ele === childDOM || (popupEle === null || popupEle === void 0 ? void 0 : popupEle.contains(ele)) || (popupEle === null || popupEle === void 0 ? void 0 : (_popupEle$getRootNode = popupEle.getRootNode()) === null || _popupEle$getRootNode === void 0 ? void 0 : _popupEle$getRootNode.host) === ele || ele === popupEle || Object.values(subPopupElements.current).some(function(subPopupEle) {
        return (subPopupEle === null || subPopupEle === void 0 ? void 0 : subPopupEle.contains(ele)) || ele === subPopupEle;
      });
    });
    var mergePopupMotion = getMotion$4(prefixCls, popupMotion, popupAnimation, popupTransitionName);
    var mergeMaskMotion = getMotion$4(prefixCls, maskMotion, maskAnimation, maskTransitionName);
    var _React$useState7 = React.useState(defaultPopupVisible || false), _React$useState8 = _slicedToArray$1(_React$useState7, 2), internalOpen = _React$useState8[0], setInternalOpen = _React$useState8[1];
    var mergedOpen = popupVisible !== null && popupVisible !== void 0 ? popupVisible : internalOpen;
    var setMergedOpen = useEvent$4(function(nextOpen) {
      if (popupVisible === void 0) {
        setInternalOpen(nextOpen);
      }
    });
    useLayoutEffect$6(function() {
      setInternalOpen(popupVisible || false);
    }, [popupVisible]);
    var openRef = React.useRef(mergedOpen);
    openRef.current = mergedOpen;
    var internalTriggerOpen = useEvent$4(function(nextOpen) {
      if (mergedOpen !== nextOpen) {
        setMergedOpen(nextOpen);
        onPopupVisibleChange === null || onPopupVisibleChange === void 0 ? void 0 : onPopupVisibleChange(nextOpen);
      }
    });
    var delayRef = React.useRef();
    var clearDelay = function clearDelay2() {
      clearTimeout(delayRef.current);
    };
    var triggerOpen = function triggerOpen2(nextOpen) {
      var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      clearDelay();
      if (delay === 0) {
        internalTriggerOpen(nextOpen);
      } else {
        delayRef.current = setTimeout(function() {
          internalTriggerOpen(nextOpen);
        }, delay * 1e3);
      }
    };
    React.useEffect(function() {
      return clearDelay;
    }, []);
    var _React$useState9 = React.useState(false), _React$useState10 = _slicedToArray$1(_React$useState9, 2), inMotion = _React$useState10[0], setInMotion = _React$useState10[1];
    var mountRef = React.useRef(true);
    useLayoutEffect$6(function() {
      if (!mountRef.current || mergedOpen) {
        setInMotion(true);
      }
      mountRef.current = true;
    }, [mergedOpen]);
    var _React$useState11 = React.useState(null), _React$useState12 = _slicedToArray$1(_React$useState11, 2), motionPrepareResolve = _React$useState12[0], setMotionPrepareResolve = _React$useState12[1];
    var _React$useState13 = React.useState([0, 0]), _React$useState14 = _slicedToArray$1(_React$useState13, 2), mousePos = _React$useState14[0], setMousePos = _React$useState14[1];
    var setMousePosByEvent = function setMousePosByEvent2(event) {
      setMousePos([event.clientX, event.clientY]);
    };
    var _useAlign = useAlign(mergedOpen, popupEle, alignPoint2 ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign), _useAlign2 = _slicedToArray$1(_useAlign, 9), ready = _useAlign2[0], offsetX = _useAlign2[1], offsetY = _useAlign2[2], arrowX = _useAlign2[3], arrowY = _useAlign2[4], scaleX = _useAlign2[5], scaleY = _useAlign2[6], alignInfo = _useAlign2[7], onAlign = _useAlign2[8];
    var triggerAlign = useEvent$4(function() {
      if (!inMotion) {
        onAlign();
      }
    });
    useWatch(mergedOpen, targetEle, popupEle, triggerAlign);
    useLayoutEffect$6(function() {
      triggerAlign();
    }, [mousePos]);
    useLayoutEffect$6(function() {
      if (mergedOpen && !(builtinPlacements !== null && builtinPlacements !== void 0 && builtinPlacements[popupPlacement])) {
        triggerAlign();
      }
    }, [JSON.stringify(popupAlign)]);
    var alignedClassName = React.useMemo(function() {
      var baseClassName = getAlignPopupClassName$2(builtinPlacements, prefixCls, alignInfo, alignPoint2);
      return classNames(baseClassName, getPopupClassNameFromAlign === null || getPopupClassNameFromAlign === void 0 ? void 0 : getPopupClassNameFromAlign(alignInfo));
    }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint2]);
    React.useImperativeHandle(ref2, function() {
      return {
        forceAlign: triggerAlign
      };
    });
    var onVisibleChanged = function onVisibleChanged2(visible) {
      setInMotion(false);
      onAlign();
      afterPopupVisibleChange === null || afterPopupVisibleChange === void 0 ? void 0 : afterPopupVisibleChange(visible);
    };
    var onPrepare = function onPrepare2() {
      return new Promise(function(resolve) {
        setMotionPrepareResolve(function() {
          return resolve;
        });
      });
    };
    useLayoutEffect$6(function() {
      if (motionPrepareResolve) {
        onAlign();
        motionPrepareResolve();
        setMotionPrepareResolve(null);
      }
    }, [motionPrepareResolve]);
    var _React$useState15 = React.useState(0), _React$useState16 = _slicedToArray$1(_React$useState15, 2), targetWidth = _React$useState16[0], setTargetWidth = _React$useState16[1];
    var _React$useState17 = React.useState(0), _React$useState18 = _slicedToArray$1(_React$useState17, 2), targetHeight = _React$useState18[0], setTargetHeight = _React$useState18[1];
    var onTargetResize = function onTargetResize2(_24, ele) {
      triggerAlign();
      if (stretch) {
        var rect = ele.getBoundingClientRect();
        setTargetWidth(rect.width);
        setTargetHeight(rect.height);
      }
    };
    var _useAction = useAction(mobile, action, showAction, hideAction), _useAction2 = _slicedToArray$1(_useAction, 2), showActions = _useAction2[0], hideActions = _useAction2[1];
    var wrapperAction = function wrapperAction2(eventName, nextOpen, delay, preEvent) {
      cloneProps[eventName] = function(event) {
        var _originChildProps$eve;
        preEvent === null || preEvent === void 0 ? void 0 : preEvent(event);
        triggerOpen(nextOpen, delay);
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        (_originChildProps$eve = originChildProps[eventName]) === null || _originChildProps$eve === void 0 ? void 0 : _originChildProps$eve.call.apply(_originChildProps$eve, [originChildProps, event].concat(args));
      };
    };
    var clickToShow = showActions.has("click");
    var clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
    if (clickToShow || clickToHide) {
      cloneProps.onClick = function(event) {
        var _originChildProps$onC;
        if (openRef.current && clickToHide) {
          triggerOpen(false);
        } else if (!openRef.current && clickToShow) {
          setMousePosByEvent(event);
          triggerOpen(true);
        }
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        (_originChildProps$onC = originChildProps.onClick) === null || _originChildProps$onC === void 0 ? void 0 : _originChildProps$onC.call.apply(_originChildProps$onC, [originChildProps, event].concat(args));
      };
    }
    React.useEffect(function() {
      if (clickToHide && popupEle && (!mask || maskClosable)) {
        var onWindowClick = function onWindowClick2(_ref2) {
          var target = _ref2.target;
          if (openRef.current && !inPopupOrChild(target)) {
            triggerOpen(false);
          }
        };
        var win = getWin(popupEle);
        var targetRoot = targetEle === null || targetEle === void 0 ? void 0 : targetEle.getRootNode();
        win.addEventListener("click", onWindowClick);
        var inShadow = targetRoot && targetRoot !== targetEle.ownerDocument;
        if (inShadow) {
          targetRoot.addEventListener("click", onWindowClick);
        }
        return function() {
          win.removeEventListener("click", onWindowClick);
          if (inShadow) {
            targetRoot.removeEventListener("click", onWindowClick);
          }
        };
      }
    }, [clickToHide, targetEle, popupEle, mask, maskClosable]);
    var hoverToShow = showActions.has("hover");
    var hoverToHide = hideActions.has("hover");
    var onPopupMouseEnter;
    var onPopupMouseLeave;
    if (hoverToShow) {
      wrapperAction("onMouseEnter", true, mouseEnterDelay, function(event) {
        setMousePosByEvent(event);
      });
      onPopupMouseEnter = function onPopupMouseEnter2() {
        triggerOpen(true, mouseEnterDelay);
      };
      if (alignPoint2) {
        cloneProps.onMouseMove = function(event) {
          var _originChildProps$onM;
          (_originChildProps$onM = originChildProps.onMouseMove) === null || _originChildProps$onM === void 0 ? void 0 : _originChildProps$onM.call(originChildProps, event);
        };
      }
    }
    if (hoverToHide) {
      wrapperAction("onMouseLeave", false, mouseLeaveDelay);
      onPopupMouseLeave = function onPopupMouseLeave2() {
        triggerOpen(false, mouseLeaveDelay);
      };
    }
    if (showActions.has("focus")) {
      wrapperAction("onFocus", true, focusDelay);
    }
    if (hideActions.has("focus")) {
      wrapperAction("onBlur", false, blurDelay);
    }
    if (showActions.has("contextMenu")) {
      cloneProps.onContextMenu = function(event) {
        var _originChildProps$onC2;
        setMousePosByEvent(event);
        triggerOpen(true);
        event.preventDefault();
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
        (_originChildProps$onC2 = originChildProps.onContextMenu) === null || _originChildProps$onC2 === void 0 ? void 0 : _originChildProps$onC2.call.apply(_originChildProps$onC2, [originChildProps, event].concat(args));
      };
    }
    if (className) {
      cloneProps.className = classNames(originChildProps.className, className);
    }
    var mergedChildrenProps = _objectSpread2$d(_objectSpread2$d({}, originChildProps), cloneProps);
    var passedProps = {};
    var passedEventList = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
    passedEventList.forEach(function(eventName) {
      if (restProps[eventName]) {
        passedProps[eventName] = function() {
          var _mergedChildrenProps$;
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          (_mergedChildrenProps$ = mergedChildrenProps[eventName]) === null || _mergedChildrenProps$ === void 0 ? void 0 : _mergedChildrenProps$.call.apply(_mergedChildrenProps$, [mergedChildrenProps].concat(args));
          restProps[eventName].apply(restProps, args);
        };
      }
    });
    var triggerNode = /* @__PURE__ */ React.cloneElement(child, _objectSpread2$d(_objectSpread2$d({}, mergedChildrenProps), passedProps));
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(RefResizeObserver, {
      disabled: !mergedOpen,
      ref: setTargetRef,
      onResize: onTargetResize
    }, /* @__PURE__ */ React.createElement(TriggerWrapper, {
      getTriggerDOMNode
    }, triggerNode)), /* @__PURE__ */ React.createElement(TriggerContext$2.Provider, {
      value: context2
    }, /* @__PURE__ */ React.createElement(Popup$3, {
      portal: PortalComponent,
      ref: setPopupRef,
      prefixCls,
      popup,
      className: classNames(popupClassName, alignedClassName),
      style: popupStyle,
      target: targetEle,
      onMouseEnter: onPopupMouseEnter,
      onMouseLeave: onPopupMouseLeave,
      zIndex,
      open: mergedOpen,
      keepDom: inMotion,
      onClick: onPopupClick,
      mask,
      motion: mergePopupMotion,
      maskMotion: mergeMaskMotion,
      onVisibleChanged,
      onPrepare,
      forceRender,
      autoDestroy: mergedAutoDestroy,
      getPopupContainer,
      align: alignInfo,
      arrow,
      ready,
      offsetX,
      offsetY,
      arrowX,
      arrowY,
      onAlign: triggerAlign,
      stretch,
      targetWidth: targetWidth / scaleX,
      targetHeight: targetHeight / scaleY
    })));
  });
  return Trigger2;
}
var Trigger$2 = generateTrigger$2(Portal$2);
var _excluded$F = ["prefixCls", "disabled", "visible", "children", "popupElement", "containerWidth", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "builtinPlacements", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"];
var getBuiltInPlacements = function getBuiltInPlacements2(dropdownMatchSelectWidth) {
  var adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    }
  };
};
var SelectTrigger = function SelectTrigger2(props, ref2) {
  var prefixCls = props.prefixCls;
  props.disabled;
  var visible = props.visible, children = props.children, popupElement = props.popupElement, containerWidth = props.containerWidth, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, _props$direction = props.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction, placement = props.placement, builtinPlacements = props.builtinPlacements, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, getPopupContainer = props.getPopupContainer, empty2 = props.empty, getTriggerDOMNode = props.getTriggerDOMNode, onPopupVisibleChange = props.onPopupVisibleChange, onPopupMouseEnter = props.onPopupMouseEnter, restProps = _objectWithoutProperties$1(props, _excluded$F);
  var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
  var popupNode = popupElement;
  if (dropdownRender) {
    popupNode = dropdownRender(popupElement);
  }
  var mergedBuiltinPlacements = React.useMemo(function() {
    return builtinPlacements || getBuiltInPlacements(dropdownMatchSelectWidth);
  }, [builtinPlacements, dropdownMatchSelectWidth]);
  var mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName;
  var popupRef = React.useRef(null);
  React.useImperativeHandle(ref2, function() {
    return {
      getPopupElement: function getPopupElement() {
        return popupRef.current;
      }
    };
  });
  var popupStyle = _objectSpread2$d({
    minWidth: containerWidth
  }, dropdownStyle);
  if (typeof dropdownMatchSelectWidth === "number") {
    popupStyle.width = dropdownMatchSelectWidth;
  } else if (dropdownMatchSelectWidth) {
    popupStyle.width = containerWidth;
  }
  return /* @__PURE__ */ React.createElement(Trigger$2, _extends$3({}, restProps, {
    showAction: onPopupVisibleChange ? ["click"] : [],
    hideAction: onPopupVisibleChange ? ["click"] : [],
    popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
    builtinPlacements: mergedBuiltinPlacements,
    prefixCls: dropdownPrefixCls,
    popupTransitionName: mergedTransitionName,
    popup: /* @__PURE__ */ React.createElement("div", {
      ref: popupRef,
      onMouseEnter: onPopupMouseEnter
    }, popupNode),
    popupAlign: dropdownAlign,
    popupVisible: visible,
    getPopupContainer,
    popupClassName: classNames(dropdownClassName, _defineProperty$3({}, "".concat(dropdownPrefixCls, "-empty"), empty2)),
    popupStyle,
    getTriggerDOMNode,
    onPopupVisibleChange
  }), children);
};
var RefSelectTrigger = /* @__PURE__ */ React.forwardRef(SelectTrigger);
RefSelectTrigger.displayName = "SelectTrigger";
function getKey$1(data2, index2) {
  var key = data2.key;
  var value;
  if ("value" in data2) {
    value = data2.value;
  }
  if (key !== null && key !== void 0) {
    return key;
  }
  if (value !== void 0) {
    return value;
  }
  return "rc-index-key-".concat(index2);
}
function fillFieldNames(fieldNames, childrenAsData) {
  var _ref2 = fieldNames || {}, label = _ref2.label, value = _ref2.value, options = _ref2.options;
  return {
    label: label || (childrenAsData ? "children" : "label"),
    value: value || "value",
    options: options || "options"
  };
}
function flattenOptions(options) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fieldNames = _ref2.fieldNames, childrenAsData = _ref2.childrenAsData;
  var flattenList = [];
  var _fillFieldNames = fillFieldNames(fieldNames, false), fieldLabel = _fillFieldNames.label, fieldValue = _fillFieldNames.value, fieldOptions = _fillFieldNames.options;
  function dig(list2, isGroupOption) {
    list2.forEach(function(data2) {
      var label = data2[fieldLabel];
      if (isGroupOption || !(fieldOptions in data2)) {
        var value = data2[fieldValue];
        flattenList.push({
          key: getKey$1(data2, flattenList.length),
          groupOption: isGroupOption,
          data: data2,
          label,
          value
        });
      } else {
        var grpLabel = label;
        if (grpLabel === void 0 && childrenAsData) {
          grpLabel = data2.label;
        }
        flattenList.push({
          key: getKey$1(data2, flattenList.length),
          group: true,
          data: data2,
          label: grpLabel
        });
        dig(data2[fieldOptions], true);
      }
    });
  }
  dig(options, false);
  return flattenList;
}
function injectPropsWithOption(option) {
  var newOption = _objectSpread2$d({}, option);
  if (!("props" in newOption)) {
    Object.defineProperty(newOption, "props", {
      get: function get2() {
        warningOnce$3(false, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`.");
        return newOption;
      }
    });
  }
  return newOption;
}
function getSeparatedContent(text2, tokens) {
  if (!tokens || !tokens.length) {
    return null;
  }
  var match2 = false;
  function separate(str, _ref3) {
    var _ref4 = _toArray$1(_ref3), token2 = _ref4[0], restTokens = _ref4.slice(1);
    if (!token2) {
      return [str];
    }
    var list3 = str.split(token2);
    match2 = match2 || list3.length > 1;
    return list3.reduce(function(prevList, unitStr) {
      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));
    }, []).filter(function(unit) {
      return unit;
    });
  }
  var list2 = separate(text2, tokens);
  return match2 ? list2 : null;
}
var _excluded$E = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "autoClearSearchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "showArrow", "inputIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "builtinPlacements", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"];
var DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autoFocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex"];
function isMultiple(mode) {
  return mode === "tags" || mode === "multiple";
}
var BaseSelect = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var _customizeRawInputEle, _classNames2;
  var id = props.id, prefixCls = props.prefixCls, className = props.className, showSearch = props.showSearch, tagRender = props.tagRender, direction = props.direction, omitDomProps = props.omitDomProps, displayValues = props.displayValues, onDisplayValuesChange = props.onDisplayValuesChange, emptyOptions = props.emptyOptions, _props$notFoundConten = props.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? "Not Found" : _props$notFoundConten, onClear = props.onClear, mode = props.mode, disabled = props.disabled, loading = props.loading, getInputElement2 = props.getInputElement, getRawInputElement = props.getRawInputElement, open = props.open, defaultOpen = props.defaultOpen, onDropdownVisibleChange = props.onDropdownVisibleChange, activeValue = props.activeValue, onActiveValueChange = props.onActiveValueChange, activeDescendantId = props.activeDescendantId, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSplit = props.onSearchSplit, tokenSeparators = props.tokenSeparators, allowClear = props.allowClear, showArrow = props.showArrow, inputIcon = props.inputIcon, clearIcon = props.clearIcon, OptionList3 = props.OptionList, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, placement = props.placement, builtinPlacements = props.builtinPlacements, getPopupContainer = props.getPopupContainer, _props$showAction = props.showAction, showAction = _props$showAction === void 0 ? [] : _props$showAction, onFocus = props.onFocus, onBlur = props.onBlur, onKeyUp = props.onKeyUp, onKeyDown = props.onKeyDown, onMouseDown = props.onMouseDown, restProps = _objectWithoutProperties$1(props, _excluded$E);
  var multiple = isMultiple(mode);
  var mergedShowSearch = (showSearch !== void 0 ? showSearch : multiple) || mode === "combobox";
  var domProps = _objectSpread2$d({}, restProps);
  DEFAULT_OMIT_PROPS.forEach(function(propName) {
    delete domProps[propName];
  });
  omitDomProps === null || omitDomProps === void 0 ? void 0 : omitDomProps.forEach(function(propName) {
    delete domProps[propName];
  });
  var _React$useState = React.useState(false), _React$useState2 = _slicedToArray$1(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
  React.useEffect(function() {
    setMobile(isMobile$4());
  }, []);
  var containerRef = React.useRef(null);
  var selectorDomRef = React.useRef(null);
  var triggerRef = React.useRef(null);
  var selectorRef = React.useRef(null);
  var listRef = React.useRef(null);
  var _useDelayReset = useDelayReset(), _useDelayReset2 = _slicedToArray$1(_useDelayReset, 3), mockFocused = _useDelayReset2[0], setMockFocused = _useDelayReset2[1], cancelSetMockFocused = _useDelayReset2[2];
  React.useImperativeHandle(ref2, function() {
    var _selectorRef$current, _selectorRef$current2;
    return {
      focus: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.focus,
      blur: (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 ? void 0 : _selectorRef$current2.blur,
      scrollTo: function scrollTo(arg) {
        var _listRef$current;
        return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(arg);
      }
    };
  });
  var mergedSearchValue = React.useMemo(function() {
    var _displayValues$;
    if (mode !== "combobox") {
      return searchValue;
    }
    var val = (_displayValues$ = displayValues[0]) === null || _displayValues$ === void 0 ? void 0 : _displayValues$.value;
    return typeof val === "string" || typeof val === "number" ? String(val) : "";
  }, [searchValue, mode, displayValues]);
  var customizeInputElement = mode === "combobox" && typeof getInputElement2 === "function" && getInputElement2() || null;
  var customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
  var customizeRawInputRef = useComposeRef$3(selectorDomRef, customizeRawInputElement === null || customizeRawInputElement === void 0 ? void 0 : (_customizeRawInputEle = customizeRawInputElement.props) === null || _customizeRawInputEle === void 0 ? void 0 : _customizeRawInputEle.ref);
  var _React$useState3 = React.useState(false), _React$useState4 = _slicedToArray$1(_React$useState3, 2), rendered = _React$useState4[0], setRendered = _React$useState4[1];
  useLayoutEffect$9(function() {
    setRendered(true);
  }, []);
  var _useMergedState = useMergedState$3(false, {
    defaultValue: defaultOpen,
    value: open
  }), _useMergedState2 = _slicedToArray$1(_useMergedState, 2), innerOpen = _useMergedState2[0], setInnerOpen = _useMergedState2[1];
  var mergedOpen = rendered ? innerOpen : false;
  var emptyListContent = !notFoundContent && emptyOptions;
  if (disabled || emptyListContent && mergedOpen && mode === "combobox") {
    mergedOpen = false;
  }
  var triggerOpen = emptyListContent ? false : mergedOpen;
  var onToggleOpen = React.useCallback(function(newOpen) {
    var nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen;
    if (!disabled) {
      setInnerOpen(nextOpen);
      if (mergedOpen !== nextOpen) {
        onDropdownVisibleChange === null || onDropdownVisibleChange === void 0 ? void 0 : onDropdownVisibleChange(nextOpen);
      }
    }
  }, [disabled, mergedOpen, setInnerOpen, onDropdownVisibleChange]);
  var tokenWithEnter = React.useMemo(function() {
    return (tokenSeparators || []).some(function(tokenSeparator) {
      return ["\n", "\r\n"].includes(tokenSeparator);
    });
  }, [tokenSeparators]);
  var onInternalSearch = function onInternalSearch2(searchText, fromTyping, isCompositing) {
    var ret = true;
    var newSearchText = searchText;
    onActiveValueChange === null || onActiveValueChange === void 0 ? void 0 : onActiveValueChange(null);
    var patchLabels = isCompositing ? null : getSeparatedContent(searchText, tokenSeparators);
    if (mode !== "combobox" && patchLabels) {
      newSearchText = "";
      onSearchSplit === null || onSearchSplit === void 0 ? void 0 : onSearchSplit(patchLabels);
      onToggleOpen(false);
      ret = false;
    }
    if (onSearch && mergedSearchValue !== newSearchText) {
      onSearch(newSearchText, {
        source: fromTyping ? "typing" : "effect"
      });
    }
    return ret;
  };
  var onInternalSearchSubmit = function onInternalSearchSubmit2(searchText) {
    if (!searchText || !searchText.trim()) {
      return;
    }
    onSearch(searchText, {
      source: "submit"
    });
  };
  React.useEffect(function() {
    if (!mergedOpen && !multiple && mode !== "combobox") {
      onInternalSearch("", false, false);
    }
  }, [mergedOpen]);
  React.useEffect(function() {
    if (innerOpen && disabled) {
      setInnerOpen(false);
    }
    if (disabled) {
      setMockFocused(false);
    }
  }, [disabled]);
  var _useLock = useLock(), _useLock2 = _slicedToArray$1(_useLock, 2), getClearLock = _useLock2[0], setClearLock = _useLock2[1];
  var onInternalKeyDown = function onInternalKeyDown2(event) {
    var clearLock = getClearLock();
    var which = event.which;
    if (which === KeyCode$3.ENTER) {
      if (mode !== "combobox") {
        event.preventDefault();
      }
      if (!mergedOpen) {
        onToggleOpen(true);
      }
    }
    setClearLock(!!mergedSearchValue);
    if (which === KeyCode$3.BACKSPACE && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
      var cloneDisplayValues = _toConsumableArray(displayValues);
      var removedDisplayValue = null;
      for (var i = cloneDisplayValues.length - 1; i >= 0; i -= 1) {
        var current = cloneDisplayValues[i];
        if (!current.disabled) {
          cloneDisplayValues.splice(i, 1);
          removedDisplayValue = current;
          break;
        }
      }
      if (removedDisplayValue) {
        onDisplayValuesChange(cloneDisplayValues, {
          type: "remove",
          values: [removedDisplayValue]
        });
      }
    }
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }
    if (mergedOpen && listRef.current) {
      var _listRef$current2;
      (_listRef$current2 = listRef.current).onKeyDown.apply(_listRef$current2, [event].concat(rest));
    }
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown.apply(void 0, [event].concat(rest));
  };
  var onInternalKeyUp = function onInternalKeyUp2(event) {
    for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      rest[_key2 - 1] = arguments[_key2];
    }
    if (mergedOpen && listRef.current) {
      var _listRef$current3;
      (_listRef$current3 = listRef.current).onKeyUp.apply(_listRef$current3, [event].concat(rest));
    }
    onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp.apply(void 0, [event].concat(rest));
  };
  var onSelectorRemove = function onSelectorRemove2(val) {
    var newValues = displayValues.filter(function(i) {
      return i !== val;
    });
    onDisplayValuesChange(newValues, {
      type: "remove",
      values: [val]
    });
  };
  var focusRef = React.useRef(false);
  var onContainerFocus = function onContainerFocus2() {
    setMockFocused(true);
    if (!disabled) {
      if (onFocus && !focusRef.current) {
        onFocus.apply(void 0, arguments);
      }
      if (showAction.includes("focus")) {
        onToggleOpen(true);
      }
    }
    focusRef.current = true;
  };
  var onContainerBlur = function onContainerBlur2() {
    setMockFocused(false, function() {
      focusRef.current = false;
      onToggleOpen(false);
    });
    if (disabled) {
      return;
    }
    if (mergedSearchValue) {
      if (mode === "tags") {
        onSearch(mergedSearchValue, {
          source: "submit"
        });
      } else if (mode === "multiple") {
        onSearch("", {
          source: "blur"
        });
      }
    }
    if (onBlur) {
      onBlur.apply(void 0, arguments);
    }
  };
  var activeTimeoutIds = [];
  React.useEffect(function() {
    return function() {
      activeTimeoutIds.forEach(function(timeoutId) {
        return clearTimeout(timeoutId);
      });
      activeTimeoutIds.splice(0, activeTimeoutIds.length);
    };
  }, []);
  var onInternalMouseDown = function onInternalMouseDown2(event) {
    var _triggerRef$current;
    var target = event.target;
    var popupElement = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getPopupElement();
    if (popupElement && popupElement.contains(target)) {
      var timeoutId = setTimeout(function() {
        var index2 = activeTimeoutIds.indexOf(timeoutId);
        if (index2 !== -1) {
          activeTimeoutIds.splice(index2, 1);
        }
        cancelSetMockFocused();
        if (!mobile && !popupElement.contains(document.activeElement)) {
          var _selectorRef$current3;
          (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 ? void 0 : _selectorRef$current3.focus();
        }
      });
      activeTimeoutIds.push(timeoutId);
    }
    for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      restArgs[_key3 - 1] = arguments[_key3];
    }
    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown.apply(void 0, [event].concat(restArgs));
  };
  var _React$useState5 = React.useState(null), _React$useState6 = _slicedToArray$1(_React$useState5, 2), containerWidth = _React$useState6[0], setContainerWidth = _React$useState6[1];
  var _React$useState7 = React.useState({}), _React$useState8 = _slicedToArray$1(_React$useState7, 2), forceUpdate = _React$useState8[1];
  function onPopupMouseEnter() {
    forceUpdate({});
  }
  useLayoutEffect$9(function() {
    if (triggerOpen) {
      var _containerRef$current;
      var newWidth = Math.ceil((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.offsetWidth);
      if (containerWidth !== newWidth && !Number.isNaN(newWidth)) {
        setContainerWidth(newWidth);
      }
    }
  }, [triggerOpen]);
  var onTriggerVisibleChange;
  if (customizeRawInputElement) {
    onTriggerVisibleChange = function onTriggerVisibleChange2(newOpen) {
      onToggleOpen(newOpen);
    };
  }
  useSelectTriggerControl(function() {
    var _triggerRef$current2;
    return [containerRef.current, (_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getPopupElement()];
  }, triggerOpen, onToggleOpen, !!customizeRawInputElement);
  var baseSelectContext = React.useMemo(function() {
    return _objectSpread2$d(_objectSpread2$d({}, props), {}, {
      notFoundContent,
      open: mergedOpen,
      triggerOpen,
      id,
      showSearch: mergedShowSearch,
      multiple,
      toggleOpen: onToggleOpen
    });
  }, [props, notFoundContent, triggerOpen, mergedOpen, id, mergedShowSearch, multiple, onToggleOpen]);
  var mergedShowArrow = showArrow !== void 0 ? showArrow : loading || !multiple && mode !== "combobox";
  var arrowNode;
  if (mergedShowArrow) {
    arrowNode = /* @__PURE__ */ React.createElement(TransBtn, {
      className: classNames("".concat(prefixCls, "-arrow"), _defineProperty$3({}, "".concat(prefixCls, "-arrow-loading"), loading)),
      customizeIcon: inputIcon,
      customizeIconProps: {
        loading,
        searchValue: mergedSearchValue,
        open: mergedOpen,
        focused: mockFocused,
        showSearch: mergedShowSearch
      }
    });
  }
  var clearNode;
  var onClearMouseDown = function onClearMouseDown2() {
    var _selectorRef$current4;
    onClear === null || onClear === void 0 ? void 0 : onClear();
    (_selectorRef$current4 = selectorRef.current) === null || _selectorRef$current4 === void 0 ? void 0 : _selectorRef$current4.focus();
    onDisplayValuesChange([], {
      type: "clear",
      values: displayValues
    });
    onInternalSearch("", false, false);
  };
  if (!disabled && allowClear && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === "")) {
    clearNode = /* @__PURE__ */ React.createElement(TransBtn, {
      className: "".concat(prefixCls, "-clear"),
      onMouseDown: onClearMouseDown,
      customizeIcon: clearIcon
    }, "\xD7");
  }
  var optionList = /* @__PURE__ */ React.createElement(OptionList3, {
    ref: listRef
  });
  var mergedClassName = classNames(prefixCls, className, (_classNames2 = {}, _defineProperty$3(_classNames2, "".concat(prefixCls, "-focused"), mockFocused), _defineProperty$3(_classNames2, "".concat(prefixCls, "-multiple"), multiple), _defineProperty$3(_classNames2, "".concat(prefixCls, "-single"), !multiple), _defineProperty$3(_classNames2, "".concat(prefixCls, "-allow-clear"), allowClear), _defineProperty$3(_classNames2, "".concat(prefixCls, "-show-arrow"), mergedShowArrow), _defineProperty$3(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$3(_classNames2, "".concat(prefixCls, "-loading"), loading), _defineProperty$3(_classNames2, "".concat(prefixCls, "-open"), mergedOpen), _defineProperty$3(_classNames2, "".concat(prefixCls, "-customize-input"), customizeInputElement), _defineProperty$3(_classNames2, "".concat(prefixCls, "-show-search"), mergedShowSearch), _classNames2));
  var selectorNode = /* @__PURE__ */ React.createElement(RefSelectTrigger, {
    ref: triggerRef,
    disabled,
    prefixCls,
    visible: triggerOpen,
    popupElement: optionList,
    containerWidth,
    animation,
    transitionName,
    dropdownStyle,
    dropdownClassName,
    direction,
    dropdownMatchSelectWidth,
    dropdownRender,
    dropdownAlign,
    placement,
    builtinPlacements,
    getPopupContainer,
    empty: emptyOptions,
    getTriggerDOMNode: function getTriggerDOMNode() {
      return selectorDomRef.current;
    },
    onPopupVisibleChange: onTriggerVisibleChange,
    onPopupMouseEnter
  }, customizeRawInputElement ? /* @__PURE__ */ React.cloneElement(customizeRawInputElement, {
    ref: customizeRawInputRef
  }) : /* @__PURE__ */ React.createElement(ForwardSelector, _extends$3({}, props, {
    domRef: selectorDomRef,
    prefixCls,
    inputElement: customizeInputElement,
    ref: selectorRef,
    id,
    showSearch: mergedShowSearch,
    autoClearSearchValue,
    mode,
    activeDescendantId,
    tagRender,
    values: displayValues,
    open: mergedOpen,
    onToggleOpen,
    activeValue,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    onSearchSubmit: onInternalSearchSubmit,
    onRemove: onSelectorRemove,
    tokenWithEnter
  })));
  var renderNode;
  if (customizeRawInputElement) {
    renderNode = selectorNode;
  } else {
    renderNode = /* @__PURE__ */ React.createElement("div", _extends$3({
      className: mergedClassName
    }, domProps, {
      ref: containerRef,
      onMouseDown: onInternalMouseDown,
      onKeyDown: onInternalKeyDown,
      onKeyUp: onInternalKeyUp,
      onFocus: onContainerFocus,
      onBlur: onContainerBlur
    }), mockFocused && !mergedOpen && /* @__PURE__ */ React.createElement("span", {
      style: {
        width: 0,
        height: 0,
        position: "absolute",
        overflow: "hidden",
        opacity: 0
      },
      "aria-live": "polite"
    }, "".concat(displayValues.map(function(_ref2) {
      var label = _ref2.label, value = _ref2.value;
      return ["number", "string"].includes(_typeof$8(label)) ? label : value;
    }).join(", "))), selectorNode, arrowNode, clearNode);
  }
  return /* @__PURE__ */ React.createElement(BaseSelectContext.Provider, {
    value: baseSelectContext
  }, renderNode);
});
var useCache = function(labeledValues, valueOptions) {
  var cacheRef = React.useRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  });
  var filledLabeledValues = React.useMemo(function() {
    var _cacheRef$current = cacheRef.current, prevValueCache = _cacheRef$current.values, prevOptionCache = _cacheRef$current.options;
    var patchedValues = labeledValues.map(function(item) {
      if (item.label === void 0) {
        var _prevValueCache$get;
        return _objectSpread2$d(_objectSpread2$d({}, item), {}, {
          label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label
        });
      }
      return item;
    });
    var valueCache = /* @__PURE__ */ new Map();
    var optionCache = /* @__PURE__ */ new Map();
    patchedValues.forEach(function(item) {
      valueCache.set(item.value, item);
      optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
    });
    cacheRef.current.values = valueCache;
    cacheRef.current.options = optionCache;
    return patchedValues;
  }, [labeledValues, valueOptions]);
  var getOption = React.useCallback(function(val) {
    return valueOptions.get(val) || cacheRef.current.options.get(val);
  }, [valueOptions]);
  return [filledLabeledValues, getOption];
};
function includes(test, search2) {
  return toArray$8(test).join("").toUpperCase().includes(search2);
}
var useFilterOptions = function(options, fieldNames, searchValue, filterOption, optionFilterProp) {
  return React.useMemo(function() {
    if (!searchValue || filterOption === false) {
      return options;
    }
    var fieldOptions = fieldNames.options, fieldLabel = fieldNames.label, fieldValue = fieldNames.value;
    var filteredOptions = [];
    var customizeFilter = typeof filterOption === "function";
    var upperSearch = searchValue.toUpperCase();
    var filterFunc = customizeFilter ? filterOption : function(_24, option) {
      if (optionFilterProp) {
        return includes(option[optionFilterProp], upperSearch);
      }
      if (option[fieldOptions]) {
        return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
      }
      return includes(option[fieldValue], upperSearch);
    };
    var wrapOption = customizeFilter ? function(opt) {
      return injectPropsWithOption(opt);
    } : function(opt) {
      return opt;
    };
    options.forEach(function(item) {
      if (item[fieldOptions]) {
        var matchGroup = filterFunc(searchValue, wrapOption(item));
        if (matchGroup) {
          filteredOptions.push(item);
        } else {
          var subOptions = item[fieldOptions].filter(function(subItem) {
            return filterFunc(searchValue, wrapOption(subItem));
          });
          if (subOptions.length) {
            filteredOptions.push(_objectSpread2$d(_objectSpread2$d({}, item), {}, _defineProperty$3({}, fieldOptions, subOptions)));
          }
        }
        return;
      }
      if (filterFunc(searchValue, wrapOption(item))) {
        filteredOptions.push(item);
      }
    });
    return filteredOptions;
  }, [options, filterOption, optionFilterProp, searchValue, fieldNames]);
};
var uuid$3 = 0;
var isBrowserClient = canUseDom$a();
function getUUID() {
  var retId;
  if (isBrowserClient) {
    retId = uuid$3;
    uuid$3 += 1;
  } else {
    retId = "TEST_OR_SSR";
  }
  return retId;
}
function useId$1(id) {
  var _React$useState = React.useState(), _React$useState2 = _slicedToArray$1(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
  React.useEffect(function() {
    setInnerId("rc_select_".concat(getUUID()));
  }, []);
  return id || innerId;
}
function toArray$5(children) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var ret = [];
  React.Children.forEach(children, function(child) {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray$5(child));
    } else if (reactIs$2.exports.isFragment(child) && child.props) {
      ret = ret.concat(toArray$5(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}
var _excluded$D = ["children", "value"], _excluded2$a = ["children"];
function convertNodeToOption(node2) {
  var _ref2 = node2, key = _ref2.key, _ref$props = _ref2.props, children = _ref$props.children, value = _ref$props.value, restProps = _objectWithoutProperties$1(_ref$props, _excluded$D);
  return _objectSpread2$d({
    key,
    value: value !== void 0 ? value : key,
    children
  }, restProps);
}
function convertChildrenToData(nodes) {
  var optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return toArray$5(nodes).map(function(node2, index2) {
    if (!/* @__PURE__ */ React.isValidElement(node2) || !node2.type) {
      return null;
    }
    var _ref2 = node2, isSelectOptGroup = _ref2.type.isSelectOptGroup, key = _ref2.key, _ref2$props = _ref2.props, children = _ref2$props.children, restProps = _objectWithoutProperties$1(_ref2$props, _excluded2$a);
    if (optionOnly || !isSelectOptGroup) {
      return convertNodeToOption(node2);
    }
    return _objectSpread2$d(_objectSpread2$d({
      key: "__RC_SELECT_GRP__".concat(key === null ? index2 : key, "__"),
      label: key
    }, restProps), {}, {
      options: convertChildrenToData(children)
    });
  }).filter(function(data2) {
    return data2;
  });
}
function useOptions(options, children, fieldNames, optionFilterProp, optionLabelProp) {
  return React.useMemo(function() {
    var mergedOptions = options;
    var childrenAsData = !options;
    if (childrenAsData) {
      mergedOptions = convertChildrenToData(children);
    }
    var valueOptions = /* @__PURE__ */ new Map();
    var labelOptions = /* @__PURE__ */ new Map();
    var setLabelOptions = function setLabelOptions2(labelOptionsMap, option, key) {
      if (key && typeof key === "string") {
        labelOptionsMap.set(option[key], option);
      }
    };
    function dig(optionList) {
      var isChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      for (var i = 0; i < optionList.length; i += 1) {
        var option = optionList[i];
        if (!option[fieldNames.options] || isChildren) {
          valueOptions.set(option[fieldNames.value], option);
          setLabelOptions(labelOptions, option, fieldNames.label);
          setLabelOptions(labelOptions, option, optionFilterProp);
          setLabelOptions(labelOptions, option, optionLabelProp);
        } else {
          dig(option[fieldNames.options], true);
        }
      }
    }
    dig(mergedOptions);
    return {
      options: mergedOptions,
      valueOptions,
      labelOptions
    };
  }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
}
function useRefFunc(callback) {
  var funcRef = React.useRef();
  funcRef.current = callback;
  var cacheFn = React.useCallback(function() {
    return funcRef.current.apply(funcRef, arguments);
  }, []);
  return cacheFn;
}
var OptGroup = function OptGroup2() {
  return null;
};
OptGroup.isSelectOptGroup = true;
var Option$1 = function Option() {
  return null;
};
Option$1.isSelectOption = true;
function omit$4(obj, fields) {
  var clone2 = _objectSpread2$d({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function(key) {
      delete clone2[key];
    });
  }
  return clone2;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _typeof$6(obj) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$6(obj);
}
function _toPrimitive(input, hint) {
  if (_typeof$6(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$6(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof$6(key) === "symbol" ? key : String(key);
}
function _defineProperty$1(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys$1(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$b(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _arrayWithHoles(arr2) {
  if (Array.isArray(arr2))
    return arr2;
}
function _iterableToArrayLimit(arr2, i) {
  var _i2 = null == arr2 ? null : "undefined" != typeof Symbol && arr2[Symbol.iterator] || arr2["@@iterator"];
  if (null != _i2) {
    var _s, _e2, _x, _r2, _arr = [], _n2 = true, _d = false;
    try {
      if (_x = (_i2 = _i2.call(arr2)).next, 0 === i) {
        if (Object(_i2) !== _i2)
          return;
        _n2 = false;
      } else
        for (; !(_n2 = (_s = _x.call(_i2)).done) && (_arr.push(_s.value), _arr.length !== i); _n2 = true)
          ;
    } catch (err) {
      _d = true, _e2 = err;
    } finally {
      try {
        if (!_n2 && null != _i2["return"] && (_r2 = _i2["return"](), Object(_r2) !== _r2))
          return;
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
}
function _arrayLikeToArray(arr2, len) {
  if (len == null || len > arr2.length)
    len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++)
    arr22[i] = arr2[i];
  return arr22;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr2, i) {
  return _arrayWithHoles(arr2) || _iterableToArrayLimit(arr2, i) || _unsupportedIterableToArray(arr2, i) || _nonIterableRest();
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var Filler = /* @__PURE__ */ React.forwardRef(function(_ref2, ref2) {
  var height = _ref2.height, offset3 = _ref2.offset, children = _ref2.children, prefixCls = _ref2.prefixCls, onInnerResize = _ref2.onInnerResize, innerProps = _ref2.innerProps;
  var outerStyle = {};
  var innerStyle = {
    display: "flex",
    flexDirection: "column"
  };
  if (offset3 !== void 0) {
    outerStyle = {
      height,
      position: "relative",
      overflow: "hidden"
    };
    innerStyle = _objectSpread2$b(_objectSpread2$b({}, innerStyle), {}, {
      transform: "translateY(".concat(offset3, "px)"),
      position: "absolute",
      left: 0,
      right: 0,
      top: 0
    });
  }
  return /* @__PURE__ */ React.createElement("div", {
    style: outerStyle
  }, /* @__PURE__ */ React.createElement(ResizeObserver$2, {
    onResize: function onResize2(_ref22) {
      var offsetHeight = _ref22.offsetHeight;
      if (offsetHeight && onInnerResize) {
        onInnerResize();
      }
    }
  }, /* @__PURE__ */ React.createElement("div", _extends({
    style: innerStyle,
    className: classNames(_defineProperty$1({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
    ref: ref2
  }, innerProps), children)));
});
Filler.displayName = "Filler";
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof$6(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
var raf$6 = function raf3(callback) {
  return +setTimeout(callback, 16);
};
var caf$5 = function caf3(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf$6 = function raf10(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf$5 = function caf10(handle2) {
    return window.cancelAnimationFrame(handle2);
  };
}
var rafUUID$5 = 0;
var rafIds$5 = /* @__PURE__ */ new Map();
function cleanup$5(id) {
  rafIds$5.delete(id);
}
function wrapperRaf$5(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID$5 += 1;
  var id = rafUUID$5;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup$5(id);
      callback();
    } else {
      var realId = raf$6(function() {
        callRef(leftTimes - 1);
      });
      rafIds$5.set(id, realId);
    }
  }
  callRef(times);
  return id;
}
wrapperRaf$5.cancel = function(id) {
  var realId = rafIds$5.get(id);
  cleanup$5(realId);
  return caf$5(realId);
};
var MIN_SIZE = 20;
function getPageY(e2) {
  return "touches" in e2 ? e2.touches[0].pageY : e2.pageY;
}
var ScrollBar = /* @__PURE__ */ function(_React$Component) {
  _inherits(ScrollBar2, _React$Component);
  var _super = _createSuper(ScrollBar2);
  function ScrollBar2() {
    var _this;
    _classCallCheck(this, ScrollBar2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.moveRaf = null;
    _this.scrollbarRef = /* @__PURE__ */ React.createRef();
    _this.thumbRef = /* @__PURE__ */ React.createRef();
    _this.visibleTimeout = null;
    _this.state = {
      dragging: false,
      pageY: null,
      startTop: null,
      visible: false
    };
    _this.delayHidden = function() {
      clearTimeout(_this.visibleTimeout);
      _this.setState({
        visible: true
      });
      _this.visibleTimeout = setTimeout(function() {
        _this.setState({
          visible: false
        });
      }, 2e3);
    };
    _this.onScrollbarTouchStart = function(e2) {
      e2.preventDefault();
    };
    _this.onContainerMouseDown = function(e2) {
      e2.stopPropagation();
      e2.preventDefault();
    };
    _this.patchEvents = function() {
      window.addEventListener("mousemove", _this.onMouseMove);
      window.addEventListener("mouseup", _this.onMouseUp);
      _this.thumbRef.current.addEventListener("touchmove", _this.onMouseMove);
      _this.thumbRef.current.addEventListener("touchend", _this.onMouseUp);
    };
    _this.removeEvents = function() {
      var _this$scrollbarRef$cu;
      window.removeEventListener("mousemove", _this.onMouseMove);
      window.removeEventListener("mouseup", _this.onMouseUp);
      (_this$scrollbarRef$cu = _this.scrollbarRef.current) === null || _this$scrollbarRef$cu === void 0 ? void 0 : _this$scrollbarRef$cu.removeEventListener("touchstart", _this.onScrollbarTouchStart);
      if (_this.thumbRef.current) {
        _this.thumbRef.current.removeEventListener("touchstart", _this.onMouseDown);
        _this.thumbRef.current.removeEventListener("touchmove", _this.onMouseMove);
        _this.thumbRef.current.removeEventListener("touchend", _this.onMouseUp);
      }
      wrapperRaf$5.cancel(_this.moveRaf);
    };
    _this.onMouseDown = function(e2) {
      var onStartMove = _this.props.onStartMove;
      _this.setState({
        dragging: true,
        pageY: getPageY(e2),
        startTop: _this.getTop()
      });
      onStartMove();
      _this.patchEvents();
      e2.stopPropagation();
      e2.preventDefault();
    };
    _this.onMouseMove = function(e2) {
      var _this$state = _this.state, dragging = _this$state.dragging, pageY = _this$state.pageY, startTop = _this$state.startTop;
      var onScroll = _this.props.onScroll;
      wrapperRaf$5.cancel(_this.moveRaf);
      if (dragging) {
        var offsetY = getPageY(e2) - pageY;
        var newTop = startTop + offsetY;
        var enableScrollRange = _this.getEnableScrollRange();
        var enableHeightRange = _this.getEnableHeightRange();
        var ptg = enableHeightRange ? newTop / enableHeightRange : 0;
        var newScrollTop = Math.ceil(ptg * enableScrollRange);
        _this.moveRaf = wrapperRaf$5(function() {
          onScroll(newScrollTop);
        });
      }
    };
    _this.onMouseUp = function() {
      var onStopMove = _this.props.onStopMove;
      _this.setState({
        dragging: false
      });
      onStopMove();
      _this.removeEvents();
    };
    _this.getSpinHeight = function() {
      var _this$props = _this.props, height = _this$props.height, count = _this$props.count;
      var baseHeight = height / count * 10;
      baseHeight = Math.max(baseHeight, MIN_SIZE);
      baseHeight = Math.min(baseHeight, height / 2);
      return Math.floor(baseHeight);
    };
    _this.getEnableScrollRange = function() {
      var _this$props2 = _this.props, scrollHeight = _this$props2.scrollHeight, height = _this$props2.height;
      return scrollHeight - height || 0;
    };
    _this.getEnableHeightRange = function() {
      var height = _this.props.height;
      var spinHeight = _this.getSpinHeight();
      return height - spinHeight || 0;
    };
    _this.getTop = function() {
      var scrollTop = _this.props.scrollTop;
      var enableScrollRange = _this.getEnableScrollRange();
      var enableHeightRange = _this.getEnableHeightRange();
      if (scrollTop === 0 || enableScrollRange === 0) {
        return 0;
      }
      var ptg = scrollTop / enableScrollRange;
      return ptg * enableHeightRange;
    };
    _this.showScroll = function() {
      var _this$props3 = _this.props, height = _this$props3.height, scrollHeight = _this$props3.scrollHeight;
      return scrollHeight > height;
    };
    return _this;
  }
  _createClass(ScrollBar2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scrollbarRef.current.addEventListener("touchstart", this.onScrollbarTouchStart);
      this.thumbRef.current.addEventListener("touchstart", this.onMouseDown);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.scrollTop !== this.props.scrollTop) {
        this.delayHidden();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.removeEvents();
      clearTimeout(this.visibleTimeout);
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$state2 = this.state, dragging = _this$state2.dragging, visible = _this$state2.visible;
      var prefixCls = this.props.prefixCls;
      var spinHeight = this.getSpinHeight();
      var top = this.getTop();
      var canScroll = this.showScroll();
      var mergedVisible = canScroll && visible;
      return /* @__PURE__ */ React.createElement("div", {
        ref: this.scrollbarRef,
        className: classNames("".concat(prefixCls, "-scrollbar"), _defineProperty$1({}, "".concat(prefixCls, "-scrollbar-show"), canScroll)),
        style: {
          width: 8,
          top: 0,
          bottom: 0,
          right: 0,
          position: "absolute",
          display: mergedVisible ? null : "none"
        },
        onMouseDown: this.onContainerMouseDown,
        onMouseMove: this.delayHidden
      }, /* @__PURE__ */ React.createElement("div", {
        ref: this.thumbRef,
        className: classNames("".concat(prefixCls, "-scrollbar-thumb"), _defineProperty$1({}, "".concat(prefixCls, "-scrollbar-thumb-moving"), dragging)),
        style: {
          width: "100%",
          height: spinHeight,
          top,
          left: 0,
          position: "absolute",
          background: "rgba(0, 0, 0, 0.5)",
          borderRadius: 99,
          cursor: "pointer",
          userSelect: "none"
        },
        onMouseDown: this.onMouseDown
      }));
    }
  }]);
  return ScrollBar2;
}(React.Component);
function Item$7(_ref2) {
  var children = _ref2.children, setRef = _ref2.setRef;
  var refFunc = React.useCallback(function(node2) {
    setRef(node2);
  }, []);
  return /* @__PURE__ */ React.cloneElement(children, {
    ref: refFunc
  });
}
function useChildren(list2, startIndex, endIndex, setNodeRef, renderFunc, _ref2) {
  var getKey3 = _ref2.getKey;
  return list2.slice(startIndex, endIndex + 1).map(function(item, index2) {
    var eleIndex = startIndex + index2;
    var node2 = renderFunc(item, eleIndex, {});
    var key = getKey3(item);
    return /* @__PURE__ */ React.createElement(Item$7, {
      key,
      setRef: function setRef(ele) {
        return setNodeRef(item, ele);
      }
    }, node2);
  });
}
function findDOMNode$1(node2) {
  if (node2 instanceof HTMLElement) {
    return node2;
  }
  return ReactDOM.findDOMNode(node2);
}
var CacheMap = /* @__PURE__ */ function() {
  function CacheMap2() {
    _classCallCheck(this, CacheMap2);
    this.maps = void 0;
    this.maps = /* @__PURE__ */ Object.create(null);
  }
  _createClass(CacheMap2, [{
    key: "set",
    value: function set2(key, value) {
      this.maps[key] = value;
    }
  }, {
    key: "get",
    value: function get2(key) {
      return this.maps[key];
    }
  }]);
  return CacheMap2;
}();
function useHeights(getKey3, onItemAdd, onItemRemove) {
  var _React$useState = React.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1];
  var instanceRef = React.useRef(/* @__PURE__ */ new Map());
  var heightsRef = React.useRef(new CacheMap());
  var collectRafRef = React.useRef();
  function cancelRaf() {
    wrapperRaf$5.cancel(collectRafRef.current);
  }
  function collectHeight() {
    cancelRaf();
    collectRafRef.current = wrapperRaf$5(function() {
      instanceRef.current.forEach(function(element2, key) {
        if (element2 && element2.offsetParent) {
          var htmlElement = findDOMNode$1(element2);
          var offsetHeight = htmlElement.offsetHeight;
          if (heightsRef.current.get(key) !== offsetHeight) {
            heightsRef.current.set(key, htmlElement.offsetHeight);
          }
        }
      });
      setUpdatedMark(function(c2) {
        return c2 + 1;
      });
    });
  }
  function setInstanceRef(item, instance2) {
    var key = getKey3(item);
    var origin = instanceRef.current.get(key);
    if (instance2) {
      instanceRef.current.set(key, instance2);
      collectHeight();
    } else {
      instanceRef.current.delete(key);
    }
    if (!origin !== !instance2) {
      if (instance2) {
        onItemAdd === null || onItemAdd === void 0 ? void 0 : onItemAdd(item);
      } else {
        onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(item);
      }
    }
  }
  React.useEffect(function() {
    return cancelRaf;
  }, []);
  return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}
function useScrollTo(containerRef, data2, heights, itemHeight, getKey3, collectHeight, syncScrollTop, triggerFlash) {
  var scrollRef = React.useRef();
  return function(arg) {
    if (arg === null || arg === void 0) {
      triggerFlash();
      return;
    }
    wrapperRaf$5.cancel(scrollRef.current);
    if (typeof arg === "number") {
      syncScrollTop(arg);
    } else if (arg && _typeof$6(arg) === "object") {
      var index2;
      var align = arg.align;
      if ("index" in arg) {
        index2 = arg.index;
      } else {
        index2 = data2.findIndex(function(item) {
          return getKey3(item) === arg.key;
        });
      }
      var _arg$offset = arg.offset, offset3 = _arg$offset === void 0 ? 0 : _arg$offset;
      var syncScroll = function syncScroll2(times, targetAlign) {
        if (times < 0 || !containerRef.current)
          return;
        var height = containerRef.current.clientHeight;
        var needCollectHeight = false;
        var newTargetAlign = targetAlign;
        if (height) {
          var mergedAlign = targetAlign || align;
          var stackTop = 0;
          var itemTop = 0;
          var itemBottom = 0;
          var maxLen = Math.min(data2.length, index2);
          for (var i = 0; i <= maxLen; i += 1) {
            var key = getKey3(data2[i]);
            itemTop = stackTop;
            var cacheHeight = heights.get(key);
            itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
            stackTop = itemBottom;
            if (i === index2 && cacheHeight === void 0) {
              needCollectHeight = true;
            }
          }
          var targetTop = null;
          switch (mergedAlign) {
            case "top":
              targetTop = itemTop - offset3;
              break;
            case "bottom":
              targetTop = itemBottom - height + offset3;
              break;
            default: {
              var scrollTop = containerRef.current.scrollTop;
              var scrollBottom = scrollTop + height;
              if (itemTop < scrollTop) {
                newTargetAlign = "top";
              } else if (itemBottom > scrollBottom) {
                newTargetAlign = "bottom";
              }
            }
          }
          if (targetTop !== null && targetTop !== containerRef.current.scrollTop) {
            syncScrollTop(targetTop);
          }
        }
        scrollRef.current = wrapperRaf$5(function() {
          if (needCollectHeight) {
            collectHeight();
          }
          syncScroll2(times - 1, newTargetAlign);
        }, 2);
      };
      syncScroll(3);
    }
  };
}
function findListDiffIndex(originList, targetList, getKey3) {
  var originLen = originList.length;
  var targetLen = targetList.length;
  var shortList;
  var longList;
  if (originLen === 0 && targetLen === 0) {
    return null;
  }
  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }
  var notExistKey = {
    __EMPTY_ITEM__: true
  };
  function getItemKey(item) {
    if (item !== void 0) {
      return getKey3(item);
    }
    return notExistKey;
  }
  var diffIndex = null;
  var multiple = Math.abs(originLen - targetLen) !== 1;
  for (var i = 0; i < longList.length; i += 1) {
    var shortKey = getItemKey(shortList[i]);
    var longKey = getItemKey(longList[i]);
    if (shortKey !== longKey) {
      diffIndex = i;
      multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
      break;
    }
  }
  return diffIndex === null ? null : {
    index: diffIndex,
    multiple
  };
}
function useDiffItem(data2, getKey3, onDiff) {
  var _React$useState = React.useState(data2), _React$useState2 = _slicedToArray(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1];
  var _React$useState3 = React.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
  React.useEffect(function() {
    var diff = findListDiffIndex(prevData || [], data2 || [], getKey3);
    if ((diff === null || diff === void 0 ? void 0 : diff.index) !== void 0) {
      onDiff === null || onDiff === void 0 ? void 0 : onDiff(diff.index);
      setDiffItem(data2[diff.index]);
    }
    setPrevData(data2);
  }, [data2]);
  return [diffItem];
}
var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof$6(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
var useOriginScroll = function(isScrollAtTop, isScrollAtBottom) {
  var lockRef = React.useRef(false);
  var lockTimeoutRef = React.useRef(null);
  function lockScroll() {
    clearTimeout(lockTimeoutRef.current);
    lockRef.current = true;
    lockTimeoutRef.current = setTimeout(function() {
      lockRef.current = false;
    }, 50);
  }
  var scrollPingRef = React.useRef({
    top: isScrollAtTop,
    bottom: isScrollAtBottom
  });
  scrollPingRef.current.top = isScrollAtTop;
  scrollPingRef.current.bottom = isScrollAtBottom;
  return function(deltaY) {
    var smoothOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var originScroll = deltaY < 0 && scrollPingRef.current.top || deltaY > 0 && scrollPingRef.current.bottom;
    if (smoothOffset && originScroll) {
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = false;
    } else if (!originScroll || lockRef.current) {
      lockScroll();
    }
    return !lockRef.current && originScroll;
  };
};
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, onWheelDelta) {
  var offsetRef = React.useRef(0);
  var nextFrameRef = React.useRef(null);
  var wheelValueRef = React.useRef(null);
  var isMouseScrollRef = React.useRef(false);
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  function onWheel(event) {
    if (!inVirtual)
      return;
    wrapperRaf$5.cancel(nextFrameRef.current);
    var deltaY = event.deltaY;
    offsetRef.current += deltaY;
    wheelValueRef.current = deltaY;
    if (originScroll(deltaY))
      return;
    if (!isFF) {
      event.preventDefault();
    }
    nextFrameRef.current = wrapperRaf$5(function() {
      var patchMultiple = isMouseScrollRef.current ? 10 : 1;
      onWheelDelta(offsetRef.current * patchMultiple);
      offsetRef.current = 0;
    });
  }
  function onFireFoxScroll(event) {
    if (!inVirtual)
      return;
    isMouseScrollRef.current = event.detail === wheelValueRef.current;
  }
  return [onWheel, onFireFoxScroll];
}
function canUseDom$8() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var useLayoutEffect$5 = canUseDom$8() ? React.useLayoutEffect : React.useEffect;
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  var touchedRef = React.useRef(false);
  var touchYRef = React.useRef(0);
  var elementRef = React.useRef(null);
  var intervalRef = React.useRef(null);
  var cleanUpEvents;
  var onTouchMove = function onTouchMove2(e2) {
    if (touchedRef.current) {
      var currentY = Math.ceil(e2.touches[0].pageY);
      var offsetY = touchYRef.current - currentY;
      touchYRef.current = currentY;
      if (callback(offsetY)) {
        e2.preventDefault();
      }
      clearInterval(intervalRef.current);
      intervalRef.current = setInterval(function() {
        offsetY *= SMOOTH_PTG;
        if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
          clearInterval(intervalRef.current);
        }
      }, 16);
    }
  };
  var onTouchEnd = function onTouchEnd2() {
    touchedRef.current = false;
    cleanUpEvents();
  };
  var onTouchStart = function onTouchStart2(e2) {
    cleanUpEvents();
    if (e2.touches.length === 1 && !touchedRef.current) {
      touchedRef.current = true;
      touchYRef.current = Math.ceil(e2.touches[0].pageY);
      elementRef.current = e2.target;
      elementRef.current.addEventListener("touchmove", onTouchMove);
      elementRef.current.addEventListener("touchend", onTouchEnd);
    }
  };
  cleanUpEvents = function cleanUpEvents2() {
    if (elementRef.current) {
      elementRef.current.removeEventListener("touchmove", onTouchMove);
      elementRef.current.removeEventListener("touchend", onTouchEnd);
    }
  };
  useLayoutEffect$5(function() {
    if (inVirtual) {
      listRef.current.addEventListener("touchstart", onTouchStart);
    }
    return function() {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.removeEventListener("touchstart", onTouchStart);
      cleanUpEvents();
      clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}
var _excluded$C = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "component", "onScroll", "onVisibleChange", "innerProps"];
var EMPTY_DATA = [];
var ScrollStyle = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function RawList(props, ref2) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-virtual-list" : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight, style2 = props.style, data2 = props.data, children = props.children, itemKey2 = props.itemKey, virtual = props.virtual, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, onScroll = props.onScroll, onVisibleChange = props.onVisibleChange, innerProps = props.innerProps, restProps = _objectWithoutProperties(props, _excluded$C);
  var useVirtual = !!(virtual !== false && height && itemHeight);
  var inVirtual = useVirtual && data2 && itemHeight * data2.length > height;
  var _useState = React.useState(0), _useState2 = _slicedToArray(_useState, 2), scrollTop = _useState2[0], setScrollTop = _useState2[1];
  var _useState3 = React.useState(false), _useState4 = _slicedToArray(_useState3, 2), scrollMoving = _useState4[0], setScrollMoving = _useState4[1];
  var mergedClassName = classNames(prefixCls, className);
  var mergedData = data2 || EMPTY_DATA;
  var componentRef = React.useRef();
  var fillerInnerRef = React.useRef();
  var scrollBarRef = React.useRef();
  var getKey3 = React.useCallback(function(item) {
    if (typeof itemKey2 === "function") {
      return itemKey2(item);
    }
    return item === null || item === void 0 ? void 0 : item[itemKey2];
  }, [itemKey2]);
  var sharedConfig = {
    getKey: getKey3
  };
  function syncScrollTop(newTop) {
    setScrollTop(function(origin) {
      var value;
      if (typeof newTop === "function") {
        value = newTop(origin);
      } else {
        value = newTop;
      }
      var alignedTop = keepInRange(value);
      componentRef.current.scrollTop = alignedTop;
      return alignedTop;
    });
  }
  var rangeRef = React.useRef({
    start: 0,
    end: mergedData.length
  });
  var diffItemRef = React.useRef();
  var _useDiffItem = useDiffItem(mergedData, getKey3), _useDiffItem2 = _slicedToArray(_useDiffItem, 1), diffItem = _useDiffItem2[0];
  diffItemRef.current = diffItem;
  var _useHeights = useHeights(getKey3, null, null), _useHeights2 = _slicedToArray(_useHeights, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3];
  var _React$useMemo = React.useMemo(function() {
    if (!useVirtual) {
      return {
        scrollHeight: void 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    if (!inVirtual) {
      var _fillerInnerRef$curre;
      return {
        scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    var itemTop = 0;
    var startIndex;
    var startOffset;
    var endIndex;
    var dataLen = mergedData.length;
    for (var i = 0; i < dataLen; i += 1) {
      var item = mergedData[i];
      var key = getKey3(item);
      var cacheHeight = heights.get(key);
      var currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
      if (currentItemBottom >= scrollTop && startIndex === void 0) {
        startIndex = i;
        startOffset = itemTop;
      }
      if (currentItemBottom > scrollTop + height && endIndex === void 0) {
        endIndex = i;
      }
      itemTop = currentItemBottom;
    }
    if (startIndex === void 0) {
      startIndex = 0;
      startOffset = 0;
      endIndex = Math.ceil(height / itemHeight);
    }
    if (endIndex === void 0) {
      endIndex = mergedData.length - 1;
    }
    endIndex = Math.min(endIndex + 1, mergedData.length);
    return {
      scrollHeight: itemTop,
      start: startIndex,
      end: endIndex,
      offset: startOffset
    };
  }, [inVirtual, useVirtual, scrollTop, mergedData, heightUpdatedMark, height]), scrollHeight = _React$useMemo.scrollHeight, start = _React$useMemo.start, end = _React$useMemo.end, offset3 = _React$useMemo.offset;
  rangeRef.current.start = start;
  rangeRef.current.end = end;
  var maxScrollHeight = scrollHeight - height;
  var maxScrollHeightRef = React.useRef(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;
  function keepInRange(newScrollTop) {
    var newTop = newScrollTop;
    if (!Number.isNaN(maxScrollHeightRef.current)) {
      newTop = Math.min(newTop, maxScrollHeightRef.current);
    }
    newTop = Math.max(newTop, 0);
    return newTop;
  }
  var isScrollAtTop = scrollTop <= 0;
  var isScrollAtBottom = scrollTop >= maxScrollHeight;
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  function onScrollBar(newScrollTop) {
    var newTop = newScrollTop;
    syncScrollTop(newTop);
  }
  function onFallbackScroll(e2) {
    var newScrollTop = e2.currentTarget.scrollTop;
    if (newScrollTop !== scrollTop) {
      syncScrollTop(newScrollTop);
    }
    onScroll === null || onScroll === void 0 ? void 0 : onScroll(e2);
  }
  var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, function(offsetY) {
    syncScrollTop(function(top) {
      var newTop = top + offsetY;
      return newTop;
    });
  }), _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
  useMobileTouchMove(useVirtual, componentRef, function(deltaY, smoothOffset) {
    if (originScroll(deltaY, smoothOffset)) {
      return false;
    }
    onRawWheel({
      preventDefault: function preventDefault() {
      },
      deltaY
    });
    return true;
  });
  useLayoutEffect$5(function() {
    function onMozMousePixelScroll(e2) {
      if (useVirtual) {
        e2.preventDefault();
      }
    }
    componentRef.current.addEventListener("wheel", onRawWheel);
    componentRef.current.addEventListener("DOMMouseScroll", onFireFoxScroll);
    componentRef.current.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
    return function() {
      if (componentRef.current) {
        componentRef.current.removeEventListener("wheel", onRawWheel);
        componentRef.current.removeEventListener("DOMMouseScroll", onFireFoxScroll);
        componentRef.current.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
      }
    };
  }, [useVirtual]);
  var scrollTo = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey3, collectHeight, syncScrollTop, function() {
    var _scrollBarRef$current;
    (_scrollBarRef$current = scrollBarRef.current) === null || _scrollBarRef$current === void 0 ? void 0 : _scrollBarRef$current.delayHidden();
  });
  React.useImperativeHandle(ref2, function() {
    return {
      scrollTo
    };
  });
  useLayoutEffect$5(function() {
    if (onVisibleChange) {
      var renderList = mergedData.slice(start, end + 1);
      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]);
  var listChildren = useChildren(mergedData, start, end, setInstanceRef, children, sharedConfig);
  var componentStyle = null;
  if (height) {
    componentStyle = _objectSpread2$b(_defineProperty$1({}, fullHeight ? "height" : "maxHeight", height), ScrollStyle);
    if (useVirtual) {
      componentStyle.overflowY = "hidden";
      if (scrollMoving) {
        componentStyle.pointerEvents = "none";
      }
    }
  }
  return /* @__PURE__ */ React.createElement("div", _extends({
    style: _objectSpread2$b(_objectSpread2$b({}, style2), {}, {
      position: "relative"
    }),
    className: mergedClassName
  }, restProps), /* @__PURE__ */ React.createElement(Component, {
    className: "".concat(prefixCls, "-holder"),
    style: componentStyle,
    ref: componentRef,
    onScroll: onFallbackScroll
  }, /* @__PURE__ */ React.createElement(Filler, {
    prefixCls,
    height: scrollHeight,
    offset: offset3,
    onInnerResize: collectHeight,
    ref: fillerInnerRef,
    innerProps
  }, listChildren)), useVirtual && /* @__PURE__ */ React.createElement(ScrollBar, {
    ref: scrollBarRef,
    prefixCls,
    scrollTop,
    height,
    scrollHeight,
    count: mergedData.length,
    onScroll: onScrollBar,
    onStartMove: function onStartMove() {
      setScrollMoving(true);
    },
    onStopMove: function onStopMove() {
      setScrollMoving(false);
    }
  }));
}
var List$1 = /* @__PURE__ */ React.forwardRef(RawList);
List$1.displayName = "List";
var SelectContext = /* @__PURE__ */ React.createContext(null);
function isPlatformMac() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
var _excluded$B = ["disabled", "title", "children", "style", "className"];
function isTitleType(content2) {
  return typeof content2 === "string" || typeof content2 === "number";
}
var OptionList = function OptionList2(_24, ref2) {
  var _useBaseProps = useBaseProps(), prefixCls = _useBaseProps.prefixCls, id = _useBaseProps.id, open = _useBaseProps.open, multiple = _useBaseProps.multiple, mode = _useBaseProps.mode, searchValue = _useBaseProps.searchValue, toggleOpen = _useBaseProps.toggleOpen, notFoundContent = _useBaseProps.notFoundContent, onPopupScroll = _useBaseProps.onPopupScroll;
  var _React$useContext = React.useContext(SelectContext), flattenOptions2 = _React$useContext.flattenOptions, onActiveValue = _React$useContext.onActiveValue, defaultActiveFirstOption = _React$useContext.defaultActiveFirstOption, onSelect = _React$useContext.onSelect, menuItemSelectedIcon = _React$useContext.menuItemSelectedIcon, rawValues = _React$useContext.rawValues, fieldNames = _React$useContext.fieldNames, virtual = _React$useContext.virtual, listHeight = _React$useContext.listHeight, listItemHeight = _React$useContext.listItemHeight;
  var itemPrefixCls = "".concat(prefixCls, "-item");
  var memoFlattenOptions = useMemo$4(function() {
    return flattenOptions2;
  }, [open, flattenOptions2], function(prev2, next2) {
    return next2[0] && prev2[1] !== next2[1];
  });
  var listRef = React.useRef(null);
  var onListMouseDown = function onListMouseDown2(event) {
    event.preventDefault();
  };
  var scrollIntoView = function scrollIntoView2(args) {
    if (listRef.current) {
      listRef.current.scrollTo(typeof args === "number" ? {
        index: args
      } : args);
    }
  };
  var getEnabledActiveIndex = function getEnabledActiveIndex2(index2) {
    var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var len = memoFlattenOptions.length;
    for (var i = 0; i < len; i += 1) {
      var current = (index2 + i * offset3 + len) % len;
      var _memoFlattenOptions$c = memoFlattenOptions[current], group2 = _memoFlattenOptions$c.group, data2 = _memoFlattenOptions$c.data;
      if (!group2 && !data2.disabled) {
        return current;
      }
    }
    return -1;
  };
  var _React$useState = React.useState(function() {
    return getEnabledActiveIndex(0);
  }), _React$useState2 = _slicedToArray$1(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
  var setActive = function setActive2(index2) {
    var fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    setActiveIndex(index2);
    var info = {
      source: fromKeyboard ? "keyboard" : "mouse"
    };
    var flattenItem = memoFlattenOptions[index2];
    if (!flattenItem) {
      onActiveValue(null, -1, info);
      return;
    }
    onActiveValue(flattenItem.value, index2, info);
  };
  React.useEffect(function() {
    setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
  }, [memoFlattenOptions.length, searchValue]);
  var isSelected = React.useCallback(function(value) {
    return rawValues.has(value) && mode !== "combobox";
  }, [mode, _toConsumableArray(rawValues).toString(), rawValues.size]);
  React.useEffect(function() {
    var timeoutId = setTimeout(function() {
      if (!multiple && open && rawValues.size === 1) {
        var value = Array.from(rawValues)[0];
        var index2 = memoFlattenOptions.findIndex(function(_ref2) {
          var data2 = _ref2.data;
          return data2.value === value;
        });
        if (index2 !== -1) {
          setActive(index2);
          scrollIntoView(index2);
        }
      }
    });
    if (open) {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(void 0);
    }
    return function() {
      return clearTimeout(timeoutId);
    };
  }, [open, searchValue, flattenOptions2.length]);
  var onSelectValue = function onSelectValue2(value) {
    if (value !== void 0) {
      onSelect(value, {
        selected: !rawValues.has(value)
      });
    }
    if (!multiple) {
      toggleOpen(false);
    }
  };
  React.useImperativeHandle(ref2, function() {
    return {
      onKeyDown: function onKeyDown(event) {
        var which = event.which, ctrlKey = event.ctrlKey;
        switch (which) {
          case KeyCode$3.N:
          case KeyCode$3.P:
          case KeyCode$3.UP:
          case KeyCode$3.DOWN: {
            var offset3 = 0;
            if (which === KeyCode$3.UP) {
              offset3 = -1;
            } else if (which === KeyCode$3.DOWN) {
              offset3 = 1;
            } else if (isPlatformMac() && ctrlKey) {
              if (which === KeyCode$3.N) {
                offset3 = 1;
              } else if (which === KeyCode$3.P) {
                offset3 = -1;
              }
            }
            if (offset3 !== 0) {
              var nextActiveIndex = getEnabledActiveIndex(activeIndex + offset3, offset3);
              scrollIntoView(nextActiveIndex);
              setActive(nextActiveIndex, true);
            }
            break;
          }
          case KeyCode$3.ENTER: {
            var item = memoFlattenOptions[activeIndex];
            if (item && !item.data.disabled) {
              onSelectValue(item.value);
            } else {
              onSelectValue(void 0);
            }
            if (open) {
              event.preventDefault();
            }
            break;
          }
          case KeyCode$3.ESC: {
            toggleOpen(false);
            if (open) {
              event.stopPropagation();
            }
          }
        }
      },
      onKeyUp: function onKeyUp() {
      },
      scrollTo: function scrollTo(index2) {
        scrollIntoView(index2);
      }
    };
  });
  if (memoFlattenOptions.length === 0) {
    return /* @__PURE__ */ React.createElement("div", {
      role: "listbox",
      id: "".concat(id, "_list"),
      className: "".concat(itemPrefixCls, "-empty"),
      onMouseDown: onListMouseDown
    }, notFoundContent);
  }
  var omitFieldNameList = Object.keys(fieldNames).map(function(key) {
    return fieldNames[key];
  });
  var getLabel = function getLabel2(item) {
    return item.label;
  };
  function getItemAriaProps(item, index2) {
    var group2 = item.group;
    return {
      role: group2 ? "presentation" : "option",
      id: "".concat(id, "_list_").concat(index2)
    };
  }
  var renderItem = function renderItem2(index2) {
    var item = memoFlattenOptions[index2];
    if (!item)
      return null;
    var itemData = item.data || {};
    var value = itemData.value;
    var group2 = item.group;
    var attrs = pickAttrs$2(itemData, true);
    var mergedLabel = getLabel(item);
    return item ? /* @__PURE__ */ React.createElement("div", _extends$3({
      "aria-label": typeof mergedLabel === "string" && !group2 ? mergedLabel : null
    }, attrs, {
      key: index2
    }, getItemAriaProps(item, index2), {
      "aria-selected": isSelected(value)
    }), value) : null;
  };
  var a11yProps = {
    role: "listbox",
    id: "".concat(id, "_list")
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, virtual && /* @__PURE__ */ React.createElement("div", _extends$3({}, a11yProps, {
    style: {
      height: 0,
      width: 0,
      overflow: "hidden"
    }
  }), renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)), /* @__PURE__ */ React.createElement(List$1, {
    itemKey: "key",
    ref: listRef,
    data: memoFlattenOptions,
    height: listHeight,
    itemHeight: listItemHeight,
    fullHeight: false,
    onMouseDown: onListMouseDown,
    onScroll: onPopupScroll,
    virtual,
    innerProps: virtual ? null : a11yProps
  }, function(item, itemIndex) {
    var _classNames;
    var group2 = item.group, groupOption = item.groupOption, data2 = item.data, label = item.label, value = item.value;
    var key = data2.key;
    if (group2) {
      var _data$title;
      var groupTitle = (_data$title = data2.title) !== null && _data$title !== void 0 ? _data$title : isTitleType(label) ? label.toString() : void 0;
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames(itemPrefixCls, "".concat(itemPrefixCls, "-group")),
        title: groupTitle
      }, label !== void 0 ? label : key);
    }
    var disabled = data2.disabled, title = data2.title;
    data2.children;
    var style2 = data2.style, className = data2.className, otherProps = _objectWithoutProperties$1(data2, _excluded$B);
    var passedProps = omit$4(otherProps, omitFieldNameList);
    var selected = isSelected(value);
    var optionPrefixCls = "".concat(itemPrefixCls, "-option");
    var optionClassName = classNames(itemPrefixCls, optionPrefixCls, className, (_classNames = {}, _defineProperty$3(_classNames, "".concat(optionPrefixCls, "-grouped"), groupOption), _defineProperty$3(_classNames, "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !disabled), _defineProperty$3(_classNames, "".concat(optionPrefixCls, "-disabled"), disabled), _defineProperty$3(_classNames, "".concat(optionPrefixCls, "-selected"), selected), _classNames));
    var mergedLabel = getLabel(item);
    var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
    var content2 = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
    var optionTitle = isTitleType(content2) ? content2.toString() : void 0;
    if (title !== void 0) {
      optionTitle = title;
    }
    return /* @__PURE__ */ React.createElement("div", _extends$3({}, pickAttrs$2(passedProps), !virtual ? getItemAriaProps(item, itemIndex) : {}, {
      "aria-selected": selected,
      className: optionClassName,
      title: optionTitle,
      onMouseMove: function onMouseMove() {
        if (activeIndex === itemIndex || disabled) {
          return;
        }
        setActive(itemIndex);
      },
      onClick: function onClick() {
        if (!disabled) {
          onSelectValue(value);
        }
      },
      style: style2
    }), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(optionPrefixCls, "-content")
    }, content2), /* @__PURE__ */ React.isValidElement(menuItemSelectedIcon) || selected, iconVisible && /* @__PURE__ */ React.createElement(TransBtn, {
      className: "".concat(itemPrefixCls, "-option-state"),
      customizeIcon: menuItemSelectedIcon,
      customizeIconProps: {
        isSelected: selected
      }
    }, selected ? "\u2713" : null));
  }));
};
var RefOptionList = /* @__PURE__ */ React.forwardRef(OptionList);
RefOptionList.displayName = "OptionList";
var _excluded$A = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "listHeight", "listItemHeight", "value", "defaultValue", "labelInValue", "onChange"];
var OMIT_DOM_PROPS = ["inputValue"];
function isRawValue(value) {
  return !value || _typeof$8(value) !== "object";
}
var Select$2 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var id = props.id, mode = props.mode, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-select" : _props$prefixCls, backfill = props.backfill, fieldNames = props.fieldNames, inputValue = props.inputValue, searchValue = props.searchValue, onSearch = props.onSearch, _props$autoClearSearc = props.autoClearSearchValue, autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc, onSelect = props.onSelect, onDeselect = props.onDeselect, _props$dropdownMatchS = props.dropdownMatchSelectWidth, dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? true : _props$dropdownMatchS, filterOption = props.filterOption, filterSort = props.filterSort, optionFilterProp = props.optionFilterProp, optionLabelProp = props.optionLabelProp, options = props.options, children = props.children, defaultActiveFirstOption = props.defaultActiveFirstOption, menuItemSelectedIcon = props.menuItemSelectedIcon, virtual = props.virtual, _props$listHeight = props.listHeight, listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight, _props$listItemHeight = props.listItemHeight, listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight, value = props.value, defaultValue = props.defaultValue, labelInValue = props.labelInValue, onChange = props.onChange, restProps = _objectWithoutProperties$1(props, _excluded$A);
  var mergedId = useId$1(id);
  var multiple = isMultiple(mode);
  var childrenAsData = !!(!options && children);
  var mergedFilterOption = React.useMemo(function() {
    if (filterOption === void 0 && mode === "combobox") {
      return false;
    }
    return filterOption;
  }, [filterOption, mode]);
  var mergedFieldNames = React.useMemo(
    function() {
      return fillFieldNames(fieldNames, childrenAsData);
    },
    [
      JSON.stringify(fieldNames),
      childrenAsData
    ]
  );
  var _useMergedState = useMergedState$3("", {
    value: searchValue !== void 0 ? searchValue : inputValue,
    postState: function postState(search2) {
      return search2 || "";
    }
  }), _useMergedState2 = _slicedToArray$1(_useMergedState, 2), mergedSearchValue = _useMergedState2[0], setSearchValue = _useMergedState2[1];
  var parsedOptions = useOptions(options, children, mergedFieldNames, optionFilterProp, optionLabelProp);
  var valueOptions = parsedOptions.valueOptions, labelOptions = parsedOptions.labelOptions, mergedOptions = parsedOptions.options;
  var convert2LabelValues = React.useCallback(function(draftValues) {
    var valueList = toArray$8(draftValues);
    return valueList.map(function(val) {
      var rawValue;
      var rawLabel;
      var rawKey;
      var rawDisabled;
      var rawTitle;
      if (isRawValue(val)) {
        rawValue = val;
      } else {
        var _val$value;
        rawKey = val.key;
        rawLabel = val.label;
        rawValue = (_val$value = val.value) !== null && _val$value !== void 0 ? _val$value : rawKey;
      }
      var option = valueOptions.get(rawValue);
      if (option) {
        var _option$key;
        if (rawLabel === void 0)
          rawLabel = option === null || option === void 0 ? void 0 : option[optionLabelProp || mergedFieldNames.label];
        if (rawKey === void 0)
          rawKey = (_option$key = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key !== void 0 ? _option$key : rawValue;
        rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
        rawTitle = option === null || option === void 0 ? void 0 : option.title;
      }
      return {
        label: rawLabel,
        value: rawValue,
        key: rawKey,
        disabled: rawDisabled,
        title: rawTitle
      };
    });
  }, [mergedFieldNames, optionLabelProp, valueOptions]);
  var _useMergedState3 = useMergedState$3(defaultValue, {
    value
  }), _useMergedState4 = _slicedToArray$1(_useMergedState3, 2), internalValue = _useMergedState4[0], setInternalValue = _useMergedState4[1];
  var rawLabeledValues = React.useMemo(function() {
    var _values$;
    var values = convert2LabelValues(internalValue);
    if (mode === "combobox" && !((_values$ = values[0]) !== null && _values$ !== void 0 && _values$.value)) {
      return [];
    }
    return values;
  }, [internalValue, convert2LabelValues, mode]);
  var _useCache = useCache(rawLabeledValues, valueOptions), _useCache2 = _slicedToArray$1(_useCache, 2), mergedValues = _useCache2[0], getMixedOption = _useCache2[1];
  var displayValues = React.useMemo(function() {
    if (!mode && mergedValues.length === 1) {
      var firstValue = mergedValues[0];
      if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
        return [];
      }
    }
    return mergedValues.map(function(item) {
      var _item$label;
      return _objectSpread2$d(_objectSpread2$d({}, item), {}, {
        label: (_item$label = item.label) !== null && _item$label !== void 0 ? _item$label : item.value
      });
    });
  }, [mode, mergedValues]);
  var rawValues = React.useMemo(function() {
    return new Set(mergedValues.map(function(val) {
      return val.value;
    }));
  }, [mergedValues]);
  React.useEffect(function() {
    if (mode === "combobox") {
      var _mergedValues$;
      var strValue = (_mergedValues$ = mergedValues[0]) === null || _mergedValues$ === void 0 ? void 0 : _mergedValues$.value;
      setSearchValue(hasValue$3(strValue) ? String(strValue) : "");
    }
  }, [mergedValues]);
  var createTagOption = useRefFunc(function(val, label) {
    var _ref2;
    var mergedLabel = label !== null && label !== void 0 ? label : val;
    return _ref2 = {}, _defineProperty$3(_ref2, mergedFieldNames.value, val), _defineProperty$3(_ref2, mergedFieldNames.label, mergedLabel), _ref2;
  });
  var filledTagOptions = React.useMemo(function() {
    if (mode !== "tags") {
      return mergedOptions;
    }
    var cloneOptions = _toConsumableArray(mergedOptions);
    var existOptions = function existOptions2(val) {
      return valueOptions.has(val);
    };
    _toConsumableArray(mergedValues).sort(function(a, b2) {
      return a.value < b2.value ? -1 : 1;
    }).forEach(function(item) {
      var val = item.value;
      if (!existOptions(val)) {
        cloneOptions.push(createTagOption(val, item.label));
      }
    });
    return cloneOptions;
  }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
  var filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, optionFilterProp);
  var filledSearchOptions = React.useMemo(function() {
    if (mode !== "tags" || !mergedSearchValue || filteredOptions.some(function(item) {
      return item[optionFilterProp || "value"] === mergedSearchValue;
    })) {
      return filteredOptions;
    }
    return [createTagOption(mergedSearchValue)].concat(_toConsumableArray(filteredOptions));
  }, [createTagOption, optionFilterProp, mode, filteredOptions, mergedSearchValue]);
  var orderedFilteredOptions = React.useMemo(function() {
    if (!filterSort) {
      return filledSearchOptions;
    }
    return _toConsumableArray(filledSearchOptions).sort(function(a, b2) {
      return filterSort(a, b2);
    });
  }, [filledSearchOptions, filterSort]);
  var displayOptions = React.useMemo(function() {
    return flattenOptions(orderedFilteredOptions, {
      fieldNames: mergedFieldNames,
      childrenAsData
    });
  }, [orderedFilteredOptions, mergedFieldNames, childrenAsData]);
  var triggerChange = function triggerChange2(values) {
    var labeledValues = convert2LabelValues(values);
    setInternalValue(labeledValues);
    if (onChange && (labeledValues.length !== mergedValues.length || labeledValues.some(function(newVal, index2) {
      var _mergedValues$index;
      return ((_mergedValues$index = mergedValues[index2]) === null || _mergedValues$index === void 0 ? void 0 : _mergedValues$index.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
    }))) {
      var returnValues = labelInValue ? labeledValues : labeledValues.map(function(v2) {
        return v2.value;
      });
      var returnOptions = labeledValues.map(function(v2) {
        return injectPropsWithOption(getMixedOption(v2.value));
      });
      onChange(
        multiple ? returnValues : returnValues[0],
        multiple ? returnOptions : returnOptions[0]
      );
    }
  };
  var _React$useState = React.useState(null), _React$useState2 = _slicedToArray$1(_React$useState, 2), activeValue = _React$useState2[0], setActiveValue = _React$useState2[1];
  var _React$useState3 = React.useState(0), _React$useState4 = _slicedToArray$1(_React$useState3, 2), accessibilityIndex = _React$useState4[0], setAccessibilityIndex = _React$useState4[1];
  var mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
  var onActiveValue = React.useCallback(function(active, index2) {
    var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$source = _ref2.source, source = _ref2$source === void 0 ? "keyboard" : _ref2$source;
    setAccessibilityIndex(index2);
    if (backfill && mode === "combobox" && active !== null && source === "keyboard") {
      setActiveValue(String(active));
    }
  }, [backfill, mode]);
  var triggerSelect = function triggerSelect2(val, selected, type4) {
    var getSelectEnt = function getSelectEnt2() {
      var _option$key2;
      var option = getMixedOption(val);
      return [labelInValue ? {
        label: option === null || option === void 0 ? void 0 : option[mergedFieldNames.label],
        value: val,
        key: (_option$key2 = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key2 !== void 0 ? _option$key2 : val
      } : val, injectPropsWithOption(option)];
    };
    if (selected && onSelect) {
      var _getSelectEnt = getSelectEnt(), _getSelectEnt2 = _slicedToArray$1(_getSelectEnt, 2), wrappedValue = _getSelectEnt2[0], _option = _getSelectEnt2[1];
      onSelect(wrappedValue, _option);
    } else if (!selected && onDeselect && type4 !== "clear") {
      var _getSelectEnt3 = getSelectEnt(), _getSelectEnt4 = _slicedToArray$1(_getSelectEnt3, 2), _wrappedValue = _getSelectEnt4[0], _option2 = _getSelectEnt4[1];
      onDeselect(_wrappedValue, _option2);
    }
  };
  var onInternalSelect = useRefFunc(function(val, info) {
    var cloneValues;
    var mergedSelect = multiple ? info.selected : true;
    if (mergedSelect) {
      cloneValues = multiple ? [].concat(_toConsumableArray(mergedValues), [val]) : [val];
    } else {
      cloneValues = mergedValues.filter(function(v2) {
        return v2.value !== val;
      });
    }
    triggerChange(cloneValues);
    triggerSelect(val, mergedSelect);
    if (mode === "combobox") {
      setActiveValue("");
    } else if (!isMultiple || autoClearSearchValue) {
      setSearchValue("");
      setActiveValue("");
    }
  });
  var onDisplayValuesChange = function onDisplayValuesChange2(nextValues, info) {
    triggerChange(nextValues);
    var type4 = info.type, values = info.values;
    if (type4 === "remove" || type4 === "clear") {
      values.forEach(function(item) {
        triggerSelect(item.value, false, type4);
      });
    }
  };
  var onInternalSearch = function onInternalSearch2(searchText, info) {
    setSearchValue(searchText);
    setActiveValue(null);
    if (info.source === "submit") {
      var formatted = (searchText || "").trim();
      if (formatted) {
        var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), [formatted])));
        triggerChange(newRawValues);
        triggerSelect(formatted, true);
        setSearchValue("");
      }
      return;
    }
    if (info.source !== "blur") {
      if (mode === "combobox") {
        triggerChange(searchText);
      }
      onSearch === null || onSearch === void 0 ? void 0 : onSearch(searchText);
    }
  };
  var onInternalSearchSplit = function onInternalSearchSplit2(words) {
    var patchValues = words;
    if (mode !== "tags") {
      patchValues = words.map(function(word) {
        var opt = labelOptions.get(word);
        return opt === null || opt === void 0 ? void 0 : opt.value;
      }).filter(function(val) {
        return val !== void 0;
      });
    }
    var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), _toConsumableArray(patchValues))));
    triggerChange(newRawValues);
    newRawValues.forEach(function(newRawValue) {
      triggerSelect(newRawValue, true);
    });
  };
  var selectContext = React.useMemo(function() {
    var realVirtual = virtual !== false && dropdownMatchSelectWidth !== false;
    return _objectSpread2$d(_objectSpread2$d({}, parsedOptions), {}, {
      flattenOptions: displayOptions,
      onActiveValue,
      defaultActiveFirstOption: mergedDefaultActiveFirstOption,
      onSelect: onInternalSelect,
      menuItemSelectedIcon,
      rawValues,
      fieldNames: mergedFieldNames,
      virtual: realVirtual,
      listHeight,
      listItemHeight,
      childrenAsData
    });
  }, [parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual, dropdownMatchSelectWidth, listHeight, listItemHeight, childrenAsData]);
  return /* @__PURE__ */ React.createElement(SelectContext.Provider, {
    value: selectContext
  }, /* @__PURE__ */ React.createElement(BaseSelect, _extends$3({}, restProps, {
    id: mergedId,
    prefixCls,
    ref: ref2,
    omitDomProps: OMIT_DOM_PROPS,
    mode,
    displayValues,
    onDisplayValuesChange,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    autoClearSearchValue,
    onSearchSplit: onInternalSearchSplit,
    dropdownMatchSelectWidth,
    OptionList: RefOptionList,
    emptyOptions: !displayOptions.length,
    activeValue,
    activeDescendantId: "".concat(mergedId, "_list_").concat(accessibilityIndex)
  })));
});
var TypedSelect = Select$2;
TypedSelect.Option = Option$1;
TypedSelect.OptGroup = OptGroup;
var useLayoutEffect$4 = canUseDom$d() ? React.useLayoutEffect : React.useEffect;
var useLayoutUpdateEffect$1 = function useLayoutUpdateEffect3(callback, deps) {
  var firstMountRef = React.useRef(true);
  useLayoutEffect$4(function() {
    if (!firstMountRef.current) {
      return callback();
    }
  }, deps);
  useLayoutEffect$4(function() {
    firstMountRef.current = false;
    return function() {
      firstMountRef.current = true;
    };
  }, []);
};
function hasValue$2(value) {
  return value !== void 0;
}
function useMergedState$2(defaultStateValue, option) {
  var _ref2 = option || {}, defaultValue = _ref2.defaultValue, value = _ref2.value, onChange = _ref2.onChange, postState = _ref2.postState;
  var _useState = useSafeState$3(function() {
    if (hasValue$2(value)) {
      return value;
    } else if (hasValue$2(defaultValue)) {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    } else {
      return typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
    }
  }), _useState2 = _slicedToArray$1(_useState, 2), innerValue = _useState2[0], setInnerValue = _useState2[1];
  var mergedValue = value !== void 0 ? value : innerValue;
  var postMergedValue = postState ? postState(mergedValue) : mergedValue;
  var onChangeFn = useEvent$6(onChange);
  var _useState3 = useSafeState$3([mergedValue]), _useState4 = _slicedToArray$1(_useState3, 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
  useLayoutUpdateEffect$1(function() {
    var prev2 = prevValue[0];
    if (innerValue !== prev2) {
      onChangeFn(innerValue, prev2);
    }
  }, [prevValue]);
  useLayoutUpdateEffect$1(function() {
    if (!hasValue$2(value)) {
      setInnerValue(value);
    }
  }, [value]);
  var triggerChange = useEvent$6(function(updater, ignoreDestroy) {
    setInnerValue(updater, ignoreDestroy);
    setPrevValue([mergedValue], ignoreDestroy);
  });
  return [postMergedValue, triggerChange];
}
function genPurePanel(Component, defaultPrefixCls2, getDropdownCls) {
  return function PurePanel2(props) {
    const {
      prefixCls: customizePrefixCls,
      style: style2
    } = props;
    const holderRef = React.useRef(null);
    const [popupHeight, setPopupHeight] = React.useState(0);
    const [popupWidth, setPopupWidth] = React.useState(0);
    const [open, setOpen] = useMergedState$2(false, {
      value: props.open
    });
    const {
      getPrefixCls
    } = React.useContext(ConfigContext$1);
    const prefixCls = getPrefixCls(defaultPrefixCls2 || "select", customizePrefixCls);
    React.useEffect(() => {
      setOpen(true);
      if (typeof ResizeObserver !== "undefined") {
        const resizeObserver2 = new ResizeObserver((entries) => {
          const element2 = entries[0].target;
          setPopupHeight(element2.offsetHeight + 8);
          setPopupWidth(element2.offsetWidth);
        });
        const interval = setInterval(() => {
          var _a2;
          const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`;
          const popup = (_a2 = holderRef.current) === null || _a2 === void 0 ? void 0 : _a2.querySelector(dropdownCls);
          if (popup) {
            clearInterval(interval);
            resizeObserver2.observe(popup);
          }
        }, 10);
        return () => {
          clearInterval(interval);
          resizeObserver2.disconnect();
        };
      }
    }, []);
    return /* @__PURE__ */ React.createElement(ConfigProvider, {
      theme: {
        token: {
          motionDurationFast: "0.01s",
          motionDurationMid: "0.01s",
          motionDurationSlow: "0.01s"
        }
      }
    }, /* @__PURE__ */ React.createElement("div", {
      ref: holderRef,
      style: {
        paddingBottom: popupHeight,
        position: "relative",
        width: "fit-content",
        minWidth: popupWidth
      }
    }, /* @__PURE__ */ React.createElement(Component, Object.assign({}, props, {
      style: Object.assign(Object.assign({}, style2), {
        margin: 0
      }),
      open,
      visible: open,
      getPopupContainer: () => holderRef.current
    }))));
  };
}
function getStatusClassNames$1(prefixCls, status, hasFeedback) {
  return classNames({
    [`${prefixCls}-status-success`]: status === "success",
    [`${prefixCls}-status-warning`]: status === "warning",
    [`${prefixCls}-status-error`]: status === "error",
    [`${prefixCls}-status-validating`]: status === "validating",
    [`${prefixCls}-has-feedback`]: hasFeedback
  });
}
const getMergedStatus$1 = (contextStatus, customStatus) => customStatus || contextStatus;
const Empty$2 = () => {
  const [, token2] = useToken$2();
  const bgColor = new TinyColor(token2.colorBgBase);
  let themeStyle = {};
  if (bgColor.toHsl().l < 0.5) {
    themeStyle = {
      opacity: 0.65
    };
  }
  return /* @__PURE__ */ React.createElement("svg", {
    style: themeStyle,
    width: "184",
    height: "152",
    viewBox: "0 0 184 152",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ React.createElement("g", {
    transform: "translate(24 31.67)"
  }, /* @__PURE__ */ React.createElement("ellipse", {
    fillOpacity: ".8",
    fill: "#F5F5F7",
    cx: "67.797",
    cy: "106.89",
    rx: "67.797",
    ry: "12.668"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
    fill: "#AEB8C2"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    fill: "url(#linearGradient-1)",
    transform: "translate(13.56)"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
    fill: "#F5F5F7"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
    fill: "#DCE0E6"
  })), /* @__PURE__ */ React.createElement("path", {
    d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
    fill: "#DCE0E6"
  }), /* @__PURE__ */ React.createElement("g", {
    transform: "translate(149.65 15.383)",
    fill: "#FFF"
  }, /* @__PURE__ */ React.createElement("ellipse", {
    cx: "20.654",
    cy: "3.167",
    rx: "2.849",
    ry: "2.815"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }))));
};
var DefaultEmptyImg = Empty$2;
const Simple = () => {
  const [, token2] = useToken$2();
  const {
    colorFill,
    colorFillTertiary,
    colorFillQuaternary,
    colorBgContainer
  } = token2;
  const {
    borderColor,
    shadowColor,
    contentColor
  } = React.useMemo(() => ({
    borderColor: new TinyColor(colorFill).onBackground(colorBgContainer).toHexShortString(),
    shadowColor: new TinyColor(colorFillTertiary).onBackground(colorBgContainer).toHexShortString(),
    contentColor: new TinyColor(colorFillQuaternary).onBackground(colorBgContainer).toHexShortString()
  }), [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]);
  return /* @__PURE__ */ React.createElement("svg", {
    width: "64",
    height: "41",
    viewBox: "0 0 64 41",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React.createElement("g", {
    transform: "translate(0 1)",
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ React.createElement("ellipse", {
    fill: shadowColor,
    cx: "32",
    cy: "33",
    rx: "32",
    ry: "7"
  }), /* @__PURE__ */ React.createElement("g", {
    fillRule: "nonzero",
    stroke: borderColor
  }, /* @__PURE__ */ React.createElement("path", {
    d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    fill: contentColor
  }))));
};
var SimpleEmptyImg = Simple;
const genSharedEmptyStyle = (token2) => {
  const {
    componentCls,
    margin,
    marginXS,
    marginXL,
    fontSize,
    lineHeight
  } = token2;
  return {
    [componentCls]: {
      marginInline: marginXS,
      fontSize,
      lineHeight,
      textAlign: "center",
      [`${componentCls}-image`]: {
        height: token2.emptyImgHeight,
        marginBottom: marginXS,
        opacity: token2.opacityImage,
        img: {
          height: "100%"
        },
        svg: {
          height: "100%",
          margin: "auto"
        }
      },
      [`${componentCls}-description`]: {
        color: token2.colorText
      },
      [`${componentCls}-footer`]: {
        marginTop: margin
      },
      "&-normal": {
        marginBlock: marginXL,
        color: token2.colorTextDisabled,
        [`${componentCls}-description`]: {
          color: token2.colorTextDisabled
        },
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeightMD
        }
      },
      "&-small": {
        marginBlock: marginXS,
        color: token2.colorTextDisabled,
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeightSM
        }
      }
    }
  };
};
var useStyle$e = genComponentStyleHook$2("Empty", (token2) => {
  const {
    componentCls,
    controlHeightLG
  } = token2;
  const emptyToken = merge$1(token2, {
    emptyImgCls: `${componentCls}-img`,
    emptyImgHeight: controlHeightLG * 2.5,
    emptyImgHeightMD: controlHeightLG,
    emptyImgHeightSM: controlHeightLG * 0.875
  });
  return [genSharedEmptyStyle(emptyToken)];
});
var __rest$x = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const defaultEmptyImg = /* @__PURE__ */ React.createElement(DefaultEmptyImg, null);
const simpleEmptyImg = /* @__PURE__ */ React.createElement(SimpleEmptyImg, null);
const Empty = (_a2) => {
  var {
    className,
    rootClassName,
    prefixCls: customizePrefixCls,
    image: image2 = defaultEmptyImg,
    description,
    children,
    imageStyle
  } = _a2, restProps = __rest$x(_a2, ["className", "rootClassName", "prefixCls", "image", "description", "children", "imageStyle"]);
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("empty", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$e(prefixCls);
  const [locale2] = useLocale$3("Empty");
  const des = typeof description !== "undefined" ? description : locale2 === null || locale2 === void 0 ? void 0 : locale2.description;
  const alt = typeof des === "string" ? des : "empty";
  let imageNode = null;
  if (typeof image2 === "string") {
    imageNode = /* @__PURE__ */ React.createElement("img", {
      alt,
      src: image2
    });
  } else {
    imageNode = image2;
  }
  return wrapSSR(/* @__PURE__ */ React.createElement("div", Object.assign({
    className: classNames(hashId, prefixCls, {
      [`${prefixCls}-normal`]: image2 === simpleEmptyImg,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName)
  }, restProps), /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-image`,
    style: imageStyle
  }, imageNode), des && /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-description`
  }, des), children && /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-footer`
  }, children)));
};
Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
var Empty$1 = Empty;
const DefaultRenderEmpty = (props) => {
  const {
    componentName
  } = props;
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefix2 = getPrefixCls("empty");
  switch (componentName) {
    case "Table":
    case "List":
      return /* @__PURE__ */ React.createElement(Empty$1, {
        image: Empty$1.PRESENTED_IMAGE_SIMPLE
      });
    case "Select":
    case "TreeSelect":
    case "Cascader":
    case "Transfer":
    case "Mentions":
      return /* @__PURE__ */ React.createElement(Empty$1, {
        image: Empty$1.PRESENTED_IMAGE_SIMPLE,
        className: `${prefix2}-small`
      });
    default:
      return /* @__PURE__ */ React.createElement(Empty$1, null);
  }
};
var DefaultRenderEmpty$1 = DefaultRenderEmpty;
const genItemStyle = (token2) => {
  const {
    controlPaddingHorizontal
  } = token2;
  return {
    position: "relative",
    display: "block",
    minHeight: token2.controlHeight,
    padding: `${(token2.controlHeight - token2.fontSize * token2.lineHeight) / 2}px ${controlPaddingHorizontal}px`,
    color: token2.colorText,
    fontWeight: "normal",
    fontSize: token2.fontSize,
    lineHeight: token2.lineHeight,
    boxSizing: "border-box"
  };
};
const genSingleStyle$1 = (token2) => {
  const {
    antCls,
    componentCls
  } = token2;
  const selectItemCls = `${componentCls}-item`;
  return [
    {
      [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        top: -9999,
        zIndex: token2.zIndexPopup,
        boxSizing: "border-box",
        padding: token2.paddingXXS,
        overflow: "hidden",
        fontSize: token2.fontSize,
        fontVariant: "initial",
        backgroundColor: token2.colorBgElevated,
        borderRadius: token2.borderRadiusLG,
        outline: "none",
        boxShadow: token2.boxShadowSecondary,
        [`
            &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
            &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft
          `]: {
          animationName: slideUpIn
        },
        [`
            &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
            &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft
          `]: {
          animationName: slideDownIn
        },
        [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft`]: {
          animationName: slideUpOut
        },
        [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft`]: {
          animationName: slideDownOut
        },
        "&-hidden": {
          display: "none"
        },
        "&-empty": {
          color: token2.colorTextDisabled
        },
        [`${selectItemCls}-empty`]: Object.assign(Object.assign({}, genItemStyle(token2)), {
          color: token2.colorTextDisabled
        }),
        [`${selectItemCls}`]: Object.assign(Object.assign({}, genItemStyle(token2)), {
          cursor: "pointer",
          transition: `background ${token2.motionDurationSlow} ease`,
          borderRadius: token2.borderRadiusSM,
          "&-group": {
            color: token2.colorTextDescription,
            fontSize: token2.fontSizeSM,
            cursor: "default"
          },
          "&-option": {
            display: "flex",
            "&-content": Object.assign(Object.assign({
              flex: "auto"
            }, textEllipsis), {
              "> *": Object.assign({}, textEllipsis)
            }),
            "&-state": {
              flex: "none"
            },
            [`&-active:not(${selectItemCls}-option-disabled)`]: {
              backgroundColor: token2.controlItemBgHover
            },
            [`&-selected:not(${selectItemCls}-option-disabled)`]: {
              color: token2.colorText,
              fontWeight: token2.fontWeightStrong,
              backgroundColor: token2.controlItemBgActive,
              [`${selectItemCls}-option-state`]: {
                color: token2.colorPrimary
              }
            },
            "&-disabled": {
              [`&${selectItemCls}-option-selected`]: {
                backgroundColor: token2.colorBgContainerDisabled
              },
              color: token2.colorTextDisabled,
              cursor: "not-allowed"
            },
            "&-grouped": {
              paddingInlineStart: token2.controlPaddingHorizontal * 2
            }
          }
        }),
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    initSlideMotion(token2, "slide-up"),
    initSlideMotion(token2, "slide-down"),
    initMoveMotion(token2, "move-up"),
    initMoveMotion(token2, "move-down")
  ];
};
var genDropdownStyle$1 = genSingleStyle$1;
const FIXED_ITEM_MARGIN = 2;
function getSelectItemStyle(_ref2) {
  let {
    controlHeightSM,
    controlHeight,
    lineWidth: borderWidth
  } = _ref2;
  const selectItemDist = (controlHeight - controlHeightSM) / 2 - borderWidth;
  const selectItemMargin = Math.ceil(selectItemDist / 2);
  return [selectItemDist, selectItemMargin];
}
function genSizeStyle$2(token2, suffix) {
  const {
    componentCls,
    iconCls
  } = token2;
  const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
  const selectItemHeight = token2.controlHeightSM;
  const [selectItemDist] = getSelectItemStyle(token2);
  const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
  return {
    [`${componentCls}-multiple${suffixCls}`]: {
      fontSize: token2.fontSize,
      [selectOverflowPrefixCls]: {
        position: "relative",
        display: "flex",
        flex: "auto",
        flexWrap: "wrap",
        maxWidth: "100%",
        "&-item": {
          flex: "none",
          alignSelf: "center",
          maxWidth: "100%",
          display: "inline-flex"
        }
      },
      [`${componentCls}-selector`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        padding: `${selectItemDist - FIXED_ITEM_MARGIN}px ${FIXED_ITEM_MARGIN * 2}px`,
        borderRadius: token2.borderRadius,
        [`${componentCls}-show-search&`]: {
          cursor: "text"
        },
        [`${componentCls}-disabled&`]: {
          background: token2.colorBgContainerDisabled,
          cursor: "not-allowed"
        },
        "&:after": {
          display: "inline-block",
          width: 0,
          margin: `${FIXED_ITEM_MARGIN}px 0`,
          lineHeight: `${selectItemHeight}px`,
          content: '"\\a0"'
        }
      },
      [`
        &${componentCls}-show-arrow ${componentCls}-selector,
        &${componentCls}-allow-clear ${componentCls}-selector
      `]: {
        paddingInlineEnd: token2.fontSizeIcon + token2.controlPaddingHorizontal
      },
      [`${componentCls}-selection-item`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        boxSizing: "border-box",
        maxWidth: "100%",
        height: selectItemHeight,
        marginTop: FIXED_ITEM_MARGIN,
        marginBottom: FIXED_ITEM_MARGIN,
        lineHeight: `${selectItemHeight - token2.lineWidth * 2}px`,
        background: token2.colorFillSecondary,
        border: `${token2.lineWidth}px solid ${token2.colorSplit}`,
        borderRadius: token2.borderRadiusSM,
        cursor: "default",
        transition: `font-size ${token2.motionDurationSlow}, line-height ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
        userSelect: "none",
        marginInlineEnd: FIXED_ITEM_MARGIN * 2,
        paddingInlineStart: token2.paddingXS,
        paddingInlineEnd: token2.paddingXS / 2,
        [`${componentCls}-disabled&`]: {
          color: token2.colorTextDisabled,
          borderColor: token2.colorBorder,
          cursor: "not-allowed"
        },
        "&-content": {
          display: "inline-block",
          marginInlineEnd: token2.paddingXS / 2,
          overflow: "hidden",
          whiteSpace: "pre",
          textOverflow: "ellipsis"
        },
        "&-remove": Object.assign(Object.assign({}, resetIcon()), {
          display: "inline-block",
          color: token2.colorIcon,
          fontWeight: "bold",
          fontSize: 10,
          lineHeight: "inherit",
          cursor: "pointer",
          [`> ${iconCls}`]: {
            verticalAlign: "-0.2em"
          },
          "&:hover": {
            color: token2.colorIconHover
          }
        })
      },
      [`${selectOverflowPrefixCls}-item + ${selectOverflowPrefixCls}-item`]: {
        [`${componentCls}-selection-search`]: {
          marginInlineStart: 0
        }
      },
      [`${componentCls}-selection-search`]: {
        display: "inline-flex",
        position: "relative",
        maxWidth: "100%",
        marginInlineStart: token2.inputPaddingHorizontalBase - selectItemDist,
        [`
          &-input,
          &-mirror
        `]: {
          height: selectItemHeight,
          fontFamily: token2.fontFamily,
          lineHeight: `${selectItemHeight}px`,
          transition: `all ${token2.motionDurationSlow}`
        },
        "&-input": {
          width: "100%",
          minWidth: 4.1
        },
        "&-mirror": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          insetInlineEnd: "auto",
          zIndex: 999,
          whiteSpace: "pre",
          visibility: "hidden"
        }
      },
      [`${componentCls}-selection-placeholder `]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: token2.inputPaddingHorizontalBase,
        insetInlineEnd: token2.inputPaddingHorizontalBase,
        transform: "translateY(-50%)",
        transition: `all ${token2.motionDurationSlow}`
      }
    }
  };
}
function genMultipleStyle(token2) {
  const {
    componentCls
  } = token2;
  const smallToken = merge$1(token2, {
    controlHeight: token2.controlHeightSM,
    controlHeightSM: token2.controlHeightXS,
    borderRadius: token2.borderRadiusSM,
    borderRadiusSM: token2.borderRadiusXS
  });
  const [, smSelectItemMargin] = getSelectItemStyle(token2);
  return [
    genSizeStyle$2(token2),
    genSizeStyle$2(smallToken, "sm"),
    {
      [`${componentCls}-multiple${componentCls}-sm`]: {
        [`${componentCls}-selection-placeholder`]: {
          insetInline: token2.controlPaddingHorizontalSM - token2.lineWidth
        },
        [`${componentCls}-selection-search`]: {
          marginInlineStart: smSelectItemMargin
        }
      }
    },
    genSizeStyle$2(merge$1(token2, {
      fontSize: token2.fontSizeLG,
      controlHeight: token2.controlHeightLG,
      controlHeightSM: token2.controlHeight,
      borderRadius: token2.borderRadiusLG,
      borderRadiusSM: token2.borderRadius
    }), "lg")
  ];
}
function genSizeStyle$1(token2, suffix) {
  const {
    componentCls,
    inputPaddingHorizontalBase,
    borderRadius
  } = token2;
  const selectHeightWithoutBorder = token2.controlHeight - token2.lineWidth * 2;
  const selectionItemPadding = Math.ceil(token2.fontSize * 1.25);
  const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
  return {
    [`${componentCls}-single${suffixCls}`]: {
      fontSize: token2.fontSize,
      [`${componentCls}-selector`]: Object.assign(Object.assign({}, resetComponent(token2)), {
        display: "flex",
        borderRadius,
        [`${componentCls}-selection-search`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: inputPaddingHorizontalBase,
          insetInlineEnd: inputPaddingHorizontalBase,
          bottom: 0,
          "&-input": {
            width: "100%"
          }
        },
        [`
          ${componentCls}-selection-item,
          ${componentCls}-selection-placeholder
        `]: {
          padding: 0,
          lineHeight: `${selectHeightWithoutBorder}px`,
          transition: `all ${token2.motionDurationSlow}`,
          "@supports (-moz-appearance: meterbar)": {
            lineHeight: `${selectHeightWithoutBorder}px`
          }
        },
        [`${componentCls}-selection-item`]: {
          position: "relative",
          userSelect: "none"
        },
        [`${componentCls}-selection-placeholder`]: {
          transition: "none",
          pointerEvents: "none"
        },
        [[
          "&:after",
          `${componentCls}-selection-item:after`,
          `${componentCls}-selection-placeholder:after`
        ].join(",")]: {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        }
      }),
      [`
        &${componentCls}-show-arrow ${componentCls}-selection-item,
        &${componentCls}-show-arrow ${componentCls}-selection-placeholder
      `]: {
        paddingInlineEnd: selectionItemPadding
      },
      [`&${componentCls}-open ${componentCls}-selection-item`]: {
        color: token2.colorTextPlaceholder
      },
      [`&:not(${componentCls}-customize-input)`]: {
        [`${componentCls}-selector`]: {
          width: "100%",
          height: token2.controlHeight,
          padding: `0 ${inputPaddingHorizontalBase}px`,
          [`${componentCls}-selection-search-input`]: {
            height: selectHeightWithoutBorder
          },
          "&:after": {
            lineHeight: `${selectHeightWithoutBorder}px`
          }
        }
      },
      [`&${componentCls}-customize-input`]: {
        [`${componentCls}-selector`]: {
          "&:after": {
            display: "none"
          },
          [`${componentCls}-selection-search`]: {
            position: "static",
            width: "100%"
          },
          [`${componentCls}-selection-placeholder`]: {
            position: "absolute",
            insetInlineStart: 0,
            insetInlineEnd: 0,
            padding: `0 ${inputPaddingHorizontalBase}px`,
            "&:after": {
              display: "none"
            }
          }
        }
      }
    }
  };
}
function genSingleStyle(token2) {
  const {
    componentCls
  } = token2;
  const inputPaddingHorizontalSM = token2.controlPaddingHorizontalSM - token2.lineWidth;
  return [
    genSizeStyle$1(token2),
    genSizeStyle$1(merge$1(token2, {
      controlHeight: token2.controlHeightSM,
      borderRadius: token2.borderRadiusSM
    }), "sm"),
    {
      [`${componentCls}-single${componentCls}-sm`]: {
        [`&:not(${componentCls}-customize-input)`]: {
          [`${componentCls}-selection-search`]: {
            insetInlineStart: inputPaddingHorizontalSM,
            insetInlineEnd: inputPaddingHorizontalSM
          },
          [`${componentCls}-selector`]: {
            padding: `0 ${inputPaddingHorizontalSM}px`
          },
          [`&${componentCls}-show-arrow ${componentCls}-selection-search`]: {
            insetInlineEnd: inputPaddingHorizontalSM + token2.fontSize * 1.5
          },
          [`
            &${componentCls}-show-arrow ${componentCls}-selection-item,
            &${componentCls}-show-arrow ${componentCls}-selection-placeholder
          `]: {
            paddingInlineEnd: token2.fontSize * 1.5
          }
        }
      }
    },
    genSizeStyle$1(merge$1(token2, {
      controlHeight: token2.controlHeightLG,
      fontSize: token2.fontSizeLG,
      borderRadius: token2.borderRadiusLG
    }), "lg")
  ];
}
const genSelectorStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    position: "relative",
    backgroundColor: token2.colorBgContainer,
    border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
    transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
    input: {
      cursor: "pointer"
    },
    [`${componentCls}-show-search&`]: {
      cursor: "text",
      input: {
        cursor: "auto",
        color: "inherit"
      }
    },
    [`${componentCls}-disabled&`]: {
      color: token2.colorTextDisabled,
      background: token2.colorBgContainerDisabled,
      cursor: "not-allowed",
      [`${componentCls}-multiple&`]: {
        background: token2.colorBgContainerDisabled
      },
      input: {
        cursor: "not-allowed"
      }
    }
  };
};
const genStatusStyle$3 = function(rootSelectCls, token2) {
  let overwriteDefaultBorder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  const {
    componentCls,
    borderHoverColor,
    outlineColor,
    antCls
  } = token2;
  const overwriteStyle = overwriteDefaultBorder ? {
    [`${componentCls}-selector`]: {
      borderColor: borderHoverColor
    }
  } : {};
  return {
    [rootSelectCls]: {
      [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: Object.assign(Object.assign({}, overwriteStyle), {
        [`${componentCls}-focused& ${componentCls}-selector`]: {
          borderColor: borderHoverColor,
          boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${outlineColor}`,
          outline: 0
        },
        [`&:hover ${componentCls}-selector`]: {
          borderColor: borderHoverColor
        }
      })
    }
  };
};
const getSearchInputWithoutBorderStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-selection-search-input`]: {
      margin: 0,
      padding: 0,
      background: "transparent",
      border: "none",
      outline: "none",
      appearance: "none",
      "&::-webkit-search-cancel-button": {
        display: "none",
        "-webkit-appearance": "none"
      }
    }
  };
};
const genBaseStyle$3 = (token2) => {
  const {
    componentCls,
    inputPaddingHorizontalBase,
    iconCls
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "relative",
      display: "inline-block",
      cursor: "pointer",
      [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: Object.assign(Object.assign({}, genSelectorStyle(token2)), getSearchInputWithoutBorderStyle(token2)),
      [`${componentCls}-selection-item`]: Object.assign(Object.assign({
        flex: 1,
        fontWeight: "normal"
      }, textEllipsis), {
        "> *": Object.assign({
          lineHeight: "inherit"
        }, textEllipsis)
      }),
      [`${componentCls}-selection-placeholder`]: Object.assign(Object.assign({}, textEllipsis), {
        flex: 1,
        color: token2.colorTextPlaceholder,
        pointerEvents: "none"
      }),
      [`${componentCls}-arrow`]: Object.assign(Object.assign({}, resetIcon()), {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: inputPaddingHorizontalBase,
        height: token2.fontSizeIcon,
        marginTop: -token2.fontSizeIcon / 2,
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        lineHeight: 1,
        textAlign: "center",
        pointerEvents: "none",
        display: "flex",
        alignItems: "center",
        [iconCls]: {
          verticalAlign: "top",
          transition: `transform ${token2.motionDurationSlow}`,
          "> svg": {
            verticalAlign: "top"
          },
          [`&:not(${componentCls}-suffix)`]: {
            pointerEvents: "auto"
          }
        },
        [`${componentCls}-disabled &`]: {
          cursor: "not-allowed"
        },
        "> *:not(:last-child)": {
          marginInlineEnd: 8
        }
      }),
      [`${componentCls}-clear`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: inputPaddingHorizontalBase,
        zIndex: 1,
        display: "inline-block",
        width: token2.fontSizeIcon,
        height: token2.fontSizeIcon,
        marginTop: -token2.fontSizeIcon / 2,
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        background: token2.colorBgContainer,
        cursor: "pointer",
        opacity: 0,
        transition: `color ${token2.motionDurationMid} ease, opacity ${token2.motionDurationSlow} ease`,
        textRendering: "auto",
        "&:before": {
          display: "block"
        },
        "&:hover": {
          color: token2.colorTextTertiary
        }
      },
      "&:hover": {
        [`${componentCls}-clear`]: {
          opacity: 1
        }
      }
    }),
    [`${componentCls}-has-feedback`]: {
      [`${componentCls}-clear`]: {
        insetInlineEnd: inputPaddingHorizontalBase + token2.fontSize + token2.paddingXXS
      }
    }
  };
};
const genSelectStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return [
    {
      [componentCls]: {
        [`&-borderless ${componentCls}-selector`]: {
          backgroundColor: `transparent !important`,
          borderColor: `transparent !important`,
          boxShadow: `none !important`
        },
        [`&${componentCls}-in-form-item`]: {
          width: "100%"
        }
      }
    },
    genBaseStyle$3(token2),
    genSingleStyle(token2),
    genMultipleStyle(token2),
    genDropdownStyle$1(token2),
    {
      [`${componentCls}-rtl`]: {
        direction: "rtl"
      }
    },
    genStatusStyle$3(componentCls, merge$1(token2, {
      borderHoverColor: token2.colorPrimaryHover,
      outlineColor: token2.controlOutline
    })),
    genStatusStyle$3(`${componentCls}-status-error`, merge$1(token2, {
      borderHoverColor: token2.colorErrorHover,
      outlineColor: token2.colorErrorOutline
    }), true),
    genStatusStyle$3(`${componentCls}-status-warning`, merge$1(token2, {
      borderHoverColor: token2.colorWarningHover,
      outlineColor: token2.colorWarningOutline
    }), true),
    genCompactItemStyle$1(token2, {
      borderElCls: `${componentCls}-selector`,
      focusElCls: `${componentCls}-focused`
    })
  ];
};
var useSelectStyle = genComponentStyleHook$2("Select", (token2, _ref2) => {
  let {
    rootPrefixCls
  } = _ref2;
  const selectToken = merge$1(token2, {
    rootPrefixCls,
    inputPaddingHorizontalBase: token2.paddingSM - 1
  });
  return [genSelectStyle(selectToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 50
}));
function useShowArrow(showArrow) {
  return showArrow !== null && showArrow !== void 0 ? showArrow : true;
}
var CheckOutlined = function CheckOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: CheckOutlinedSvg
  }));
};
CheckOutlined.displayName = "CheckOutlined";
var CheckOutlined$1 = /* @__PURE__ */ React.forwardRef(CheckOutlined);
var DownOutlined2 = function DownOutlined3(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: DownOutlinedSvg
  }));
};
DownOutlined2.displayName = "DownOutlined";
var DownOutlined$1 = /* @__PURE__ */ React.forwardRef(DownOutlined2);
var SearchOutlined$5 = function SearchOutlined(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: SearchOutlinedSvg
  }));
};
SearchOutlined$5.displayName = "SearchOutlined";
var SearchOutlined$6 = /* @__PURE__ */ React.forwardRef(SearchOutlined$5);
function getIcons(_ref2) {
  let {
    suffixIcon,
    clearIcon,
    menuItemSelectedIcon,
    removeIcon,
    loading,
    multiple,
    hasFeedback,
    prefixCls,
    showArrow,
    feedbackIcon
  } = _ref2;
  const mergedClearIcon = clearIcon !== null && clearIcon !== void 0 ? clearIcon : /* @__PURE__ */ React.createElement(CloseCircleFilled$6, null);
  const getSuffixIconNode = (arrowIcon) => /* @__PURE__ */ React.createElement(React.Fragment, null, showArrow !== false && arrowIcon, hasFeedback && feedbackIcon);
  let mergedSuffixIcon = null;
  if (suffixIcon !== void 0) {
    mergedSuffixIcon = getSuffixIconNode(suffixIcon);
  } else if (loading) {
    mergedSuffixIcon = getSuffixIconNode(/* @__PURE__ */ React.createElement(LoadingOutlined$6, {
      spin: true
    }));
  } else {
    const iconCls = `${prefixCls}-suffix`;
    mergedSuffixIcon = (_ref22) => {
      let {
        open,
        showSearch
      } = _ref22;
      if (open && showSearch) {
        return getSuffixIconNode(/* @__PURE__ */ React.createElement(SearchOutlined$6, {
          className: iconCls
        }));
      }
      return getSuffixIconNode(/* @__PURE__ */ React.createElement(DownOutlined$1, {
        className: iconCls
      }));
    };
  }
  let mergedItemIcon = null;
  if (menuItemSelectedIcon !== void 0) {
    mergedItemIcon = menuItemSelectedIcon;
  } else if (multiple) {
    mergedItemIcon = /* @__PURE__ */ React.createElement(CheckOutlined$1, null);
  } else {
    mergedItemIcon = null;
  }
  let mergedRemoveIcon = null;
  if (removeIcon !== void 0) {
    mergedRemoveIcon = removeIcon;
  } else {
    mergedRemoveIcon = /* @__PURE__ */ React.createElement(CloseOutlined$1, null);
  }
  return {
    clearIcon: mergedClearIcon,
    suffixIcon: mergedSuffixIcon,
    itemIcon: mergedItemIcon,
    removeIcon: mergedRemoveIcon
  };
}
var __rest$w = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
const InternalSelect = (_a2, ref2) => {
  var {
    prefixCls: customizePrefixCls,
    bordered = true,
    className,
    rootClassName,
    getPopupContainer,
    popupClassName,
    dropdownClassName,
    listHeight = 256,
    placement,
    listItemHeight = 24,
    size: customizeSize,
    disabled: customDisabled,
    notFoundContent,
    status: customStatus,
    showArrow
  } = _a2, props = __rest$w(_a2, ["prefixCls", "bordered", "className", "rootClassName", "getPopupContainer", "popupClassName", "dropdownClassName", "listHeight", "placement", "listItemHeight", "size", "disabled", "notFoundContent", "status", "showArrow"]);
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    renderEmpty,
    direction,
    virtual,
    dropdownMatchSelectWidth,
    select
  } = React.useContext(ConfigContext$1);
  const size = React.useContext(SizeContext$3);
  const prefixCls = getPrefixCls("select", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext$1(prefixCls, direction);
  const [wrapSSR, hashId] = useSelectStyle(prefixCls);
  const mode = React.useMemo(() => {
    const {
      mode: m2
    } = props;
    if (m2 === "combobox") {
      return void 0;
    }
    if (m2 === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
      return "combobox";
    }
    return m2;
  }, [props.mode]);
  const isMultiple2 = mode === "multiple" || mode === "tags";
  const mergedShowArrow = useShowArrow(showArrow);
  const {
    status: contextStatus,
    hasFeedback,
    isFormItemInput,
    feedbackIcon
  } = React.useContext(FormItemInputContext$1);
  const mergedStatus = getMergedStatus$1(contextStatus, customStatus);
  let mergedNotFound;
  if (notFoundContent !== void 0) {
    mergedNotFound = notFoundContent;
  } else if (mode === "combobox") {
    mergedNotFound = null;
  } else {
    mergedNotFound = (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Select")) || /* @__PURE__ */ React.createElement(DefaultRenderEmpty$1, {
      componentName: "Select"
    });
  }
  const {
    suffixIcon,
    itemIcon,
    removeIcon,
    clearIcon
  } = getIcons(Object.assign(Object.assign({}, props), {
    multiple: isMultiple2,
    hasFeedback,
    feedbackIcon,
    showArrow: mergedShowArrow,
    prefixCls
  }));
  const selectProps = omit$5(props, ["suffixIcon", "itemIcon"]);
  const rcSelectRtlDropdownClassName = classNames(popupClassName || dropdownClassName, {
    [`${prefixCls}-dropdown-${direction}`]: direction === "rtl"
  }, rootClassName, hashId);
  const mergedSize = compactSize || customizeSize || size;
  const disabled = React.useContext(DisabledContext$3);
  const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  const mergedClassName = classNames({
    [`${prefixCls}-lg`]: mergedSize === "large",
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-borderless`]: !bordered,
    [`${prefixCls}-in-form-item`]: isFormItemInput
  }, getStatusClassNames$1(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, className, rootClassName, hashId);
  const memoPlacement = React.useMemo(() => {
    if (placement !== void 0) {
      return placement;
    }
    return direction === "rtl" ? "bottomRight" : "bottomLeft";
  }, [placement, direction]);
  return wrapSSR(/* @__PURE__ */ React.createElement(TypedSelect, Object.assign({
    ref: ref2,
    virtual,
    dropdownMatchSelectWidth,
    showSearch: select === null || select === void 0 ? void 0 : select.showSearch
  }, selectProps, {
    transitionName: getTransitionName$1(rootPrefixCls, getTransitionDirection(placement), props.transitionName),
    listHeight,
    listItemHeight,
    mode,
    prefixCls,
    placement: memoPlacement,
    direction,
    inputIcon: suffixIcon,
    menuItemSelectedIcon: itemIcon,
    removeIcon,
    clearIcon,
    notFoundContent: mergedNotFound,
    className: mergedClassName,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    dropdownClassName: rcSelectRtlDropdownClassName,
    showArrow: hasFeedback || mergedShowArrow,
    disabled: mergedDisabled
  })));
};
const Select = /* @__PURE__ */ React.forwardRef(InternalSelect);
const PurePanel$2 = genPurePanel(Select);
Select.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
Select.Option = Option$1;
Select.OptGroup = OptGroup;
Select._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$2;
var Select$1 = Select;
function useForceUpdate() {
  const [, forceUpdate] = React.useReducer((x2) => x2 + 1, 0);
  return forceUpdate;
}
const responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"];
const getResponsiveMap = (token2) => ({
  xs: `(max-width: ${token2.screenXSMax}px)`,
  sm: `(min-width: ${token2.screenSM}px)`,
  md: `(min-width: ${token2.screenMD}px)`,
  lg: `(min-width: ${token2.screenLG}px)`,
  xl: `(min-width: ${token2.screenXL}px)`,
  xxl: `(min-width: ${token2.screenXXL}px)`
});
const validateBreakpoints = (token2) => {
  const indexableToken = token2;
  const revBreakpoints = [].concat(responsiveArray).reverse();
  revBreakpoints.forEach((breakpoint, i) => {
    const breakpointUpper = breakpoint.toUpperCase();
    const screenMin = `screen${breakpointUpper}Min`;
    const screen = `screen${breakpointUpper}`;
    if (!(indexableToken[screenMin] <= indexableToken[screen])) {
      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);
    }
    if (i < revBreakpoints.length - 1) {
      const screenMax = `screen${breakpointUpper}Max`;
      if (!(indexableToken[screen] <= indexableToken[screenMax])) {
        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);
      }
      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();
      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;
      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {
        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);
      }
    }
  });
  return token2;
};
function useResponsiveObserver() {
  const [, token2] = useToken$2();
  const responsiveMap = getResponsiveMap(validateBreakpoints(token2));
  return React.useMemo(() => {
    const subscribers = /* @__PURE__ */ new Map();
    let subUid = -1;
    let screens = {};
    return {
      matchHandlers: {},
      dispatch(pointMap) {
        screens = pointMap;
        subscribers.forEach((func) => func(screens));
        return subscribers.size >= 1;
      },
      subscribe(func) {
        if (!subscribers.size)
          this.register();
        subUid += 1;
        subscribers.set(subUid, func);
        func(screens);
        return subUid;
      },
      unsubscribe(paramToken) {
        subscribers.delete(paramToken);
        if (!subscribers.size)
          this.unregister();
      },
      unregister() {
        Object.keys(responsiveMap).forEach((screen) => {
          const matchMediaQuery = responsiveMap[screen];
          const handler = this.matchHandlers[matchMediaQuery];
          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);
        });
        subscribers.clear();
      },
      register() {
        Object.keys(responsiveMap).forEach((screen) => {
          const matchMediaQuery = responsiveMap[screen];
          const listener = (_ref2) => {
            let {
              matches
            } = _ref2;
            this.dispatch(Object.assign(Object.assign({}, screens), {
              [screen]: matches
            }));
          };
          const mql = window.matchMedia(matchMediaQuery);
          mql.addListener(listener);
          this.matchHandlers[matchMediaQuery] = {
            mql,
            listener
          };
          listener(mql);
        });
      },
      responsiveMap
    };
  }, [token2]);
}
function useBreakpoint() {
  let refreshOnChange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  const screensRef = React.useRef({});
  const forceUpdate = useForceUpdate();
  const responsiveObserver = useResponsiveObserver();
  React.useEffect(() => {
    const token2 = responsiveObserver.subscribe((supportScreens) => {
      screensRef.current = supportScreens;
      if (refreshOnChange) {
        forceUpdate();
      }
    });
    return () => responsiveObserver.unsubscribe(token2);
  }, []);
  return screensRef.current;
}
var autoAdjustOverflowTopBottom = {
  shiftX: 64,
  adjustY: 1
};
var autoAdjustOverflowLeftRight = {
  adjustX: 1,
  shiftY: true
};
var targetOffset$1 = [0, 0];
var placements$3 = {
  left: {
    points: ["cr", "cl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset: targetOffset$1
  },
  right: {
    points: ["cl", "cr"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset: targetOffset$1
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset: targetOffset$1
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset: targetOffset$1
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset: targetOffset$1
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset: targetOffset$1
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset: targetOffset$1
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset: targetOffset$1
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset: targetOffset$1
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset: targetOffset$1
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset: targetOffset$1
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset: targetOffset$1
  }
};
function Popup$2(props) {
  var children = props.children, prefixCls = props.prefixCls, id = props.id, overlayInnerStyle = props.overlayInnerStyle, className = props.className, style2 = props.style;
  return /* @__PURE__ */ React.createElement("div", {
    className: classNames("".concat(prefixCls, "-content"), className),
    style: style2
  }, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-inner"),
    id,
    role: "tooltip",
    style: overlayInnerStyle
  }, typeof children === "function" ? children() : children));
}
var _excluded$z = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"];
var Tooltip$2 = function Tooltip(props, ref2) {
  var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, motion2 = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle;
  props.arrowContent;
  var overlay = props.overlay, id = props.id, _props$showArrow = props.showArrow, showArrow = _props$showArrow === void 0 ? true : _props$showArrow, restProps = _objectWithoutProperties$1(props, _excluded$z);
  var triggerRef = React.useRef(null);
  React.useImperativeHandle(ref2, function() {
    return triggerRef.current;
  });
  var extraProps = _objectSpread2$d({}, restProps);
  if ("visible" in props) {
    extraProps.popupVisible = props.visible;
  }
  var getPopupElement = function getPopupElement2() {
    return /* @__PURE__ */ React.createElement(Popup$2, {
      key: "content",
      prefixCls,
      id,
      overlayInnerStyle
    }, overlay);
  };
  return /* @__PURE__ */ React.createElement(Trigger$2, _extends$3({
    popupClassName: overlayClassName,
    prefixCls,
    popup: getPopupElement,
    action: trigger,
    builtinPlacements: placements$3,
    popupPlacement: placement,
    ref: triggerRef,
    popupAlign: align,
    getPopupContainer: getTooltipContainer,
    onPopupVisibleChange: onVisibleChange,
    afterPopupVisibleChange: afterVisibleChange,
    popupTransitionName: transitionName,
    popupAnimation: animation,
    popupMotion: motion2,
    defaultPopupVisible: defaultVisible,
    autoDestroy: destroyTooltipOnHide,
    mouseLeaveDelay,
    popupStyle: overlayStyle,
    mouseEnterDelay,
    arrow: showArrow
  }, extraProps), children);
};
var Tooltip$3 = /* @__PURE__ */ React.forwardRef(Tooltip$2);
const MAX_VERTICAL_CONTENT_RADIUS = 8;
function getArrowOffset(options) {
  const maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS;
  const {
    contentRadius,
    limitVerticalRadius
  } = options;
  const dropdownArrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
  const dropdownArrowOffsetVertical = limitVerticalRadius ? maxVerticalContentRadius : dropdownArrowOffset;
  return {
    dropdownArrowOffset,
    dropdownArrowOffsetVertical
  };
}
function isInject(valid2, code2) {
  if (!valid2)
    return {};
  return code2;
}
function getArrowStyle(token2, options) {
  const {
    componentCls,
    sizePopupArrow,
    borderRadiusXS,
    borderRadiusOuter,
    boxShadowPopoverArrow
  } = token2;
  const {
    colorBg,
    contentRadius = token2.borderRadiusLG,
    limitVerticalRadius,
    arrowDistance = 0,
    arrowPlacement = {
      left: true,
      right: true,
      top: true,
      bottom: true
    }
  } = options;
  const {
    dropdownArrowOffsetVertical,
    dropdownArrowOffset
  } = getArrowOffset({
    contentRadius,
    limitVerticalRadius
  });
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({
      [`${componentCls}-arrow`]: [Object.assign(Object.assign({
        position: "absolute",
        zIndex: 1,
        display: "block"
      }, roundedArrow$2(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
        "&:before": {
          background: colorBg
        }
      })]
    }, isInject(!!arrowPlacement.top, {
      [[`&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow`].join(",")]: {
        bottom: arrowDistance,
        transform: "translateY(100%) rotate(180deg)"
      },
      [`&-placement-top ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(100%) rotate(180deg)"
      },
      [`&-placement-topLeft ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: dropdownArrowOffset
        }
      },
      [`&-placement-topRight ${componentCls}-arrow`]: {
        right: {
          _skip_check_: true,
          value: dropdownArrowOffset
        }
      }
    })), isInject(!!arrowPlacement.bottom, {
      [[`&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow`].join(",")]: {
        top: arrowDistance,
        transform: `translateY(-100%)`
      },
      [`&-placement-bottom ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: "50%"
        },
        transform: `translateX(-50%) translateY(-100%)`
      },
      [`&-placement-bottomLeft ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: dropdownArrowOffset
        }
      },
      [`&-placement-bottomRight ${componentCls}-arrow`]: {
        right: {
          _skip_check_: true,
          value: dropdownArrowOffset
        }
      }
    })), isInject(!!arrowPlacement.left, {
      [[`&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow`].join(",")]: {
        right: {
          _skip_check_: true,
          value: arrowDistance
        },
        transform: "translateX(100%) rotate(90deg)"
      },
      [`&-placement-left ${componentCls}-arrow`]: {
        top: {
          _skip_check_: true,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(100%) rotate(90deg)"
      },
      [`&-placement-leftTop ${componentCls}-arrow`]: {
        top: dropdownArrowOffsetVertical
      },
      [`&-placement-leftBottom ${componentCls}-arrow`]: {
        bottom: dropdownArrowOffsetVertical
      }
    })), isInject(!!arrowPlacement.right, {
      [[`&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow`].join(",")]: {
        left: {
          _skip_check_: true,
          value: arrowDistance
        },
        transform: "translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-right ${componentCls}-arrow`]: {
        top: {
          _skip_check_: true,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-rightTop ${componentCls}-arrow`]: {
        top: dropdownArrowOffsetVertical
      },
      [`&-placement-rightBottom ${componentCls}-arrow`]: {
        bottom: dropdownArrowOffsetVertical
      }
    }))
  };
}
function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow2) {
  if (autoAdjustOverflow2 === false) {
    return {
      adjustX: false,
      adjustY: false
    };
  }
  const overflow = autoAdjustOverflow2 && typeof autoAdjustOverflow2 === "object" ? autoAdjustOverflow2 : {};
  const baseOverflow = {};
  switch (placement) {
    case "top":
    case "bottom":
      baseOverflow.shiftX = arrowOffset.dropdownArrowOffset * 2 + arrowWidth;
      break;
    case "left":
    case "right":
      baseOverflow.shiftY = arrowOffset.dropdownArrowOffsetVertical * 2 + arrowWidth;
      break;
  }
  const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);
  if (!mergedOverflow.shiftX) {
    mergedOverflow.adjustX = true;
  }
  if (!mergedOverflow.shiftY) {
    mergedOverflow.adjustY = true;
  }
  return mergedOverflow;
}
const PlacementAlignMap = {
  left: {
    points: ["cr", "cl"]
  },
  right: {
    points: ["cl", "cr"]
  },
  top: {
    points: ["bc", "tc"]
  },
  bottom: {
    points: ["tc", "bc"]
  },
  topLeft: {
    points: ["bl", "tl"]
  },
  leftTop: {
    points: ["tr", "tl"]
  },
  topRight: {
    points: ["br", "tr"]
  },
  rightTop: {
    points: ["tl", "tr"]
  },
  bottomRight: {
    points: ["tr", "br"]
  },
  rightBottom: {
    points: ["bl", "br"]
  },
  bottomLeft: {
    points: ["tl", "bl"]
  },
  leftBottom: {
    points: ["br", "bl"]
  }
};
const ArrowCenterPlacementAlignMap = {
  topLeft: {
    points: ["bl", "tc"]
  },
  leftTop: {
    points: ["tr", "cl"]
  },
  topRight: {
    points: ["br", "tc"]
  },
  rightTop: {
    points: ["tl", "cr"]
  },
  bottomRight: {
    points: ["tr", "bc"]
  },
  rightBottom: {
    points: ["bl", "cr"]
  },
  bottomLeft: {
    points: ["tl", "bc"]
  },
  leftBottom: {
    points: ["br", "cl"]
  }
};
const DisableAutoArrowList = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
function getPlacements(config) {
  const {
    arrowWidth,
    autoAdjustOverflow: autoAdjustOverflow2,
    arrowPointAtCenter,
    offset: offset3,
    borderRadius
  } = config;
  const halfArrowWidth = arrowWidth / 2;
  const placementMap = {};
  Object.keys(PlacementAlignMap).forEach((key) => {
    const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
    const placementInfo = Object.assign(Object.assign({}, template), {
      offset: [0, 0]
    });
    placementMap[key] = placementInfo;
    if (DisableAutoArrowList.has(key)) {
      placementInfo.autoArrow = false;
    }
    switch (key) {
      case "top":
      case "topLeft":
      case "topRight":
        placementInfo.offset[1] = -halfArrowWidth - offset3;
        break;
      case "bottom":
      case "bottomLeft":
      case "bottomRight":
        placementInfo.offset[1] = halfArrowWidth + offset3;
        break;
      case "left":
      case "leftTop":
      case "leftBottom":
        placementInfo.offset[0] = -halfArrowWidth - offset3;
        break;
      case "right":
      case "rightTop":
      case "rightBottom":
        placementInfo.offset[0] = halfArrowWidth + offset3;
        break;
    }
    const arrowOffset = getArrowOffset({
      contentRadius: borderRadius,
      limitVerticalRadius: true
    });
    if (arrowPointAtCenter) {
      switch (key) {
        case "topLeft":
        case "bottomLeft":
          placementInfo.offset[0] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
          break;
        case "topRight":
        case "bottomRight":
          placementInfo.offset[0] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
          break;
        case "leftTop":
        case "rightTop":
          placementInfo.offset[1] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
          break;
        case "leftBottom":
        case "rightBottom":
          placementInfo.offset[1] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
          break;
      }
    }
    placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow2);
  });
  return placementMap;
}
const getAlphaColor$3 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
const getSolidColor$1 = (baseColor, brightness) => {
  const instance2 = new TinyColor(baseColor);
  return instance2.lighten(brightness).toHexString();
};
const generateColorPalettes$1 = (baseColor) => {
  const colors2 = generate$2(baseColor, {
    theme: "dark"
  });
  return {
    1: colors2[0],
    2: colors2[1],
    3: colors2[2],
    4: colors2[3],
    5: colors2[6],
    6: colors2[5],
    7: colors2[4],
    8: colors2[6],
    9: colors2[5],
    10: colors2[4]
  };
};
const generateNeutralColorPalettes$1 = (bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#000";
  const colorTextBase = textBaseColor || "#fff";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor$3(colorTextBase, 0.85),
    colorTextSecondary: getAlphaColor$3(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor$3(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor$3(colorTextBase, 0.25),
    colorFill: getAlphaColor$3(colorTextBase, 0.18),
    colorFillSecondary: getAlphaColor$3(colorTextBase, 0.12),
    colorFillTertiary: getAlphaColor$3(colorTextBase, 0.08),
    colorFillQuaternary: getAlphaColor$3(colorTextBase, 0.04),
    colorBgElevated: getSolidColor$1(colorBgBase, 12),
    colorBgContainer: getSolidColor$1(colorBgBase, 8),
    colorBgLayout: getSolidColor$1(colorBgBase, 0),
    colorBgSpotlight: getSolidColor$1(colorBgBase, 26),
    colorBorder: getSolidColor$1(colorBgBase, 26),
    colorBorderSecondary: getSolidColor$1(colorBgBase, 19)
  };
};
const derivative$2 = (token2, mapToken) => {
  const colorPalettes = Object.keys(defaultPresetColors$1).map((colorKey) => {
    const colors2 = generate$2(token2[colorKey], {
      theme: "dark"
    });
    return new Array(10).fill(1).reduce((prev2, _24, i) => {
      prev2[`${colorKey}-${i + 1}`] = colors2[i];
      prev2[`${colorKey}${i + 1}`] = colors2[i];
      return prev2;
    }, {});
  }).reduce((prev2, cur) => {
    prev2 = Object.assign(Object.assign({}, prev2), cur);
    return prev2;
  }, {});
  const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$3(token2);
  return Object.assign(Object.assign(Object.assign({}, mergedMapToken), colorPalettes), genColorMapToken$2(token2, {
    generateColorPalettes: generateColorPalettes$1,
    generateNeutralColorPalettes: generateNeutralColorPalettes$1
  }));
};
var darkAlgorithm = derivative$2;
function genSizeMapToken$2(token2) {
  const {
    sizeUnit,
    sizeStep
  } = token2;
  const compactSizeStep = sizeStep - 2;
  return {
    sizeXXL: sizeUnit * (compactSizeStep + 10),
    sizeXL: sizeUnit * (compactSizeStep + 6),
    sizeLG: sizeUnit * (compactSizeStep + 2),
    sizeMD: sizeUnit * (compactSizeStep + 2),
    sizeMS: sizeUnit * (compactSizeStep + 1),
    size: sizeUnit * compactSizeStep,
    sizeSM: sizeUnit * compactSizeStep,
    sizeXS: sizeUnit * (compactSizeStep - 1),
    sizeXXS: sizeUnit * (compactSizeStep - 1)
  };
}
const derivative$1 = (token2, mapToken) => {
  const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$3(token2);
  const fontSize = mergedMapToken.fontSizeSM;
  const controlHeight = mergedMapToken.controlHeight - 4;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, mergedMapToken), genSizeMapToken$2(mapToken !== null && mapToken !== void 0 ? mapToken : token2)), genFontMapToken$3(fontSize)), {
    controlHeight
  }), genControlHeight$3(Object.assign(Object.assign({}, mergedMapToken), {
    controlHeight
  })));
};
var compactAlgorithm = derivative$1;
function useToken$1() {
  const [theme2, token2, hashId] = useToken$2();
  return {
    theme: theme2,
    token: token2,
    hashId
  };
}
var theme = {
  defaultConfig,
  defaultSeed: defaultConfig.token,
  useToken: useToken$1,
  defaultAlgorithm: derivative$3,
  darkAlgorithm,
  compactAlgorithm
};
const genTooltipStyle = (token2) => {
  const {
    componentCls,
    tooltipMaxWidth,
    tooltipColor,
    tooltipBg,
    tooltipBorderRadius,
    zIndexPopup,
    controlHeight,
    boxShadowSecondary,
    paddingSM,
    paddingXS,
    tooltipRadiusOuter
  } = token2;
  return [
    {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        zIndex: zIndexPopup,
        display: "block",
        width: "max-content",
        maxWidth: tooltipMaxWidth,
        visibility: "visible",
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": tooltipBg,
        [`${componentCls}-inner`]: {
          minWidth: controlHeight,
          minHeight: controlHeight,
          padding: `${paddingSM / 2}px ${paddingXS}px`,
          color: tooltipColor,
          textAlign: "start",
          textDecoration: "none",
          wordWrap: "break-word",
          backgroundColor: tooltipBg,
          borderRadius: tooltipBorderRadius,
          boxShadow: boxShadowSecondary
        },
        [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
          [`${componentCls}-inner`]: {
            borderRadius: Math.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
          }
        },
        [`${componentCls}-content`]: {
          position: "relative"
        }
      }), genPresetColor$2(token2, (colorKey, _ref2) => {
        let {
          darkColor
        } = _ref2;
        return {
          [`&${componentCls}-${colorKey}`]: {
            [`${componentCls}-inner`]: {
              backgroundColor: darkColor
            },
            [`${componentCls}-arrow`]: {
              "--antd-arrow-background-color": darkColor
            }
          }
        };
      })), {
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    getArrowStyle(merge$1(token2, {
      borderRadiusOuter: tooltipRadiusOuter
    }), {
      colorBg: "var(--antd-arrow-background-color)",
      contentRadius: tooltipBorderRadius,
      limitVerticalRadius: true
    }),
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: token2.sizePopupArrow
      }
    }
  ];
};
var useStyle$d = (prefixCls, injectStyle) => {
  const useOriginHook = genComponentStyleHook$2("Tooltip", (token2) => {
    if (injectStyle === false) {
      return [];
    }
    const {
      borderRadius,
      colorTextLightSolid,
      colorBgDefault,
      borderRadiusOuter
    } = token2;
    const TooltipToken = merge$1(token2, {
      tooltipMaxWidth: 250,
      tooltipColor: colorTextLightSolid,
      tooltipBorderRadius: borderRadius,
      tooltipBg: colorBgDefault,
      tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
    });
    return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
  }, (_ref2) => {
    let {
      zIndexPopupBase,
      colorBgSpotlight
    } = _ref2;
    return {
      zIndexPopup: zIndexPopupBase + 70,
      colorBgDefault: colorBgSpotlight
    };
  });
  return useOriginHook(prefixCls);
};
const inverseColors = PresetColors$1.map((color2) => `${color2}-inverse`);
function isPresetColor(color2) {
  let includeInverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (includeInverse) {
    return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors$1)).includes(color2);
  }
  return PresetColors$1.includes(color2);
}
function parseColor(prefixCls, color2) {
  const isInternalColor = isPresetColor(color2);
  const className = classNames({
    [`${prefixCls}-${color2}`]: color2 && isInternalColor
  });
  const overlayStyle = {};
  const arrowStyle = {};
  if (color2 && !isInternalColor) {
    overlayStyle.background = color2;
    arrowStyle["--antd-arrow-background-color"] = color2;
  }
  return {
    className,
    overlayStyle,
    arrowStyle
  };
}
function PurePanel$1(props) {
  const {
    prefixCls: customizePrefixCls,
    className,
    placement = "top",
    title,
    color: color2,
    overlayInnerStyle
  } = props;
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$d(prefixCls, true);
  const colorInfo = parseColor(prefixCls, color2);
  const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
  const arrowContentStyle = colorInfo.arrowStyle;
  return wrapSSR(/* @__PURE__ */ React.createElement("div", {
    className: classNames(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className),
    style: arrowContentStyle
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-arrow`
  }), /* @__PURE__ */ React.createElement(Popup$2, Object.assign({}, props, {
    className: hashId,
    prefixCls,
    overlayInnerStyle: formattedOverlayInnerStyle
  }), title)));
}
var __rest$v = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const {
  useToken
} = theme;
const splitObject = (obj, keys2) => {
  const picked = {};
  const omitted = Object.assign({}, obj);
  keys2.forEach((key) => {
    if (obj && key in obj) {
      picked[key] = obj[key];
      delete omitted[key];
    }
  });
  return {
    picked,
    omitted
  };
};
function getDisabledCompatibleChildren(element2, prefixCls) {
  const elementType = element2.type;
  if ((elementType.__ANT_BUTTON === true || element2.type === "button") && element2.props.disabled || elementType.__ANT_SWITCH === true && (element2.props.disabled || element2.props.loading) || elementType.__ANT_RADIO === true && element2.props.disabled) {
    const {
      picked,
      omitted
    } = splitObject(element2.props.style, ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]);
    const spanStyle = Object.assign(Object.assign({
      display: "inline-block"
    }, picked), {
      cursor: "not-allowed",
      width: element2.props.block ? "100%" : void 0
    });
    const buttonStyle = Object.assign(Object.assign({}, omitted), {
      pointerEvents: "none"
    });
    const child = cloneElement$1(element2, {
      style: buttonStyle,
      className: null
    });
    return /* @__PURE__ */ React.createElement("span", {
      style: spanStyle,
      className: classNames(element2.props.className, `${prefixCls}-disabled-compatible-wrapper`)
    }, child);
  }
  return element2;
}
const Tooltip2 = /* @__PURE__ */ React.forwardRef((props, ref2) => {
  var _a2, _b;
  const {
    prefixCls: customizePrefixCls,
    openClassName,
    getTooltipContainer,
    overlayClassName,
    color: color2,
    overlayInnerStyle,
    children,
    afterOpenChange,
    afterVisibleChange,
    destroyTooltipOnHide,
    arrow = true,
    title,
    overlay,
    builtinPlacements,
    arrowPointAtCenter = false,
    autoAdjustOverflow: autoAdjustOverflow2 = true
  } = props;
  const mergedShowArrow = !!arrow;
  const {
    token: token2
  } = useToken();
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext$1);
  const tooltipRef = React.useRef(null);
  const forceAlign = () => {
    var _a3;
    (_a3 = tooltipRef.current) === null || _a3 === void 0 ? void 0 : _a3.forceAlign();
  };
  React.useImperativeHandle(ref2, () => ({
    forceAlign,
    forcePopupAlign: () => {
      forceAlign();
    }
  }));
  const [open, setOpen] = useMergedState$2(false, {
    value: (_a2 = props.open) !== null && _a2 !== void 0 ? _a2 : props.visible,
    defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
  });
  const noTitle = !title && !overlay && title !== 0;
  const onOpenChange = (vis) => {
    var _a3, _b2;
    setOpen(noTitle ? false : vis);
    if (!noTitle) {
      (_a3 = props.onOpenChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, vis);
      (_b2 = props.onVisibleChange) === null || _b2 === void 0 ? void 0 : _b2.call(props, vis);
    }
  };
  const tooltipPlacements = React.useMemo(() => {
    var _a3, _b2;
    let mergedArrowPointAtCenter = arrowPointAtCenter;
    if (typeof arrow === "object") {
      mergedArrowPointAtCenter = (_b2 = (_a3 = arrow.pointAtCenter) !== null && _a3 !== void 0 ? _a3 : arrow.arrowPointAtCenter) !== null && _b2 !== void 0 ? _b2 : arrowPointAtCenter;
    }
    return builtinPlacements || getPlacements({
      arrowPointAtCenter: mergedArrowPointAtCenter,
      autoAdjustOverflow: autoAdjustOverflow2,
      arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
      borderRadius: token2.borderRadius,
      offset: token2.marginXXS
    });
  }, [arrowPointAtCenter, arrow, builtinPlacements, token2]);
  const onPopupAlign = (domNode, align) => {
    const placement2 = Object.keys(tooltipPlacements).find((key) => {
      var _a3, _b2;
      return tooltipPlacements[key].points[0] === ((_a3 = align.points) === null || _a3 === void 0 ? void 0 : _a3[0]) && tooltipPlacements[key].points[1] === ((_b2 = align.points) === null || _b2 === void 0 ? void 0 : _b2[1]);
    });
    if (placement2) {
      const rect = domNode.getBoundingClientRect();
      const transformOrigin = {
        top: "50%",
        left: "50%"
      };
      if (/top|Bottom/.test(placement2)) {
        transformOrigin.top = `${rect.height - align.offset[1]}px`;
      } else if (/Top|bottom/.test(placement2)) {
        transformOrigin.top = `${-align.offset[1]}px`;
      }
      if (/left|Right/.test(placement2)) {
        transformOrigin.left = `${rect.width - align.offset[0]}px`;
      } else if (/right|Left/.test(placement2)) {
        transformOrigin.left = `${-align.offset[0]}px`;
      }
      domNode.style.transformOrigin = `${transformOrigin.left} ${transformOrigin.top}`;
    }
  };
  const memoOverlay = React.useMemo(() => {
    if (title === 0) {
      return title;
    }
    return overlay || title || "";
  }, [overlay, title]);
  const {
    getPopupContainer,
    placement = "top",
    mouseEnterDelay = 0.1,
    mouseLeaveDelay = 0.1,
    overlayStyle,
    rootClassName
  } = props, otherProps = __rest$v(props, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]);
  const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const injectFromPopover = props["data-popover-inject"];
  let tempOpen = open;
  if (!("open" in props) && !("visible" in props) && noTitle) {
    tempOpen = false;
  }
  const child = getDisabledCompatibleChildren(isValidElement$1(children) && !isFragment$1(children) ? children : /* @__PURE__ */ React.createElement("span", null, children), prefixCls);
  const childProps = child.props;
  const childCls = !childProps.className || typeof childProps.className === "string" ? classNames(childProps.className, {
    [openClassName || `${prefixCls}-open`]: true
  }) : childProps.className;
  const [wrapSSR, hashId] = useStyle$d(prefixCls, !injectFromPopover);
  const colorInfo = parseColor(prefixCls, color2);
  const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
  const arrowContentStyle = colorInfo.arrowStyle;
  const customOverlayClassName = classNames(overlayClassName, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, colorInfo.className, rootClassName, hashId);
  return wrapSSR(/* @__PURE__ */ React.createElement(Tooltip$3, Object.assign({}, otherProps, {
    showArrow: mergedShowArrow,
    placement,
    mouseEnterDelay,
    mouseLeaveDelay,
    prefixCls,
    overlayClassName: customOverlayClassName,
    overlayStyle: Object.assign(Object.assign({}, arrowContentStyle), overlayStyle),
    getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
    ref: tooltipRef,
    builtinPlacements: tooltipPlacements,
    overlay: memoOverlay,
    visible: tempOpen,
    onVisibleChange: onOpenChange,
    afterVisibleChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
    onPopupAlign,
    overlayInnerStyle: formattedOverlayInnerStyle,
    arrowContent: /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-arrow-content`
    }),
    motion: {
      motionName: getTransitionName$1(rootPrefixCls, "zoom-big-fast", props.transitionName),
      motionDeadline: 1e3
    },
    destroyTooltipOnHide: !!destroyTooltipOnHide
  }), tempOpen ? cloneElement$1(child, {
    className: childCls
  }) : child));
});
Tooltip2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$1;
var Tooltip$1 = Tooltip2;
var attributes$1 = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
var eventsName$1 = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
var propList$1 = "".concat(attributes$1, " ").concat(eventsName$1).split(/[\s\n]+/);
var ariaPrefix$1 = "aria-";
var dataPrefix$1 = "data-";
function match$1(key, prefix2) {
  return key.indexOf(prefix2) === 0;
}
function pickAttrs$1(props) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _objectSpread2$d({}, ariaOnly);
  }
  var attrs = {};
  Object.keys(props).forEach(function(key) {
    if (mergedConfig.aria && (key === "role" || match$1(key, ariaPrefix$1)) || mergedConfig.data && match$1(key, dataPrefix$1) || mergedConfig.attr && propList$1.includes(key)) {
      attrs[key] = props[key];
    }
  });
  return attrs;
}
var RightOutlined = function RightOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: RightOutlinedSvg
  }));
};
RightOutlined.displayName = "RightOutlined";
var RightOutlined$1 = /* @__PURE__ */ React.forwardRef(RightOutlined);
function addEventListenerWrap$1(target, eventType, cb, option) {
  var callback = ReactDOM.unstable_batchedUpdates ? function run(e2) {
    ReactDOM.unstable_batchedUpdates(cb, e2);
  } : cb;
  if (target.addEventListener) {
    target.addEventListener(eventType, callback, option);
  }
  return {
    remove: function remove3() {
      if (target.removeEventListener) {
        target.removeEventListener(eventType, callback, option);
      }
    }
  };
}
var Portal$1 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var didUpdate = props.didUpdate, getContainer2 = props.getContainer, children = props.children;
  var parentRef = React.useRef();
  var containerRef = React.useRef();
  React.useImperativeHandle(ref2, function() {
    return {};
  });
  var initRef = React.useRef(false);
  if (!initRef.current && canUseDom$f()) {
    containerRef.current = getContainer2();
    parentRef.current = containerRef.current.parentNode;
    initRef.current = true;
  }
  React.useEffect(function() {
    didUpdate === null || didUpdate === void 0 ? void 0 : didUpdate(props);
  });
  React.useEffect(function() {
    if (containerRef.current.parentNode === null && parentRef.current !== null) {
      parentRef.current.appendChild(containerRef.current);
    }
    return function() {
      var _containerRef$current, _containerRef$current2;
      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.parentNode) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.removeChild(containerRef.current);
    };
  }, []);
  return containerRef.current ? /* @__PURE__ */ ReactDOM.createPortal(children, containerRef.current) : null;
});
function isPointsEq$1(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }
  return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignFromPlacement$1(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return _objectSpread2$d(_objectSpread2$d({}, baseAlign), align);
}
function getAlignPopupClassName$1(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;
  var placements2 = Object.keys(builtinPlacements);
  for (var i = 0; i < placements2.length; i += 1) {
    var placement = placements2[i];
    if (isPointsEq$1(builtinPlacements[placement].points, points, isAlignPoint)) {
      return "".concat(prefixCls, "-placement-").concat(placement);
    }
  }
  return "";
}
var isMobile$2 = function() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
};
function getMotion$3(_ref2) {
  var prefixCls = _ref2.prefixCls, motion2 = _ref2.motion, animation = _ref2.animation, transitionName = _ref2.transitionName;
  if (motion2) {
    return motion2;
  }
  if (animation) {
    return {
      motionName: "".concat(prefixCls, "-").concat(animation)
    };
  }
  if (transitionName) {
    return {
      motionName: transitionName
    };
  }
  return null;
}
function Mask$2(props) {
  var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, mask = props.mask, maskMotion = props.maskMotion, maskAnimation = props.maskAnimation, maskTransitionName = props.maskTransitionName;
  if (!mask) {
    return null;
  }
  var motion2 = {};
  if (maskMotion || maskTransitionName || maskAnimation) {
    motion2 = _objectSpread2$d({
      motionAppear: true
    }, getMotion$3({
      motion: maskMotion,
      prefixCls,
      transitionName: maskTransitionName,
      animation: maskAnimation
    }));
  }
  return /* @__PURE__ */ React.createElement(CSSMotion, _extends$3({}, motion2, {
    visible,
    removeOnLeave: true
  }), function(_ref2) {
    var className = _ref2.className;
    return /* @__PURE__ */ React.createElement("div", {
      style: {
        zIndex
      },
      className: classNames("".concat(prefixCls, "-mask"), className)
    });
  });
}
var isVisible$2 = function(element2) {
  if (!element2) {
    return false;
  }
  if (element2 instanceof HTMLElement && element2.offsetParent) {
    return true;
  }
  if (element2 instanceof SVGGraphicsElement && element2.getBBox) {
    var _element$getBBox = element2.getBBox(), width = _element$getBBox.width, height = _element$getBBox.height;
    if (width || height) {
      return true;
    }
  }
  if (element2 instanceof HTMLElement && element2.getBoundingClientRect) {
    var _element$getBoundingC = element2.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
    if (_width || _height) {
      return true;
    }
  }
  return false;
};
function ownKeys(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$a(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$5 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$5(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var vendorPrefix;
var jsCssMap = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  ms: "-ms-",
  O: "-o-"
};
function getVendorPrefix() {
  if (vendorPrefix !== void 0) {
    return vendorPrefix;
  }
  vendorPrefix = "";
  var style2 = document.createElement("p").style;
  var testProp = "Transform";
  for (var key in jsCssMap) {
    if (key + testProp in style2) {
      vendorPrefix = key;
    }
  }
  return vendorPrefix;
}
function getTransitionName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
}
function getTransformName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
}
function setTransitionProperty(node2, value) {
  var name = getTransitionName();
  if (name) {
    node2.style[name] = value;
    if (name !== "transitionProperty") {
      node2.style.transitionProperty = value;
    }
  }
}
function setTransform(node2, value) {
  var name = getTransformName();
  if (name) {
    node2.style[name] = value;
    if (name !== "transform") {
      node2.style.transform = value;
    }
  }
}
function getTransitionProperty(node2) {
  return node2.style.transitionProperty || node2.style[getTransitionName()];
}
function getTransformXY(node2) {
  var style2 = window.getComputedStyle(node2, null);
  var transform3 = style2.getPropertyValue("transform") || style2.getPropertyValue(getTransformName());
  if (transform3 && transform3 !== "none") {
    var matrix = transform3.replace(/[^0-9\-.,]/g, "").split(",");
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node2, xy) {
  var style2 = window.getComputedStyle(node2, null);
  var transform3 = style2.getPropertyValue("transform") || style2.getPropertyValue(getTransformName());
  if (transform3 && transform3 !== "none") {
    var arr2;
    var match2d = transform3.match(matrix2d);
    if (match2d) {
      match2d = match2d[1];
      arr2 = match2d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr2[4] = xy.x;
      arr2[5] = xy.y;
      setTransform(node2, "matrix(".concat(arr2.join(","), ")"));
    } else {
      var match3d = transform3.match(matrix3d)[1];
      arr2 = match3d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr2[12] = xy.x;
      arr2[13] = xy.y;
      setTransform(node2, "matrix3d(".concat(arr2.join(","), ")"));
    }
  } else {
    setTransform(node2, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
  }
}
var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX;
function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = "none";
  elem.offsetHeight;
  elem.style.display = originalStyle;
}
function css(el, name, v2) {
  var value = v2;
  if (_typeof$5(name) === "object") {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }
    return void 0;
  }
  if (typeof value !== "undefined") {
    if (typeof value === "number") {
      value = "".concat(value, "px");
    }
    el.style[name] = value;
    return void 0;
  }
  return getComputedStyleX(el, name);
}
function getClientPosition(elem) {
  var box2;
  var x2;
  var y2;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  box2 = elem.getBoundingClientRect();
  x2 = Math.floor(box2.left);
  y2 = Math.floor(box2.top);
  x2 -= docElem.clientLeft || body.clientLeft || 0;
  y2 -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x2,
    top: y2
  };
}
function getScroll$1(w2, top) {
  var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
  var method4 = "scroll".concat(top ? "Top" : "Left");
  if (typeof ret !== "number") {
    var d2 = w2.document;
    ret = d2.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d2.body[method4];
    }
  }
  return ret;
}
function getScrollLeft(w2) {
  return getScroll$1(w2);
}
function getScrollTop(w2) {
  return getScroll$1(w2, true);
}
function getOffset$3(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w2 = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w2);
  pos.top += getScrollTop(w2);
  return pos;
}
function isWindow(obj) {
  return obj !== null && obj !== void 0 && obj == obj.window;
}
function getDocument(node2) {
  if (isWindow(node2)) {
    return node2.document;
  }
  if (node2.nodeType === 9) {
    return node2;
  }
  return node2.ownerDocument;
}
function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = "";
  var d2 = getDocument(elem);
  computedStyle = computedStyle || d2.defaultView.getComputedStyle(elem, null);
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }
  return val;
}
var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i");
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = "currentStyle";
var RUNTIME_STYLE = "runtimeStyle";
var LEFT$2 = "left";
var PX = "px";
function _getComputedStyleIE(elem, name) {
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    var style2 = elem.style;
    var left = style2[LEFT$2];
    var rsLeft = elem[RUNTIME_STYLE][LEFT$2];
    elem[RUNTIME_STYLE][LEFT$2] = elem[CURRENT_STYLE][LEFT$2];
    style2[LEFT$2] = name === "fontSize" ? "1em" : ret || 0;
    ret = style2.pixelLeft + PX;
    style2[LEFT$2] = left;
    elem[RUNTIME_STYLE][LEFT$2] = rsLeft;
  }
  return ret === "" ? "auto" : ret;
}
if (typeof window !== "undefined") {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}
function getOffsetDirection(dir, option) {
  if (dir === "left") {
    return option.useCssRight ? "right" : dir;
  }
  return option.useCssBottom ? "bottom" : dir;
}
function oppositeOffsetDirection(dir) {
  if (dir === "left") {
    return "right";
  } else if (dir === "right") {
    return "left";
  } else if (dir === "top") {
    return "bottom";
  } else if (dir === "bottom") {
    return "top";
  }
}
function setLeftTop(elem, offset3, option) {
  if (css(elem, "position") === "static") {
    elem.style.position = "relative";
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection("left", option);
  var verticalProperty = getOffsetDirection("top", option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
  if (horizontalProperty !== "left") {
    presetH = 999;
  }
  if (verticalProperty !== "top") {
    presetV = 999;
  }
  var originalTransition = "";
  var originalOffset = getOffset$3(elem);
  if ("left" in offset3 || "top" in offset3) {
    originalTransition = getTransitionProperty(elem) || "";
    setTransitionProperty(elem, "none");
  }
  if ("left" in offset3) {
    elem.style[oppositeHorizontalProperty] = "";
    elem.style[horizontalProperty] = "".concat(presetH, "px");
  }
  if ("top" in offset3) {
    elem.style[oppositeVerticalProperty] = "";
    elem.style[verticalProperty] = "".concat(presetV, "px");
  }
  forceRelayout(elem);
  var old = getOffset$3(elem);
  var originalStyle = {};
  for (var key in offset3) {
    if (offset3.hasOwnProperty(key)) {
      var dir = getOffsetDirection(key, option);
      var preset = key === "left" ? presetH : presetV;
      var off = originalOffset[key] - old[key];
      if (dir === key) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }
  css(elem, originalStyle);
  forceRelayout(elem);
  if ("left" in offset3 || "top" in offset3) {
    setTransitionProperty(elem, originalTransition);
  }
  var ret = {};
  for (var _key in offset3) {
    if (offset3.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);
      var _off = offset3[_key] - originalOffset[_key];
      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }
  css(elem, ret);
}
function setTransform$1(elem, offset3) {
  var originalOffset = getOffset$3(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };
  if ("left" in offset3) {
    resultXY.x = originalXY.x + offset3.left - originalOffset.left;
  }
  if ("top" in offset3) {
    resultXY.y = originalXY.y + offset3.top - originalOffset.top;
  }
  setTransformXY(elem, resultXY);
}
function setOffset(elem, offset3, option) {
  if (option.ignoreShake) {
    var oriOffset = getOffset$3(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset3.left.toFixed(0);
    var tTop = offset3.top.toFixed(0);
    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }
  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset3, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform$1(elem, offset3);
  } else {
    setLeftTop(elem, offset3, option);
  }
}
function each(arr2, fn2) {
  for (var i = 0; i < arr2.length; i++) {
    fn2(arr2[i]);
  }
}
function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, "boxSizing") === "border-box";
}
var BOX_MODELS = ["margin", "border", "padding"];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;
function swap(elem, options, callback) {
  var old = {};
  var style2 = elem.style;
  var name;
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style2[name];
      style2[name] = options[name];
    }
  }
  callback.call(elem);
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style2[name] = old[name];
    }
  }
}
function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop;
  var j2;
  var i;
  for (j2 = 0; j2 < props.length; j2++) {
    prop = props[j2];
    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = void 0;
        if (prop === "border") {
          cssProp = "".concat(prop).concat(which[i], "Width");
        } else {
          cssProp = prop + which[i];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}
var domUtils = {
  getParent: function getParent(element2) {
    var parent = element2;
    do {
      if (parent.nodeType === 11 && parent.host) {
        parent = parent.host;
      } else {
        parent = parent.parentNode;
      }
    } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);
    return parent;
  }
};
each(["Width", "Height"], function(name) {
  domUtils["doc".concat(name)] = function(refWin) {
    var d2 = refWin.document;
    return Math.max(
      d2.documentElement["scroll".concat(name)],
      d2.body["scroll".concat(name)],
      domUtils["viewport".concat(name)](d2)
    );
  };
  domUtils["viewport".concat(name)] = function(win) {
    var prop = "client".concat(name);
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    return doc.compatMode === "CSS1Compat" && documentElementProp || body && body[prop] || documentElementProp;
  };
});
function getWH(elem, name, ex) {
  var extra = ex;
  if (isWindow(elem)) {
    return name === "width" ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === "width" ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  var borderBoxValue = name === "width" ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === void 0 || borderBoxValue <= 0) {
    borderBoxValue = void 0;
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue === null || cssBoxValue === void 0 || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }
  if (extra === void 0) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== void 0 || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ["border", "padding"], which);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ["border"], which) : getPBMWidth(elem, ["margin"], which));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}
var cssShow = {
  position: "absolute",
  visibility: "hidden",
  display: "block"
};
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var val;
  var elem = args[0];
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(void 0, args);
  } else {
    swap(elem, cssShow, function() {
      val = getWH.apply(void 0, args);
    });
  }
  return val;
}
each(["width", "height"], function(name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);
  domUtils["outer".concat(first)] = function(el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  domUtils[name] = function(elem, v2) {
    var val = v2;
    if (val !== void 0) {
      if (elem) {
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ["padding", "border"], which);
        }
        return css(elem, name, val);
      }
      return void 0;
    }
    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});
function mix(to2, from2) {
  for (var i in from2) {
    if (from2.hasOwnProperty(i)) {
      to2[i] = from2[i];
    }
  }
  return to2;
}
var utils$2 = {
  getWindow: function getWindow(node2) {
    if (node2 && node2.document && node2.setTimeout) {
      return node2;
    }
    var doc = node2.ownerDocument || node2;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument,
  offset: function offset(el, value, option) {
    if (typeof value !== "undefined") {
      setOffset(el, value, option || {});
    } else {
      return getOffset$3(el);
    }
  },
  isWindow,
  each,
  css,
  clone: function clone(obj) {
    var i;
    var ret = {};
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }
    return ret;
  },
  mix,
  getWindowScrollLeft: function getWindowScrollLeft(w2) {
    return getScrollLeft(w2);
  },
  getWindowScrollTop: function getWindowScrollTop(w2) {
    return getScrollTop(w2);
  },
  merge: function merge() {
    var ret = {};
    for (var i = 0; i < arguments.length; i++) {
      utils$2.mix(ret, i < 0 || arguments.length <= i ? void 0 : arguments[i]);
    }
    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix(utils$2, domUtils);
var getParent2 = utils$2.getParent;
function getOffsetParent(element2) {
  if (utils$2.isWindow(element2) || element2.nodeType === 9) {
    return null;
  }
  var doc = utils$2.getDocument(element2);
  var body = doc.body;
  var parent;
  var positionStyle = utils$2.css(element2, "position");
  var skipStatic = positionStyle === "fixed" || positionStyle === "absolute";
  if (!skipStatic) {
    return element2.nodeName.toLowerCase() === "html" ? null : getParent2(element2);
  }
  for (parent = getParent2(element2); parent && parent !== body && parent.nodeType !== 9; parent = getParent2(parent)) {
    positionStyle = utils$2.css(parent, "position");
    if (positionStyle !== "static") {
      return parent;
    }
  }
  return null;
}
var getParent$1 = utils$2.getParent;
function isAncestorFixed(element2) {
  if (utils$2.isWindow(element2) || element2.nodeType === 9) {
    return false;
  }
  var doc = utils$2.getDocument(element2);
  var body = doc.body;
  var parent = null;
  for (parent = getParent$1(element2); parent && parent !== body && parent !== doc; parent = getParent$1(parent)) {
    var positionStyle = utils$2.css(parent, "position");
    if (positionStyle === "fixed") {
      return true;
    }
  }
  return false;
}
function getVisibleRectForElement(element2, alwaysByViewport) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = getOffsetParent(element2);
  var doc = utils$2.getDocument(element2);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement;
  while (el) {
    if ((navigator.userAgent.indexOf("MSIE") === -1 || el.clientWidth !== 0) && el !== body && el !== documentElement && utils$2.css(el, "overflow") !== "visible") {
      var pos = utils$2.offset(el);
      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(
        visibleRect.right,
        pos.left + el.clientWidth
      );
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }
    el = getOffsetParent(el);
  }
  var originalPosition = null;
  if (!utils$2.isWindow(element2) && element2.nodeType !== 9) {
    originalPosition = element2.style.position;
    var position2 = utils$2.css(element2, "position");
    if (position2 === "absolute") {
      element2.style.position = "fixed";
    }
  }
  var scrollX = utils$2.getWindowScrollLeft(win);
  var scrollY = utils$2.getWindowScrollTop(win);
  var viewportWidth = utils$2.viewportWidth(win);
  var viewportHeight = utils$2.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight;
  var bodyStyle = window.getComputedStyle(body);
  if (bodyStyle.overflowX === "hidden") {
    documentWidth = win.innerWidth;
  }
  if (bodyStyle.overflowY === "hidden") {
    documentHeight = win.innerHeight;
  }
  if (element2.style) {
    element2.style.position = originalPosition;
  }
  if (alwaysByViewport || isAncestorFixed(element2)) {
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}
function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = utils$2.clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };
  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  }
  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  }
  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  }
  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  }
  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  }
  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }
  return utils$2.mix(pos, size);
}
function getRegion(node2) {
  var offset3;
  var w2;
  var h2;
  if (!utils$2.isWindow(node2) && node2.nodeType !== 9) {
    offset3 = utils$2.offset(node2);
    w2 = utils$2.outerWidth(node2);
    h2 = utils$2.outerHeight(node2);
  } else {
    var win = utils$2.getWindow(node2);
    offset3 = {
      left: utils$2.getWindowScrollLeft(win),
      top: utils$2.getWindowScrollTop(win)
    };
    w2 = utils$2.viewportWidth(win);
    h2 = utils$2.viewportHeight(win);
  }
  offset3.width = w2;
  offset3.height = h2;
  return offset3;
}
function getAlignOffset(region, align) {
  var V2 = align.charAt(0);
  var H2 = align.charAt(1);
  var w2 = region.width;
  var h2 = region.height;
  var x2 = region.left;
  var y2 = region.top;
  if (V2 === "c") {
    y2 += h2 / 2;
  } else if (V2 === "b") {
    y2 += h2;
  }
  if (H2 === "c") {
    x2 += w2 / 2;
  } else if (H2 === "r") {
    x2 += w2;
  }
  return {
    left: x2,
    top: y2
  };
}
function getElFuturePos(elRegion, refNodeRegion, points, offset3, targetOffset2) {
  var p1 = getAlignOffset(refNodeRegion, points[1]);
  var p2 = getAlignOffset(elRegion, points[0]);
  var diff = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: Math.round(elRegion.left - diff[0] + offset3[0] - targetOffset2[0]),
    top: Math.round(elRegion.top - diff[1] + offset3[1] - targetOffset2[1])
  };
}
function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}
function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}
function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}
function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}
function flip(points, reg, map) {
  var ret = [];
  utils$2.each(points, function(p2) {
    ret.push(p2.replace(reg, function(m2) {
      return map[m2];
    }));
  });
  return ret;
}
function flipOffset(offset3, index2) {
  offset3[index2] = -offset3[index2];
  return offset3;
}
function convertOffset(str, offsetLen) {
  var n2;
  if (/%$/.test(str)) {
    n2 = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n2 = parseInt(str, 10);
  }
  return n2 || 0;
}
function normalizeOffset(offset3, el) {
  offset3[0] = convertOffset(offset3[0], el.width);
  offset3[1] = convertOffset(offset3[1], el.height);
}
function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
  var points = align.points;
  var offset3 = align.offset || [0, 0];
  var targetOffset2 = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source = align.source || el;
  offset3 = [].concat(offset3);
  targetOffset2 = [].concat(targetOffset2);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail = 0;
  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
  var visibleRect = getVisibleRectForElement(source, alwaysByViewport);
  var elRegion = getRegion(source);
  normalizeOffset(offset3, elRegion);
  normalizeOffset(targetOffset2, tgtRegion);
  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset3, targetOffset2);
  var newElRegion = utils$2.merge(elRegion, elFuturePos);
  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        var newPoints = flip(points, /[lr]/gi, {
          l: "r",
          r: "l"
        });
        var newOffset = flipOffset(offset3, 0);
        var newTargetOffset = flipOffset(targetOffset2, 0);
        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset3 = newOffset;
          targetOffset2 = newTargetOffset;
        }
      }
    }
    if (overflow.adjustY) {
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        var _newPoints = flip(points, /[tb]/gi, {
          t: "b",
          b: "t"
        });
        var _newOffset = flipOffset(offset3, 1);
        var _newTargetOffset = flipOffset(targetOffset2, 1);
        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = _newPoints;
          offset3 = _newOffset;
          targetOffset2 = _newTargetOffset;
        }
      }
    }
    if (fail) {
      elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset3, targetOffset2);
      utils$2.mix(newElRegion, elFuturePos);
    }
    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
    if (isStillFailX || isStillFailY) {
      var _newPoints2 = points;
      if (isStillFailX) {
        _newPoints2 = flip(points, /[lr]/gi, {
          l: "r",
          r: "l"
        });
      }
      if (isStillFailY) {
        _newPoints2 = flip(points, /[tb]/gi, {
          t: "b",
          b: "t"
        });
      }
      points = _newPoints2;
      offset3 = align.offset || [0, 0];
      targetOffset2 = align.targetOffset || [0, 0];
    }
    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  }
  if (newElRegion.width !== elRegion.width) {
    utils$2.css(source, "width", utils$2.width(source) + newElRegion.width - elRegion.width);
  }
  if (newElRegion.height !== elRegion.height) {
    utils$2.css(source, "height", utils$2.height(source) + newElRegion.height - elRegion.height);
  }
  utils$2.offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points,
    offset: offset3,
    targetOffset: targetOffset2,
    overflow: newOverflowCfg
  };
}
function isOutOfVisibleRect(target, alwaysByViewport) {
  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
  var targetRegion = getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}
function alignElement(el, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
  return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
}
alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;
function alignPoint(el, tgtPoint, align) {
  var pageX;
  var pageY;
  var doc = utils$2.getDocument(el);
  var win = doc.defaultView || doc.parentWindow;
  var scrollX = utils$2.getWindowScrollLeft(win);
  var scrollY = utils$2.getWindowScrollTop(win);
  var viewportWidth = utils$2.viewportWidth(win);
  var viewportHeight = utils$2.viewportHeight(win);
  if ("pageX" in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }
  if ("pageY" in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }
  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;
  var points = [align.points[0], "cc"];
  return doAlign(el, tgtRegion, _objectSpread2$a(_objectSpread2$a({}, align), {}, {
    points
  }), pointInView);
}
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$2(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$2;
var eq$1 = eq_1;
function assocIndexOf$4(array4, key) {
  var length2 = array4.length;
  while (length2--) {
    if (eq$1(array4[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data2 = this.__data__, index2 = assocIndexOf$3(data2, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data2 = this.__data__, index2 = assocIndexOf$2(data2, key);
  return index2 < 0 ? void 0 : data2[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  if (index2 < 0) {
    ++this.size;
    data2.push([key, value]);
  } else {
    data2[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data2 = this.__data__, result = data2["delete"](key);
  this.size = data2.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$8 = freeGlobal || freeSelf || Function("return this")();
var _root = root$8;
var root$7 = _root;
var Symbol$4 = root$7.Symbol;
var _Symbol = Symbol$4;
var Symbol$3 = _Symbol;
var objectProto$b = Object.prototype;
var hasOwnProperty$8 = objectProto$b.hasOwnProperty;
var nativeObjectToString$1 = objectProto$b.toString;
var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$a = Object.prototype;
var nativeObjectToString = objectProto$a.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$4(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$4;
function isObject$3(value) {
  var type4 = typeof value;
  return value != null && (type4 == "object" || type4 == "function");
}
var isObject_1 = isObject$3;
var baseGetTag$3 = _baseGetTag, isObject$2 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(value) {
  if (!isObject$2(value)) {
    return false;
  }
  var tag = baseGetTag$3(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$2;
var root$6 = _root;
var coreJsData$1 = root$6["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$1 = isFunction_1, isMasked = _isMasked, isObject$1 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$9 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern4 = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern4.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$2(object4, key) {
  return object4 == null ? void 0 : object4[key];
}
var _getValue = getValue$2;
var baseIsNative = _baseIsNative, getValue$1 = _getValue;
function getNative$6(object4, key) {
  var value = getValue$1(object4, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$6;
var getNative$5 = _getNative, root$5 = _root;
var Map$4 = getNative$5(root$5, "Map");
var _Map = Map$4;
var getNative$4 = _getNative;
var nativeCreate$4 = getNative$4(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashGet$1(key) {
  var data2 = this.__data__;
  if (nativeCreate$2) {
    var result = data2[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$6.call(data2, key) ? data2[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function hashHas$1(key) {
  var data2 = this.__data__;
  return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$5.call(data2, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type4 = typeof value;
  return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data2 = map.__data__;
  return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data2 = getMapData(this, key), size = data2.size;
  data2.set(key, value);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$2(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$2.prototype.clear = mapCacheClear;
MapCache$2.prototype["delete"] = mapCacheDelete;
MapCache$2.prototype.get = mapCacheGet;
MapCache$2.prototype.has = mapCacheHas;
MapCache$2.prototype.set = mapCacheSet;
var _MapCache = MapCache$2;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache$1) {
    var pairs = data2.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache$1(pairs);
  }
  data2.set(key, value);
  this.size = data2.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$1(entries) {
  var data2 = this.__data__ = new ListCache(entries);
  this.size = data2.size;
}
Stack$1.prototype.clear = stackClear;
Stack$1.prototype["delete"] = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$1(values) {
  var index2 = -1, length2 = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length2) {
    this.add(values[index2]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function arraySome$1(array4, predicate) {
  var index2 = -1, length2 = array4 == null ? 0 : array4.length;
  while (++index2 < length2) {
    if (predicate(array4[index2], index2, array4)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$1(cache2, key) {
  return cache2.has(key);
}
var _cacheHas = cacheHas$1;
var SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays$2(array4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array4.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array4);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array4;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  stack.set(array4, other);
  stack.set(other, array4);
  while (++index2 < arrLength) {
    var arrValue = array4[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack) : customizer(arrValue, othValue, index2, array4, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array4);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
var root$4 = _root;
var Uint8Array$2 = root$4.Uint8Array;
var _Uint8Array = Uint8Array$2;
function mapToArray$1(map) {
  var index2 = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$1;
var Symbol$1 = _Symbol, Uint8Array$1 = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag$1(object4, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$2:
      if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
        return false;
      }
      object4 = object4.buffer;
      other = other.buffer;
    case arrayBufferTag$1:
      if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object4), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      return eq(+object4, +other);
    case errorTag$1:
      return object4.name == other.name && object4.message == other.message;
    case regexpTag$1:
    case stringTag$1:
      return object4 == other + "";
    case mapTag$2:
      var convert2 = mapToArray;
    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert2 || (convert2 = setToArray);
      if (object4.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object4);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object4, other);
      var result = equalArrays$1(convert2(object4), convert2(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object4);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object4) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$1(array4, values) {
  var index2 = -1, length2 = values.length, offset3 = array4.length;
  while (++index2 < length2) {
    array4[offset3 + index2] = values[index2];
  }
  return array4;
}
var _arrayPush = arrayPush$1;
var isArray$3 = Array.isArray;
var isArray_1 = isArray$3;
var arrayPush = _arrayPush, isArray$2 = isArray_1;
function baseGetAllKeys$1(object4, keysFunc, symbolsFunc) {
  var result = keysFunc(object4);
  return isArray$2(object4) ? result : arrayPush(result, symbolsFunc(object4));
}
var _baseGetAllKeys = baseGetAllKeys$1;
function arrayFilter$1(array4, predicate) {
  var index2 = -1, length2 = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array4[index2];
    if (predicate(value, index2, array4)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$1() {
  return [];
}
var stubArray_1 = stubArray$1;
var arrayFilter = _arrayFilter, stubArray = stubArray_1;
var objectProto$6 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object4) {
  if (object4 == null) {
    return [];
  }
  object4 = Object(object4);
  return arrayFilter(nativeGetSymbols(object4), function(symbol) {
    return propertyIsEnumerable$1.call(object4, symbol);
  });
};
var _getSymbols = getSymbols$1;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$4(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$4;
var baseGetTag$2 = _baseGetTag, isObjectLike$3 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$3(value) && baseGetTag$2(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$2 = isObjectLike_1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
var isArguments$1 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$2(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_1 = isArguments$1;
var isBuffer$2 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module2, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer3 = nativeIsBuffer || stubFalse2;
  module2.exports = isBuffer3;
})(isBuffer$2, isBuffer$2.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value, length2) {
  var type4 = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
var _isIndex = isIndex$1;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2;
var baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$1 = isObjectLike_1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$2 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$1(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
(function(module2, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module2.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes, isArguments = isArguments_1, isArray$1 = isArray_1, isBuffer$1 = isBuffer$2.exports, isIndex = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$1(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$3 = Object.prototype;
function isPrototype$1(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$3;
  return value === proto;
}
var _isPrototype = isPrototype$1;
function overArg$1(func, transform3) {
  return function(arg) {
    return func(transform3(arg));
  };
}
var _overArg = overArg$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function baseKeys$1(object4) {
  if (!isPrototype(object4)) {
    return nativeKeys(object4);
  }
  var result = [];
  for (var key in Object(object4)) {
    if (hasOwnProperty$2.call(object4, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction = isFunction_1, isLength = isLength_1;
function isArrayLike$1(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
var isArrayLike_1 = isArrayLike$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike = isArrayLike_1;
function keys$1(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4) : baseKeys(object4);
}
var keys_1 = keys$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys = keys_1;
function getAllKeys$1(object4) {
  return baseGetAllKeys(object4, keys, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects$1(object4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object4), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object4);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object4;
  }
  var result = true;
  stack.set(object4, other);
  stack.set(other, object4);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object4[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object4, stack) : customizer(objValue, othValue, key, object4, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object4.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object4);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$3 = _getNative, root$3 = _root;
var DataView$2 = getNative$3(root$3, "DataView");
var _DataView = DataView$2;
var getNative$2 = _getNative, root$2 = _root;
var Promise$2 = getNative$2(root$2, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative, root$1 = _root;
var Set$2 = getNative$1(root$1, "Set");
var _Set = Set$2;
var getNative = _getNative, root = _root;
var WeakMap$2 = getNative(root, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView$1 = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag$1 = baseGetTag;
if (DataView$1 && getTag$1(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag) {
  getTag$1 = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var _getTag = getTag$1;
var Stack = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray2 = isArray_1, isBuffer2 = isBuffer$2.exports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep$1(object4, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray2(object4), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object4), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer2(object4)) {
    if (!isBuffer2(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object4, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike = isObjectLike_1;
function baseIsEqual$1(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$1, stack);
}
var _baseIsEqual = baseIsEqual$1;
var baseIsEqual = _baseIsEqual;
function isEqual$3(value, other) {
  return baseIsEqual(value, other);
}
var isEqual_1 = isEqual$3;
function isSamePoint(prev2, next2) {
  if (prev2 === next2)
    return true;
  if (!prev2 || !next2)
    return false;
  if ("pageX" in next2 && "pageY" in next2) {
    return prev2.pageX === next2.pageX && prev2.pageY === next2.pageY;
  }
  if ("clientX" in next2 && "clientY" in next2) {
    return prev2.clientX === next2.clientX && prev2.clientY === next2.clientY;
  }
  return false;
}
function restoreFocus(activeElement, container) {
  if (activeElement !== document.activeElement && contains$a(container, activeElement) && typeof activeElement.focus === "function") {
    activeElement.focus();
  }
}
function monitorResize(element2, callback) {
  var prevWidth = null;
  var prevHeight = null;
  function onResize2(_ref2) {
    var _ref22 = _slicedToArray$1(_ref2, 1), target = _ref22[0].target;
    if (!document.documentElement.contains(target))
      return;
    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
      Promise.resolve().then(function() {
        callback({
          width: fixedWidth,
          height: fixedHeight
        });
      });
    }
    prevWidth = fixedWidth;
    prevHeight = fixedHeight;
  }
  var resizeObserver2 = new index(onResize2);
  if (element2) {
    resizeObserver2.observe(element2);
  }
  return function() {
    resizeObserver2.disconnect();
  };
}
var useBuffer = function(callback, buffer) {
  var calledRef = React.useRef(false);
  var timeoutRef = React.useRef(null);
  function cancelTrigger() {
    window.clearTimeout(timeoutRef.current);
  }
  function trigger(force) {
    cancelTrigger();
    if (!calledRef.current || force === true) {
      if (callback() === false) {
        return;
      }
      calledRef.current = true;
      timeoutRef.current = window.setTimeout(function() {
        calledRef.current = false;
      }, buffer);
    } else {
      timeoutRef.current = window.setTimeout(function() {
        calledRef.current = false;
        trigger();
      }, buffer);
    }
  }
  return [trigger, function() {
    calledRef.current = false;
    cancelTrigger();
  }];
};
function getElement(func) {
  if (typeof func !== "function")
    return null;
  return func();
}
function getPoint(point2) {
  if (_typeof$8(point2) !== "object" || !point2)
    return null;
  return point2;
}
var Align = function Align2(_ref2, ref2) {
  var children = _ref2.children, disabled = _ref2.disabled, target = _ref2.target, align = _ref2.align, onAlign = _ref2.onAlign, monitorWindowResize = _ref2.monitorWindowResize, _ref$monitorBufferTim = _ref2.monitorBufferTime, monitorBufferTime = _ref$monitorBufferTim === void 0 ? 0 : _ref$monitorBufferTim;
  var cacheRef = React.useRef({});
  var nodeRef = React.useRef();
  var childNode = React.Children.only(children);
  var forceAlignPropsRef = React.useRef({});
  forceAlignPropsRef.current.disabled = disabled;
  forceAlignPropsRef.current.target = target;
  forceAlignPropsRef.current.align = align;
  forceAlignPropsRef.current.onAlign = onAlign;
  var _useBuffer = useBuffer(function() {
    var _forceAlignPropsRef$c = forceAlignPropsRef.current, latestDisabled = _forceAlignPropsRef$c.disabled, latestTarget = _forceAlignPropsRef$c.target, latestAlign = _forceAlignPropsRef$c.align, latestOnAlign = _forceAlignPropsRef$c.onAlign;
    if (!latestDisabled && latestTarget) {
      var source = nodeRef.current;
      var result;
      var element2 = getElement(latestTarget);
      var point2 = getPoint(latestTarget);
      cacheRef.current.element = element2;
      cacheRef.current.point = point2;
      cacheRef.current.align = latestAlign;
      var _document = document, activeElement = _document.activeElement;
      if (element2 && isVisible$2(element2)) {
        result = alignElement(source, element2, latestAlign);
      } else if (point2) {
        result = alignPoint(source, point2, latestAlign);
      }
      restoreFocus(activeElement, source);
      if (latestOnAlign && result) {
        latestOnAlign(source, result);
      }
      return true;
    }
    return false;
  }, monitorBufferTime), _useBuffer2 = _slicedToArray$1(_useBuffer, 2), _forceAlign = _useBuffer2[0], cancelForceAlign = _useBuffer2[1];
  var resizeMonitor = React.useRef({
    cancel: function cancel() {
    }
  });
  var sourceResizeMonitor = React.useRef({
    cancel: function cancel() {
    }
  });
  React.useEffect(function() {
    var element2 = getElement(target);
    var point2 = getPoint(target);
    if (nodeRef.current !== sourceResizeMonitor.current.element) {
      sourceResizeMonitor.current.cancel();
      sourceResizeMonitor.current.element = nodeRef.current;
      sourceResizeMonitor.current.cancel = monitorResize(nodeRef.current, _forceAlign);
    }
    if (cacheRef.current.element !== element2 || !isSamePoint(cacheRef.current.point, point2) || !isEqual_1(cacheRef.current.align, align)) {
      _forceAlign();
      if (resizeMonitor.current.element !== element2) {
        resizeMonitor.current.cancel();
        resizeMonitor.current.element = element2;
        resizeMonitor.current.cancel = monitorResize(element2, _forceAlign);
      }
    }
  });
  React.useEffect(function() {
    if (!disabled) {
      _forceAlign();
    } else {
      cancelForceAlign();
    }
  }, [disabled]);
  var winResizeRef = React.useRef(null);
  React.useEffect(function() {
    if (monitorWindowResize) {
      if (!winResizeRef.current) {
        winResizeRef.current = addEventListenerWrap$1(window, "resize", _forceAlign);
      }
    } else if (winResizeRef.current) {
      winResizeRef.current.remove();
      winResizeRef.current = null;
    }
  }, [monitorWindowResize]);
  React.useEffect(function() {
    return function() {
      resizeMonitor.current.cancel();
      sourceResizeMonitor.current.cancel();
      if (winResizeRef.current)
        winResizeRef.current.remove();
      cancelForceAlign();
    };
  }, []);
  React.useImperativeHandle(ref2, function() {
    return {
      forceAlign: function forceAlign() {
        return _forceAlign(true);
      }
    };
  });
  if (/* @__PURE__ */ React.isValidElement(childNode)) {
    childNode = /* @__PURE__ */ React.cloneElement(childNode, {
      ref: composeRef$7(childNode.ref, nodeRef)
    });
  }
  return childNode;
};
var RcAlign = /* @__PURE__ */ React.forwardRef(Align);
RcAlign.displayName = "Align";
var StatusQueue$1 = ["measure", "alignPre", "align", null, "motion"];
var useVisibleStatus$1 = function(visible, doMeasure) {
  var _useState = useSafeState$4(null), _useState2 = _slicedToArray$1(_useState, 2), status = _useState2[0], setInternalStatus = _useState2[1];
  var rafRef = React.useRef();
  function setStatus(nextStatus) {
    setInternalStatus(nextStatus, true);
  }
  function cancelRaf() {
    wrapperRaf$6.cancel(rafRef.current);
  }
  function goNextStatus(callback) {
    cancelRaf();
    rafRef.current = wrapperRaf$6(function() {
      setStatus(function(prev2) {
        switch (status) {
          case "align":
            return "motion";
          case "motion":
            return "stable";
        }
        return prev2;
      });
      callback === null || callback === void 0 ? void 0 : callback();
    });
  }
  React.useEffect(function() {
    setStatus("measure");
  }, [visible]);
  React.useEffect(function() {
    switch (status) {
      case "measure":
        doMeasure();
        break;
    }
    if (status) {
      rafRef.current = wrapperRaf$6(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
        var index2, nextStatus;
        return _regeneratorRuntime().wrap(function _callee$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                index2 = StatusQueue$1.indexOf(status);
                nextStatus = StatusQueue$1[index2 + 1];
                if (nextStatus && index2 !== -1) {
                  setStatus(nextStatus);
                }
              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee);
      })));
    }
  }, [status]);
  React.useEffect(function() {
    return function() {
      cancelRaf();
    };
  }, []);
  return [status, goNextStatus];
};
var useStretchStyle$1 = function(stretch) {
  var _React$useState = React.useState({
    width: 0,
    height: 0
  }), _React$useState2 = _slicedToArray$1(_React$useState, 2), targetSize = _React$useState2[0], setTargetSize = _React$useState2[1];
  function measureStretch(element2) {
    setTargetSize({
      width: element2.offsetWidth,
      height: element2.offsetHeight
    });
  }
  var style2 = React.useMemo(function() {
    var sizeStyle = {};
    if (stretch) {
      var width = targetSize.width, height = targetSize.height;
      if (stretch.indexOf("height") !== -1 && height) {
        sizeStyle.height = height;
      } else if (stretch.indexOf("minHeight") !== -1 && height) {
        sizeStyle.minHeight = height;
      }
      if (stretch.indexOf("width") !== -1 && width) {
        sizeStyle.width = width;
      } else if (stretch.indexOf("minWidth") !== -1 && width) {
        sizeStyle.minWidth = width;
      }
    }
    return sizeStyle;
  }, [stretch, targetSize]);
  return [style2, measureStretch];
};
var PopupInner$1 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var visible = props.visible, prefixCls = props.prefixCls, className = props.className, style2 = props.style, children = props.children, zIndex = props.zIndex, stretch = props.stretch, destroyPopupOnHide = props.destroyPopupOnHide, forceRender = props.forceRender, align = props.align, point2 = props.point, getRootDomNode = props.getRootDomNode, getClassNameFromAlign = props.getClassNameFromAlign, onAlign = props.onAlign, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onMouseDown = props.onMouseDown, onTouchStart = props.onTouchStart, onClick = props.onClick;
  var alignRef = React.useRef();
  var elementRef = React.useRef();
  var _useState = React.useState(), _useState2 = _slicedToArray$1(_useState, 2), alignedClassName = _useState2[0], setAlignedClassName = _useState2[1];
  var _useStretchStyle = useStretchStyle$1(stretch), _useStretchStyle2 = _slicedToArray$1(_useStretchStyle, 2), stretchStyle = _useStretchStyle2[0], measureStretchStyle = _useStretchStyle2[1];
  function doMeasure() {
    if (stretch) {
      measureStretchStyle(getRootDomNode());
    }
  }
  var _useVisibleStatus = useVisibleStatus$1(visible, doMeasure), _useVisibleStatus2 = _slicedToArray$1(_useVisibleStatus, 2), status = _useVisibleStatus2[0], goNextStatus = _useVisibleStatus2[1];
  var _useState3 = React.useState(0), _useState4 = _slicedToArray$1(_useState3, 2), alignTimes = _useState4[0], setAlignTimes = _useState4[1];
  var prepareResolveRef = React.useRef();
  useLayoutEffect$8(function() {
    if (status === "alignPre") {
      setAlignTimes(0);
    }
  }, [status]);
  function getAlignTarget() {
    if (point2) {
      return point2;
    }
    return getRootDomNode;
  }
  function forceAlign() {
    var _alignRef$current;
    (_alignRef$current = alignRef.current) === null || _alignRef$current === void 0 ? void 0 : _alignRef$current.forceAlign();
  }
  function onInternalAlign(popupDomNode, matchAlign) {
    var nextAlignedClassName = getClassNameFromAlign(matchAlign);
    if (alignedClassName !== nextAlignedClassName) {
      setAlignedClassName(nextAlignedClassName);
    }
    setAlignTimes(function(val) {
      return val + 1;
    });
    if (status === "align") {
      onAlign === null || onAlign === void 0 ? void 0 : onAlign(popupDomNode, matchAlign);
    }
  }
  useLayoutEffect$8(function() {
    if (status === "align") {
      if (alignTimes < 2) {
        forceAlign();
      } else {
        goNextStatus(function() {
          var _prepareResolveRef$cu;
          (_prepareResolveRef$cu = prepareResolveRef.current) === null || _prepareResolveRef$cu === void 0 ? void 0 : _prepareResolveRef$cu.call(prepareResolveRef);
        });
      }
    }
  }, [alignTimes]);
  var motion2 = _objectSpread2$d({}, getMotion$3(props));
  ["onAppearEnd", "onEnterEnd", "onLeaveEnd"].forEach(function(eventName) {
    var originHandler = motion2[eventName];
    motion2[eventName] = function(element2, event) {
      goNextStatus();
      return originHandler === null || originHandler === void 0 ? void 0 : originHandler(element2, event);
    };
  });
  function onShowPrepare() {
    return new Promise(function(resolve) {
      prepareResolveRef.current = resolve;
    });
  }
  React.useEffect(function() {
    if (!motion2.motionName && status === "motion") {
      goNextStatus();
    }
  }, [motion2.motionName, status]);
  React.useImperativeHandle(ref2, function() {
    return {
      forceAlign,
      getElement: function getElement2() {
        return elementRef.current;
      }
    };
  });
  var mergedStyle = _objectSpread2$d(_objectSpread2$d({}, stretchStyle), {}, {
    zIndex,
    opacity: status === "motion" || status === "stable" || !visible ? void 0 : 0,
    pointerEvents: !visible && status !== "stable" ? "none" : void 0
  }, style2);
  var alignDisabled = true;
  if ((align === null || align === void 0 ? void 0 : align.points) && (status === "align" || status === "stable")) {
    alignDisabled = false;
  }
  var childNode = children;
  if (React.Children.count(children) > 1) {
    childNode = /* @__PURE__ */ React.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, children);
  }
  return /* @__PURE__ */ React.createElement(CSSMotion, _extends$3({
    visible,
    ref: elementRef,
    leavedClassName: "".concat(prefixCls, "-hidden")
  }, motion2, {
    onAppearPrepare: onShowPrepare,
    onEnterPrepare: onShowPrepare,
    removeOnLeave: destroyPopupOnHide,
    forceRender
  }), function(_ref2, motionRef) {
    var motionClassName = _ref2.className, motionStyle = _ref2.style;
    var mergedClassName = classNames(prefixCls, className, alignedClassName, motionClassName);
    return /* @__PURE__ */ React.createElement(RcAlign, {
      target: getAlignTarget(),
      key: "popup",
      ref: alignRef,
      monitorWindowResize: true,
      disabled: alignDisabled,
      align,
      onAlign: onInternalAlign
    }, /* @__PURE__ */ React.createElement("div", {
      ref: motionRef,
      className: mergedClassName,
      onMouseEnter,
      onMouseLeave,
      onMouseDownCapture: onMouseDown,
      onTouchStartCapture: onTouchStart,
      onClick,
      style: _objectSpread2$d(_objectSpread2$d({}, motionStyle), mergedStyle)
    }, childNode));
  });
});
PopupInner$1.displayName = "PopupInner";
var MobilePopupInner$1 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, children = props.children, _props$mobile = props.mobile;
  _props$mobile = _props$mobile === void 0 ? {} : _props$mobile;
  var popupClassName = _props$mobile.popupClassName, popupStyle = _props$mobile.popupStyle, _props$mobile$popupMo = _props$mobile.popupMotion, popupMotion = _props$mobile$popupMo === void 0 ? {} : _props$mobile$popupMo, popupRender = _props$mobile.popupRender, onClick = props.onClick;
  var elementRef = React.useRef();
  React.useImperativeHandle(ref2, function() {
    return {
      forceAlign: function forceAlign() {
      },
      getElement: function getElement2() {
        return elementRef.current;
      }
    };
  });
  var mergedStyle = _objectSpread2$d({
    zIndex
  }, popupStyle);
  var childNode = children;
  if (React.Children.count(children) > 1) {
    childNode = /* @__PURE__ */ React.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, children);
  }
  if (popupRender) {
    childNode = popupRender(childNode);
  }
  return /* @__PURE__ */ React.createElement(CSSMotion, _extends$3({
    visible,
    ref: elementRef,
    removeOnLeave: true
  }, popupMotion), function(_ref2, motionRef) {
    var motionClassName = _ref2.className, motionStyle = _ref2.style;
    var mergedClassName = classNames(prefixCls, popupClassName, motionClassName);
    return /* @__PURE__ */ React.createElement("div", {
      ref: motionRef,
      className: mergedClassName,
      onClick,
      style: _objectSpread2$d(_objectSpread2$d({}, motionStyle), mergedStyle)
    }, childNode);
  });
});
MobilePopupInner$1.displayName = "MobilePopupInner";
var _excluded$y = ["visible", "mobile"];
var Popup$1 = /* @__PURE__ */ React.forwardRef(function(_ref2, ref2) {
  var visible = _ref2.visible, mobile = _ref2.mobile, props = _objectWithoutProperties$1(_ref2, _excluded$y);
  var _useState = React.useState(visible), _useState2 = _slicedToArray$1(_useState, 2), innerVisible = _useState2[0], serInnerVisible = _useState2[1];
  var _useState3 = React.useState(false), _useState4 = _slicedToArray$1(_useState3, 2), inMobile = _useState4[0], setInMobile = _useState4[1];
  var cloneProps = _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    visible: innerVisible
  });
  React.useEffect(function() {
    serInnerVisible(visible);
    if (visible && mobile) {
      setInMobile(isMobile$2());
    }
  }, [visible, mobile]);
  var popupNode = inMobile ? /* @__PURE__ */ React.createElement(MobilePopupInner$1, _extends$3({}, cloneProps, {
    mobile,
    ref: ref2
  })) : /* @__PURE__ */ React.createElement(PopupInner$1, _extends$3({}, cloneProps, {
    ref: ref2
  }));
  return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(Mask$2, cloneProps), popupNode);
});
Popup$1.displayName = "Popup";
var TriggerContext$1 = /* @__PURE__ */ React.createContext(null);
function noop$3() {
}
function returnEmptyString$1() {
  return "";
}
function returnDocument$1(element2) {
  if (element2) {
    return element2.ownerDocument;
  }
  return window.document;
}
var ALL_HANDLERS$1 = ["onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur", "onContextMenu"];
function generateTrigger$1(PortalComponent) {
  var Trigger2 = /* @__PURE__ */ function(_React$Component) {
    _inherits$2(Trigger3, _React$Component);
    var _super = _createSuper$2(Trigger3);
    function Trigger3(props) {
      var _this;
      _classCallCheck$2(this, Trigger3);
      _this = _super.call(this, props);
      _this.popupRef = /* @__PURE__ */ React.createRef();
      _this.triggerRef = /* @__PURE__ */ React.createRef();
      _this.portalContainer = void 0;
      _this.attachId = void 0;
      _this.clickOutsideHandler = void 0;
      _this.touchOutsideHandler = void 0;
      _this.contextMenuOutsideHandler1 = void 0;
      _this.contextMenuOutsideHandler2 = void 0;
      _this.mouseDownTimeout = void 0;
      _this.focusTime = void 0;
      _this.preClickTime = void 0;
      _this.preTouchTime = void 0;
      _this.delayTimer = void 0;
      _this.hasPopupMouseDown = void 0;
      _this.onMouseEnter = function(e2) {
        var mouseEnterDelay = _this.props.mouseEnterDelay;
        _this.fireEvents("onMouseEnter", e2);
        _this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e2);
      };
      _this.onMouseMove = function(e2) {
        _this.fireEvents("onMouseMove", e2);
        _this.setPoint(e2);
      };
      _this.onMouseLeave = function(e2) {
        _this.fireEvents("onMouseLeave", e2);
        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      };
      _this.onPopupMouseEnter = function() {
        _this.clearDelayTimer();
      };
      _this.onPopupMouseLeave = function(e2) {
        var _this$popupRef$curren;
        if (e2.relatedTarget && !e2.relatedTarget.setTimeout && contains$a((_this$popupRef$curren = _this.popupRef.current) === null || _this$popupRef$curren === void 0 ? void 0 : _this$popupRef$curren.getElement(), e2.relatedTarget)) {
          return;
        }
        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      };
      _this.onFocus = function(e2) {
        _this.fireEvents("onFocus", e2);
        _this.clearDelayTimer();
        if (_this.isFocusToShow()) {
          _this.focusTime = Date.now();
          _this.delaySetPopupVisible(true, _this.props.focusDelay);
        }
      };
      _this.onMouseDown = function(e2) {
        _this.fireEvents("onMouseDown", e2);
        _this.preClickTime = Date.now();
      };
      _this.onTouchStart = function(e2) {
        _this.fireEvents("onTouchStart", e2);
        _this.preTouchTime = Date.now();
      };
      _this.onBlur = function(e2) {
        _this.fireEvents("onBlur", e2);
        _this.clearDelayTimer();
        if (_this.isBlurToHide()) {
          _this.delaySetPopupVisible(false, _this.props.blurDelay);
        }
      };
      _this.onContextMenu = function(e2) {
        e2.preventDefault();
        _this.fireEvents("onContextMenu", e2);
        _this.setPopupVisible(true, e2);
      };
      _this.onContextMenuClose = function() {
        if (_this.isContextMenuToShow()) {
          _this.close();
        }
      };
      _this.onClick = function(event) {
        _this.fireEvents("onClick", event);
        if (_this.focusTime) {
          var preTime;
          if (_this.preClickTime && _this.preTouchTime) {
            preTime = Math.min(_this.preClickTime, _this.preTouchTime);
          } else if (_this.preClickTime) {
            preTime = _this.preClickTime;
          } else if (_this.preTouchTime) {
            preTime = _this.preTouchTime;
          }
          if (Math.abs(preTime - _this.focusTime) < 20) {
            return;
          }
          _this.focusTime = 0;
        }
        _this.preClickTime = 0;
        _this.preTouchTime = 0;
        if (_this.isClickToShow() && (_this.isClickToHide() || _this.isBlurToHide()) && event && event.preventDefault) {
          event.preventDefault();
        }
        var nextVisible = !_this.state.popupVisible;
        if (_this.isClickToHide() && !nextVisible || nextVisible && _this.isClickToShow()) {
          _this.setPopupVisible(!_this.state.popupVisible, event);
        }
      };
      _this.onPopupMouseDown = function() {
        _this.hasPopupMouseDown = true;
        clearTimeout(_this.mouseDownTimeout);
        _this.mouseDownTimeout = window.setTimeout(function() {
          _this.hasPopupMouseDown = false;
        }, 0);
        if (_this.context) {
          var _this$context;
          (_this$context = _this.context).onPopupMouseDown.apply(_this$context, arguments);
        }
      };
      _this.onDocumentClick = function(event) {
        if (_this.props.mask && !_this.props.maskClosable) {
          return;
        }
        var target = event.target;
        var root2 = _this.getRootDomNode();
        var popupNode = _this.getPopupDomNode();
        if ((!contains$a(root2, target) || _this.isContextMenuOnly()) && !contains$a(popupNode, target) && !_this.hasPopupMouseDown) {
          _this.close();
        }
      };
      _this.getRootDomNode = function() {
        var getTriggerDOMNode = _this.props.getTriggerDOMNode;
        if (getTriggerDOMNode) {
          return getTriggerDOMNode(_this.triggerRef.current);
        }
        try {
          var domNode = findDOMNode$3(_this.triggerRef.current);
          if (domNode) {
            return domNode;
          }
        } catch (err) {
        }
        return ReactDOM.findDOMNode(_assertThisInitialized$2(_this));
      };
      _this.getPopupClassNameFromAlign = function(align) {
        var className = [];
        var _this$props = _this.props, popupPlacement = _this$props.popupPlacement, builtinPlacements = _this$props.builtinPlacements, prefixCls = _this$props.prefixCls, alignPoint2 = _this$props.alignPoint, getPopupClassNameFromAlign = _this$props.getPopupClassNameFromAlign;
        if (popupPlacement && builtinPlacements) {
          className.push(getAlignPopupClassName$1(builtinPlacements, prefixCls, align, alignPoint2));
        }
        if (getPopupClassNameFromAlign) {
          className.push(getPopupClassNameFromAlign(align));
        }
        return className.join(" ");
      };
      _this.getComponent = function() {
        var _this$props2 = _this.props, prefixCls = _this$props2.prefixCls, destroyPopupOnHide = _this$props2.destroyPopupOnHide, popupClassName = _this$props2.popupClassName, onPopupAlign = _this$props2.onPopupAlign, popupMotion = _this$props2.popupMotion, popupAnimation = _this$props2.popupAnimation, popupTransitionName = _this$props2.popupTransitionName, popupStyle = _this$props2.popupStyle, mask = _this$props2.mask, maskAnimation = _this$props2.maskAnimation, maskTransitionName = _this$props2.maskTransitionName, maskMotion = _this$props2.maskMotion, zIndex = _this$props2.zIndex, popup = _this$props2.popup, stretch = _this$props2.stretch, alignPoint2 = _this$props2.alignPoint, mobile = _this$props2.mobile, forceRender = _this$props2.forceRender, onPopupClick = _this$props2.onPopupClick;
        var _this$state = _this.state, popupVisible = _this$state.popupVisible, point2 = _this$state.point;
        var align = _this.getPopupAlign();
        var mouseProps = {};
        if (_this.isMouseEnterToShow()) {
          mouseProps.onMouseEnter = _this.onPopupMouseEnter;
        }
        if (_this.isMouseLeaveToHide()) {
          mouseProps.onMouseLeave = _this.onPopupMouseLeave;
        }
        mouseProps.onMouseDown = _this.onPopupMouseDown;
        mouseProps.onTouchStart = _this.onPopupMouseDown;
        return /* @__PURE__ */ React.createElement(Popup$1, _extends$3({
          prefixCls,
          destroyPopupOnHide,
          visible: popupVisible,
          point: alignPoint2 && point2,
          className: popupClassName,
          align,
          onAlign: onPopupAlign,
          animation: popupAnimation,
          getClassNameFromAlign: _this.getPopupClassNameFromAlign
        }, mouseProps, {
          stretch,
          getRootDomNode: _this.getRootDomNode,
          style: popupStyle,
          mask,
          zIndex,
          transitionName: popupTransitionName,
          maskAnimation,
          maskTransitionName,
          maskMotion,
          ref: _this.popupRef,
          motion: popupMotion,
          mobile,
          forceRender,
          onClick: onPopupClick
        }), typeof popup === "function" ? popup() : popup);
      };
      _this.attachParent = function(popupContainer) {
        wrapperRaf$6.cancel(_this.attachId);
        var _this$props3 = _this.props, getPopupContainer = _this$props3.getPopupContainer, getDocument2 = _this$props3.getDocument;
        var domNode = _this.getRootDomNode();
        var mountNode;
        if (!getPopupContainer) {
          mountNode = getDocument2(_this.getRootDomNode()).body;
        } else if (domNode || getPopupContainer.length === 0) {
          mountNode = getPopupContainer(domNode);
        }
        if (mountNode) {
          mountNode.appendChild(popupContainer);
        } else {
          _this.attachId = wrapperRaf$6(function() {
            _this.attachParent(popupContainer);
          });
        }
      };
      _this.getContainer = function() {
        if (!_this.portalContainer) {
          var getDocument2 = _this.props.getDocument;
          var popupContainer = getDocument2(_this.getRootDomNode()).createElement("div");
          popupContainer.style.position = "absolute";
          popupContainer.style.top = "0";
          popupContainer.style.left = "0";
          popupContainer.style.width = "100%";
          _this.portalContainer = popupContainer;
        }
        _this.attachParent(_this.portalContainer);
        return _this.portalContainer;
      };
      _this.setPoint = function(point2) {
        var alignPoint2 = _this.props.alignPoint;
        if (!alignPoint2 || !point2)
          return;
        _this.setState({
          point: {
            pageX: point2.pageX,
            pageY: point2.pageY
          }
        });
      };
      _this.handlePortalUpdate = function() {
        if (_this.state.prevPopupVisible !== _this.state.popupVisible) {
          _this.props.afterPopupVisibleChange(_this.state.popupVisible);
        }
      };
      _this.triggerContextValue = {
        onPopupMouseDown: _this.onPopupMouseDown
      };
      var _popupVisible;
      if ("popupVisible" in props) {
        _popupVisible = !!props.popupVisible;
      } else {
        _popupVisible = !!props.defaultPopupVisible;
      }
      _this.state = {
        prevPopupVisible: _popupVisible,
        popupVisible: _popupVisible
      };
      ALL_HANDLERS$1.forEach(function(h2) {
        _this["fire".concat(h2)] = function(e2) {
          _this.fireEvents(h2, e2);
        };
      });
      return _this;
    }
    _createClass$2(Trigger3, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.componentDidUpdate();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var props = this.props;
        var state = this.state;
        if (state.popupVisible) {
          var currentDocument;
          if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow())) {
            currentDocument = props.getDocument(this.getRootDomNode());
            this.clickOutsideHandler = addEventListenerWrap$1(currentDocument, "mousedown", this.onDocumentClick);
          }
          if (!this.touchOutsideHandler) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.touchOutsideHandler = addEventListenerWrap$1(currentDocument, "touchstart", this.onDocumentClick);
          }
          if (!this.contextMenuOutsideHandler1 && this.isContextMenuToShow()) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.contextMenuOutsideHandler1 = addEventListenerWrap$1(currentDocument, "scroll", this.onContextMenuClose);
          }
          if (!this.contextMenuOutsideHandler2 && this.isContextMenuToShow()) {
            this.contextMenuOutsideHandler2 = addEventListenerWrap$1(window, "blur", this.onContextMenuClose);
          }
          return;
        }
        this.clearOutsideHandler();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.clearDelayTimer();
        this.clearOutsideHandler();
        clearTimeout(this.mouseDownTimeout);
        wrapperRaf$6.cancel(this.attachId);
      }
    }, {
      key: "getPopupDomNode",
      value: function getPopupDomNode() {
        var _this$popupRef$curren2;
        return ((_this$popupRef$curren2 = this.popupRef.current) === null || _this$popupRef$curren2 === void 0 ? void 0 : _this$popupRef$curren2.getElement()) || null;
      }
    }, {
      key: "getPopupAlign",
      value: function getPopupAlign() {
        var props = this.props;
        var popupPlacement = props.popupPlacement, popupAlign = props.popupAlign, builtinPlacements = props.builtinPlacements;
        if (popupPlacement && builtinPlacements) {
          return getAlignFromPlacement$1(builtinPlacements, popupPlacement, popupAlign);
        }
        return popupAlign;
      }
    }, {
      key: "setPopupVisible",
      value: function setPopupVisible(popupVisible, event) {
        var alignPoint2 = this.props.alignPoint;
        var prevPopupVisible = this.state.popupVisible;
        this.clearDelayTimer();
        if (prevPopupVisible !== popupVisible) {
          if (!("popupVisible" in this.props)) {
            this.setState({
              popupVisible,
              prevPopupVisible
            });
          }
          this.props.onPopupVisibleChange(popupVisible);
        }
        if (alignPoint2 && event && popupVisible) {
          this.setPoint(event);
        }
      }
    }, {
      key: "delaySetPopupVisible",
      value: function delaySetPopupVisible(visible, delayS, event) {
        var _this2 = this;
        var delay = delayS * 1e3;
        this.clearDelayTimer();
        if (delay) {
          var point2 = event ? {
            pageX: event.pageX,
            pageY: event.pageY
          } : null;
          this.delayTimer = window.setTimeout(function() {
            _this2.setPopupVisible(visible, point2);
            _this2.clearDelayTimer();
          }, delay);
        } else {
          this.setPopupVisible(visible, event);
        }
      }
    }, {
      key: "clearDelayTimer",
      value: function clearDelayTimer() {
        if (this.delayTimer) {
          clearTimeout(this.delayTimer);
          this.delayTimer = null;
        }
      }
    }, {
      key: "clearOutsideHandler",
      value: function clearOutsideHandler() {
        if (this.clickOutsideHandler) {
          this.clickOutsideHandler.remove();
          this.clickOutsideHandler = null;
        }
        if (this.contextMenuOutsideHandler1) {
          this.contextMenuOutsideHandler1.remove();
          this.contextMenuOutsideHandler1 = null;
        }
        if (this.contextMenuOutsideHandler2) {
          this.contextMenuOutsideHandler2.remove();
          this.contextMenuOutsideHandler2 = null;
        }
        if (this.touchOutsideHandler) {
          this.touchOutsideHandler.remove();
          this.touchOutsideHandler = null;
        }
      }
    }, {
      key: "createTwoChains",
      value: function createTwoChains(event) {
        var childPros = this.props.children.props;
        var props = this.props;
        if (childPros[event] && props[event]) {
          return this["fire".concat(event)];
        }
        return childPros[event] || props[event];
      }
    }, {
      key: "isClickToShow",
      value: function isClickToShow() {
        var _this$props4 = this.props, action = _this$props4.action, showAction = _this$props4.showAction;
        return action.indexOf("click") !== -1 || showAction.indexOf("click") !== -1;
      }
    }, {
      key: "isContextMenuOnly",
      value: function isContextMenuOnly() {
        var action = this.props.action;
        return action === "contextMenu" || action.length === 1 && action[0] === "contextMenu";
      }
    }, {
      key: "isContextMenuToShow",
      value: function isContextMenuToShow() {
        var _this$props5 = this.props, action = _this$props5.action, showAction = _this$props5.showAction;
        return action.indexOf("contextMenu") !== -1 || showAction.indexOf("contextMenu") !== -1;
      }
    }, {
      key: "isClickToHide",
      value: function isClickToHide() {
        var _this$props6 = this.props, action = _this$props6.action, hideAction = _this$props6.hideAction;
        return action.indexOf("click") !== -1 || hideAction.indexOf("click") !== -1;
      }
    }, {
      key: "isMouseEnterToShow",
      value: function isMouseEnterToShow() {
        var _this$props7 = this.props, action = _this$props7.action, showAction = _this$props7.showAction;
        return action.indexOf("hover") !== -1 || showAction.indexOf("mouseEnter") !== -1;
      }
    }, {
      key: "isMouseLeaveToHide",
      value: function isMouseLeaveToHide() {
        var _this$props8 = this.props, action = _this$props8.action, hideAction = _this$props8.hideAction;
        return action.indexOf("hover") !== -1 || hideAction.indexOf("mouseLeave") !== -1;
      }
    }, {
      key: "isFocusToShow",
      value: function isFocusToShow() {
        var _this$props9 = this.props, action = _this$props9.action, showAction = _this$props9.showAction;
        return action.indexOf("focus") !== -1 || showAction.indexOf("focus") !== -1;
      }
    }, {
      key: "isBlurToHide",
      value: function isBlurToHide() {
        var _this$props10 = this.props, action = _this$props10.action, hideAction = _this$props10.hideAction;
        return action.indexOf("focus") !== -1 || hideAction.indexOf("blur") !== -1;
      }
    }, {
      key: "forcePopupAlign",
      value: function forcePopupAlign() {
        if (this.state.popupVisible) {
          var _this$popupRef$curren3;
          (_this$popupRef$curren3 = this.popupRef.current) === null || _this$popupRef$curren3 === void 0 ? void 0 : _this$popupRef$curren3.forceAlign();
        }
      }
    }, {
      key: "fireEvents",
      value: function fireEvents(type4, e2) {
        var childCallback = this.props.children.props[type4];
        if (childCallback) {
          childCallback(e2);
        }
        var callback = this.props[type4];
        if (callback) {
          callback(e2);
        }
      }
    }, {
      key: "close",
      value: function close() {
        this.setPopupVisible(false);
      }
    }, {
      key: "render",
      value: function render2() {
        var popupVisible = this.state.popupVisible;
        var _this$props11 = this.props, children = _this$props11.children, forceRender = _this$props11.forceRender, alignPoint2 = _this$props11.alignPoint, className = _this$props11.className, autoDestroy = _this$props11.autoDestroy;
        var child = React.Children.only(children);
        var newChildProps = {
          key: "trigger"
        };
        if (this.isContextMenuToShow()) {
          newChildProps.onContextMenu = this.onContextMenu;
        } else {
          newChildProps.onContextMenu = this.createTwoChains("onContextMenu");
        }
        if (this.isClickToHide() || this.isClickToShow()) {
          newChildProps.onClick = this.onClick;
          newChildProps.onMouseDown = this.onMouseDown;
          newChildProps.onTouchStart = this.onTouchStart;
        } else {
          newChildProps.onClick = this.createTwoChains("onClick");
          newChildProps.onMouseDown = this.createTwoChains("onMouseDown");
          newChildProps.onTouchStart = this.createTwoChains("onTouchStart");
        }
        if (this.isMouseEnterToShow()) {
          newChildProps.onMouseEnter = this.onMouseEnter;
          if (alignPoint2) {
            newChildProps.onMouseMove = this.onMouseMove;
          }
        } else {
          newChildProps.onMouseEnter = this.createTwoChains("onMouseEnter");
        }
        if (this.isMouseLeaveToHide()) {
          newChildProps.onMouseLeave = this.onMouseLeave;
        } else {
          newChildProps.onMouseLeave = this.createTwoChains("onMouseLeave");
        }
        if (this.isFocusToShow() || this.isBlurToHide()) {
          newChildProps.onFocus = this.onFocus;
          newChildProps.onBlur = this.onBlur;
        } else {
          newChildProps.onFocus = this.createTwoChains("onFocus");
          newChildProps.onBlur = this.createTwoChains("onBlur");
        }
        var childrenClassName = classNames(child && child.props && child.props.className, className);
        if (childrenClassName) {
          newChildProps.className = childrenClassName;
        }
        var cloneProps = _objectSpread2$d({}, newChildProps);
        if (supportRef$5(child)) {
          cloneProps.ref = composeRef$7(this.triggerRef, child.ref);
        }
        var trigger = /* @__PURE__ */ React.cloneElement(child, cloneProps);
        var portal;
        if (popupVisible || this.popupRef.current || forceRender) {
          portal = /* @__PURE__ */ React.createElement(PortalComponent, {
            key: "portal",
            getContainer: this.getContainer,
            didUpdate: this.handlePortalUpdate
          }, this.getComponent());
        }
        if (!popupVisible && autoDestroy) {
          portal = null;
        }
        return /* @__PURE__ */ React.createElement(TriggerContext$1.Provider, {
          value: this.triggerContextValue
        }, trigger, portal);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref2, prevState) {
        var popupVisible = _ref2.popupVisible;
        var newState = {};
        if (popupVisible !== void 0 && prevState.popupVisible !== popupVisible) {
          newState.popupVisible = popupVisible;
          newState.prevPopupVisible = prevState.popupVisible;
        }
        return newState;
      }
    }]);
    return Trigger3;
  }(React.Component);
  Trigger2.contextType = TriggerContext$1;
  Trigger2.defaultProps = {
    prefixCls: "rc-trigger-popup",
    getPopupClassNameFromAlign: returnEmptyString$1,
    getDocument: returnDocument$1,
    onPopupVisibleChange: noop$3,
    afterPopupVisibleChange: noop$3,
    onPopupAlign: noop$3,
    popupClassName: "",
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0.1,
    focusDelay: 0,
    blurDelay: 0.15,
    popupStyle: {},
    destroyPopupOnHide: false,
    popupAlign: {},
    defaultPopupVisible: false,
    mask: false,
    maskClosable: true,
    action: [],
    showAction: [],
    hideAction: [],
    autoDestroy: false
  };
  return Trigger2;
}
var Trigger$1 = generateTrigger$1(Portal$1);
var autoAdjustOverflow$2 = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset = [0, 0];
var placements$2 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset
  },
  topCenter: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset
  },
  bottomCenter: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset
  }
};
function focusable$2(node2) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (isVisible$2(node2)) {
    var nodeName = node2.nodeName.toLowerCase();
    var isFocusableElement = ["input", "select", "textarea", "button"].includes(nodeName) || node2.isContentEditable || nodeName === "a" && !!node2.getAttribute("href");
    var tabIndexAttr = node2.getAttribute("tabindex");
    var tabIndexNum = Number(tabIndexAttr);
    var tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
      tabIndex = tabIndexNum;
    } else if (isFocusableElement && tabIndex === null) {
      tabIndex = 0;
    }
    if (isFocusableElement && node2.disabled) {
      tabIndex = null;
    }
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
function getFocusNodeList$2(node2) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var res = _toConsumableArray(node2.querySelectorAll("*")).filter(function(child) {
    return focusable$2(child, includePositive);
  });
  if (focusable$2(node2, includePositive)) {
    res.unshift(node2);
  }
  return res;
}
var ESC$2 = KeyCode$5.ESC, TAB = KeyCode$5.TAB;
function useAccessibility$2(_ref2) {
  var visible = _ref2.visible, setTriggerVisible = _ref2.setTriggerVisible, triggerRef = _ref2.triggerRef, onVisibleChange = _ref2.onVisibleChange, autoFocus = _ref2.autoFocus;
  var focusMenuRef = React.useRef(false);
  var handleCloseMenuAndReturnFocus = function handleCloseMenuAndReturnFocus2() {
    if (visible && triggerRef.current) {
      var _triggerRef$current, _triggerRef$current$t, _triggerRef$current$t2, _triggerRef$current$t3;
      (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : (_triggerRef$current$t = _triggerRef$current.triggerRef) === null || _triggerRef$current$t === void 0 ? void 0 : (_triggerRef$current$t2 = _triggerRef$current$t.current) === null || _triggerRef$current$t2 === void 0 ? void 0 : (_triggerRef$current$t3 = _triggerRef$current$t2.focus) === null || _triggerRef$current$t3 === void 0 ? void 0 : _triggerRef$current$t3.call(_triggerRef$current$t2);
      setTriggerVisible(false);
      if (typeof onVisibleChange === "function") {
        onVisibleChange(false);
      }
    }
  };
  var focusMenu = function focusMenu2() {
    var _triggerRef$current2, _triggerRef$current2$, _triggerRef$current2$2, _triggerRef$current2$3;
    var elements = getFocusNodeList$2((_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : (_triggerRef$current2$ = _triggerRef$current2.popupRef) === null || _triggerRef$current2$ === void 0 ? void 0 : (_triggerRef$current2$2 = _triggerRef$current2$.current) === null || _triggerRef$current2$2 === void 0 ? void 0 : (_triggerRef$current2$3 = _triggerRef$current2$2.getElement) === null || _triggerRef$current2$3 === void 0 ? void 0 : _triggerRef$current2$3.call(_triggerRef$current2$2));
    var firstElement = elements[0];
    if (firstElement === null || firstElement === void 0 ? void 0 : firstElement.focus) {
      firstElement.focus();
      focusMenuRef.current = true;
      return true;
    }
    return false;
  };
  var handleKeyDown = function handleKeyDown2(event) {
    switch (event.keyCode) {
      case ESC$2:
        handleCloseMenuAndReturnFocus();
        break;
      case TAB: {
        var focusResult = false;
        if (!focusMenuRef.current) {
          focusResult = focusMenu();
        }
        if (focusResult) {
          event.preventDefault();
        } else {
          handleCloseMenuAndReturnFocus();
        }
        break;
      }
    }
  };
  React.useEffect(function() {
    if (visible) {
      window.addEventListener("keydown", handleKeyDown);
      if (autoFocus) {
        wrapperRaf$6(focusMenu, 3);
      }
      return function() {
        window.removeEventListener("keydown", handleKeyDown);
        focusMenuRef.current = false;
      };
    }
    return function() {
      focusMenuRef.current = false;
    };
  }, [visible]);
}
var _excluded$x = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus"];
function Dropdown$2(props, ref2) {
  var _props$arrow = props.arrow, arrow = _props$arrow === void 0 ? false : _props$arrow, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dropdown" : _props$prefixCls, transitionName = props.transitionName, animation = props.animation, align = props.align, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomLeft" : _props$placement, _props$placements = props.placements, placements2 = _props$placements === void 0 ? placements$2 : _props$placements, getPopupContainer = props.getPopupContainer, showAction = props.showAction, hideAction = props.hideAction, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, visible = props.visible, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, autoFocus = props.autoFocus, otherProps = _objectWithoutProperties$1(props, _excluded$x);
  var _React$useState = React.useState(), _React$useState2 = _slicedToArray$1(_React$useState, 2), triggerVisible = _React$useState2[0], setTriggerVisible = _React$useState2[1];
  var mergedVisible = "visible" in props ? visible : triggerVisible;
  var triggerRef = React.useRef(null);
  React.useImperativeHandle(ref2, function() {
    return triggerRef.current;
  });
  useAccessibility$2({
    visible: mergedVisible,
    setTriggerVisible,
    triggerRef,
    onVisibleChange: props.onVisibleChange,
    autoFocus
  });
  var getOverlayElement = function getOverlayElement2() {
    var overlay = props.overlay;
    var overlayElement;
    if (typeof overlay === "function") {
      overlayElement = overlay();
    } else {
      overlayElement = overlay;
    }
    return overlayElement;
  };
  var onClick = function onClick2(e2) {
    var onOverlayClick = props.onOverlayClick;
    setTriggerVisible(false);
    if (onOverlayClick) {
      onOverlayClick(e2);
    }
  };
  var onVisibleChange = function onVisibleChange2(newVisible) {
    var onVisibleChangeProp = props.onVisibleChange;
    setTriggerVisible(newVisible);
    if (typeof onVisibleChangeProp === "function") {
      onVisibleChangeProp(newVisible);
    }
  };
  var getMenuElement = function getMenuElement2() {
    var overlayElement = getOverlayElement();
    return /* @__PURE__ */ React.createElement(React.Fragment, null, arrow && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(prefixCls, "-arrow")
    }), overlayElement);
  };
  var getMenuElementOrLambda = function getMenuElementOrLambda2() {
    var overlay = props.overlay;
    if (typeof overlay === "function") {
      return getMenuElement;
    }
    return getMenuElement();
  };
  var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger2() {
    var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger, alignPoint2 = props.alignPoint;
    if ("minOverlayWidthMatchTrigger" in props) {
      return minOverlayWidthMatchTrigger;
    }
    return !alignPoint2;
  };
  var getOpenClassName = function getOpenClassName2() {
    var openClassName = props.openClassName;
    if (openClassName !== void 0) {
      return openClassName;
    }
    return "".concat(prefixCls, "-open");
  };
  var renderChildren = function renderChildren2() {
    var children = props.children;
    var childrenProps = children.props ? children.props : {};
    var childClassName = classNames(childrenProps.className, getOpenClassName());
    return mergedVisible && children ? /* @__PURE__ */ React.cloneElement(children, {
      className: childClassName
    }) : children;
  };
  var triggerHideAction = hideAction;
  if (!triggerHideAction && trigger.indexOf("contextMenu") !== -1) {
    triggerHideAction = ["click"];
  }
  return /* @__PURE__ */ React.createElement(Trigger$1, _objectSpread2$d(_objectSpread2$d({
    builtinPlacements: placements2
  }, otherProps), {}, {
    prefixCls,
    ref: triggerRef,
    popupClassName: classNames(overlayClassName, _defineProperty$3({}, "".concat(prefixCls, "-show-arrow"), arrow)),
    popupStyle: overlayStyle,
    action: trigger,
    showAction,
    hideAction: triggerHideAction || [],
    popupPlacement: placement,
    popupAlign: align,
    popupTransitionName: transitionName,
    popupAnimation: animation,
    popupVisible: mergedVisible,
    stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
    popup: getMenuElementOrLambda(),
    onPopupVisibleChange: onVisibleChange,
    onPopupClick: onClick,
    getPopupContainer
  }), renderChildren());
}
var Dropdown$3 = /* @__PURE__ */ React.forwardRef(Dropdown$2);
function canUseDom$7() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var useLayoutEffect$3 = canUseDom$7() ? React.useLayoutEffect : React.useEffect;
var _excluded$w = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];
var UNDEFINED$1 = void 0;
function InternalItem$2(props, ref2) {
  var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey2 = props.itemKey, className = props.className, style2 = props.style, children = props.children, display = props.display, order2 = props.order, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties$1(props, _excluded$w);
  var mergedHidden = responsive && !display;
  function internalRegisterSize(width) {
    registerSize(itemKey2, width);
  }
  React.useEffect(function() {
    return function() {
      internalRegisterSize(null);
    };
  }, []);
  var childNode = renderItem && item !== UNDEFINED$1 ? renderItem(item) : children;
  var overflowStyle;
  if (!invalidate) {
    overflowStyle = {
      opacity: mergedHidden ? 0 : 1,
      height: mergedHidden ? 0 : UNDEFINED$1,
      overflowY: mergedHidden ? "hidden" : UNDEFINED$1,
      order: responsive ? order2 : UNDEFINED$1,
      pointerEvents: mergedHidden ? "none" : UNDEFINED$1,
      position: mergedHidden ? "absolute" : UNDEFINED$1
    };
  }
  var overflowProps = {};
  if (mergedHidden) {
    overflowProps["aria-hidden"] = true;
  }
  var itemNode = /* @__PURE__ */ React.createElement(Component, _extends$3({
    className: classNames(!invalidate && prefixCls, className),
    style: _objectSpread2$d(_objectSpread2$d({}, overflowStyle), style2)
  }, overflowProps, restProps, {
    ref: ref2
  }), childNode);
  if (responsive) {
    itemNode = /* @__PURE__ */ React.createElement(ResizeObserver$2, {
      onResize: function onResize2(_ref2) {
        var offsetWidth = _ref2.offsetWidth;
        internalRegisterSize(offsetWidth);
      },
      disabled: responsiveDisabled
    }, itemNode);
  }
  return itemNode;
}
var Item$6 = /* @__PURE__ */ React.forwardRef(InternalItem$2);
Item$6.displayName = "Item";
function useEvent$3(callback) {
  var fnRef = React.useRef();
  fnRef.current = callback;
  var memoFn = React.useCallback(function() {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
var raf$5 = function raf4(callback) {
  return +setTimeout(callback, 16);
};
var caf$4 = function caf4(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf$5 = function raf10(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf$4 = function caf10(handle2) {
    return window.cancelAnimationFrame(handle2);
  };
}
var rafUUID$4 = 0;
var rafIds$4 = /* @__PURE__ */ new Map();
function cleanup$4(id) {
  rafIds$4.delete(id);
}
function wrapperRaf$4(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID$4 += 1;
  var id = rafUUID$4;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup$4(id);
      callback();
    } else {
      var realId = raf$5(function() {
        callRef(leftTimes - 1);
      });
      rafIds$4.set(id, realId);
    }
  }
  callRef(times);
  return id;
}
wrapperRaf$4.cancel = function(id) {
  var realId = rafIds$4.get(id);
  cleanup$4(realId);
  return caf$4(realId);
};
function channelUpdate$1(callback) {
  if (typeof MessageChannel === "undefined") {
    wrapperRaf$4(callback);
  } else {
    var channel = new MessageChannel();
    channel.port1.onmessage = function() {
      return callback();
    };
    channel.port2.postMessage(void 0);
  }
}
function useBatcher$1() {
  var updateFuncRef = React.useRef(null);
  var notifyEffectUpdate = function notifyEffectUpdate2(callback) {
    if (!updateFuncRef.current) {
      updateFuncRef.current = [];
      channelUpdate$1(function() {
        ReactDOM.unstable_batchedUpdates(function() {
          updateFuncRef.current.forEach(function(fn2) {
            fn2();
          });
          updateFuncRef.current = null;
        });
      });
    }
    updateFuncRef.current.push(callback);
  };
  return notifyEffectUpdate;
}
function useEffectState$1(notifyEffectUpdate, defaultValue) {
  var _React$useState = React.useState(defaultValue), _React$useState2 = _slicedToArray$1(_React$useState, 2), stateValue = _React$useState2[0], setStateValue = _React$useState2[1];
  var setEffectVal = useEvent$3(function(nextValue) {
    notifyEffectUpdate(function() {
      setStateValue(nextValue);
    });
  });
  return [stateValue, setEffectVal];
}
var _excluded$v = ["component"], _excluded2$9 = ["className"], _excluded3$3 = ["className"];
var InternalRawItem$1 = function InternalRawItem2(props, ref2) {
  var context2 = React.useContext(OverflowContext$1);
  if (!context2) {
    var _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties$1(props, _excluded$v);
    return /* @__PURE__ */ React.createElement(Component, _extends$3({}, _restProps, {
      ref: ref2
    }));
  }
  var contextClassName = context2.className, restContext = _objectWithoutProperties$1(context2, _excluded2$9);
  var className = props.className, restProps = _objectWithoutProperties$1(props, _excluded3$3);
  return /* @__PURE__ */ React.createElement(OverflowContext$1.Provider, {
    value: null
  }, /* @__PURE__ */ React.createElement(Item$6, _extends$3({
    ref: ref2,
    className: classNames(contextClassName, className)
  }, restContext, restProps)));
};
var RawItem$1 = /* @__PURE__ */ React.forwardRef(InternalRawItem$1);
RawItem$1.displayName = "RawItem";
var _excluded$u = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];
var OverflowContext$1 = /* @__PURE__ */ React.createContext(null);
var RESPONSIVE$1 = "responsive";
var INVALIDATE$1 = "invalidate";
function defaultRenderRest$1(omittedItems) {
  return "+ ".concat(omittedItems.length, " ...");
}
function Overflow$1(props, ref2) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data2 = _props$data === void 0 ? [] : _props$data, renderItem = props.renderItem, renderRawItem = props.renderRawItem, itemKey2 = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style2 = props.style, className = props.className, maxCount = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix = props.suffix, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties$1(props, _excluded$u);
  var fullySSR = ssr === "full";
  var notifyEffectUpdate = useBatcher$1();
  var _useEffectState = useEffectState$1(notifyEffectUpdate, null), _useEffectState2 = _slicedToArray$1(_useEffectState, 2), containerWidth = _useEffectState2[0], setContainerWidth = _useEffectState2[1];
  var mergedContainerWidth = containerWidth || 0;
  var _useEffectState3 = useEffectState$1(notifyEffectUpdate, /* @__PURE__ */ new Map()), _useEffectState4 = _slicedToArray$1(_useEffectState3, 2), itemWidths = _useEffectState4[0], setItemWidths = _useEffectState4[1];
  var _useEffectState5 = useEffectState$1(notifyEffectUpdate, 0), _useEffectState6 = _slicedToArray$1(_useEffectState5, 2), prevRestWidth = _useEffectState6[0], setPrevRestWidth = _useEffectState6[1];
  var _useEffectState7 = useEffectState$1(notifyEffectUpdate, 0), _useEffectState8 = _slicedToArray$1(_useEffectState7, 2), restWidth = _useEffectState8[0], setRestWidth = _useEffectState8[1];
  var _useEffectState9 = useEffectState$1(notifyEffectUpdate, 0), _useEffectState10 = _slicedToArray$1(_useEffectState9, 2), suffixWidth = _useEffectState10[0], setSuffixWidth = _useEffectState10[1];
  var _useState = React.useState(null), _useState2 = _slicedToArray$1(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1];
  var _useState3 = React.useState(null), _useState4 = _slicedToArray$1(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1];
  var mergedDisplayCount = React.useMemo(function() {
    if (displayCount === null && fullySSR) {
      return Number.MAX_SAFE_INTEGER;
    }
    return displayCount || 0;
  }, [displayCount, containerWidth]);
  var _useState5 = React.useState(false), _useState6 = _slicedToArray$1(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1];
  var itemPrefixCls = "".concat(prefixCls, "-item");
  var mergedRestWidth = Math.max(prevRestWidth, restWidth);
  var isResponsive = maxCount === RESPONSIVE$1;
  var shouldResponsive = data2.length && isResponsive;
  var invalidate = maxCount === INVALIDATE$1;
  var showRest = shouldResponsive || typeof maxCount === "number" && data2.length > maxCount;
  var mergedData = React.useMemo(function() {
    var items = data2;
    if (shouldResponsive) {
      if (containerWidth === null && fullySSR) {
        items = data2;
      } else {
        items = data2.slice(0, Math.min(data2.length, mergedContainerWidth / itemWidth));
      }
    } else if (typeof maxCount === "number") {
      items = data2.slice(0, maxCount);
    }
    return items;
  }, [data2, itemWidth, containerWidth, maxCount, shouldResponsive]);
  var omittedItems = React.useMemo(function() {
    if (shouldResponsive) {
      return data2.slice(mergedDisplayCount + 1);
    }
    return data2.slice(mergedData.length);
  }, [data2, mergedData, shouldResponsive, mergedDisplayCount]);
  var getKey3 = React.useCallback(function(item, index2) {
    var _ref2;
    if (typeof itemKey2 === "function") {
      return itemKey2(item);
    }
    return (_ref2 = itemKey2 && (item === null || item === void 0 ? void 0 : item[itemKey2])) !== null && _ref2 !== void 0 ? _ref2 : index2;
  }, [itemKey2]);
  var mergedRenderItem = React.useCallback(renderItem || function(item) {
    return item;
  }, [renderItem]);
  function updateDisplayCount(count, suffixFixedStartVal, notReady) {
    if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
      return;
    }
    setDisplayCount(count);
    if (!notReady) {
      setRestReady(count < data2.length - 1);
      onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(count);
    }
    if (suffixFixedStartVal !== void 0) {
      setSuffixFixedStart(suffixFixedStartVal);
    }
  }
  function onOverflowResize(_24, element2) {
    setContainerWidth(element2.clientWidth);
  }
  function registerSize(key, width) {
    setItemWidths(function(origin) {
      var clone2 = new Map(origin);
      if (width === null) {
        clone2.delete(key);
      } else {
        clone2.set(key, width);
      }
      return clone2;
    });
  }
  function registerOverflowSize(_24, width) {
    setRestWidth(width);
    setPrevRestWidth(restWidth);
  }
  function registerSuffixSize(_24, width) {
    setSuffixWidth(width);
  }
  function getItemWidth(index2) {
    return itemWidths.get(getKey3(mergedData[index2], index2));
  }
  useLayoutEffect$3(function() {
    if (mergedContainerWidth && typeof mergedRestWidth === "number" && mergedData) {
      var totalWidth = suffixWidth;
      var len = mergedData.length;
      var lastIndex = len - 1;
      if (!len) {
        updateDisplayCount(0, null);
        return;
      }
      for (var i = 0; i < len; i += 1) {
        var currentItemWidth = getItemWidth(i);
        if (fullySSR) {
          currentItemWidth = currentItemWidth || 0;
        }
        if (currentItemWidth === void 0) {
          updateDisplayCount(i - 1, void 0, true);
          break;
        }
        totalWidth += currentItemWidth;
        if (lastIndex === 0 && totalWidth <= mergedContainerWidth || i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth) {
          updateDisplayCount(lastIndex, null);
          break;
        } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
          updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
          break;
        }
      }
      if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
        setSuffixFixedStart(null);
      }
    }
  }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey3, mergedData]);
  var displayRest = restReady && !!omittedItems.length;
  var suffixStyle = {};
  if (suffixFixedStart !== null && shouldResponsive) {
    suffixStyle = {
      position: "absolute",
      left: suffixFixedStart,
      top: 0
    };
  }
  var itemSharedProps = {
    prefixCls: itemPrefixCls,
    responsive: shouldResponsive,
    component: itemComponent,
    invalidate
  };
  var internalRenderItemNode = renderRawItem ? function(item, index2) {
    var key = getKey3(item, index2);
    return /* @__PURE__ */ React.createElement(OverflowContext$1.Provider, {
      key,
      value: _objectSpread2$d(_objectSpread2$d({}, itemSharedProps), {}, {
        order: index2,
        item,
        itemKey: key,
        registerSize,
        display: index2 <= mergedDisplayCount
      })
    }, renderRawItem(item, index2));
  } : function(item, index2) {
    var key = getKey3(item, index2);
    return /* @__PURE__ */ React.createElement(Item$6, _extends$3({}, itemSharedProps, {
      order: index2,
      key,
      item,
      renderItem: mergedRenderItem,
      itemKey: key,
      registerSize,
      display: index2 <= mergedDisplayCount
    }));
  };
  var restNode;
  var restContextProps = {
    order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
    className: "".concat(itemPrefixCls, "-rest"),
    registerSize: registerOverflowSize,
    display: displayRest
  };
  if (!renderRawRest) {
    var mergedRenderRest = renderRest || defaultRenderRest$1;
    restNode = /* @__PURE__ */ React.createElement(Item$6, _extends$3({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
  } else if (renderRawRest) {
    restNode = /* @__PURE__ */ React.createElement(OverflowContext$1.Provider, {
      value: _objectSpread2$d(_objectSpread2$d({}, itemSharedProps), restContextProps)
    }, renderRawRest(omittedItems));
  }
  var overflowNode = /* @__PURE__ */ React.createElement(Component, _extends$3({
    className: classNames(!invalidate && prefixCls, className),
    style: style2,
    ref: ref2
  }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ React.createElement(Item$6, _extends$3({}, itemSharedProps, {
    responsive: isResponsive,
    responsiveDisabled: !shouldResponsive,
    order: mergedDisplayCount,
    className: "".concat(itemPrefixCls, "-suffix"),
    registerSize: registerSuffixSize,
    display: true,
    style: suffixStyle
  }), suffix));
  if (isResponsive) {
    overflowNode = /* @__PURE__ */ React.createElement(ResizeObserver$2, {
      onResize: onOverflowResize,
      disabled: !shouldResponsive
    }, overflowNode);
  }
  return overflowNode;
}
var ForwardOverflow$1 = /* @__PURE__ */ React.forwardRef(Overflow$1);
ForwardOverflow$1.displayName = "Overflow";
ForwardOverflow$1.Item = RawItem$1;
ForwardOverflow$1.RESPONSIVE = RESPONSIVE$1;
ForwardOverflow$1.INVALIDATE = INVALIDATE$1;
var IdContext$1 = /* @__PURE__ */ React.createContext(null);
function getMenuId$1(uuid2, eventKey) {
  if (uuid2 === void 0) {
    return null;
  }
  return "".concat(uuid2, "-").concat(eventKey);
}
function useMenuId$1(eventKey) {
  var id = React.useContext(IdContext$1);
  return getMenuId$1(id, eventKey);
}
var _excluded$t = ["children", "locked"];
var MenuContext$3 = /* @__PURE__ */ React.createContext(null);
function mergeProps$1(origin, target) {
  var clone2 = _objectSpread2$d({}, origin);
  Object.keys(target).forEach(function(key) {
    var value = target[key];
    if (value !== void 0) {
      clone2[key] = value;
    }
  });
  return clone2;
}
function InheritableContextProvider$1(_ref2) {
  var children = _ref2.children, locked = _ref2.locked, restProps = _objectWithoutProperties$1(_ref2, _excluded$t);
  var context2 = React.useContext(MenuContext$3);
  var inheritableContext = useMemo$6(function() {
    return mergeProps$1(context2, restProps);
  }, [context2, restProps], function(prev2, next2) {
    return !locked && (prev2[0] !== next2[0] || !isEqual$4(prev2[1], next2[1], true));
  });
  return /* @__PURE__ */ React.createElement(MenuContext$3.Provider, {
    value: inheritableContext
  }, children);
}
var EmptyList$1 = [];
var PathRegisterContext$1 = /* @__PURE__ */ React.createContext(null);
function useMeasure$1() {
  return React.useContext(PathRegisterContext$1);
}
var PathTrackerContext$1 = /* @__PURE__ */ React.createContext(EmptyList$1);
function useFullPath$1(eventKey) {
  var parentKeyPath = React.useContext(PathTrackerContext$1);
  return React.useMemo(function() {
    return eventKey !== void 0 ? [].concat(_toConsumableArray(parentKeyPath), [eventKey]) : parentKeyPath;
  }, [parentKeyPath, eventKey]);
}
var PathUserContext$1 = /* @__PURE__ */ React.createContext(null);
var PrivateContext$1 = /* @__PURE__ */ React.createContext({});
var KeyCode$2 = {
  MAC_ENTER: 3,
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  PRINT_SCREEN: 44,
  INSERT: 45,
  DELETE: 46,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  QUESTION_MARK: 63,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  META: 91,
  WIN_KEY_RIGHT: 92,
  CONTEXT_MENU: 93,
  NUM_ZERO: 96,
  NUM_ONE: 97,
  NUM_TWO: 98,
  NUM_THREE: 99,
  NUM_FOUR: 100,
  NUM_FIVE: 101,
  NUM_SIX: 102,
  NUM_SEVEN: 103,
  NUM_EIGHT: 104,
  NUM_NINE: 105,
  NUM_MULTIPLY: 106,
  NUM_PLUS: 107,
  NUM_MINUS: 109,
  NUM_PERIOD: 110,
  NUM_DIVISION: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SEMICOLON: 186,
  DASH: 189,
  EQUALS: 187,
  COMMA: 188,
  PERIOD: 190,
  SLASH: 191,
  APOSTROPHE: 192,
  SINGLE_QUOTE: 222,
  OPEN_SQUARE_BRACKET: 219,
  BACKSLASH: 220,
  CLOSE_SQUARE_BRACKET: 221,
  WIN_KEY: 224,
  MAC_FF_META: 224,
  WIN_IME: 229,
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent4(e2) {
    var keyCode = e2.keyCode;
    if (e2.altKey && !e2.ctrlKey || e2.metaKey || keyCode >= KeyCode$2.F1 && keyCode <= KeyCode$2.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode$2.ALT:
      case KeyCode$2.CAPS_LOCK:
      case KeyCode$2.CONTEXT_MENU:
      case KeyCode$2.CTRL:
      case KeyCode$2.DOWN:
      case KeyCode$2.END:
      case KeyCode$2.ESC:
      case KeyCode$2.HOME:
      case KeyCode$2.INSERT:
      case KeyCode$2.LEFT:
      case KeyCode$2.MAC_FF_META:
      case KeyCode$2.META:
      case KeyCode$2.NUMLOCK:
      case KeyCode$2.NUM_CENTER:
      case KeyCode$2.PAGE_DOWN:
      case KeyCode$2.PAGE_UP:
      case KeyCode$2.PAUSE:
      case KeyCode$2.PRINT_SCREEN:
      case KeyCode$2.RIGHT:
      case KeyCode$2.SHIFT:
      case KeyCode$2.UP:
      case KeyCode$2.WIN_KEY:
      case KeyCode$2.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  isCharacterKey: function isCharacterKey4(keyCode) {
    if (keyCode >= KeyCode$2.ZERO && keyCode <= KeyCode$2.NINE) {
      return true;
    }
    if (keyCode >= KeyCode$2.NUM_ZERO && keyCode <= KeyCode$2.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode$2.A && keyCode <= KeyCode$2.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode$2.SPACE:
      case KeyCode$2.QUESTION_MARK:
      case KeyCode$2.NUM_PLUS:
      case KeyCode$2.NUM_MINUS:
      case KeyCode$2.NUM_PERIOD:
      case KeyCode$2.NUM_DIVISION:
      case KeyCode$2.SEMICOLON:
      case KeyCode$2.DASH:
      case KeyCode$2.EQUALS:
      case KeyCode$2.COMMA:
      case KeyCode$2.PERIOD:
      case KeyCode$2.SLASH:
      case KeyCode$2.APOSTROPHE:
      case KeyCode$2.SINGLE_QUOTE:
      case KeyCode$2.OPEN_SQUARE_BRACKET:
      case KeyCode$2.BACKSLASH:
      case KeyCode$2.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
function focusable$1(node2) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (isVisible$4(node2)) {
    var nodeName = node2.nodeName.toLowerCase();
    var isFocusableElement = ["input", "select", "textarea", "button"].includes(nodeName) || node2.isContentEditable || nodeName === "a" && !!node2.getAttribute("href");
    var tabIndexAttr = node2.getAttribute("tabindex");
    var tabIndexNum = Number(tabIndexAttr);
    var tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
      tabIndex = tabIndexNum;
    } else if (isFocusableElement && tabIndex === null) {
      tabIndex = 0;
    }
    if (isFocusableElement && node2.disabled) {
      tabIndex = null;
    }
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
function getFocusNodeList$1(node2) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var res = _toConsumableArray(node2.querySelectorAll("*")).filter(function(child) {
    return focusable$1(child, includePositive);
  });
  if (focusable$1(node2, includePositive)) {
    res.unshift(node2);
  }
  return res;
}
var LEFT$1 = KeyCode$2.LEFT, RIGHT$1 = KeyCode$2.RIGHT, UP$1 = KeyCode$2.UP, DOWN$1 = KeyCode$2.DOWN, ENTER$1 = KeyCode$2.ENTER, ESC$1 = KeyCode$2.ESC, HOME$1 = KeyCode$2.HOME, END$1 = KeyCode$2.END;
var ArrowKeys$1 = [UP$1, DOWN$1, LEFT$1, RIGHT$1];
function getOffset$2(mode, isRootLevel, isRtl, which) {
  var _inline, _horizontal, _vertical, _offsets;
  var prev2 = "prev";
  var next2 = "next";
  var children = "children";
  var parent = "parent";
  if (mode === "inline" && which === ENTER$1) {
    return {
      inlineTrigger: true
    };
  }
  var inline2 = (_inline = {}, _defineProperty$3(_inline, UP$1, prev2), _defineProperty$3(_inline, DOWN$1, next2), _inline);
  var horizontal = (_horizontal = {}, _defineProperty$3(_horizontal, LEFT$1, isRtl ? next2 : prev2), _defineProperty$3(_horizontal, RIGHT$1, isRtl ? prev2 : next2), _defineProperty$3(_horizontal, DOWN$1, children), _defineProperty$3(_horizontal, ENTER$1, children), _horizontal);
  var vertical = (_vertical = {}, _defineProperty$3(_vertical, UP$1, prev2), _defineProperty$3(_vertical, DOWN$1, next2), _defineProperty$3(_vertical, ENTER$1, children), _defineProperty$3(_vertical, ESC$1, parent), _defineProperty$3(_vertical, LEFT$1, isRtl ? children : parent), _defineProperty$3(_vertical, RIGHT$1, isRtl ? parent : children), _vertical);
  var offsets = {
    inline: inline2,
    horizontal,
    vertical,
    inlineSub: inline2,
    horizontalSub: vertical,
    verticalSub: vertical
  };
  var type4 = (_offsets = offsets["".concat(mode).concat(isRootLevel ? "" : "Sub")]) === null || _offsets === void 0 ? void 0 : _offsets[which];
  switch (type4) {
    case prev2:
      return {
        offset: -1,
        sibling: true
      };
    case next2:
      return {
        offset: 1,
        sibling: true
      };
    case parent:
      return {
        offset: -1,
        sibling: false
      };
    case children:
      return {
        offset: 1,
        sibling: false
      };
    default:
      return null;
  }
}
function findContainerUL$1(element2) {
  var current = element2;
  while (current) {
    if (current.getAttribute("data-menu-list")) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusElement$1(activeElement, elements) {
  var current = activeElement || document.activeElement;
  while (current) {
    if (elements.has(current)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusableElements$1(container, elements) {
  var list2 = getFocusNodeList$1(container, true);
  return list2.filter(function(ele) {
    return elements.has(ele);
  });
}
function getNextFocusElement$1(parentQueryContainer, elements, focusMenuElement) {
  var offset3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  if (!parentQueryContainer) {
    return null;
  }
  var sameLevelFocusableMenuElementList = getFocusableElements$1(parentQueryContainer, elements);
  var count = sameLevelFocusableMenuElementList.length;
  var focusIndex = sameLevelFocusableMenuElementList.findIndex(function(ele) {
    return focusMenuElement === ele;
  });
  if (offset3 < 0) {
    if (focusIndex === -1) {
      focusIndex = count - 1;
    } else {
      focusIndex -= 1;
    }
  } else if (offset3 > 0) {
    focusIndex += 1;
  }
  focusIndex = (focusIndex + count) % count;
  return sameLevelFocusableMenuElementList[focusIndex];
}
function useAccessibility$1(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
  var rafRef = React.useRef();
  var activeRef = React.useRef();
  activeRef.current = activeKey;
  var cleanRaf = function cleanRaf2() {
    wrapperRaf$7.cancel(rafRef.current);
  };
  React.useEffect(function() {
    return function() {
      cleanRaf();
    };
  }, []);
  return function(e2) {
    var which = e2.which;
    if ([].concat(ArrowKeys$1, [ENTER$1, ESC$1, HOME$1, END$1]).includes(which)) {
      var elements;
      var key2element;
      var element2key;
      var refreshElements = function refreshElements2() {
        elements = /* @__PURE__ */ new Set();
        key2element = /* @__PURE__ */ new Map();
        element2key = /* @__PURE__ */ new Map();
        var keys2 = getKeys();
        keys2.forEach(function(key) {
          var element2 = document.querySelector("[data-menu-id='".concat(getMenuId$1(id, key), "']"));
          if (element2) {
            elements.add(element2);
            element2key.set(element2, key);
            key2element.set(key, element2);
          }
        });
        return elements;
      };
      refreshElements();
      var activeElement = key2element.get(activeKey);
      var focusMenuElement = getFocusElement$1(activeElement, elements);
      var focusMenuKey = element2key.get(focusMenuElement);
      var offsetObj = getOffset$2(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
      if (!offsetObj && which !== HOME$1 && which !== END$1) {
        return;
      }
      if (ArrowKeys$1.includes(which) || [HOME$1, END$1].includes(which)) {
        e2.preventDefault();
      }
      var tryFocus = function tryFocus2(menuElement) {
        if (menuElement) {
          var focusTargetElement = menuElement;
          var link2 = menuElement.querySelector("a");
          if (link2 !== null && link2 !== void 0 && link2.getAttribute("href")) {
            focusTargetElement = link2;
          }
          var targetKey = element2key.get(menuElement);
          triggerActiveKey(targetKey);
          cleanRaf();
          rafRef.current = wrapperRaf$7(function() {
            if (activeRef.current === targetKey) {
              focusTargetElement.focus();
            }
          });
        }
      };
      if ([HOME$1, END$1].includes(which) || offsetObj.sibling || !focusMenuElement) {
        var parentQueryContainer;
        if (!focusMenuElement || mode === "inline") {
          parentQueryContainer = containerRef.current;
        } else {
          parentQueryContainer = findContainerUL$1(focusMenuElement);
        }
        var targetElement;
        var focusableElements = getFocusableElements$1(parentQueryContainer, elements);
        if (which === HOME$1) {
          targetElement = focusableElements[0];
        } else if (which === END$1) {
          targetElement = focusableElements[focusableElements.length - 1];
        } else {
          targetElement = getNextFocusElement$1(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
        }
        tryFocus(targetElement);
      } else if (offsetObj.inlineTrigger) {
        triggerAccessibilityOpen(focusMenuKey);
      } else if (offsetObj.offset > 0) {
        triggerAccessibilityOpen(focusMenuKey, true);
        cleanRaf();
        rafRef.current = wrapperRaf$7(function() {
          refreshElements();
          var controlId = focusMenuElement.getAttribute("aria-controls");
          var subQueryContainer = document.getElementById(controlId);
          var targetElement2 = getNextFocusElement$1(subQueryContainer, elements);
          tryFocus(targetElement2);
        }, 5);
      } else if (offsetObj.offset < 0) {
        var keyPath = getKeyPath(focusMenuKey, true);
        var parentKey = keyPath[keyPath.length - 2];
        var parentMenuElement = key2element.get(parentKey);
        triggerAccessibilityOpen(parentKey, false);
        tryFocus(parentMenuElement);
      }
    }
    originOnKeyDown === null || originOnKeyDown === void 0 ? void 0 : originOnKeyDown(e2);
  };
}
function nextSlice$1(callback) {
  Promise.resolve().then(callback);
}
var PATH_SPLIT$1 = "__RC_UTIL_PATH_SPLIT__";
var getPathStr$1 = function getPathStr(keyPath) {
  return keyPath.join(PATH_SPLIT$1);
};
var getPathKeys$1 = function getPathKeys(keyPathStr) {
  return keyPathStr.split(PATH_SPLIT$1);
};
var OVERFLOW_KEY$1 = "rc-menu-more";
function useKeyRecords$1() {
  var _React$useState = React.useState({}), _React$useState2 = _slicedToArray$1(_React$useState, 2), internalForceUpdate = _React$useState2[1];
  var key2pathRef = React.useRef(/* @__PURE__ */ new Map());
  var path2keyRef = React.useRef(/* @__PURE__ */ new Map());
  var _React$useState3 = React.useState([]), _React$useState4 = _slicedToArray$1(_React$useState3, 2), overflowKeys = _React$useState4[0], setOverflowKeys = _React$useState4[1];
  var updateRef = React.useRef(0);
  var destroyRef = React.useRef(false);
  var forceUpdate = function forceUpdate2() {
    if (!destroyRef.current) {
      internalForceUpdate({});
    }
  };
  var registerPath = React.useCallback(function(key, keyPath) {
    var connectedPath = getPathStr$1(keyPath);
    path2keyRef.current.set(connectedPath, key);
    key2pathRef.current.set(key, connectedPath);
    updateRef.current += 1;
    var id = updateRef.current;
    nextSlice$1(function() {
      if (id === updateRef.current) {
        forceUpdate();
      }
    });
  }, []);
  var unregisterPath = React.useCallback(function(key, keyPath) {
    var connectedPath = getPathStr$1(keyPath);
    path2keyRef.current.delete(connectedPath);
    key2pathRef.current.delete(key);
  }, []);
  var refreshOverflowKeys = React.useCallback(function(keys2) {
    setOverflowKeys(keys2);
  }, []);
  var getKeyPath = React.useCallback(function(eventKey, includeOverflow) {
    var fullPath = key2pathRef.current.get(eventKey) || "";
    var keys2 = getPathKeys$1(fullPath);
    if (includeOverflow && overflowKeys.includes(keys2[0])) {
      keys2.unshift(OVERFLOW_KEY$1);
    }
    return keys2;
  }, [overflowKeys]);
  var isSubPathKey = React.useCallback(function(pathKeys, eventKey) {
    return pathKeys.some(function(pathKey) {
      var pathKeyList = getKeyPath(pathKey, true);
      return pathKeyList.includes(eventKey);
    });
  }, [getKeyPath]);
  var getKeys = function getKeys2() {
    var keys2 = _toConsumableArray(key2pathRef.current.keys());
    if (overflowKeys.length) {
      keys2.push(OVERFLOW_KEY$1);
    }
    return keys2;
  };
  var getSubPathKeys = React.useCallback(function(key) {
    var connectedPath = "".concat(key2pathRef.current.get(key)).concat(PATH_SPLIT$1);
    var pathKeys = /* @__PURE__ */ new Set();
    _toConsumableArray(path2keyRef.current.keys()).forEach(function(pathKey) {
      if (pathKey.startsWith(connectedPath)) {
        pathKeys.add(path2keyRef.current.get(pathKey));
      }
    });
    return pathKeys;
  }, []);
  React.useEffect(function() {
    return function() {
      destroyRef.current = true;
    };
  }, []);
  return {
    registerPath,
    unregisterPath,
    refreshOverflowKeys,
    isSubPathKey,
    getKeyPath,
    getKeys,
    getSubPathKeys
  };
}
function useMemoCallback$1(func) {
  var funRef = React.useRef(func);
  funRef.current = func;
  var callback = React.useCallback(function() {
    var _funRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
  }, []);
  return func ? callback : void 0;
}
var uniquePrefix$1 = Math.random().toFixed(5).toString().slice(2);
var internalId$1 = 0;
function useUUID$1(id) {
  var _useMergedState = useMergedState$2(id, {
    value: id
  }), _useMergedState2 = _slicedToArray$1(_useMergedState, 2), uuid2 = _useMergedState2[0], setUUID = _useMergedState2[1];
  React.useEffect(function() {
    internalId$1 += 1;
    var newId = "".concat(uniquePrefix$1, "-").concat(internalId$1);
    setUUID("rc-menu-uuid-".concat(newId));
  }, []);
  return uuid2;
}
function useActive$1(eventKey, disabled, onMouseEnter, onMouseLeave) {
  var _React$useContext = React.useContext(MenuContext$3), activeKey = _React$useContext.activeKey, onActive = _React$useContext.onActive, onInactive = _React$useContext.onInactive;
  var ret = {
    active: activeKey === eventKey
  };
  if (!disabled) {
    ret.onMouseEnter = function(domEvent) {
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
        key: eventKey,
        domEvent
      });
      onActive(eventKey);
    };
    ret.onMouseLeave = function(domEvent) {
      onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
        key: eventKey,
        domEvent
      });
      onInactive(eventKey);
    };
  }
  return ret;
}
function useDirectionStyle$1(level) {
  var _React$useContext = React.useContext(MenuContext$3), mode = _React$useContext.mode, rtl = _React$useContext.rtl, inlineIndent = _React$useContext.inlineIndent;
  if (mode !== "inline") {
    return null;
  }
  var len = level;
  return rtl ? {
    paddingRight: len * inlineIndent
  } : {
    paddingLeft: len * inlineIndent
  };
}
function Icon$2(_ref2) {
  var icon = _ref2.icon, props = _ref2.props, children = _ref2.children;
  var iconNode;
  if (typeof icon === "function") {
    iconNode = /* @__PURE__ */ React.createElement(icon, _objectSpread2$d({}, props));
  } else {
    iconNode = icon;
  }
  return iconNode || children || null;
}
var _excluded$s = ["item"];
function warnItemProp$1(_ref2) {
  var item = _ref2.item, restInfo = _objectWithoutProperties$1(_ref2, _excluded$s);
  Object.defineProperty(restInfo, "item", {
    get: function get2() {
      warningOnce$5(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
      return item;
    }
  });
  return restInfo;
}
var _excluded$r = ["title", "attribute", "elementRef"], _excluded2$8 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"], _excluded3$2 = ["active"];
var LegacyMenuItem$1 = /* @__PURE__ */ function(_React$Component) {
  _inherits$2(LegacyMenuItem2, _React$Component);
  var _super = _createSuper$2(LegacyMenuItem2);
  function LegacyMenuItem2() {
    _classCallCheck$2(this, LegacyMenuItem2);
    return _super.apply(this, arguments);
  }
  _createClass$2(LegacyMenuItem2, [{
    key: "render",
    value: function render2() {
      var _this$props = this.props, title = _this$props.title, attribute = _this$props.attribute, elementRef = _this$props.elementRef, restProps = _objectWithoutProperties$1(_this$props, _excluded$r);
      var passedProps = omit$5(restProps, ["eventKey", "popupClassName", "popupOffset", "onTitleClick"]);
      warningOnce$5(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
      return /* @__PURE__ */ React.createElement(ForwardOverflow$1.Item, _extends$3({}, attribute, {
        title: typeof title === "string" ? title : void 0
      }, passedProps, {
        ref: elementRef
      }));
    }
  }]);
  return LegacyMenuItem2;
}(React.Component);
var InternalMenuItem$1 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var _classNames;
  var style2 = props.style, className = props.className, eventKey = props.eventKey;
  props.warnKey;
  var disabled = props.disabled, itemIcon = props.itemIcon, children = props.children, role = props.role, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown = props.onKeyDown, onFocus = props.onFocus, restProps = _objectWithoutProperties$1(props, _excluded2$8);
  var domDataId = useMenuId$1(eventKey);
  var _React$useContext = React.useContext(MenuContext$3), prefixCls = _React$useContext.prefixCls, onItemClick = _React$useContext.onItemClick, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, contextItemIcon = _React$useContext.itemIcon, selectedKeys = _React$useContext.selectedKeys, onActive = _React$useContext.onActive;
  var _React$useContext2 = React.useContext(PrivateContext$1), _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
  var itemCls = "".concat(prefixCls, "-item");
  var legacyMenuItemRef = React.useRef();
  var elementRef = React.useRef();
  var mergedDisabled = contextDisabled || disabled;
  var mergedEleRef = useComposeRef$5(ref2, elementRef);
  var connectedKeys = useFullPath$1(eventKey);
  var getEventInfo = function getEventInfo2(e2) {
    return {
      key: eventKey,
      keyPath: _toConsumableArray(connectedKeys).reverse(),
      item: legacyMenuItemRef.current,
      domEvent: e2
    };
  };
  var mergedItemIcon = itemIcon || contextItemIcon;
  var _useActive = useActive$1(eventKey, mergedDisabled, onMouseEnter, onMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties$1(_useActive, _excluded3$2);
  var selected = selectedKeys.includes(eventKey);
  var directionStyle = useDirectionStyle$1(connectedKeys.length);
  var onInternalClick = function onInternalClick2(e2) {
    if (mergedDisabled) {
      return;
    }
    var info = getEventInfo(e2);
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp$1(info));
    onItemClick(info);
  };
  var onInternalKeyDown = function onInternalKeyDown2(e2) {
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e2);
    if (e2.which === KeyCode$2.ENTER) {
      var info = getEventInfo(e2);
      onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp$1(info));
      onItemClick(info);
    }
  };
  var onInternalFocus = function onInternalFocus2(e2) {
    onActive(eventKey);
    onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
  };
  var optionRoleProps = {};
  if (props.role === "option") {
    optionRoleProps["aria-selected"] = selected;
  }
  var renderNode = /* @__PURE__ */ React.createElement(LegacyMenuItem$1, _extends$3({
    ref: legacyMenuItemRef,
    elementRef: mergedEleRef,
    role: role === null ? "none" : role || "menuitem",
    tabIndex: disabled ? null : -1,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId
  }, restProps, activeProps, optionRoleProps, {
    component: "li",
    "aria-disabled": disabled,
    style: _objectSpread2$d(_objectSpread2$d({}, directionStyle), style2),
    className: classNames(itemCls, (_classNames = {}, _defineProperty$3(_classNames, "".concat(itemCls, "-active"), active), _defineProperty$3(_classNames, "".concat(itemCls, "-selected"), selected), _defineProperty$3(_classNames, "".concat(itemCls, "-disabled"), mergedDisabled), _classNames), className),
    onClick: onInternalClick,
    onKeyDown: onInternalKeyDown,
    onFocus: onInternalFocus
  }), children, /* @__PURE__ */ React.createElement(Icon$2, {
    props: _objectSpread2$d(_objectSpread2$d({}, props), {}, {
      isSelected: selected
    }),
    icon: mergedItemIcon
  }));
  if (_internalRenderMenuItem) {
    renderNode = _internalRenderMenuItem(renderNode, props, {
      selected
    });
  }
  return renderNode;
});
function MenuItem$3(props, ref2) {
  var eventKey = props.eventKey;
  var measure = useMeasure$1();
  var connectedKeyPath = useFullPath$1(eventKey);
  React.useEffect(function() {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function() {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  if (measure) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(InternalMenuItem$1, _extends$3({}, props, {
    ref: ref2
  }));
}
var Item$5 = /* @__PURE__ */ React.forwardRef(MenuItem$3);
var _excluded$q = ["className", "children"];
var InternalSubMenuList$1 = function InternalSubMenuList(_ref2, ref2) {
  var className = _ref2.className, children = _ref2.children, restProps = _objectWithoutProperties$1(_ref2, _excluded$q);
  var _React$useContext = React.useContext(MenuContext$3), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, rtl = _React$useContext.rtl;
  return /* @__PURE__ */ React.createElement("ul", _extends$3({
    className: classNames(prefixCls, rtl && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === "inline" ? "inline" : "vertical"), className),
    role: "menu"
  }, restProps, {
    "data-menu-list": true,
    ref: ref2
  }), children);
};
var SubMenuList$1 = /* @__PURE__ */ React.forwardRef(InternalSubMenuList$1);
SubMenuList$1.displayName = "SubMenuList";
var _excluded$p = ["label", "children", "key", "type"];
function parseChildren$1(children, keyPath) {
  return toArray$9(children).map(function(child, index2) {
    if (/* @__PURE__ */ React.isValidElement(child)) {
      var _eventKey, _child$props;
      var key = child.key;
      var eventKey = (_eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _eventKey !== void 0 ? _eventKey : key;
      var emptyKey = eventKey === null || eventKey === void 0;
      if (emptyKey) {
        eventKey = "tmp_key-".concat([].concat(_toConsumableArray(keyPath), [index2]).join("-"));
      }
      var cloneProps = {
        key: eventKey,
        eventKey
      };
      return /* @__PURE__ */ React.cloneElement(child, cloneProps);
    }
    return child;
  });
}
function convertItemsToNodes$2(list2) {
  return (list2 || []).map(function(opt, index2) {
    if (opt && _typeof$8(opt) === "object") {
      var _ref2 = opt, label = _ref2.label, children = _ref2.children, key = _ref2.key, type4 = _ref2.type, restProps = _objectWithoutProperties$1(_ref2, _excluded$p);
      var mergedKey = key !== null && key !== void 0 ? key : "tmp-".concat(index2);
      if (children || type4 === "group") {
        if (type4 === "group") {
          return /* @__PURE__ */ React.createElement(MenuItemGroup$1, _extends$3({
            key: mergedKey
          }, restProps, {
            title: label
          }), convertItemsToNodes$2(children));
        }
        return /* @__PURE__ */ React.createElement(SubMenu$3, _extends$3({
          key: mergedKey
        }, restProps, {
          title: label
        }), convertItemsToNodes$2(children));
      }
      if (type4 === "divider") {
        return /* @__PURE__ */ React.createElement(Divider$3, _extends$3({
          key: mergedKey
        }, restProps));
      }
      return /* @__PURE__ */ React.createElement(Item$5, _extends$3({
        key: mergedKey
      }, restProps), label);
    }
    return null;
  }).filter(function(opt) {
    return opt;
  });
}
function parseItems$1(children, items, keyPath) {
  var childNodes = children;
  if (items) {
    childNodes = convertItemsToNodes$2(items);
  }
  return parseChildren$1(childNodes, keyPath);
}
var raf$4 = function raf5(callback) {
  return +setTimeout(callback, 16);
};
var caf$3 = function caf5(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf$4 = function raf10(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf$3 = function caf10(handle2) {
    return window.cancelAnimationFrame(handle2);
  };
}
var rafUUID$3 = 0;
var rafIds$3 = /* @__PURE__ */ new Map();
function cleanup$3(id) {
  rafIds$3.delete(id);
}
function wrapperRaf$3(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID$3 += 1;
  var id = rafUUID$3;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup$3(id);
      callback();
    } else {
      var realId = raf$4(function() {
        callRef(leftTimes - 1);
      });
      rafIds$3.set(id, realId);
    }
  }
  callRef(times);
  return id;
}
wrapperRaf$3.cancel = function(id) {
  var realId = rafIds$3.get(id);
  cleanup$3(realId);
  return caf$3(realId);
};
function contains$4(root2, n2) {
  if (!root2) {
    return false;
  }
  if (root2.contains) {
    return root2.contains(n2);
  }
  var node2 = n2;
  while (node2) {
    if (node2 === root2) {
      return true;
    }
    node2 = node2.parentNode;
  }
  return false;
}
function findDOMNode(node2) {
  if (node2 instanceof HTMLElement) {
    return node2;
  }
  return ReactDOM.findDOMNode(node2);
}
function fillRef$2(ref2, node2) {
  if (typeof ref2 === "function") {
    ref2(node2);
  } else if (_typeof$8(ref2) === "object" && ref2 && "current" in ref2) {
    ref2.current = node2;
  }
}
function composeRef$2() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function(ref2) {
    return ref2;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function(node2) {
    refs.forEach(function(ref2) {
      fillRef$2(ref2, node2);
    });
  };
}
function supportRef$1(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type4 = reactIs$2.exports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  if (typeof type4 === "function" && !((_type$prototype = type4.prototype) === null || _type$prototype === void 0 ? void 0 : _type$prototype.render)) {
    return false;
  }
  if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) === null || _nodeOrComponent$prot === void 0 ? void 0 : _nodeOrComponent$prot.render)) {
    return false;
  }
  return true;
}
function addEventListenerWrap(target, eventType, cb, option) {
  var callback = ReactDOM.unstable_batchedUpdates ? function run(e2) {
    ReactDOM.unstable_batchedUpdates(cb, e2);
  } : cb;
  if (target.addEventListener) {
    target.addEventListener(eventType, callback, option);
  }
  return {
    remove: function remove3() {
      if (target.removeEventListener) {
        target.removeEventListener(eventType, callback, option);
      }
    }
  };
}
function canUseDom$6() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var Portal = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var didUpdate = props.didUpdate, getContainer2 = props.getContainer, children = props.children;
  var parentRef = React.useRef();
  var containerRef = React.useRef();
  React.useImperativeHandle(ref2, function() {
    return {};
  });
  var initRef = React.useRef(false);
  if (!initRef.current && canUseDom$6()) {
    containerRef.current = getContainer2();
    parentRef.current = containerRef.current.parentNode;
    initRef.current = true;
  }
  React.useEffect(function() {
    didUpdate === null || didUpdate === void 0 ? void 0 : didUpdate(props);
  });
  React.useEffect(function() {
    if (containerRef.current.parentNode === null && parentRef.current !== null) {
      parentRef.current.appendChild(containerRef.current);
    }
    return function() {
      var _containerRef$current, _containerRef$current2;
      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.parentNode) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.removeChild(containerRef.current);
    };
  }, []);
  return containerRef.current ? /* @__PURE__ */ ReactDOM.createPortal(children, containerRef.current) : null;
});
function isPointsEq(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }
  return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return _objectSpread2$d(_objectSpread2$d({}, baseAlign), align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;
  var placements2 = Object.keys(builtinPlacements);
  for (var i = 0; i < placements2.length; i += 1) {
    var placement = placements2[i];
    if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
      return "".concat(prefixCls, "-placement-").concat(placement);
    }
  }
  return "";
}
var isMobile$1 = function() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
};
function getMotion$2(_ref2) {
  var prefixCls = _ref2.prefixCls, motion2 = _ref2.motion, animation = _ref2.animation, transitionName = _ref2.transitionName;
  if (motion2) {
    return motion2;
  }
  if (animation) {
    return {
      motionName: "".concat(prefixCls, "-").concat(animation)
    };
  }
  if (transitionName) {
    return {
      motionName: transitionName
    };
  }
  return null;
}
function Mask$1(props) {
  var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, mask = props.mask, maskMotion = props.maskMotion, maskAnimation = props.maskAnimation, maskTransitionName = props.maskTransitionName;
  if (!mask) {
    return null;
  }
  var motion2 = {};
  if (maskMotion || maskTransitionName || maskAnimation) {
    motion2 = _objectSpread2$d({
      motionAppear: true
    }, getMotion$2({
      motion: maskMotion,
      prefixCls,
      transitionName: maskTransitionName,
      animation: maskAnimation
    }));
  }
  return /* @__PURE__ */ React.createElement(CSSMotion, _extends$3({}, motion2, {
    visible,
    removeOnLeave: true
  }), function(_ref2) {
    var className = _ref2.className;
    return /* @__PURE__ */ React.createElement("div", {
      style: {
        zIndex
      },
      className: classNames("".concat(prefixCls, "-mask"), className)
    });
  });
}
var useLayoutEffect$2 = canUseDom$6() ? React.useLayoutEffect : React.useEffect;
function useSafeState$1(defaultValue) {
  var destroyRef = React.useRef(false);
  var _React$useState = React.useState(defaultValue), _React$useState2 = _slicedToArray$1(_React$useState, 2), value = _React$useState2[0], setValue2 = _React$useState2[1];
  React.useEffect(function() {
    destroyRef.current = false;
    return function() {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue2(updater);
  }
  return [value, safeSetState];
}
var StatusQueue = ["measure", "alignPre", "align", null, "motion"];
var useVisibleStatus = function(visible, doMeasure) {
  var _useState = useSafeState$1(null), _useState2 = _slicedToArray$1(_useState, 2), status = _useState2[0], setInternalStatus = _useState2[1];
  var rafRef = React.useRef();
  function setStatus(nextStatus) {
    setInternalStatus(nextStatus, true);
  }
  function cancelRaf() {
    wrapperRaf$3.cancel(rafRef.current);
  }
  function goNextStatus(callback) {
    cancelRaf();
    rafRef.current = wrapperRaf$3(function() {
      setStatus(function(prev2) {
        switch (status) {
          case "align":
            return "motion";
          case "motion":
            return "stable";
        }
        return prev2;
      });
      callback === null || callback === void 0 ? void 0 : callback();
    });
  }
  React.useEffect(function() {
    setStatus("measure");
  }, [visible]);
  React.useEffect(function() {
    switch (status) {
      case "measure":
        doMeasure();
        break;
    }
    if (status) {
      rafRef.current = wrapperRaf$3(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
        var index2, nextStatus;
        return _regeneratorRuntime().wrap(function _callee$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                index2 = StatusQueue.indexOf(status);
                nextStatus = StatusQueue[index2 + 1];
                if (nextStatus && index2 !== -1) {
                  setStatus(nextStatus);
                }
              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee);
      })));
    }
  }, [status]);
  React.useEffect(function() {
    return function() {
      cancelRaf();
    };
  }, []);
  return [status, goNextStatus];
};
var useStretchStyle = function(stretch) {
  var _React$useState = React.useState({
    width: 0,
    height: 0
  }), _React$useState2 = _slicedToArray$1(_React$useState, 2), targetSize = _React$useState2[0], setTargetSize = _React$useState2[1];
  function measureStretch(element2) {
    setTargetSize({
      width: element2.offsetWidth,
      height: element2.offsetHeight
    });
  }
  var style2 = React.useMemo(function() {
    var sizeStyle = {};
    if (stretch) {
      var width = targetSize.width, height = targetSize.height;
      if (stretch.indexOf("height") !== -1 && height) {
        sizeStyle.height = height;
      } else if (stretch.indexOf("minHeight") !== -1 && height) {
        sizeStyle.minHeight = height;
      }
      if (stretch.indexOf("width") !== -1 && width) {
        sizeStyle.width = width;
      } else if (stretch.indexOf("minWidth") !== -1 && width) {
        sizeStyle.minWidth = width;
      }
    }
    return sizeStyle;
  }, [stretch, targetSize]);
  return [style2, measureStretch];
};
var PopupInner = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var visible = props.visible, prefixCls = props.prefixCls, className = props.className, style2 = props.style, children = props.children, zIndex = props.zIndex, stretch = props.stretch, destroyPopupOnHide = props.destroyPopupOnHide, forceRender = props.forceRender, align = props.align, point2 = props.point, getRootDomNode = props.getRootDomNode, getClassNameFromAlign = props.getClassNameFromAlign, onAlign = props.onAlign, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onMouseDown = props.onMouseDown, onTouchStart = props.onTouchStart, onClick = props.onClick;
  var alignRef = React.useRef();
  var elementRef = React.useRef();
  var _useState = React.useState(), _useState2 = _slicedToArray$1(_useState, 2), alignedClassName = _useState2[0], setAlignedClassName = _useState2[1];
  var _useStretchStyle = useStretchStyle(stretch), _useStretchStyle2 = _slicedToArray$1(_useStretchStyle, 2), stretchStyle = _useStretchStyle2[0], measureStretchStyle = _useStretchStyle2[1];
  function doMeasure() {
    if (stretch) {
      measureStretchStyle(getRootDomNode());
    }
  }
  var _useVisibleStatus = useVisibleStatus(visible, doMeasure), _useVisibleStatus2 = _slicedToArray$1(_useVisibleStatus, 2), status = _useVisibleStatus2[0], goNextStatus = _useVisibleStatus2[1];
  var _useState3 = React.useState(0), _useState4 = _slicedToArray$1(_useState3, 2), alignTimes = _useState4[0], setAlignTimes = _useState4[1];
  var prepareResolveRef = React.useRef();
  useLayoutEffect$2(function() {
    if (status === "alignPre") {
      setAlignTimes(0);
    }
  }, [status]);
  function getAlignTarget() {
    if (point2) {
      return point2;
    }
    return getRootDomNode;
  }
  function forceAlign() {
    var _alignRef$current;
    (_alignRef$current = alignRef.current) === null || _alignRef$current === void 0 ? void 0 : _alignRef$current.forceAlign();
  }
  function onInternalAlign(popupDomNode, matchAlign) {
    var nextAlignedClassName = getClassNameFromAlign(matchAlign);
    if (alignedClassName !== nextAlignedClassName) {
      setAlignedClassName(nextAlignedClassName);
    }
    setAlignTimes(function(val) {
      return val + 1;
    });
    if (status === "align") {
      onAlign === null || onAlign === void 0 ? void 0 : onAlign(popupDomNode, matchAlign);
    }
  }
  useLayoutEffect$2(function() {
    if (status === "align") {
      if (alignTimes < 2) {
        forceAlign();
      } else {
        goNextStatus(function() {
          var _prepareResolveRef$cu;
          (_prepareResolveRef$cu = prepareResolveRef.current) === null || _prepareResolveRef$cu === void 0 ? void 0 : _prepareResolveRef$cu.call(prepareResolveRef);
        });
      }
    }
  }, [alignTimes]);
  var motion2 = _objectSpread2$d({}, getMotion$2(props));
  ["onAppearEnd", "onEnterEnd", "onLeaveEnd"].forEach(function(eventName) {
    var originHandler = motion2[eventName];
    motion2[eventName] = function(element2, event) {
      goNextStatus();
      return originHandler === null || originHandler === void 0 ? void 0 : originHandler(element2, event);
    };
  });
  function onShowPrepare() {
    return new Promise(function(resolve) {
      prepareResolveRef.current = resolve;
    });
  }
  React.useEffect(function() {
    if (!motion2.motionName && status === "motion") {
      goNextStatus();
    }
  }, [motion2.motionName, status]);
  React.useImperativeHandle(ref2, function() {
    return {
      forceAlign,
      getElement: function getElement2() {
        return elementRef.current;
      }
    };
  });
  var mergedStyle = _objectSpread2$d(_objectSpread2$d({}, stretchStyle), {}, {
    zIndex,
    opacity: status === "motion" || status === "stable" || !visible ? void 0 : 0,
    pointerEvents: !visible && status !== "stable" ? "none" : void 0
  }, style2);
  var alignDisabled = true;
  if ((align === null || align === void 0 ? void 0 : align.points) && (status === "align" || status === "stable")) {
    alignDisabled = false;
  }
  var childNode = children;
  if (React.Children.count(children) > 1) {
    childNode = /* @__PURE__ */ React.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, children);
  }
  return /* @__PURE__ */ React.createElement(CSSMotion, _extends$3({
    visible,
    ref: elementRef,
    leavedClassName: "".concat(prefixCls, "-hidden")
  }, motion2, {
    onAppearPrepare: onShowPrepare,
    onEnterPrepare: onShowPrepare,
    removeOnLeave: destroyPopupOnHide,
    forceRender
  }), function(_ref2, motionRef) {
    var motionClassName = _ref2.className, motionStyle = _ref2.style;
    var mergedClassName = classNames(prefixCls, className, alignedClassName, motionClassName);
    return /* @__PURE__ */ React.createElement(RcAlign, {
      target: getAlignTarget(),
      key: "popup",
      ref: alignRef,
      monitorWindowResize: true,
      disabled: alignDisabled,
      align,
      onAlign: onInternalAlign
    }, /* @__PURE__ */ React.createElement("div", {
      ref: motionRef,
      className: mergedClassName,
      onMouseEnter,
      onMouseLeave,
      onMouseDownCapture: onMouseDown,
      onTouchStartCapture: onTouchStart,
      onClick,
      style: _objectSpread2$d(_objectSpread2$d({}, motionStyle), mergedStyle)
    }, childNode));
  });
});
PopupInner.displayName = "PopupInner";
var MobilePopupInner = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, children = props.children, _props$mobile = props.mobile;
  _props$mobile = _props$mobile === void 0 ? {} : _props$mobile;
  var popupClassName = _props$mobile.popupClassName, popupStyle = _props$mobile.popupStyle, _props$mobile$popupMo = _props$mobile.popupMotion, popupMotion = _props$mobile$popupMo === void 0 ? {} : _props$mobile$popupMo, popupRender = _props$mobile.popupRender, onClick = props.onClick;
  var elementRef = React.useRef();
  React.useImperativeHandle(ref2, function() {
    return {
      forceAlign: function forceAlign() {
      },
      getElement: function getElement2() {
        return elementRef.current;
      }
    };
  });
  var mergedStyle = _objectSpread2$d({
    zIndex
  }, popupStyle);
  var childNode = children;
  if (React.Children.count(children) > 1) {
    childNode = /* @__PURE__ */ React.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, children);
  }
  if (popupRender) {
    childNode = popupRender(childNode);
  }
  return /* @__PURE__ */ React.createElement(CSSMotion, _extends$3({
    visible,
    ref: elementRef,
    removeOnLeave: true
  }, popupMotion), function(_ref2, motionRef) {
    var motionClassName = _ref2.className, motionStyle = _ref2.style;
    var mergedClassName = classNames(prefixCls, popupClassName, motionClassName);
    return /* @__PURE__ */ React.createElement("div", {
      ref: motionRef,
      className: mergedClassName,
      onClick,
      style: _objectSpread2$d(_objectSpread2$d({}, motionStyle), mergedStyle)
    }, childNode);
  });
});
MobilePopupInner.displayName = "MobilePopupInner";
var _excluded$o = ["visible", "mobile"];
var Popup = /* @__PURE__ */ React.forwardRef(function(_ref2, ref2) {
  var visible = _ref2.visible, mobile = _ref2.mobile, props = _objectWithoutProperties$1(_ref2, _excluded$o);
  var _useState = React.useState(visible), _useState2 = _slicedToArray$1(_useState, 2), innerVisible = _useState2[0], serInnerVisible = _useState2[1];
  var _useState3 = React.useState(false), _useState4 = _slicedToArray$1(_useState3, 2), inMobile = _useState4[0], setInMobile = _useState4[1];
  var cloneProps = _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    visible: innerVisible
  });
  React.useEffect(function() {
    serInnerVisible(visible);
    if (visible && mobile) {
      setInMobile(isMobile$1());
    }
  }, [visible, mobile]);
  var popupNode = inMobile ? /* @__PURE__ */ React.createElement(MobilePopupInner, _extends$3({}, cloneProps, {
    mobile,
    ref: ref2
  })) : /* @__PURE__ */ React.createElement(PopupInner, _extends$3({}, cloneProps, {
    ref: ref2
  }));
  return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(Mask$1, cloneProps), popupNode);
});
Popup.displayName = "Popup";
var TriggerContext = /* @__PURE__ */ React.createContext(null);
function noop$2() {
}
function returnEmptyString() {
  return "";
}
function returnDocument(element2) {
  if (element2) {
    return element2.ownerDocument;
  }
  return window.document;
}
var ALL_HANDLERS = ["onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur", "onContextMenu"];
function generateTrigger(PortalComponent) {
  var Trigger2 = /* @__PURE__ */ function(_React$Component) {
    _inherits$2(Trigger3, _React$Component);
    var _super = _createSuper$2(Trigger3);
    function Trigger3(props) {
      var _this;
      _classCallCheck$2(this, Trigger3);
      _this = _super.call(this, props);
      _this.popupRef = /* @__PURE__ */ React.createRef();
      _this.triggerRef = /* @__PURE__ */ React.createRef();
      _this.portalContainer = void 0;
      _this.attachId = void 0;
      _this.clickOutsideHandler = void 0;
      _this.touchOutsideHandler = void 0;
      _this.contextMenuOutsideHandler1 = void 0;
      _this.contextMenuOutsideHandler2 = void 0;
      _this.mouseDownTimeout = void 0;
      _this.focusTime = void 0;
      _this.preClickTime = void 0;
      _this.preTouchTime = void 0;
      _this.delayTimer = void 0;
      _this.hasPopupMouseDown = void 0;
      _this.onMouseEnter = function(e2) {
        var mouseEnterDelay = _this.props.mouseEnterDelay;
        _this.fireEvents("onMouseEnter", e2);
        _this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e2);
      };
      _this.onMouseMove = function(e2) {
        _this.fireEvents("onMouseMove", e2);
        _this.setPoint(e2);
      };
      _this.onMouseLeave = function(e2) {
        _this.fireEvents("onMouseLeave", e2);
        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      };
      _this.onPopupMouseEnter = function() {
        _this.clearDelayTimer();
      };
      _this.onPopupMouseLeave = function(e2) {
        var _this$popupRef$curren;
        if (e2.relatedTarget && !e2.relatedTarget.setTimeout && contains$4((_this$popupRef$curren = _this.popupRef.current) === null || _this$popupRef$curren === void 0 ? void 0 : _this$popupRef$curren.getElement(), e2.relatedTarget)) {
          return;
        }
        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      };
      _this.onFocus = function(e2) {
        _this.fireEvents("onFocus", e2);
        _this.clearDelayTimer();
        if (_this.isFocusToShow()) {
          _this.focusTime = Date.now();
          _this.delaySetPopupVisible(true, _this.props.focusDelay);
        }
      };
      _this.onMouseDown = function(e2) {
        _this.fireEvents("onMouseDown", e2);
        _this.preClickTime = Date.now();
      };
      _this.onTouchStart = function(e2) {
        _this.fireEvents("onTouchStart", e2);
        _this.preTouchTime = Date.now();
      };
      _this.onBlur = function(e2) {
        _this.fireEvents("onBlur", e2);
        _this.clearDelayTimer();
        if (_this.isBlurToHide()) {
          _this.delaySetPopupVisible(false, _this.props.blurDelay);
        }
      };
      _this.onContextMenu = function(e2) {
        e2.preventDefault();
        _this.fireEvents("onContextMenu", e2);
        _this.setPopupVisible(true, e2);
      };
      _this.onContextMenuClose = function() {
        if (_this.isContextMenuToShow()) {
          _this.close();
        }
      };
      _this.onClick = function(event) {
        _this.fireEvents("onClick", event);
        if (_this.focusTime) {
          var preTime;
          if (_this.preClickTime && _this.preTouchTime) {
            preTime = Math.min(_this.preClickTime, _this.preTouchTime);
          } else if (_this.preClickTime) {
            preTime = _this.preClickTime;
          } else if (_this.preTouchTime) {
            preTime = _this.preTouchTime;
          }
          if (Math.abs(preTime - _this.focusTime) < 20) {
            return;
          }
          _this.focusTime = 0;
        }
        _this.preClickTime = 0;
        _this.preTouchTime = 0;
        if (_this.isClickToShow() && (_this.isClickToHide() || _this.isBlurToHide()) && event && event.preventDefault) {
          event.preventDefault();
        }
        var nextVisible = !_this.state.popupVisible;
        if (_this.isClickToHide() && !nextVisible || nextVisible && _this.isClickToShow()) {
          _this.setPopupVisible(!_this.state.popupVisible, event);
        }
      };
      _this.onPopupMouseDown = function() {
        _this.hasPopupMouseDown = true;
        clearTimeout(_this.mouseDownTimeout);
        _this.mouseDownTimeout = window.setTimeout(function() {
          _this.hasPopupMouseDown = false;
        }, 0);
        if (_this.context) {
          var _this$context;
          (_this$context = _this.context).onPopupMouseDown.apply(_this$context, arguments);
        }
      };
      _this.onDocumentClick = function(event) {
        if (_this.props.mask && !_this.props.maskClosable) {
          return;
        }
        var target = event.target;
        var root2 = _this.getRootDomNode();
        var popupNode = _this.getPopupDomNode();
        if ((!contains$4(root2, target) || _this.isContextMenuOnly()) && !contains$4(popupNode, target) && !_this.hasPopupMouseDown) {
          _this.close();
        }
      };
      _this.getRootDomNode = function() {
        var getTriggerDOMNode = _this.props.getTriggerDOMNode;
        if (getTriggerDOMNode) {
          return getTriggerDOMNode(_this.triggerRef.current);
        }
        try {
          var domNode = findDOMNode(_this.triggerRef.current);
          if (domNode) {
            return domNode;
          }
        } catch (err) {
        }
        return ReactDOM.findDOMNode(_assertThisInitialized$2(_this));
      };
      _this.getPopupClassNameFromAlign = function(align) {
        var className = [];
        var _this$props = _this.props, popupPlacement = _this$props.popupPlacement, builtinPlacements = _this$props.builtinPlacements, prefixCls = _this$props.prefixCls, alignPoint2 = _this$props.alignPoint, getPopupClassNameFromAlign = _this$props.getPopupClassNameFromAlign;
        if (popupPlacement && builtinPlacements) {
          className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint2));
        }
        if (getPopupClassNameFromAlign) {
          className.push(getPopupClassNameFromAlign(align));
        }
        return className.join(" ");
      };
      _this.getComponent = function() {
        var _this$props2 = _this.props, prefixCls = _this$props2.prefixCls, destroyPopupOnHide = _this$props2.destroyPopupOnHide, popupClassName = _this$props2.popupClassName, onPopupAlign = _this$props2.onPopupAlign, popupMotion = _this$props2.popupMotion, popupAnimation = _this$props2.popupAnimation, popupTransitionName = _this$props2.popupTransitionName, popupStyle = _this$props2.popupStyle, mask = _this$props2.mask, maskAnimation = _this$props2.maskAnimation, maskTransitionName = _this$props2.maskTransitionName, maskMotion = _this$props2.maskMotion, zIndex = _this$props2.zIndex, popup = _this$props2.popup, stretch = _this$props2.stretch, alignPoint2 = _this$props2.alignPoint, mobile = _this$props2.mobile, forceRender = _this$props2.forceRender, onPopupClick = _this$props2.onPopupClick;
        var _this$state = _this.state, popupVisible = _this$state.popupVisible, point2 = _this$state.point;
        var align = _this.getPopupAlign();
        var mouseProps = {};
        if (_this.isMouseEnterToShow()) {
          mouseProps.onMouseEnter = _this.onPopupMouseEnter;
        }
        if (_this.isMouseLeaveToHide()) {
          mouseProps.onMouseLeave = _this.onPopupMouseLeave;
        }
        mouseProps.onMouseDown = _this.onPopupMouseDown;
        mouseProps.onTouchStart = _this.onPopupMouseDown;
        return /* @__PURE__ */ React.createElement(Popup, _extends$3({
          prefixCls,
          destroyPopupOnHide,
          visible: popupVisible,
          point: alignPoint2 && point2,
          className: popupClassName,
          align,
          onAlign: onPopupAlign,
          animation: popupAnimation,
          getClassNameFromAlign: _this.getPopupClassNameFromAlign
        }, mouseProps, {
          stretch,
          getRootDomNode: _this.getRootDomNode,
          style: popupStyle,
          mask,
          zIndex,
          transitionName: popupTransitionName,
          maskAnimation,
          maskTransitionName,
          maskMotion,
          ref: _this.popupRef,
          motion: popupMotion,
          mobile,
          forceRender,
          onClick: onPopupClick
        }), typeof popup === "function" ? popup() : popup);
      };
      _this.attachParent = function(popupContainer) {
        wrapperRaf$3.cancel(_this.attachId);
        var _this$props3 = _this.props, getPopupContainer = _this$props3.getPopupContainer, getDocument2 = _this$props3.getDocument;
        var domNode = _this.getRootDomNode();
        var mountNode;
        if (!getPopupContainer) {
          mountNode = getDocument2(_this.getRootDomNode()).body;
        } else if (domNode || getPopupContainer.length === 0) {
          mountNode = getPopupContainer(domNode);
        }
        if (mountNode) {
          mountNode.appendChild(popupContainer);
        } else {
          _this.attachId = wrapperRaf$3(function() {
            _this.attachParent(popupContainer);
          });
        }
      };
      _this.getContainer = function() {
        if (!_this.portalContainer) {
          var getDocument2 = _this.props.getDocument;
          var popupContainer = getDocument2(_this.getRootDomNode()).createElement("div");
          popupContainer.style.position = "absolute";
          popupContainer.style.top = "0";
          popupContainer.style.left = "0";
          popupContainer.style.width = "100%";
          _this.portalContainer = popupContainer;
        }
        _this.attachParent(_this.portalContainer);
        return _this.portalContainer;
      };
      _this.setPoint = function(point2) {
        var alignPoint2 = _this.props.alignPoint;
        if (!alignPoint2 || !point2)
          return;
        _this.setState({
          point: {
            pageX: point2.pageX,
            pageY: point2.pageY
          }
        });
      };
      _this.handlePortalUpdate = function() {
        if (_this.state.prevPopupVisible !== _this.state.popupVisible) {
          _this.props.afterPopupVisibleChange(_this.state.popupVisible);
        }
      };
      _this.triggerContextValue = {
        onPopupMouseDown: _this.onPopupMouseDown
      };
      var _popupVisible;
      if ("popupVisible" in props) {
        _popupVisible = !!props.popupVisible;
      } else {
        _popupVisible = !!props.defaultPopupVisible;
      }
      _this.state = {
        prevPopupVisible: _popupVisible,
        popupVisible: _popupVisible
      };
      ALL_HANDLERS.forEach(function(h2) {
        _this["fire".concat(h2)] = function(e2) {
          _this.fireEvents(h2, e2);
        };
      });
      return _this;
    }
    _createClass$2(Trigger3, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.componentDidUpdate();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var props = this.props;
        var state = this.state;
        if (state.popupVisible) {
          var currentDocument;
          if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow())) {
            currentDocument = props.getDocument(this.getRootDomNode());
            this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick);
          }
          if (!this.touchOutsideHandler) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick);
          }
          if (!this.contextMenuOutsideHandler1 && this.isContextMenuToShow()) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.contextMenuOutsideHandler1 = addEventListenerWrap(currentDocument, "scroll", this.onContextMenuClose);
          }
          if (!this.contextMenuOutsideHandler2 && this.isContextMenuToShow()) {
            this.contextMenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextMenuClose);
          }
          return;
        }
        this.clearOutsideHandler();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.clearDelayTimer();
        this.clearOutsideHandler();
        clearTimeout(this.mouseDownTimeout);
        wrapperRaf$3.cancel(this.attachId);
      }
    }, {
      key: "getPopupDomNode",
      value: function getPopupDomNode() {
        var _this$popupRef$curren2;
        return ((_this$popupRef$curren2 = this.popupRef.current) === null || _this$popupRef$curren2 === void 0 ? void 0 : _this$popupRef$curren2.getElement()) || null;
      }
    }, {
      key: "getPopupAlign",
      value: function getPopupAlign() {
        var props = this.props;
        var popupPlacement = props.popupPlacement, popupAlign = props.popupAlign, builtinPlacements = props.builtinPlacements;
        if (popupPlacement && builtinPlacements) {
          return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
        }
        return popupAlign;
      }
    }, {
      key: "setPopupVisible",
      value: function setPopupVisible(popupVisible, event) {
        var alignPoint2 = this.props.alignPoint;
        var prevPopupVisible = this.state.popupVisible;
        this.clearDelayTimer();
        if (prevPopupVisible !== popupVisible) {
          if (!("popupVisible" in this.props)) {
            this.setState({
              popupVisible,
              prevPopupVisible
            });
          }
          this.props.onPopupVisibleChange(popupVisible);
        }
        if (alignPoint2 && event && popupVisible) {
          this.setPoint(event);
        }
      }
    }, {
      key: "delaySetPopupVisible",
      value: function delaySetPopupVisible(visible, delayS, event) {
        var _this2 = this;
        var delay = delayS * 1e3;
        this.clearDelayTimer();
        if (delay) {
          var point2 = event ? {
            pageX: event.pageX,
            pageY: event.pageY
          } : null;
          this.delayTimer = window.setTimeout(function() {
            _this2.setPopupVisible(visible, point2);
            _this2.clearDelayTimer();
          }, delay);
        } else {
          this.setPopupVisible(visible, event);
        }
      }
    }, {
      key: "clearDelayTimer",
      value: function clearDelayTimer() {
        if (this.delayTimer) {
          clearTimeout(this.delayTimer);
          this.delayTimer = null;
        }
      }
    }, {
      key: "clearOutsideHandler",
      value: function clearOutsideHandler() {
        if (this.clickOutsideHandler) {
          this.clickOutsideHandler.remove();
          this.clickOutsideHandler = null;
        }
        if (this.contextMenuOutsideHandler1) {
          this.contextMenuOutsideHandler1.remove();
          this.contextMenuOutsideHandler1 = null;
        }
        if (this.contextMenuOutsideHandler2) {
          this.contextMenuOutsideHandler2.remove();
          this.contextMenuOutsideHandler2 = null;
        }
        if (this.touchOutsideHandler) {
          this.touchOutsideHandler.remove();
          this.touchOutsideHandler = null;
        }
      }
    }, {
      key: "createTwoChains",
      value: function createTwoChains(event) {
        var childPros = this.props.children.props;
        var props = this.props;
        if (childPros[event] && props[event]) {
          return this["fire".concat(event)];
        }
        return childPros[event] || props[event];
      }
    }, {
      key: "isClickToShow",
      value: function isClickToShow() {
        var _this$props4 = this.props, action = _this$props4.action, showAction = _this$props4.showAction;
        return action.indexOf("click") !== -1 || showAction.indexOf("click") !== -1;
      }
    }, {
      key: "isContextMenuOnly",
      value: function isContextMenuOnly() {
        var action = this.props.action;
        return action === "contextMenu" || action.length === 1 && action[0] === "contextMenu";
      }
    }, {
      key: "isContextMenuToShow",
      value: function isContextMenuToShow() {
        var _this$props5 = this.props, action = _this$props5.action, showAction = _this$props5.showAction;
        return action.indexOf("contextMenu") !== -1 || showAction.indexOf("contextMenu") !== -1;
      }
    }, {
      key: "isClickToHide",
      value: function isClickToHide() {
        var _this$props6 = this.props, action = _this$props6.action, hideAction = _this$props6.hideAction;
        return action.indexOf("click") !== -1 || hideAction.indexOf("click") !== -1;
      }
    }, {
      key: "isMouseEnterToShow",
      value: function isMouseEnterToShow() {
        var _this$props7 = this.props, action = _this$props7.action, showAction = _this$props7.showAction;
        return action.indexOf("hover") !== -1 || showAction.indexOf("mouseEnter") !== -1;
      }
    }, {
      key: "isMouseLeaveToHide",
      value: function isMouseLeaveToHide() {
        var _this$props8 = this.props, action = _this$props8.action, hideAction = _this$props8.hideAction;
        return action.indexOf("hover") !== -1 || hideAction.indexOf("mouseLeave") !== -1;
      }
    }, {
      key: "isFocusToShow",
      value: function isFocusToShow() {
        var _this$props9 = this.props, action = _this$props9.action, showAction = _this$props9.showAction;
        return action.indexOf("focus") !== -1 || showAction.indexOf("focus") !== -1;
      }
    }, {
      key: "isBlurToHide",
      value: function isBlurToHide() {
        var _this$props10 = this.props, action = _this$props10.action, hideAction = _this$props10.hideAction;
        return action.indexOf("focus") !== -1 || hideAction.indexOf("blur") !== -1;
      }
    }, {
      key: "forcePopupAlign",
      value: function forcePopupAlign() {
        if (this.state.popupVisible) {
          var _this$popupRef$curren3;
          (_this$popupRef$curren3 = this.popupRef.current) === null || _this$popupRef$curren3 === void 0 ? void 0 : _this$popupRef$curren3.forceAlign();
        }
      }
    }, {
      key: "fireEvents",
      value: function fireEvents(type4, e2) {
        var childCallback = this.props.children.props[type4];
        if (childCallback) {
          childCallback(e2);
        }
        var callback = this.props[type4];
        if (callback) {
          callback(e2);
        }
      }
    }, {
      key: "close",
      value: function close() {
        this.setPopupVisible(false);
      }
    }, {
      key: "render",
      value: function render2() {
        var popupVisible = this.state.popupVisible;
        var _this$props11 = this.props, children = _this$props11.children, forceRender = _this$props11.forceRender, alignPoint2 = _this$props11.alignPoint, className = _this$props11.className, autoDestroy = _this$props11.autoDestroy;
        var child = React.Children.only(children);
        var newChildProps = {
          key: "trigger"
        };
        if (this.isContextMenuToShow()) {
          newChildProps.onContextMenu = this.onContextMenu;
        } else {
          newChildProps.onContextMenu = this.createTwoChains("onContextMenu");
        }
        if (this.isClickToHide() || this.isClickToShow()) {
          newChildProps.onClick = this.onClick;
          newChildProps.onMouseDown = this.onMouseDown;
          newChildProps.onTouchStart = this.onTouchStart;
        } else {
          newChildProps.onClick = this.createTwoChains("onClick");
          newChildProps.onMouseDown = this.createTwoChains("onMouseDown");
          newChildProps.onTouchStart = this.createTwoChains("onTouchStart");
        }
        if (this.isMouseEnterToShow()) {
          newChildProps.onMouseEnter = this.onMouseEnter;
          if (alignPoint2) {
            newChildProps.onMouseMove = this.onMouseMove;
          }
        } else {
          newChildProps.onMouseEnter = this.createTwoChains("onMouseEnter");
        }
        if (this.isMouseLeaveToHide()) {
          newChildProps.onMouseLeave = this.onMouseLeave;
        } else {
          newChildProps.onMouseLeave = this.createTwoChains("onMouseLeave");
        }
        if (this.isFocusToShow() || this.isBlurToHide()) {
          newChildProps.onFocus = this.onFocus;
          newChildProps.onBlur = this.onBlur;
        } else {
          newChildProps.onFocus = this.createTwoChains("onFocus");
          newChildProps.onBlur = this.createTwoChains("onBlur");
        }
        var childrenClassName = classNames(child && child.props && child.props.className, className);
        if (childrenClassName) {
          newChildProps.className = childrenClassName;
        }
        var cloneProps = _objectSpread2$d({}, newChildProps);
        if (supportRef$1(child)) {
          cloneProps.ref = composeRef$2(this.triggerRef, child.ref);
        }
        var trigger = /* @__PURE__ */ React.cloneElement(child, cloneProps);
        var portal;
        if (popupVisible || this.popupRef.current || forceRender) {
          portal = /* @__PURE__ */ React.createElement(PortalComponent, {
            key: "portal",
            getContainer: this.getContainer,
            didUpdate: this.handlePortalUpdate
          }, this.getComponent());
        }
        if (!popupVisible && autoDestroy) {
          portal = null;
        }
        return /* @__PURE__ */ React.createElement(TriggerContext.Provider, {
          value: this.triggerContextValue
        }, trigger, portal);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref2, prevState) {
        var popupVisible = _ref2.popupVisible;
        var newState = {};
        if (popupVisible !== void 0 && prevState.popupVisible !== popupVisible) {
          newState.popupVisible = popupVisible;
          newState.prevPopupVisible = prevState.popupVisible;
        }
        return newState;
      }
    }]);
    return Trigger3;
  }(React.Component);
  Trigger2.contextType = TriggerContext;
  Trigger2.defaultProps = {
    prefixCls: "rc-trigger-popup",
    getPopupClassNameFromAlign: returnEmptyString,
    getDocument: returnDocument,
    onPopupVisibleChange: noop$2,
    afterPopupVisibleChange: noop$2,
    onPopupAlign: noop$2,
    popupClassName: "",
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0.1,
    focusDelay: 0,
    blurDelay: 0.15,
    popupStyle: {},
    destroyPopupOnHide: false,
    popupAlign: {},
    defaultPopupVisible: false,
    mask: false,
    maskClosable: true,
    action: [],
    showAction: [],
    hideAction: [],
    autoDestroy: false
  };
  return Trigger2;
}
var Trigger = generateTrigger(Portal);
var autoAdjustOverflow$1 = {
  adjustX: 1,
  adjustY: 1
};
var placements$1 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 7]
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [-4, 0]
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [4, 0]
  }
};
var placementsRtl$1 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 7]
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [-4, 0]
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [4, 0]
  }
};
function getMotion$1(mode, motion2, defaultMotions) {
  if (motion2) {
    return motion2;
  }
  if (defaultMotions) {
    return defaultMotions[mode] || defaultMotions.other;
  }
  return void 0;
}
var popupPlacementMap$1 = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
function PopupTrigger$1(_ref2) {
  var prefixCls = _ref2.prefixCls, visible = _ref2.visible, children = _ref2.children, popup = _ref2.popup, popupClassName = _ref2.popupClassName, popupOffset = _ref2.popupOffset, disabled = _ref2.disabled, mode = _ref2.mode, onVisibleChange = _ref2.onVisibleChange;
  var _React$useContext = React.useContext(MenuContext$3), getPopupContainer = _React$useContext.getPopupContainer, rtl = _React$useContext.rtl, subMenuOpenDelay = _React$useContext.subMenuOpenDelay, subMenuCloseDelay = _React$useContext.subMenuCloseDelay, builtinPlacements = _React$useContext.builtinPlacements, triggerSubMenuAction = _React$useContext.triggerSubMenuAction, forceSubMenuRender = _React$useContext.forceSubMenuRender, rootClassName = _React$useContext.rootClassName, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions;
  var _React$useState = React.useState(false), _React$useState2 = _slicedToArray$1(_React$useState, 2), innerVisible = _React$useState2[0], setInnerVisible = _React$useState2[1];
  var placement = rtl ? _objectSpread2$d(_objectSpread2$d({}, placementsRtl$1), builtinPlacements) : _objectSpread2$d(_objectSpread2$d({}, placements$1), builtinPlacements);
  var popupPlacement = popupPlacementMap$1[mode];
  var targetMotion = getMotion$1(mode, motion2, defaultMotions);
  var targetMotionRef = React.useRef(targetMotion);
  if (mode !== "inline") {
    targetMotionRef.current = targetMotion;
  }
  var mergedMotion = _objectSpread2$d(_objectSpread2$d({}, targetMotionRef.current), {}, {
    leavedClassName: "".concat(prefixCls, "-hidden"),
    removeOnLeave: false,
    motionAppear: true
  });
  var visibleRef = React.useRef();
  React.useEffect(function() {
    visibleRef.current = wrapperRaf$7(function() {
      setInnerVisible(visible);
    });
    return function() {
      wrapperRaf$7.cancel(visibleRef.current);
    };
  }, [visible]);
  return /* @__PURE__ */ React.createElement(Trigger, {
    prefixCls,
    popupClassName: classNames("".concat(prefixCls, "-popup"), _defineProperty$3({}, "".concat(prefixCls, "-rtl"), rtl), popupClassName, rootClassName),
    stretch: mode === "horizontal" ? "minWidth" : null,
    getPopupContainer,
    builtinPlacements: placement,
    popupPlacement,
    popupVisible: innerVisible,
    popup,
    popupAlign: popupOffset && {
      offset: popupOffset
    },
    action: disabled ? [] : [triggerSubMenuAction],
    mouseEnterDelay: subMenuOpenDelay,
    mouseLeaveDelay: subMenuCloseDelay,
    onPopupVisibleChange: onVisibleChange,
    forceRender: forceSubMenuRender,
    popupMotion: mergedMotion
  }, children);
}
function InlineSubMenuList$1(_ref2) {
  var id = _ref2.id, open = _ref2.open, keyPath = _ref2.keyPath, children = _ref2.children;
  var fixedMode = "inline";
  var _React$useContext = React.useContext(MenuContext$3), prefixCls = _React$useContext.prefixCls, forceSubMenuRender = _React$useContext.forceSubMenuRender, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions, mode = _React$useContext.mode;
  var sameModeRef = React.useRef(false);
  sameModeRef.current = mode === fixedMode;
  var _React$useState = React.useState(!sameModeRef.current), _React$useState2 = _slicedToArray$1(_React$useState, 2), destroy = _React$useState2[0], setDestroy = _React$useState2[1];
  var mergedOpen = sameModeRef.current ? open : false;
  React.useEffect(function() {
    if (sameModeRef.current) {
      setDestroy(false);
    }
  }, [mode]);
  var mergedMotion = _objectSpread2$d({}, getMotion$1(fixedMode, motion2, defaultMotions));
  if (keyPath.length > 1) {
    mergedMotion.motionAppear = false;
  }
  var originOnVisibleChanged = mergedMotion.onVisibleChanged;
  mergedMotion.onVisibleChanged = function(newVisible) {
    if (!sameModeRef.current && !newVisible) {
      setDestroy(true);
    }
    return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
  };
  if (destroy) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(InheritableContextProvider$1, {
    mode: fixedMode,
    locked: !sameModeRef.current
  }, /* @__PURE__ */ React.createElement(CSSMotion, _extends$3({
    visible: mergedOpen
  }, mergedMotion, {
    forceRender: forceSubMenuRender,
    removeOnLeave: false,
    leavedClassName: "".concat(prefixCls, "-hidden")
  }), function(_ref22) {
    var motionClassName = _ref22.className, motionStyle = _ref22.style;
    return /* @__PURE__ */ React.createElement(SubMenuList$1, {
      id,
      className: motionClassName,
      style: motionStyle
    }, children);
  }));
}
var _excluded$n = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"], _excluded2$7 = ["active"];
var InternalSubMenu$1 = function InternalSubMenu(props) {
  var _classNames;
  var style2 = props.style, className = props.className, title = props.title, eventKey = props.eventKey;
  props.warnKey;
  var disabled = props.disabled, internalPopupClose = props.internalPopupClose, children = props.children, itemIcon = props.itemIcon, expandIcon = props.expandIcon, popupClassName = props.popupClassName, popupOffset = props.popupOffset, onClick = props.onClick, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onTitleClick = props.onTitleClick, onTitleMouseEnter = props.onTitleMouseEnter, onTitleMouseLeave = props.onTitleMouseLeave, restProps = _objectWithoutProperties$1(props, _excluded$n);
  var domDataId = useMenuId$1(eventKey);
  var _React$useContext = React.useContext(MenuContext$3), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, openKeys = _React$useContext.openKeys, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, activeKey = _React$useContext.activeKey, selectedKeys = _React$useContext.selectedKeys, contextItemIcon = _React$useContext.itemIcon, contextExpandIcon = _React$useContext.expandIcon, onItemClick = _React$useContext.onItemClick, onOpenChange = _React$useContext.onOpenChange, onActive = _React$useContext.onActive;
  var _React$useContext2 = React.useContext(PrivateContext$1), _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
  var _React$useContext3 = React.useContext(PathUserContext$1), isSubPathKey = _React$useContext3.isSubPathKey;
  var connectedPath = useFullPath$1();
  var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
  var mergedDisabled = contextDisabled || disabled;
  var elementRef = React.useRef();
  var popupRef = React.useRef();
  var mergedItemIcon = itemIcon || contextItemIcon;
  var mergedExpandIcon = expandIcon || contextExpandIcon;
  var originOpen = openKeys.includes(eventKey);
  var open = !overflowDisabled && originOpen;
  var childrenSelected = isSubPathKey(selectedKeys, eventKey);
  var _useActive = useActive$1(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties$1(_useActive, _excluded2$7);
  var _React$useState = React.useState(false), _React$useState2 = _slicedToArray$1(_React$useState, 2), childrenActive = _React$useState2[0], setChildrenActive = _React$useState2[1];
  var triggerChildrenActive = function triggerChildrenActive2(newActive) {
    if (!mergedDisabled) {
      setChildrenActive(newActive);
    }
  };
  var onInternalMouseEnter = function onInternalMouseEnter2(domEvent) {
    triggerChildrenActive(true);
    onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
      key: eventKey,
      domEvent
    });
  };
  var onInternalMouseLeave = function onInternalMouseLeave2(domEvent) {
    triggerChildrenActive(false);
    onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
      key: eventKey,
      domEvent
    });
  };
  var mergedActive = React.useMemo(function() {
    if (active) {
      return active;
    }
    if (mode !== "inline") {
      return childrenActive || isSubPathKey([activeKey], eventKey);
    }
    return false;
  }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
  var directionStyle = useDirectionStyle$1(connectedPath.length);
  var onInternalTitleClick = function onInternalTitleClick2(e2) {
    if (mergedDisabled) {
      return;
    }
    onTitleClick === null || onTitleClick === void 0 ? void 0 : onTitleClick({
      key: eventKey,
      domEvent: e2
    });
    if (mode === "inline") {
      onOpenChange(eventKey, !originOpen);
    }
  };
  var onMergedItemClick = useMemoCallback$1(function(info) {
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp$1(info));
    onItemClick(info);
  });
  var onPopupVisibleChange = function onPopupVisibleChange2(newVisible) {
    if (mode !== "inline") {
      onOpenChange(eventKey, newVisible);
    }
  };
  var onInternalFocus = function onInternalFocus2() {
    onActive(eventKey);
  };
  var popupId = domDataId && "".concat(domDataId, "-popup");
  var titleNode = /* @__PURE__ */ React.createElement("div", _extends$3({
    role: "menuitem",
    style: directionStyle,
    className: "".concat(subMenuPrefixCls, "-title"),
    tabIndex: mergedDisabled ? null : -1,
    ref: elementRef,
    title: typeof title === "string" ? title : null,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
    "aria-expanded": open,
    "aria-haspopup": true,
    "aria-controls": popupId,
    "aria-disabled": mergedDisabled,
    onClick: onInternalTitleClick,
    onFocus: onInternalFocus
  }, activeProps), title, /* @__PURE__ */ React.createElement(Icon$2, {
    icon: mode !== "horizontal" ? mergedExpandIcon : null,
    props: _objectSpread2$d(_objectSpread2$d({}, props), {}, {
      isOpen: open,
      isSubMenu: true
    })
  }, /* @__PURE__ */ React.createElement("i", {
    className: "".concat(subMenuPrefixCls, "-arrow")
  })));
  var triggerModeRef = React.useRef(mode);
  if (mode !== "inline" && connectedPath.length > 1) {
    triggerModeRef.current = "vertical";
  } else {
    triggerModeRef.current = mode;
  }
  if (!overflowDisabled) {
    var triggerMode = triggerModeRef.current;
    titleNode = /* @__PURE__ */ React.createElement(PopupTrigger$1, {
      mode: triggerMode,
      prefixCls: subMenuPrefixCls,
      visible: !internalPopupClose && open && mode !== "inline",
      popupClassName,
      popupOffset,
      popup: /* @__PURE__ */ React.createElement(
        InheritableContextProvider$1,
        {
          mode: triggerMode === "horizontal" ? "vertical" : triggerMode
        },
        /* @__PURE__ */ React.createElement(SubMenuList$1, {
          id: popupId,
          ref: popupRef
        }, children)
      ),
      disabled: mergedDisabled,
      onVisibleChange: onPopupVisibleChange
    }, titleNode);
  }
  var listNode = /* @__PURE__ */ React.createElement(ForwardOverflow$1.Item, _extends$3({
    role: "none"
  }, restProps, {
    component: "li",
    style: style2,
    className: classNames(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, (_classNames = {}, _defineProperty$3(_classNames, "".concat(subMenuPrefixCls, "-open"), open), _defineProperty$3(_classNames, "".concat(subMenuPrefixCls, "-active"), mergedActive), _defineProperty$3(_classNames, "".concat(subMenuPrefixCls, "-selected"), childrenSelected), _defineProperty$3(_classNames, "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled), _classNames)),
    onMouseEnter: onInternalMouseEnter,
    onMouseLeave: onInternalMouseLeave
  }), titleNode, !overflowDisabled && /* @__PURE__ */ React.createElement(InlineSubMenuList$1, {
    id: popupId,
    open,
    keyPath: connectedPath
  }, children));
  if (_internalRenderSubMenuItem) {
    listNode = _internalRenderSubMenuItem(listNode, props, {
      selected: childrenSelected,
      active: mergedActive,
      open,
      disabled: mergedDisabled
    });
  }
  return /* @__PURE__ */ React.createElement(InheritableContextProvider$1, {
    onItemClick: onMergedItemClick,
    mode: mode === "horizontal" ? "vertical" : mode,
    itemIcon: mergedItemIcon,
    expandIcon: mergedExpandIcon
  }, listNode);
};
function SubMenu$3(props) {
  var eventKey = props.eventKey, children = props.children;
  var connectedKeyPath = useFullPath$1(eventKey);
  var childList = parseChildren$1(children, connectedKeyPath);
  var measure = useMeasure$1();
  React.useEffect(function() {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function() {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  var renderNode;
  if (measure) {
    renderNode = childList;
  } else {
    renderNode = /* @__PURE__ */ React.createElement(InternalSubMenu$1, props, childList);
  }
  return /* @__PURE__ */ React.createElement(PathTrackerContext$1.Provider, {
    value: connectedKeyPath
  }, renderNode);
}
var _excluded$m = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem"];
var EMPTY_LIST$1 = [];
var Menu$3 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var _childList$, _classNames;
  var _ref2 = props, _ref$prefixCls = _ref2.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-menu" : _ref$prefixCls, rootClassName = _ref2.rootClassName, style2 = _ref2.style, className = _ref2.className, _ref$tabIndex = _ref2.tabIndex, tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, items = _ref2.items, children = _ref2.children, direction = _ref2.direction, id = _ref2.id, _ref$mode = _ref2.mode, mode = _ref$mode === void 0 ? "vertical" : _ref$mode, inlineCollapsed = _ref2.inlineCollapsed, disabled = _ref2.disabled, disabledOverflow = _ref2.disabledOverflow, _ref$subMenuOpenDelay = _ref2.subMenuOpenDelay, subMenuOpenDelay = _ref$subMenuOpenDelay === void 0 ? 0.1 : _ref$subMenuOpenDelay, _ref$subMenuCloseDela = _ref2.subMenuCloseDelay, subMenuCloseDelay = _ref$subMenuCloseDela === void 0 ? 0.1 : _ref$subMenuCloseDela, forceSubMenuRender = _ref2.forceSubMenuRender, defaultOpenKeys = _ref2.defaultOpenKeys, openKeys = _ref2.openKeys, activeKey = _ref2.activeKey, defaultActiveFirst = _ref2.defaultActiveFirst, _ref$selectable = _ref2.selectable, selectable = _ref$selectable === void 0 ? true : _ref$selectable, _ref$multiple = _ref2.multiple, multiple = _ref$multiple === void 0 ? false : _ref$multiple, defaultSelectedKeys = _ref2.defaultSelectedKeys, selectedKeys = _ref2.selectedKeys, onSelect = _ref2.onSelect, onDeselect = _ref2.onDeselect, _ref$inlineIndent = _ref2.inlineIndent, inlineIndent = _ref$inlineIndent === void 0 ? 24 : _ref$inlineIndent, motion2 = _ref2.motion, defaultMotions = _ref2.defaultMotions, _ref$triggerSubMenuAc = _ref2.triggerSubMenuAction, triggerSubMenuAction = _ref$triggerSubMenuAc === void 0 ? "hover" : _ref$triggerSubMenuAc, builtinPlacements = _ref2.builtinPlacements, itemIcon = _ref2.itemIcon, expandIcon = _ref2.expandIcon, _ref$overflowedIndica = _ref2.overflowedIndicator, overflowedIndicator = _ref$overflowedIndica === void 0 ? "..." : _ref$overflowedIndica, overflowedIndicatorPopupClassName = _ref2.overflowedIndicatorPopupClassName, getPopupContainer = _ref2.getPopupContainer, onClick = _ref2.onClick, onOpenChange = _ref2.onOpenChange, onKeyDown = _ref2.onKeyDown;
  _ref2.openAnimation;
  _ref2.openTransitionName;
  var _internalRenderMenuItem = _ref2._internalRenderMenuItem, _internalRenderSubMenuItem = _ref2._internalRenderSubMenuItem, restProps = _objectWithoutProperties$1(_ref2, _excluded$m);
  var childList = React.useMemo(function() {
    return parseItems$1(children, items, EMPTY_LIST$1);
  }, [children, items]);
  var _React$useState = React.useState(false), _React$useState2 = _slicedToArray$1(_React$useState, 2), mounted = _React$useState2[0], setMounted = _React$useState2[1];
  var containerRef = React.useRef();
  var uuid2 = useUUID$1(id);
  var isRtl = direction === "rtl";
  var _useMergedState = useMergedState$2(defaultOpenKeys, {
    value: openKeys,
    postState: function postState(keys2) {
      return keys2 || EMPTY_LIST$1;
    }
  }), _useMergedState2 = _slicedToArray$1(_useMergedState, 2), mergedOpenKeys = _useMergedState2[0], setMergedOpenKeys = _useMergedState2[1];
  var triggerOpenKeys = function triggerOpenKeys2(keys2) {
    var forceFlush = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    function doUpdate() {
      setMergedOpenKeys(keys2);
      onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(keys2);
    }
    if (forceFlush) {
      ReactDOM.flushSync(doUpdate);
    } else {
      doUpdate();
    }
  };
  var _React$useState3 = React.useState(mergedOpenKeys), _React$useState4 = _slicedToArray$1(_React$useState3, 2), inlineCacheOpenKeys = _React$useState4[0], setInlineCacheOpenKeys = _React$useState4[1];
  var mountRef = React.useRef(false);
  var _React$useMemo = React.useMemo(function() {
    if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
      return ["vertical", inlineCollapsed];
    }
    return [mode, false];
  }, [mode, inlineCollapsed]), _React$useMemo2 = _slicedToArray$1(_React$useMemo, 2), mergedMode = _React$useMemo2[0], mergedInlineCollapsed = _React$useMemo2[1];
  var isInlineMode = mergedMode === "inline";
  var _React$useState5 = React.useState(mergedMode), _React$useState6 = _slicedToArray$1(_React$useState5, 2), internalMode = _React$useState6[0], setInternalMode = _React$useState6[1];
  var _React$useState7 = React.useState(mergedInlineCollapsed), _React$useState8 = _slicedToArray$1(_React$useState7, 2), internalInlineCollapsed = _React$useState8[0], setInternalInlineCollapsed = _React$useState8[1];
  React.useEffect(function() {
    setInternalMode(mergedMode);
    setInternalInlineCollapsed(mergedInlineCollapsed);
    if (!mountRef.current) {
      return;
    }
    if (isInlineMode) {
      setMergedOpenKeys(inlineCacheOpenKeys);
    } else {
      triggerOpenKeys(EMPTY_LIST$1);
    }
  }, [mergedMode, mergedInlineCollapsed]);
  var _React$useState9 = React.useState(0), _React$useState10 = _slicedToArray$1(_React$useState9, 2), lastVisibleIndex = _React$useState10[0], setLastVisibleIndex = _React$useState10[1];
  var allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
  React.useEffect(function() {
    if (isInlineMode) {
      setInlineCacheOpenKeys(mergedOpenKeys);
    }
  }, [mergedOpenKeys]);
  React.useEffect(function() {
    mountRef.current = true;
    return function() {
      mountRef.current = false;
    };
  }, []);
  var _useKeyRecords = useKeyRecords$1(), registerPath = _useKeyRecords.registerPath, unregisterPath = _useKeyRecords.unregisterPath, refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys, isSubPathKey = _useKeyRecords.isSubPathKey, getKeyPath = _useKeyRecords.getKeyPath, getKeys = _useKeyRecords.getKeys, getSubPathKeys = _useKeyRecords.getSubPathKeys;
  var registerPathContext = React.useMemo(function() {
    return {
      registerPath,
      unregisterPath
    };
  }, [registerPath, unregisterPath]);
  var pathUserContext = React.useMemo(function() {
    return {
      isSubPathKey
    };
  }, [isSubPathKey]);
  React.useEffect(function() {
    refreshOverflowKeys(allVisible ? EMPTY_LIST$1 : childList.slice(lastVisibleIndex + 1).map(function(child) {
      return child.key;
    }));
  }, [lastVisibleIndex, allVisible]);
  var _useMergedState3 = useMergedState$2(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
    value: activeKey
  }), _useMergedState4 = _slicedToArray$1(_useMergedState3, 2), mergedActiveKey = _useMergedState4[0], setMergedActiveKey = _useMergedState4[1];
  var onActive = useMemoCallback$1(function(key) {
    setMergedActiveKey(key);
  });
  var onInactive = useMemoCallback$1(function() {
    setMergedActiveKey(void 0);
  });
  React.useImperativeHandle(ref2, function() {
    return {
      list: containerRef.current,
      focus: function focus(options) {
        var _childList$find;
        var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : (_childList$find = childList.find(function(node2) {
          return !node2.props.disabled;
        })) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
        if (shouldFocusKey) {
          var _containerRef$current, _containerRef$current2, _containerRef$current3;
          (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.querySelector("li[data-menu-id='".concat(getMenuId$1(uuid2, shouldFocusKey), "']"))) === null || _containerRef$current2 === void 0 ? void 0 : (_containerRef$current3 = _containerRef$current2.focus) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.call(_containerRef$current2, options);
        }
      }
    };
  });
  var _useMergedState5 = useMergedState$2(defaultSelectedKeys || [], {
    value: selectedKeys,
    postState: function postState(keys2) {
      if (Array.isArray(keys2)) {
        return keys2;
      }
      if (keys2 === null || keys2 === void 0) {
        return EMPTY_LIST$1;
      }
      return [keys2];
    }
  }), _useMergedState6 = _slicedToArray$1(_useMergedState5, 2), mergedSelectKeys = _useMergedState6[0], setMergedSelectKeys = _useMergedState6[1];
  var triggerSelection = function triggerSelection2(info) {
    if (selectable) {
      var targetKey = info.key;
      var exist = mergedSelectKeys.includes(targetKey);
      var newSelectKeys;
      if (multiple) {
        if (exist) {
          newSelectKeys = mergedSelectKeys.filter(function(key) {
            return key !== targetKey;
          });
        } else {
          newSelectKeys = [].concat(_toConsumableArray(mergedSelectKeys), [targetKey]);
        }
      } else {
        newSelectKeys = [targetKey];
      }
      setMergedSelectKeys(newSelectKeys);
      var selectInfo = _objectSpread2$d(_objectSpread2$d({}, info), {}, {
        selectedKeys: newSelectKeys
      });
      if (exist) {
        onDeselect === null || onDeselect === void 0 ? void 0 : onDeselect(selectInfo);
      } else {
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectInfo);
      }
    }
    if (!multiple && mergedOpenKeys.length && internalMode !== "inline") {
      triggerOpenKeys(EMPTY_LIST$1);
    }
  };
  var onInternalClick = useMemoCallback$1(function(info) {
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp$1(info));
    triggerSelection(info);
  });
  var onInternalOpenChange = useMemoCallback$1(function(key, open) {
    var newOpenKeys = mergedOpenKeys.filter(function(k2) {
      return k2 !== key;
    });
    if (open) {
      newOpenKeys.push(key);
    } else if (internalMode !== "inline") {
      var subPathKeys = getSubPathKeys(key);
      newOpenKeys = newOpenKeys.filter(function(k2) {
        return !subPathKeys.has(k2);
      });
    }
    if (!isEqual$4(mergedOpenKeys, newOpenKeys, true)) {
      triggerOpenKeys(newOpenKeys, true);
    }
  });
  var getInternalPopupContainer = useMemoCallback$1(getPopupContainer);
  var triggerAccessibilityOpen = function triggerAccessibilityOpen2(key, open) {
    var nextOpen = open !== null && open !== void 0 ? open : !mergedOpenKeys.includes(key);
    onInternalOpenChange(key, nextOpen);
  };
  var onInternalKeyDown = useAccessibility$1(internalMode, mergedActiveKey, isRtl, uuid2, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown);
  React.useEffect(function() {
    setMounted(true);
  }, []);
  var privateContext = React.useMemo(function() {
    return {
      _internalRenderMenuItem,
      _internalRenderSubMenuItem
    };
  }, [_internalRenderMenuItem, _internalRenderSubMenuItem]);
  var wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : childList.map(function(child, index2) {
    return /* @__PURE__ */ React.createElement(InheritableContextProvider$1, {
      key: child.key,
      overflowDisabled: index2 > lastVisibleIndex
    }, child);
  });
  var container = /* @__PURE__ */ React.createElement(ForwardOverflow$1, _extends$3({
    id,
    ref: containerRef,
    prefixCls: "".concat(prefixCls, "-overflow"),
    component: "ul",
    itemComponent: Item$5,
    className: classNames(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(internalMode), className, (_classNames = {}, _defineProperty$3(_classNames, "".concat(prefixCls, "-inline-collapsed"), internalInlineCollapsed), _defineProperty$3(_classNames, "".concat(prefixCls, "-rtl"), isRtl), _classNames), rootClassName),
    dir: direction,
    style: style2,
    role: "menu",
    tabIndex,
    data: wrappedChildList,
    renderRawItem: function renderRawItem(node2) {
      return node2;
    },
    renderRawRest: function renderRawRest(omitItems) {
      var len = omitItems.length;
      var originOmitItems = len ? childList.slice(-len) : null;
      return /* @__PURE__ */ React.createElement(SubMenu$3, {
        eventKey: OVERFLOW_KEY$1,
        title: overflowedIndicator,
        disabled: allVisible,
        internalPopupClose: len === 0,
        popupClassName: overflowedIndicatorPopupClassName
      }, originOmitItems);
    },
    maxCount: internalMode !== "horizontal" || disabledOverflow ? ForwardOverflow$1.INVALIDATE : ForwardOverflow$1.RESPONSIVE,
    ssr: "full",
    "data-menu-list": true,
    onVisibleChange: function onVisibleChange(newLastIndex) {
      setLastVisibleIndex(newLastIndex);
    },
    onKeyDown: onInternalKeyDown
  }, restProps));
  return /* @__PURE__ */ React.createElement(PrivateContext$1.Provider, {
    value: privateContext
  }, /* @__PURE__ */ React.createElement(IdContext$1.Provider, {
    value: uuid2
  }, /* @__PURE__ */ React.createElement(InheritableContextProvider$1, {
    prefixCls,
    rootClassName,
    mode: internalMode,
    openKeys: mergedOpenKeys,
    rtl: isRtl,
    disabled,
    motion: mounted ? motion2 : null,
    defaultMotions: mounted ? defaultMotions : null,
    activeKey: mergedActiveKey,
    onActive,
    onInactive,
    selectedKeys: mergedSelectKeys,
    inlineIndent,
    subMenuOpenDelay,
    subMenuCloseDelay,
    forceSubMenuRender,
    builtinPlacements,
    triggerSubMenuAction,
    getPopupContainer: getInternalPopupContainer,
    itemIcon,
    expandIcon,
    onItemClick: onInternalClick,
    onOpenChange: onInternalOpenChange
  }, /* @__PURE__ */ React.createElement(PathUserContext$1.Provider, {
    value: pathUserContext
  }, container), /* @__PURE__ */ React.createElement("div", {
    style: {
      display: "none"
    },
    "aria-hidden": true
  }, /* @__PURE__ */ React.createElement(PathRegisterContext$1.Provider, {
    value: registerPathContext
  }, childList)))));
});
var _excluded$l = ["className", "title", "eventKey", "children"], _excluded2$6 = ["children"];
var InternalMenuItemGroup$1 = function InternalMenuItemGroup(_ref2) {
  var className = _ref2.className, title = _ref2.title;
  _ref2.eventKey;
  var children = _ref2.children, restProps = _objectWithoutProperties$1(_ref2, _excluded$l);
  var _React$useContext = React.useContext(MenuContext$3), prefixCls = _React$useContext.prefixCls;
  var groupPrefixCls = "".concat(prefixCls, "-item-group");
  return /* @__PURE__ */ React.createElement("li", _extends$3({
    role: "presentation"
  }, restProps, {
    onClick: function onClick(e2) {
      return e2.stopPropagation();
    },
    className: classNames(groupPrefixCls, className)
  }), /* @__PURE__ */ React.createElement("div", {
    role: "presentation",
    className: "".concat(groupPrefixCls, "-title"),
    title: typeof title === "string" ? title : void 0
  }, title), /* @__PURE__ */ React.createElement("ul", {
    role: "group",
    className: "".concat(groupPrefixCls, "-list")
  }, children));
};
function MenuItemGroup$1(_ref2) {
  var children = _ref2.children, props = _objectWithoutProperties$1(_ref2, _excluded2$6);
  var connectedKeyPath = useFullPath$1(props.eventKey);
  var childList = parseChildren$1(children, connectedKeyPath);
  var measure = useMeasure$1();
  if (measure) {
    return childList;
  }
  return /* @__PURE__ */ React.createElement(InternalMenuItemGroup$1, omit$5(props, ["warnKey"]), childList);
}
function Divider$3(_ref2) {
  var className = _ref2.className, style2 = _ref2.style;
  var _React$useContext = React.useContext(MenuContext$3), prefixCls = _React$useContext.prefixCls;
  var measure = useMeasure$1();
  if (measure) {
    return null;
  }
  return /* @__PURE__ */ React.createElement("li", {
    className: classNames("".concat(prefixCls, "-item-divider"), className),
    style: style2
  });
}
var ExportMenu$1 = Menu$3;
ExportMenu$1.Item = Item$5;
ExportMenu$1.SubMenu = SubMenu$3;
ExportMenu$1.ItemGroup = MenuItemGroup$1;
ExportMenu$1.Divider = Divider$3;
var EllipsisOutlined = function EllipsisOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: EllipsisOutlinedSvg
  }));
};
EllipsisOutlined.displayName = "EllipsisOutlined";
var EllipsisOutlined$1 = /* @__PURE__ */ React.forwardRef(EllipsisOutlined);
const getHorizontalStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow,
    menuHorizontalHeight,
    colorSplit,
    lineWidth,
    lineType,
    menuItemPaddingInline
  } = token2;
  return {
    [`${componentCls}-horizontal`]: {
      lineHeight: `${menuHorizontalHeight}px`,
      border: 0,
      borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
      boxShadow: "none",
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        content: '"\\20"'
      },
      [`${componentCls}-item, ${componentCls}-submenu`]: {
        position: "relative",
        display: "inline-block",
        verticalAlign: "bottom",
        paddingInline: menuItemPaddingInline
      },
      [`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: {
        backgroundColor: "transparent"
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(",")
      },
      [`${componentCls}-submenu-arrow`]: {
        display: "none"
      }
    }
  };
};
var getHorizontalStyle$1 = getHorizontalStyle;
const getRTLStyle = (_ref2) => {
  let {
    componentCls,
    menuArrowOffset
  } = _ref2;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-submenu-rtl`]: {
      transformOrigin: "100% 0"
    },
    [`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: {
      [`${componentCls}-submenu-arrow`]: {
        "&::before": {
          transform: `rotate(-45deg) translateY(-${menuArrowOffset})`
        },
        "&::after": {
          transform: `rotate(45deg) translateY(${menuArrowOffset})`
        }
      }
    }
  };
};
var getRTLStyle$1 = getRTLStyle;
const accessibilityFocus = (token2) => Object.assign({}, genFocusOutline(token2));
const getThemeStyle = (token2, themeSuffix) => {
  const {
    componentCls,
    colorItemText,
    colorItemTextSelected,
    colorGroupTitle,
    colorItemBg,
    colorSubItemBg,
    colorItemBgSelected,
    colorActiveBarHeight,
    colorActiveBarWidth,
    colorActiveBarBorderSize,
    motionDurationSlow,
    motionEaseInOut,
    motionEaseOut,
    menuItemPaddingInline,
    motionDurationMid,
    colorItemTextHover,
    lineType,
    colorSplit,
    colorItemTextDisabled,
    colorDangerItemText,
    colorDangerItemTextHover,
    colorDangerItemTextSelected,
    colorDangerItemBgActive,
    colorDangerItemBgSelected,
    colorItemBgHover,
    menuSubMenuBg,
    colorItemTextSelectedHorizontal,
    colorItemBgSelectedHorizontal
  } = token2;
  return {
    [`${componentCls}-${themeSuffix}, ${componentCls}-${themeSuffix} > ${componentCls}`]: {
      color: colorItemText,
      background: colorItemBg,
      [`&${componentCls}-root:focus-visible`]: Object.assign({}, accessibilityFocus(token2)),
      [`${componentCls}-item-group-title`]: {
        color: colorGroupTitle
      },
      [`${componentCls}-submenu-selected`]: {
        [`> ${componentCls}-submenu-title`]: {
          color: colorItemTextSelected
        }
      },
      [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
        color: `${colorItemTextDisabled} !important`
      },
      [`${componentCls}-item:hover, ${componentCls}-submenu-title:hover`]: {
        [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
          color: colorItemTextHover
        }
      },
      [`&:not(${componentCls}-horizontal)`]: {
        [`${componentCls}-item:not(${componentCls}-item-selected)`]: {
          "&:hover": {
            backgroundColor: colorItemBgHover
          },
          "&:active": {
            backgroundColor: colorItemBgSelected
          }
        },
        [`${componentCls}-submenu-title`]: {
          "&:hover": {
            backgroundColor: colorItemBgHover
          },
          "&:active": {
            backgroundColor: colorItemBgSelected
          }
        }
      },
      [`${componentCls}-item-danger`]: {
        color: colorDangerItemText,
        [`&${componentCls}-item:hover`]: {
          [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
            color: colorDangerItemTextHover
          }
        },
        [`&${componentCls}-item:active`]: {
          background: colorDangerItemBgActive
        }
      },
      [`${componentCls}-item a`]: {
        "&, &:hover": {
          color: "inherit"
        }
      },
      [`${componentCls}-item-selected`]: {
        color: colorItemTextSelected,
        [`&${componentCls}-item-danger`]: {
          color: colorDangerItemTextSelected
        },
        [`a, a:hover`]: {
          color: "inherit"
        }
      },
      [`& ${componentCls}-item-selected`]: {
        backgroundColor: colorItemBgSelected,
        [`&${componentCls}-item-danger`]: {
          backgroundColor: colorDangerItemBgSelected
        }
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        [`&:not(${componentCls}-item-disabled):focus-visible`]: Object.assign({}, accessibilityFocus(token2))
      },
      [`&${componentCls}-submenu > ${componentCls}`]: {
        backgroundColor: menuSubMenuBg
      },
      [`&${componentCls}-popup > ${componentCls}`]: {
        backgroundColor: colorItemBg
      },
      [`&${componentCls}-horizontal`]: Object.assign(Object.assign({}, themeSuffix === "dark" ? {
        borderBottom: 0
      } : {}), {
        [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
          top: colorActiveBarBorderSize,
          marginTop: -colorActiveBarBorderSize,
          marginBottom: 0,
          borderRadius: 0,
          "&::after": {
            position: "absolute",
            insetInline: menuItemPaddingInline,
            bottom: 0,
            borderBottom: `${colorActiveBarHeight}px solid transparent`,
            transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
            content: '""'
          },
          [`&:hover, &-active, &-open`]: {
            "&::after": {
              borderBottomWidth: colorActiveBarHeight,
              borderBottomColor: colorItemTextSelectedHorizontal
            }
          },
          [`&-selected`]: {
            color: colorItemTextSelectedHorizontal,
            backgroundColor: colorItemBgSelectedHorizontal,
            "&::after": {
              borderBottomWidth: colorActiveBarHeight,
              borderBottomColor: colorItemTextSelectedHorizontal
            }
          }
        }
      }),
      [`&${componentCls}-root`]: {
        [`&${componentCls}-inline, &${componentCls}-vertical`]: {
          borderInlineEnd: `${colorActiveBarBorderSize}px ${lineType} ${colorSplit}`
        }
      },
      [`&${componentCls}-inline`]: {
        [`${componentCls}-sub${componentCls}-inline`]: {
          background: colorSubItemBg
        },
        [`${componentCls}-item, ${componentCls}-submenu-title`]: colorActiveBarBorderSize && colorActiveBarWidth ? {
          width: `calc(100% + ${colorActiveBarBorderSize}px)`
        } : {},
        [`${componentCls}-item`]: {
          position: "relative",
          "&::after": {
            position: "absolute",
            insetBlock: 0,
            insetInlineEnd: 0,
            borderInlineEnd: `${colorActiveBarWidth}px solid ${colorItemTextSelected}`,
            transform: "scaleY(0.0001)",
            opacity: 0,
            transition: [`transform ${motionDurationMid} ${motionEaseOut}`, `opacity ${motionDurationMid} ${motionEaseOut}`].join(","),
            content: '""'
          },
          [`&${componentCls}-item-danger`]: {
            "&::after": {
              borderInlineEndColor: colorDangerItemTextSelected
            }
          }
        },
        [`${componentCls}-selected, ${componentCls}-item-selected`]: {
          "&::after": {
            transform: "scaleY(1)",
            opacity: 1,
            transition: [`transform ${motionDurationMid} ${motionEaseInOut}`, `opacity ${motionDurationMid} ${motionEaseInOut}`].join(",")
          }
        }
      }
    }
  };
};
var getThemeStyle$1 = getThemeStyle;
const getVerticalInlineStyle = (token2) => {
  const {
    componentCls,
    menuItemHeight,
    itemMarginInline,
    padding,
    menuArrowSize,
    marginXS,
    marginXXS
  } = token2;
  const paddingWithArrow = padding + menuArrowSize + marginXS;
  return {
    [`${componentCls}-item`]: {
      position: "relative"
    },
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      height: menuItemHeight,
      lineHeight: `${menuItemHeight}px`,
      paddingInline: padding,
      overflow: "hidden",
      textOverflow: "ellipsis",
      marginInline: itemMarginInline,
      marginBlock: marginXXS,
      width: `calc(100% - ${itemMarginInline * 2}px)`
    },
    [`${componentCls}-submenu`]: {
      paddingBottom: 0.02
    },
    [`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
      height: menuItemHeight,
      lineHeight: `${menuItemHeight}px`
    },
    [`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: {
      paddingInlineEnd: paddingWithArrow
    }
  };
};
const getVerticalStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    menuItemHeight,
    colorTextLightSolid,
    dropdownWidth,
    controlHeightLG,
    motionDurationMid,
    motionEaseOut,
    paddingXL,
    fontSizeSM,
    fontSizeLG,
    motionDurationSlow,
    paddingXS,
    boxShadowSecondary
  } = token2;
  const inlineItemStyle = {
    height: menuItemHeight,
    lineHeight: `${menuItemHeight}px`,
    listStylePosition: "inside",
    listStyleType: "disc"
  };
  return [
    {
      [componentCls]: {
        [`&-inline, &-vertical`]: Object.assign({
          [`&${componentCls}-root`]: {
            boxShadow: "none"
          }
        }, getVerticalInlineStyle(token2))
      },
      [`${componentCls}-submenu-popup`]: {
        [`${componentCls}-vertical`]: Object.assign(Object.assign({}, getVerticalInlineStyle(token2)), {
          boxShadow: boxShadowSecondary
        })
      }
    },
    {
      [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
        minWidth: dropdownWidth,
        maxHeight: `calc(100vh - ${controlHeightLG * 2.5}px)`,
        padding: "0",
        overflow: "hidden",
        borderInlineEnd: 0,
        "&:not([class*='-active'])": {
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    },
    {
      [`${componentCls}-inline`]: {
        width: "100%",
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu-title`]: {
            display: "flex",
            alignItems: "center",
            transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationMid} ${motionEaseOut}`].join(","),
            [`> ${componentCls}-title-content`]: {
              flex: "auto",
              minWidth: 0,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            "> *": {
              flex: "none"
            }
          }
        },
        [`${componentCls}-sub${componentCls}-inline`]: {
          padding: 0,
          border: 0,
          borderRadius: 0,
          boxShadow: "none",
          [`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
          [`& ${componentCls}-item-group-title`]: {
            paddingInlineStart: paddingXL
          }
        },
        [`${componentCls}-item`]: inlineItemStyle
      }
    },
    {
      [`${componentCls}-inline-collapsed`]: {
        width: menuItemHeight * 2,
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: {
            [`> ${componentCls}-inline-collapsed-noicon`]: {
              fontSize: fontSizeLG,
              textAlign: "center"
            }
          }
        },
        [`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
          insetInlineStart: 0,
          paddingInline: `calc(50% - ${fontSizeSM}px)`,
          textOverflow: "clip",
          [`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: {
            opacity: 0
          },
          [`${componentCls}-item-icon, ${iconCls}`]: {
            margin: 0,
            fontSize: fontSizeLG,
            lineHeight: `${menuItemHeight}px`,
            "+ span": {
              display: "inline-block",
              opacity: 0
            }
          }
        },
        [`${componentCls}-item-icon, ${iconCls}`]: {
          display: "inline-block"
        },
        "&-tooltip": {
          pointerEvents: "none",
          [`${componentCls}-item-icon, ${iconCls}`]: {
            display: "none"
          },
          "a, a:hover": {
            color: colorTextLightSolid
          }
        },
        [`${componentCls}-item-group-title`]: Object.assign(Object.assign({}, textEllipsis), {
          paddingInline: paddingXS
        })
      }
    }
  ];
};
var getVerticalStyle$1 = getVerticalStyle;
const genMenuItemStyle = (token2) => {
  const {
    componentCls,
    fontSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    motionEaseOut,
    iconCls,
    controlHeightSM
  } = token2;
  return {
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      position: "relative",
      display: "block",
      margin: 0,
      whiteSpace: "nowrap",
      cursor: "pointer",
      transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(","),
      [`${componentCls}-item-icon, ${iconCls}`]: {
        minWidth: fontSize,
        fontSize,
        transition: [`font-size ${motionDurationMid} ${motionEaseOut}`, `margin ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow}`].join(","),
        "+ span": {
          marginInlineStart: controlHeightSM - fontSize,
          opacity: 1,
          transition: [`opacity ${motionDurationSlow} ${motionEaseInOut}`, `margin ${motionDurationSlow}`, `color ${motionDurationSlow}`].join(",")
        }
      },
      [`${componentCls}-item-icon`]: Object.assign({}, resetIcon()),
      [`&${componentCls}-item-only-child`]: {
        [`> ${iconCls}, > ${componentCls}-item-icon`]: {
          marginInlineEnd: 0
        }
      }
    },
    [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
      background: "none !important",
      cursor: "not-allowed",
      "&::after": {
        borderColor: "transparent !important"
      },
      a: {
        color: "inherit !important"
      },
      [`> ${componentCls}-submenu-title`]: {
        color: "inherit !important",
        cursor: "not-allowed"
      }
    }
  };
};
const genSubMenuArrowStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow,
    motionEaseInOut,
    borderRadius,
    menuArrowSize,
    menuArrowOffset
  } = token2;
  return {
    [`${componentCls}-submenu`]: {
      [`&-expand-icon, &-arrow`]: {
        position: "absolute",
        top: "50%",
        insetInlineEnd: token2.margin,
        width: menuArrowSize,
        color: "currentcolor",
        transform: "translateY(-50%)",
        transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
      },
      "&-arrow": {
        "&::before, &::after": {
          position: "absolute",
          width: menuArrowSize * 0.6,
          height: menuArrowSize * 0.15,
          backgroundColor: "currentcolor",
          borderRadius,
          transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `transform ${motionDurationSlow} ${motionEaseInOut}`, `top ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow} ${motionEaseInOut}`].join(","),
          content: '""'
        },
        "&::before": {
          transform: `rotate(45deg) translateY(-${menuArrowOffset})`
        },
        "&::after": {
          transform: `rotate(-45deg) translateY(${menuArrowOffset})`
        }
      }
    }
  };
};
const getBaseStyle = (token2) => {
  const {
    antCls,
    componentCls,
    fontSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    lineHeight,
    paddingXS,
    padding,
    colorSplit,
    lineWidth,
    zIndexPopup,
    borderRadiusLG,
    radiusSubMenuItem,
    menuArrowSize,
    menuArrowOffset,
    lineType,
    menuPanelMaskInset
  } = token2;
  return [
    {
      "": {
        [`${componentCls}`]: Object.assign(Object.assign({}, clearFix()), {
          [`&-hidden`]: {
            display: "none"
          }
        })
      },
      [`${componentCls}-submenu-hidden`]: {
        display: "none"
      }
    },
    {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), clearFix()), {
        marginBottom: 0,
        paddingInlineStart: 0,
        fontSize,
        lineHeight: 0,
        listStyle: "none",
        outline: "none",
        transition: [
          `background ${motionDurationSlow}`,
          `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`
        ].join(","),
        [`ul, ol`]: {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        [`&-overflow`]: {
          display: "flex",
          [`${componentCls}-item`]: {
            flex: "none"
          }
        },
        [`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: {
          borderRadius: token2.radiusItem
        },
        [`${componentCls}-item-group-title`]: {
          padding: `${paddingXS}px ${padding}px`,
          fontSize,
          lineHeight,
          transition: `all ${motionDurationSlow}`
        },
        [`&-horizontal ${componentCls}-submenu`]: {
          transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-submenu, ${componentCls}-submenu-inline`]: {
          transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationMid} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-submenu ${componentCls}-sub`]: {
          cursor: "initial",
          transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-title-content`]: {
          transition: `color ${motionDurationSlow}`
        },
        [`${componentCls}-item a`]: {
          "&::before": {
            position: "absolute",
            inset: 0,
            backgroundColor: "transparent",
            content: '""'
          }
        },
        [`${componentCls}-item-divider`]: {
          overflow: "hidden",
          lineHeight: 0,
          borderColor: colorSplit,
          borderStyle: lineType,
          borderWidth: 0,
          borderTopWidth: lineWidth,
          marginBlock: lineWidth,
          padding: 0,
          "&-dashed": {
            borderStyle: "dashed"
          }
        }
      }), genMenuItemStyle(token2)), {
        [`${componentCls}-item-group`]: {
          [`${componentCls}-item-group-list`]: {
            margin: 0,
            padding: 0,
            [`${componentCls}-item, ${componentCls}-submenu-title`]: {
              paddingInline: `${fontSize * 2}px ${padding}px`
            }
          }
        },
        "&-submenu": {
          "&-popup": {
            position: "absolute",
            zIndex: zIndexPopup,
            background: "transparent",
            borderRadius: borderRadiusLG,
            boxShadow: "none",
            transformOrigin: "0 0",
            "&::before": {
              position: "absolute",
              inset: `${menuPanelMaskInset}px 0 0`,
              zIndex: -1,
              width: "100%",
              height: "100%",
              opacity: 0,
              content: '""'
            }
          },
          "&-placement-rightTop::before": {
            top: 0,
            insetInlineStart: menuPanelMaskInset
          },
          [`> ${componentCls}`]: Object.assign(Object.assign(Object.assign({
            borderRadius: borderRadiusLG
          }, genMenuItemStyle(token2)), genSubMenuArrowStyle(token2)), {
            [`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
              borderRadius: radiusSubMenuItem
            },
            [`${componentCls}-submenu-title::after`]: {
              transition: `transform ${motionDurationSlow} ${motionEaseInOut}`
            }
          })
        }
      }), genSubMenuArrowStyle(token2)), {
        [`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
          "&::before": {
            transform: `rotate(-45deg) translateX(${menuArrowOffset})`
          },
          "&::after": {
            transform: `rotate(45deg) translateX(-${menuArrowOffset})`
          }
        },
        [`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
          transform: `translateY(-${menuArrowSize * 0.2}px)`,
          "&::after": {
            transform: `rotate(-45deg) translateX(-${menuArrowOffset})`
          },
          "&::before": {
            transform: `rotate(45deg) translateX(${menuArrowOffset})`
          }
        }
      })
    },
    {
      [`${antCls}-layout-header`]: {
        [componentCls]: {
          lineHeight: "inherit"
        }
      }
    }
  ];
};
var useStyle$c = (prefixCls, injectStyle) => {
  const useOriginHook = genComponentStyleHook$2("Menu", (token2, _ref2) => {
    let {
      overrideComponentToken
    } = _ref2;
    if (injectStyle === false) {
      return [];
    }
    const {
      colorBgElevated,
      colorPrimary,
      colorError,
      colorErrorHover,
      colorTextLightSolid,
      controlHeightLG,
      fontSize
    } = token2;
    const menuArrowSize = fontSize / 7 * 5;
    const menuToken = merge$1(token2, {
      menuItemHeight: controlHeightLG,
      menuItemPaddingInline: token2.margin,
      menuArrowSize,
      menuHorizontalHeight: controlHeightLG * 1.15,
      menuArrowOffset: `${menuArrowSize * 0.25}px`,
      menuPanelMaskInset: -7,
      menuSubMenuBg: colorBgElevated
    });
    const colorTextDark = new TinyColor(colorTextLightSolid).setAlpha(0.65).toRgbString();
    const menuDarkToken = merge$1(menuToken, {
      colorItemText: colorTextDark,
      colorItemTextHover: colorTextLightSolid,
      colorGroupTitle: colorTextDark,
      colorItemTextSelected: colorTextLightSolid,
      colorItemBg: "#001529",
      colorSubItemBg: "#000c17",
      colorItemBgActive: "transparent",
      colorItemBgSelected: colorPrimary,
      colorActiveBarWidth: 0,
      colorActiveBarHeight: 0,
      colorActiveBarBorderSize: 0,
      colorItemTextDisabled: new TinyColor(colorTextLightSolid).setAlpha(0.25).toRgbString(),
      colorDangerItemText: colorError,
      colorDangerItemTextHover: colorErrorHover,
      colorDangerItemTextSelected: colorTextLightSolid,
      colorDangerItemBgActive: colorError,
      colorDangerItemBgSelected: colorError,
      menuSubMenuBg: "#001529",
      colorItemTextSelectedHorizontal: colorTextLightSolid,
      colorItemBgSelectedHorizontal: colorPrimary
    }, Object.assign({}, overrideComponentToken));
    return [
      getBaseStyle(menuToken),
      getHorizontalStyle$1(menuToken),
      getVerticalStyle$1(menuToken),
      getThemeStyle$1(menuToken, "light"),
      getThemeStyle$1(menuDarkToken, "dark"),
      getRTLStyle$1(menuToken),
      genCollapseMotion$1(menuToken),
      initSlideMotion(menuToken, "slide-up"),
      initSlideMotion(menuToken, "slide-down"),
      initZoomMotion(menuToken, "zoom-big")
    ];
  }, (token2) => {
    const {
      colorPrimary,
      colorError,
      colorTextDisabled,
      colorErrorBg,
      colorText,
      colorTextDescription,
      colorBgContainer,
      colorFillAlter,
      colorFillContent,
      lineWidth,
      lineWidthBold,
      controlItemBgActive,
      colorBgTextHover
    } = token2;
    return {
      dropdownWidth: 160,
      zIndexPopup: token2.zIndexPopupBase + 50,
      radiusItem: token2.borderRadiusLG,
      radiusSubMenuItem: token2.borderRadiusSM,
      colorItemText: colorText,
      colorItemTextHover: colorText,
      colorItemTextHoverHorizontal: colorPrimary,
      colorGroupTitle: colorTextDescription,
      colorItemTextSelected: colorPrimary,
      colorItemTextSelectedHorizontal: colorPrimary,
      colorItemBg: colorBgContainer,
      colorItemBgHover: colorBgTextHover,
      colorItemBgActive: colorFillContent,
      colorSubItemBg: colorFillAlter,
      colorItemBgSelected: controlItemBgActive,
      colorItemBgSelectedHorizontal: "transparent",
      colorActiveBarWidth: 0,
      colorActiveBarHeight: lineWidthBold,
      colorActiveBarBorderSize: lineWidth,
      colorItemTextDisabled: colorTextDisabled,
      colorDangerItemText: colorError,
      colorDangerItemTextHover: colorError,
      colorDangerItemTextSelected: colorError,
      colorDangerItemBgActive: colorErrorBg,
      colorDangerItemBgSelected: colorErrorBg,
      itemMarginInline: token2.marginXXS
    };
  });
  return useOriginHook(prefixCls);
};
var __rest$u = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const OverrideContext = /* @__PURE__ */ React.createContext(null);
const OverrideProvider = (props) => {
  const {
    children
  } = props, restProps = __rest$u(props, ["children"]);
  const override = React.useContext(OverrideContext);
  const context2 = React.useMemo(() => Object.assign(Object.assign({}, override), restProps), [
    override,
    restProps.prefixCls,
    restProps.mode,
    restProps.selectable
  ]);
  return /* @__PURE__ */ React.createElement(OverrideContext.Provider, {
    value: context2
  }, children);
};
var __rest$t = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const MenuDivider = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    dashed
  } = props, restProps = __rest$t(props, ["prefixCls", "className", "dashed"]);
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("menu", customizePrefixCls);
  const classString = classNames({
    [`${prefixCls}-item-divider-dashed`]: !!dashed
  }, className);
  return /* @__PURE__ */ React.createElement(Divider$3, Object.assign({
    className: classString
  }, restProps));
};
var MenuDivider$1 = MenuDivider;
var LeftOutlined = function LeftOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: LeftOutlinedSvg
  }));
};
LeftOutlined.displayName = "LeftOutlined";
var LeftOutlined$1 = /* @__PURE__ */ React.forwardRef(LeftOutlined);
globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const SiderContext = /* @__PURE__ */ React.createContext({});
const MenuContext$1 = /* @__PURE__ */ React.createContext({
  prefixCls: "",
  firstLevel: true,
  inlineCollapsed: false
});
var MenuContext$2 = MenuContext$1;
const MenuItem$2 = (props) => {
  var _a2;
  const {
    className,
    children,
    icon,
    title,
    danger
  } = props;
  const {
    prefixCls,
    firstLevel,
    direction,
    disableMenuItemTitleTooltip,
    inlineCollapsed: isInlineCollapsed
  } = React.useContext(MenuContext$2);
  const renderItemChildren = (inlineCollapsed) => {
    const wrapNode = /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-title-content`
    }, children);
    if (!icon || isValidElement$1(children) && children.type === "span") {
      if (children && inlineCollapsed && firstLevel && typeof children === "string") {
        return /* @__PURE__ */ React.createElement("div", {
          className: `${prefixCls}-inline-collapsed-noicon`
        }, children.charAt(0));
      }
    }
    return wrapNode;
  };
  const {
    siderCollapsed
  } = React.useContext(SiderContext);
  let tooltipTitle = title;
  if (typeof title === "undefined") {
    tooltipTitle = firstLevel ? children : "";
  } else if (title === false) {
    tooltipTitle = "";
  }
  const tooltipProps = {
    title: tooltipTitle
  };
  if (!siderCollapsed && !isInlineCollapsed) {
    tooltipProps.title = null;
    tooltipProps.open = false;
  }
  const childrenLength = toArray$9(children).length;
  let returnNode2 = /* @__PURE__ */ React.createElement(Item$5, Object.assign({}, omit$5(props, ["title", "icon", "danger"]), {
    className: classNames({
      [`${prefixCls}-item-danger`]: danger,
      [`${prefixCls}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
    }, className),
    title: typeof title === "string" ? title : void 0
  }), cloneElement$1(icon, {
    className: classNames(isValidElement$1(icon) ? (_a2 = icon.props) === null || _a2 === void 0 ? void 0 : _a2.className : "", `${prefixCls}-item-icon`)
  }), renderItemChildren(isInlineCollapsed));
  if (!disableMenuItemTitleTooltip) {
    returnNode2 = /* @__PURE__ */ React.createElement(Tooltip$1, Object.assign({}, tooltipProps, {
      placement: direction === "rtl" ? "left" : "right",
      overlayClassName: `${prefixCls}-inline-collapsed-tooltip`
    }), returnNode2);
  }
  return returnNode2;
};
var Item$4 = MenuItem$2;
const SubMenu$1 = (props) => {
  var _a2;
  const {
    popupClassName,
    icon,
    title,
    theme: customTheme
  } = props;
  const context2 = React.useContext(MenuContext$2);
  const {
    prefixCls,
    inlineCollapsed,
    theme: contextTheme,
    mode
  } = context2;
  const parentPath = useFullPath$1();
  let titleNode;
  if (!icon) {
    titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-inline-collapsed-noicon`
    }, title.charAt(0)) : /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-title-content`
    }, title);
  } else {
    const titleIsSpan = isValidElement$1(title) && title.type === "span";
    titleNode = /* @__PURE__ */ React.createElement(React.Fragment, null, cloneElement$1(icon, {
      className: classNames(isValidElement$1(icon) ? (_a2 = icon.props) === null || _a2 === void 0 ? void 0 : _a2.className : "", `${prefixCls}-item-icon`)
    }), titleIsSpan ? title : /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-title-content`
    }, title));
  }
  const contextValue = React.useMemo(() => Object.assign(Object.assign({}, context2), {
    firstLevel: false
  }), [context2]);
  const popupOffset = mode === "horizontal" ? [0, 8] : [10, 0];
  return /* @__PURE__ */ React.createElement(MenuContext$2.Provider, {
    value: contextValue
  }, /* @__PURE__ */ React.createElement(SubMenu$3, Object.assign({
    popupOffset
  }, omit$5(props, ["icon"]), {
    title: titleNode,
    popupClassName: classNames(prefixCls, popupClassName, `${prefixCls}-${customTheme || contextTheme}`)
  })));
};
var SubMenu$2 = SubMenu$1;
var __rest$s = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function convertItemsToNodes$1(list2) {
  return (list2 || []).map((opt, index2) => {
    if (opt && typeof opt === "object") {
      const _a2 = opt, {
        label,
        children,
        key,
        type: type4
      } = _a2, restProps = __rest$s(_a2, ["label", "children", "key", "type"]);
      const mergedKey = key !== null && key !== void 0 ? key : `tmp-${index2}`;
      if (children || type4 === "group") {
        if (type4 === "group") {
          return /* @__PURE__ */ React.createElement(MenuItemGroup$1, Object.assign({
            key: mergedKey
          }, restProps, {
            title: label
          }), convertItemsToNodes$1(children));
        }
        return /* @__PURE__ */ React.createElement(SubMenu$2, Object.assign({
          key: mergedKey
        }, restProps, {
          title: label
        }), convertItemsToNodes$1(children));
      }
      if (type4 === "divider") {
        return /* @__PURE__ */ React.createElement(MenuDivider$1, Object.assign({
          key: mergedKey
        }, restProps));
      }
      return /* @__PURE__ */ React.createElement(Item$4, Object.assign({
        key: mergedKey
      }, restProps), label);
    }
    return null;
  }).filter((opt) => opt);
}
function useItems$1(items) {
  return React.useMemo(() => {
    if (!items) {
      return items;
    }
    return convertItemsToNodes$1(items);
  }, [items]);
}
var __rest$r = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const InternalMenu = /* @__PURE__ */ React.forwardRef((props, ref2) => {
  var _a2, _b;
  const override = React.useContext(OverrideContext);
  const overrideObj = override || {};
  const {
    getPrefixCls,
    getPopupContainer,
    direction
  } = React.useContext(ConfigContext$1);
  const rootPrefixCls = getPrefixCls();
  const {
    prefixCls: customizePrefixCls,
    className,
    theme: theme2 = "light",
    expandIcon,
    _internalDisableMenuItemTitleTooltip,
    inlineCollapsed,
    siderCollapsed,
    items,
    children,
    rootClassName,
    mode,
    selectable,
    onClick
  } = props, restProps = __rest$r(props, ["prefixCls", "className", "theme", "expandIcon", "_internalDisableMenuItemTitleTooltip", "inlineCollapsed", "siderCollapsed", "items", "children", "rootClassName", "mode", "selectable", "onClick"]);
  const passedProps = omit$5(restProps, ["collapsedWidth"]);
  const mergedChildren = useItems$1(items) || children;
  (_a2 = overrideObj.validator) === null || _a2 === void 0 ? void 0 : _a2.call(overrideObj, {
    mode
  });
  const onItemClick = useEvent$6(function() {
    var _a3;
    onClick === null || onClick === void 0 ? void 0 : onClick.apply(void 0, arguments);
    (_a3 = overrideObj.onClick) === null || _a3 === void 0 ? void 0 : _a3.call(overrideObj);
  });
  const mergedMode = overrideObj.mode || mode;
  const mergedSelectable = selectable !== null && selectable !== void 0 ? selectable : overrideObj.selectable;
  const mergedInlineCollapsed = React.useMemo(() => {
    if (siderCollapsed !== void 0) {
      return siderCollapsed;
    }
    return inlineCollapsed;
  }, [inlineCollapsed, siderCollapsed]);
  const defaultMotions = {
    horizontal: {
      motionName: `${rootPrefixCls}-slide-up`
    },
    inline: initCollapseMotion(rootPrefixCls),
    other: {
      motionName: `${rootPrefixCls}-zoom-big`
    }
  };
  const prefixCls = getPrefixCls("menu", customizePrefixCls || overrideObj.prefixCls);
  const [wrapSSR, hashId] = useStyle$c(prefixCls, !override);
  const menuClassName = classNames(`${prefixCls}-${theme2}`, className);
  let mergedExpandIcon;
  if (typeof expandIcon === "function") {
    mergedExpandIcon = expandIcon;
  } else {
    const beClone = expandIcon || overrideObj.expandIcon;
    mergedExpandIcon = cloneElement$1(beClone, {
      className: classNames(`${prefixCls}-submenu-expand-icon`, (_b = beClone === null || beClone === void 0 ? void 0 : beClone.props) === null || _b === void 0 ? void 0 : _b.className)
    });
  }
  const contextValue = React.useMemo(() => ({
    prefixCls,
    inlineCollapsed: mergedInlineCollapsed || false,
    direction,
    firstLevel: true,
    theme: theme2,
    mode: mergedMode,
    disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip
  }), [prefixCls, mergedInlineCollapsed, direction, _internalDisableMenuItemTitleTooltip, theme2]);
  return wrapSSR(/* @__PURE__ */ React.createElement(OverrideContext.Provider, {
    value: null
  }, /* @__PURE__ */ React.createElement(MenuContext$2.Provider, {
    value: contextValue
  }, /* @__PURE__ */ React.createElement(ExportMenu$1, Object.assign({
    getPopupContainer,
    overflowedIndicator: /* @__PURE__ */ React.createElement(EllipsisOutlined$1, null),
    overflowedIndicatorPopupClassName: `${prefixCls}-${theme2}`,
    mode: mergedMode,
    selectable: mergedSelectable,
    onClick: onItemClick
  }, passedProps, {
    inlineCollapsed: mergedInlineCollapsed,
    className: menuClassName,
    prefixCls,
    direction,
    defaultMotions,
    expandIcon: mergedExpandIcon,
    ref: ref2,
    rootClassName: classNames(rootClassName, hashId)
  }), mergedChildren))));
});
var InternalMenu$1 = InternalMenu;
const Menu$1 = /* @__PURE__ */ React.forwardRef((props, ref2) => {
  const menuRef = React.useRef(null);
  const context2 = React.useContext(SiderContext);
  React.useImperativeHandle(ref2, () => ({
    menu: menuRef.current,
    focus: (options) => {
      var _a2;
      (_a2 = menuRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus(options);
    }
  }));
  return /* @__PURE__ */ React.createElement(InternalMenu$1, Object.assign({
    ref: menuRef
  }, props, context2));
});
Menu$1.Item = Item$4;
Menu$1.SubMenu = SubMenu$2;
Menu$1.Divider = MenuDivider$1;
Menu$1.ItemGroup = MenuItemGroup$1;
var Menu$2 = Menu$1;
var useFlexGapSupport = () => {
  const [flexible, setFlexible] = React.useState(false);
  React.useEffect(() => {
    setFlexible(detectFlexGapSupported());
  }, []);
  return flexible;
};
function Item$3(_ref2) {
  let {
    className,
    direction,
    index: index2,
    marginDirection,
    children,
    split: split2,
    wrap: wrap2
  } = _ref2;
  const {
    horizontalSize,
    verticalSize,
    latestIndex,
    supportFlexGap
  } = React.useContext(SpaceContext);
  let style2 = {};
  if (!supportFlexGap) {
    if (direction === "vertical") {
      if (index2 < latestIndex) {
        style2 = {
          marginBottom: horizontalSize / (split2 ? 2 : 1)
        };
      }
    } else {
      style2 = Object.assign(Object.assign({}, index2 < latestIndex && {
        [marginDirection]: horizontalSize / (split2 ? 2 : 1)
      }), wrap2 && {
        paddingBottom: verticalSize
      });
    }
  }
  if (children === null || children === void 0) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className,
    style: style2
  }, children), index2 < latestIndex && split2 && /* @__PURE__ */ React.createElement("span", {
    className: `${className}-split`,
    style: style2
  }, split2));
}
var __rest$q = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const SpaceContext = /* @__PURE__ */ React.createContext({
  latestIndex: 0,
  horizontalSize: 0,
  verticalSize: 0,
  supportFlexGap: false
});
const spaceSize = {
  small: 8,
  middle: 16,
  large: 24
};
function getNumberSize(size) {
  return typeof size === "string" ? spaceSize[size] : size || 0;
}
const Space = (props) => {
  const {
    getPrefixCls,
    space: space2,
    direction: directionConfig
  } = React.useContext(ConfigContext$1);
  const {
    size = (space2 === null || space2 === void 0 ? void 0 : space2.size) || "small",
    align,
    className,
    rootClassName,
    children,
    direction = "horizontal",
    prefixCls: customizePrefixCls,
    split: split2,
    style: style2,
    wrap: wrap2 = false
  } = props, otherProps = __rest$q(props, ["size", "align", "className", "rootClassName", "children", "direction", "prefixCls", "split", "style", "wrap"]);
  const supportFlexGap = useFlexGapSupport();
  const [horizontalSize, verticalSize] = React.useMemo(() => (Array.isArray(size) ? size : [size, size]).map((item) => getNumberSize(item)), [size]);
  const childNodes = toArray$9(children, {
    keepEmpty: true
  });
  const mergedAlign = align === void 0 && direction === "horizontal" ? "center" : align;
  const prefixCls = getPrefixCls("space", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$i(prefixCls);
  const cn2 = classNames(prefixCls, hashId, `${prefixCls}-${direction}`, {
    [`${prefixCls}-rtl`]: directionConfig === "rtl",
    [`${prefixCls}-align-${mergedAlign}`]: mergedAlign
  }, className, rootClassName);
  const itemClassName = `${prefixCls}-item`;
  const marginDirection = directionConfig === "rtl" ? "marginLeft" : "marginRight";
  let latestIndex = 0;
  const nodes = childNodes.map((child, i) => {
    if (child !== null && child !== void 0) {
      latestIndex = i;
    }
    const key = child && child.key || `${itemClassName}-${i}`;
    return /* @__PURE__ */ React.createElement(Item$3, {
      className: itemClassName,
      key,
      direction,
      index: i,
      marginDirection,
      split: split2,
      wrap: wrap2
    }, child);
  });
  const spaceContext = React.useMemo(() => ({
    horizontalSize,
    verticalSize,
    latestIndex,
    supportFlexGap
  }), [horizontalSize, verticalSize, latestIndex, supportFlexGap]);
  if (childNodes.length === 0) {
    return null;
  }
  const gapStyle = {};
  if (wrap2) {
    gapStyle.flexWrap = "wrap";
    if (!supportFlexGap) {
      gapStyle.marginBottom = -verticalSize;
    }
  }
  if (supportFlexGap) {
    gapStyle.columnGap = horizontalSize;
    gapStyle.rowGap = verticalSize;
  }
  return wrapSSR(/* @__PURE__ */ React.createElement("div", Object.assign({
    className: cn2,
    style: Object.assign(Object.assign({}, gapStyle), style2)
  }, otherProps), /* @__PURE__ */ React.createElement(SpaceContext.Provider, {
    value: spaceContext
  }, nodes)));
};
const CompoundedSpace = Space;
CompoundedSpace.Compact = Compact$3;
var Space$1 = CompoundedSpace;
const genStatusStyle$1 = (token2) => {
  const {
    componentCls,
    menuCls,
    colorError,
    colorTextLightSolid
  } = token2;
  const itemCls = `${menuCls}-item`;
  return {
    [`${componentCls}, ${componentCls}-menu-submenu`]: {
      [`${menuCls} ${itemCls}`]: {
        [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
          color: colorError,
          "&:hover": {
            color: colorTextLightSolid,
            backgroundColor: colorError
          }
        }
      }
    }
  };
};
var genStatusStyle$2 = genStatusStyle$1;
const genBaseStyle$2 = (token2) => {
  const {
    componentCls,
    menuCls,
    zIndexPopup,
    dropdownArrowDistance,
    sizePopupArrow,
    antCls,
    iconCls,
    motionDurationMid,
    dropdownPaddingVertical,
    fontSize,
    dropdownEdgeChildPadding,
    colorTextDisabled,
    fontSizeIcon,
    controlPaddingHorizontal,
    colorBgElevated
  } = token2;
  return [
    {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        top: -9999,
        left: {
          _skip_check_: true,
          value: -9999
        },
        zIndex: zIndexPopup,
        display: "block",
        "&::before": {
          position: "absolute",
          insetBlock: -dropdownArrowDistance + sizePopupArrow / 2,
          zIndex: -9999,
          opacity: 1e-4,
          content: '""'
        },
        [`&-trigger${antCls}-btn > ${iconCls}-down`]: {
          fontSize: fontSizeIcon,
          transform: "none"
        },
        [`${componentCls}-wrap`]: {
          position: "relative",
          [`${antCls}-btn > ${iconCls}-down`]: {
            fontSize: fontSizeIcon
          },
          [`${iconCls}-down::before`]: {
            transition: `transform ${motionDurationMid}`
          }
        },
        [`${componentCls}-wrap-open`]: {
          [`${iconCls}-down::before`]: {
            transform: `rotate(180deg)`
          }
        },
        [`
        &-hidden,
        &-menu-hidden,
        &-menu-submenu-hidden
      `]: {
          display: "none"
        },
        [`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpIn
        },
        [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: {
          animationName: slideDownIn
        },
        [`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpOut
        },
        [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: {
          animationName: slideDownOut
        }
      })
    },
    getArrowStyle(token2, {
      colorBg: colorBgElevated,
      limitVerticalRadius: true,
      arrowPlacement: {
        top: true,
        bottom: true
      }
    }),
    {
      [`${componentCls} ${menuCls}`]: {
        position: "relative",
        margin: 0
      },
      [`${menuCls}-submenu-popup`]: {
        position: "absolute",
        zIndex: zIndexPopup,
        background: "transparent",
        boxShadow: "none",
        transformOrigin: "0 0",
        "ul, li": {
          listStyle: "none",
          margin: 0
        }
      },
      [`${componentCls}, ${componentCls}-menu-submenu`]: {
        [menuCls]: Object.assign(Object.assign({
          padding: dropdownEdgeChildPadding,
          listStyleType: "none",
          backgroundColor: colorBgElevated,
          backgroundClip: "padding-box",
          borderRadius: token2.borderRadiusLG,
          outline: "none",
          boxShadow: token2.boxShadowSecondary
        }, genFocusStyle(token2)), {
          [`${menuCls}-item-group-title`]: {
            padding: `${dropdownPaddingVertical}px ${controlPaddingHorizontal}px`,
            color: token2.colorTextDescription,
            transition: `all ${motionDurationMid}`
          },
          [`${menuCls}-item`]: {
            position: "relative",
            display: "flex",
            alignItems: "center"
          },
          [`${menuCls}-item-icon`]: {
            minWidth: fontSize,
            marginInlineEnd: token2.marginXS,
            fontSize: token2.fontSizeSM
          },
          [`${menuCls}-title-content`]: {
            flex: "auto",
            "> a": {
              color: "inherit",
              transition: `all ${motionDurationMid}`,
              "&:hover": {
                color: "inherit"
              },
              "&::after": {
                position: "absolute",
                inset: 0,
                content: '""'
              }
            }
          },
          [`${menuCls}-item, ${menuCls}-submenu-title`]: Object.assign(Object.assign({
            clear: "both",
            margin: 0,
            padding: `${dropdownPaddingVertical}px ${controlPaddingHorizontal}px`,
            color: token2.colorText,
            fontWeight: "normal",
            fontSize,
            lineHeight: token2.lineHeight,
            cursor: "pointer",
            transition: `all ${motionDurationMid}`,
            borderRadius: token2.borderRadiusSM,
            [`&:hover, &-active`]: {
              backgroundColor: token2.controlItemBgHover
            }
          }, genFocusStyle(token2)), {
            "&-selected": {
              color: token2.colorPrimary,
              backgroundColor: token2.controlItemBgActive,
              "&:hover, &-active": {
                backgroundColor: token2.controlItemBgActiveHover
              }
            },
            "&-disabled": {
              color: colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                color: colorTextDisabled,
                backgroundColor: colorBgElevated,
                cursor: "not-allowed"
              },
              a: {
                pointerEvents: "none"
              }
            },
            "&-divider": {
              height: 1,
              margin: `${token2.marginXXS}px 0`,
              overflow: "hidden",
              lineHeight: 0,
              backgroundColor: token2.colorSplit
            },
            [`${componentCls}-menu-submenu-expand-icon`]: {
              position: "absolute",
              insetInlineEnd: token2.paddingXS,
              [`${componentCls}-menu-submenu-arrow-icon`]: {
                marginInlineEnd: "0 !important",
                color: token2.colorTextDescription,
                fontSize: fontSizeIcon,
                fontStyle: "normal"
              }
            }
          }),
          [`${menuCls}-item-group-list`]: {
            margin: `0 ${token2.marginXS}px`,
            padding: 0,
            listStyle: "none"
          },
          [`${menuCls}-submenu-title`]: {
            paddingInlineEnd: controlPaddingHorizontal + token2.fontSizeSM
          },
          [`${menuCls}-submenu-vertical`]: {
            position: "relative"
          },
          [`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: {
            [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
              color: colorTextDisabled,
              backgroundColor: colorBgElevated,
              cursor: "not-allowed"
            }
          },
          [`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: {
            color: token2.colorPrimary
          }
        })
      }
    },
    [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down"), initMoveMotion(token2, "move-up"), initMoveMotion(token2, "move-down"), initZoomMotion(token2, "zoom-big")]
  ];
};
var useStyle$b = genComponentStyleHook$2("Dropdown", (token2, _ref2) => {
  let {
    rootPrefixCls
  } = _ref2;
  const {
    marginXXS,
    sizePopupArrow,
    controlHeight,
    fontSize,
    lineHeight,
    paddingXXS,
    componentCls,
    borderRadiusLG
  } = token2;
  const dropdownPaddingVertical = (controlHeight - fontSize * lineHeight) / 2;
  const {
    dropdownArrowOffset
  } = getArrowOffset({
    contentRadius: borderRadiusLG
  });
  const dropdownToken = merge$1(token2, {
    menuCls: `${componentCls}-menu`,
    rootPrefixCls,
    dropdownArrowDistance: sizePopupArrow / 2 + marginXXS,
    dropdownArrowOffset,
    dropdownPaddingVertical,
    dropdownEdgeChildPadding: paddingXXS
  });
  return [genBaseStyle$2(dropdownToken), genStatusStyle$2(dropdownToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 50
}));
var __rest$p = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const DropdownButton = (props) => {
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext$1);
  const {
    prefixCls: customizePrefixCls,
    type: type4 = "default",
    danger,
    disabled,
    loading,
    onClick,
    htmlType,
    children,
    className,
    menu,
    arrow,
    autoFocus,
    overlay,
    trigger,
    align,
    open,
    onOpenChange,
    placement,
    getPopupContainer,
    href,
    icon = /* @__PURE__ */ React.createElement(EllipsisOutlined$1, null),
    title,
    buttonsRender = (buttons) => buttons,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayClassName,
    overlayStyle,
    destroyPopupOnHide,
    dropdownRender
  } = props, restProps = __rest$p(props, ["prefixCls", "type", "danger", "disabled", "loading", "onClick", "htmlType", "children", "className", "menu", "arrow", "autoFocus", "overlay", "trigger", "align", "open", "onOpenChange", "placement", "getPopupContainer", "href", "icon", "title", "buttonsRender", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "dropdownRender"]);
  const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
  const buttonPrefixCls = `${prefixCls}-button`;
  const [wrapSSR, hashId] = useStyle$b(prefixCls);
  const dropdownProps = {
    menu,
    arrow,
    autoFocus,
    align,
    disabled,
    trigger: disabled ? [] : trigger,
    onOpenChange,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayClassName,
    overlayStyle,
    destroyPopupOnHide,
    dropdownRender
  };
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext$1(prefixCls, direction);
  const classes = classNames(buttonPrefixCls, compactItemClassnames, className, hashId);
  if ("overlay" in props) {
    dropdownProps.overlay = overlay;
  }
  if ("open" in props) {
    dropdownProps.open = open;
  }
  if ("placement" in props) {
    dropdownProps.placement = placement;
  } else {
    dropdownProps.placement = direction === "rtl" ? "bottomLeft" : "bottomRight";
  }
  const leftButton = /* @__PURE__ */ React.createElement(Button$2, {
    type: type4,
    danger,
    disabled,
    loading,
    onClick,
    htmlType,
    href,
    title
  }, children);
  const rightButton = /* @__PURE__ */ React.createElement(Button$2, {
    type: type4,
    danger,
    icon
  });
  const [leftButtonToRender, rightButtonToRender] = buttonsRender([leftButton, rightButton]);
  return wrapSSR(/* @__PURE__ */ React.createElement(Space$1.Compact, Object.assign({
    className: classes,
    size: compactSize,
    block: true
  }, restProps), leftButtonToRender, /* @__PURE__ */ React.createElement(Dropdown$1, Object.assign({}, dropdownProps), rightButtonToRender)));
};
DropdownButton.__ANT_BUTTON = true;
var DropdownButton$1 = DropdownButton;
const Dropdown = (props) => {
  const {
    menu,
    arrow,
    prefixCls: customizePrefixCls,
    children,
    trigger,
    disabled,
    dropdownRender,
    getPopupContainer,
    overlayClassName,
    rootClassName,
    open,
    onOpenChange,
    visible,
    onVisibleChange,
    mouseEnterDelay = 0.15,
    mouseLeaveDelay = 0.1,
    autoAdjustOverflow: autoAdjustOverflow2 = true,
    placement = "",
    overlay,
    transitionName
  } = props;
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext$1);
  const memoTransitionName = React.useMemo(() => {
    const rootPrefixCls = getPrefixCls();
    if (transitionName !== void 0) {
      return transitionName;
    }
    if (placement.includes("top")) {
      return `${rootPrefixCls}-slide-down`;
    }
    return `${rootPrefixCls}-slide-up`;
  }, [getPrefixCls, placement, transitionName]);
  const memoPlacement = React.useMemo(() => {
    if (!placement) {
      return direction === "rtl" ? "bottomRight" : "bottomLeft";
    }
    if (placement.includes("Center")) {
      const newPlacement = placement.slice(0, placement.indexOf("Center"));
      return newPlacement;
    }
    return placement;
  }, [placement, direction]);
  const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$b(prefixCls);
  const {
    token: token2
  } = theme.useToken();
  const child = React.Children.only(children);
  const dropdownTrigger = cloneElement$1(child, {
    className: classNames(`${prefixCls}-trigger`, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, child.props.className),
    disabled
  });
  const triggerActions = disabled ? [] : trigger;
  let alignPoint2;
  if (triggerActions && triggerActions.includes("contextMenu")) {
    alignPoint2 = true;
  }
  const [mergedOpen, setOpen] = useMergedState$2(false, {
    value: open !== null && open !== void 0 ? open : visible
  });
  const onInnerOpenChange = useEvent$6((nextOpen) => {
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(nextOpen);
    onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(nextOpen);
    setOpen(nextOpen);
  });
  const overlayClassNameCustomized = classNames(overlayClassName, rootClassName, hashId, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  });
  const builtinPlacements = getPlacements({
    arrowPointAtCenter: typeof arrow === "object" && arrow.pointAtCenter,
    autoAdjustOverflow: autoAdjustOverflow2,
    offset: token2.marginXXS,
    arrowWidth: arrow ? token2.sizePopupArrow : 0,
    borderRadius: token2.borderRadius
  });
  const onMenuClick = React.useCallback(() => {
    setOpen(false);
  }, []);
  const renderOverlay = () => {
    let overlayNode;
    if (menu === null || menu === void 0 ? void 0 : menu.items) {
      overlayNode = /* @__PURE__ */ React.createElement(Menu$2, Object.assign({}, menu));
    } else if (typeof overlay === "function") {
      overlayNode = overlay();
    } else {
      overlayNode = overlay;
    }
    if (dropdownRender) {
      overlayNode = dropdownRender(overlayNode);
    }
    overlayNode = React.Children.only(typeof overlayNode === "string" ? /* @__PURE__ */ React.createElement("span", null, overlayNode) : overlayNode);
    return /* @__PURE__ */ React.createElement(OverrideProvider, {
      prefixCls: `${prefixCls}-menu`,
      expandIcon: /* @__PURE__ */ React.createElement("span", {
        className: `${prefixCls}-menu-submenu-arrow`
      }, /* @__PURE__ */ React.createElement(RightOutlined$1, {
        className: `${prefixCls}-menu-submenu-arrow-icon`
      })),
      mode: "vertical",
      selectable: false,
      onClick: onMenuClick,
      validator: (_ref3) => {
      }
    }, /* @__PURE__ */ React.createElement(NoCompactStyle$1, null, overlayNode));
  };
  return wrapSSR(/* @__PURE__ */ React.createElement(Dropdown$3, Object.assign({
    alignPoint: alignPoint2
  }, omit$5(props, ["rootClassName"]), {
    mouseEnterDelay,
    mouseLeaveDelay,
    visible: mergedOpen,
    builtinPlacements,
    arrow: !!arrow,
    overlayClassName: overlayClassNameCustomized,
    prefixCls,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    transitionName: memoTransitionName,
    trigger: triggerActions,
    overlay: renderOverlay,
    placement: memoPlacement,
    onVisibleChange: onInnerOpenChange
  }), dropdownTrigger));
};
Dropdown.Button = DropdownButton$1;
const PurePanel = genPurePanel(Dropdown, "dropdown", (prefixCls) => prefixCls);
const WrapPurePanel = (props) => /* @__PURE__ */ React.createElement(PurePanel, Object.assign({}, props), /* @__PURE__ */ React.createElement("span", null));
Dropdown._InternalPanelDoNotUseOrYouWillBeFired = WrapPurePanel;
var Dropdown$1 = Dropdown;
const BreadcrumbSeparator = (_ref2) => {
  let {
    children
  } = _ref2;
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("breadcrumb");
  return /* @__PURE__ */ React.createElement("li", {
    className: `${prefixCls}-separator`,
    "aria-hidden": "true"
  }, children === "" ? children : children || "/");
};
BreadcrumbSeparator.__ANT_BREADCRUMB_SEPARATOR = true;
var BreadcrumbSeparator$1 = BreadcrumbSeparator;
var __rest$o = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const BreadcrumbItem = (props) => {
  const {
    prefixCls: customizePrefixCls,
    separator = "/",
    children,
    menu,
    overlay,
    dropdownProps,
    href
  } = props, restProps = __rest$o(props, ["prefixCls", "separator", "children", "menu", "overlay", "dropdownProps", "href"]);
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
  const renderBreadcrumbNode = (breadcrumbItem) => {
    if (menu || overlay) {
      const mergeDropDownProps = Object.assign({}, dropdownProps);
      if (menu) {
        const _a2 = menu || {}, {
          items
        } = _a2, menuProps = __rest$o(_a2, ["items"]);
        mergeDropDownProps.menu = Object.assign(Object.assign({}, menuProps), {
          items: items === null || items === void 0 ? void 0 : items.map((_a3, index2) => {
            var {
              key,
              title,
              label,
              path: path2
            } = _a3, itemProps = __rest$o(_a3, ["key", "title", "label", "path"]);
            let mergedLabel = label !== null && label !== void 0 ? label : title;
            if (path2) {
              mergedLabel = /* @__PURE__ */ React.createElement("a", {
                href: `${href}${path2}`
              }, mergedLabel);
            }
            return Object.assign(Object.assign({}, itemProps), {
              key: key !== null && key !== void 0 ? key : index2,
              label: mergedLabel
            });
          })
        });
      } else if (overlay) {
        mergeDropDownProps.overlay = overlay;
      }
      return /* @__PURE__ */ React.createElement(Dropdown$1, Object.assign({
        placement: "bottom"
      }, mergeDropDownProps), /* @__PURE__ */ React.createElement("span", {
        className: `${prefixCls}-overlay-link`
      }, breadcrumbItem, /* @__PURE__ */ React.createElement(DownOutlined$1, null)));
    }
    return breadcrumbItem;
  };
  let link2;
  if (href !== void 0) {
    link2 = /* @__PURE__ */ React.createElement("a", Object.assign({
      className: `${prefixCls}-link`,
      href
    }, restProps), children);
  } else {
    link2 = /* @__PURE__ */ React.createElement("span", Object.assign({
      className: `${prefixCls}-link`
    }, restProps), children);
  }
  link2 = renderBreadcrumbNode(link2);
  if (children !== void 0 && children !== null) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("li", null, link2), separator && /* @__PURE__ */ React.createElement(BreadcrumbSeparator$1, null, separator));
  }
  return null;
};
BreadcrumbItem.__ANT_BREADCRUMB_ITEM = true;
var BreadcrumbItem$1 = BreadcrumbItem;
const genBreadcrumbStyle = (token2) => {
  const {
    componentCls,
    iconCls
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      color: token2.breadcrumbBaseColor,
      fontSize: token2.breadcrumbFontSize,
      [iconCls]: {
        fontSize: token2.breadcrumbIconFontSize
      },
      ol: {
        display: "flex",
        flexWrap: "wrap",
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      a: Object.assign({
        color: token2.breadcrumbLinkColor,
        transition: `color ${token2.motionDurationMid}`,
        padding: `0 ${token2.paddingXXS}px`,
        borderRadius: token2.borderRadiusSM,
        height: token2.lineHeight * token2.fontSize,
        display: "inline-block",
        marginInline: -token2.marginXXS,
        "&:hover": {
          color: token2.breadcrumbLinkColorHover,
          backgroundColor: token2.colorBgTextHover
        }
      }, genFocusStyle(token2)),
      [`li:last-child`]: {
        color: token2.breadcrumbLastItemColor
      },
      [`${componentCls}-separator`]: {
        marginInline: token2.breadcrumbSeparatorMargin,
        color: token2.breadcrumbSeparatorColor
      },
      [`${componentCls}-link`]: {
        [`
          > ${iconCls} + span,
          > ${iconCls} + a
        `]: {
          marginInlineStart: token2.marginXXS
        }
      },
      [`${componentCls}-overlay-link`]: {
        borderRadius: token2.borderRadiusSM,
        height: token2.lineHeight * token2.fontSize,
        display: "inline-block",
        padding: `0 ${token2.paddingXXS}px`,
        marginInline: -token2.marginXXS,
        [`> ${iconCls}`]: {
          marginInlineStart: token2.marginXXS,
          fontSize: token2.fontSizeIcon
        },
        "&:hover": {
          color: token2.breadcrumbLinkColorHover,
          backgroundColor: token2.colorBgTextHover,
          a: {
            color: token2.breadcrumbLinkColorHover
          }
        },
        a: {
          "&:hover": {
            backgroundColor: "transparent"
          }
        }
      },
      [`&${token2.componentCls}-rtl`]: {
        direction: "rtl"
      }
    })
  };
};
var useStyle$a = genComponentStyleHook$2("Breadcrumb", (token2) => {
  const BreadcrumbToken = merge$1(token2, {
    breadcrumbBaseColor: token2.colorTextDescription,
    breadcrumbFontSize: token2.fontSize,
    breadcrumbIconFontSize: token2.fontSize,
    breadcrumbLinkColor: token2.colorTextDescription,
    breadcrumbLinkColorHover: token2.colorText,
    breadcrumbLastItemColor: token2.colorText,
    breadcrumbSeparatorMargin: token2.marginXS,
    breadcrumbSeparatorColor: token2.colorTextDescription
  });
  return [genBreadcrumbStyle(BreadcrumbToken)];
});
var __rest$n = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function route2item(route) {
  const {
    breadcrumbName,
    children
  } = route, rest = __rest$n(route, ["breadcrumbName", "children"]);
  const clone2 = Object.assign({
    title: breadcrumbName
  }, rest);
  if (children) {
    clone2.menu = {
      items: children.map((_a2) => {
        var {
          breadcrumbName: itemBreadcrumbName
        } = _a2, itemProps = __rest$n(_a2, ["breadcrumbName"]);
        return Object.assign(Object.assign({}, itemProps), {
          title: itemBreadcrumbName
        });
      })
    };
  }
  return clone2;
}
function useItems(items, routes) {
  return React.useMemo(() => {
    if (items) {
      return items;
    }
    if (routes) {
      return routes.map(route2item);
    }
    return null;
  }, [items, routes]);
}
var __rest$m = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function getBreadcrumbName(route, params) {
  if (route.title === void 0) {
    return null;
  }
  const paramsKeys = Object.keys(params).join("|");
  return typeof route.title === "object" ? route.title : String(route.title).replace(new RegExp(`:(${paramsKeys})`, "g"), (replacement, key) => params[key] || replacement);
}
const getPath = (params, path2) => {
  if (path2 === void 0) {
    return path2;
  }
  let mergedPath = (path2 || "").replace(/^\//, "");
  Object.keys(params).forEach((key) => {
    mergedPath = mergedPath.replace(`:${key}`, params[key]);
  });
  return mergedPath;
};
const Breadcrumb = (props) => {
  const _a2 = props, {
    prefixCls: customizePrefixCls,
    separator = "/",
    style: style2,
    className,
    rootClassName,
    routes: legacyRoutes,
    items,
    children,
    itemRender,
    params = {}
  } = _a2, restProps = __rest$m(_a2, ["prefixCls", "separator", "style", "className", "rootClassName", "routes", "items", "children", "itemRender", "params"]);
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext$1);
  let crumbs;
  const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$a(prefixCls);
  const mergedItems = useItems(items, legacyRoutes);
  const mergedItemRender = itemRender || ((route) => {
    const name = getBreadcrumbName(route, params);
    return name;
  });
  if (mergedItems && mergedItems.length > 0) {
    const paths = [];
    const itemRenderRoutes = items || legacyRoutes;
    crumbs = mergedItems.map((item, index2) => {
      const {
        path: path2,
        key,
        type: type4,
        menu,
        overlay,
        onClick,
        className: itemClassName,
        separator: itemSeparator
      } = item;
      const mergedPath = getPath(params, path2);
      if (mergedPath !== void 0) {
        paths.push(mergedPath);
      }
      const mergedKey = key !== null && key !== void 0 ? key : index2;
      if (type4 === "separator") {
        return /* @__PURE__ */ React.createElement(BreadcrumbSeparator$1, {
          key: mergedKey
        }, itemSeparator);
      }
      const itemProps = {};
      const isLastItem = index2 === mergedItems.length - 1;
      if (menu) {
        itemProps.menu = menu;
      } else if (overlay) {
        itemProps.overlay = overlay;
      }
      if (itemClassName) {
        itemProps.className = itemClassName;
      }
      let {
        href
      } = item;
      if (paths.length && mergedPath !== void 0) {
        href = `#/${paths.join("/")}`;
      }
      return /* @__PURE__ */ React.createElement(BreadcrumbItem$1, Object.assign({
        key: mergedKey
      }, itemProps, pickAttrs$1(item, {
        data: true,
        aria: true
      }), {
        href,
        separator: isLastItem ? "" : separator,
        onClick
      }), mergedItemRender(item, params, itemRenderRoutes, paths));
    });
  } else if (children) {
    const childrenLength = toArray$9(children).length;
    crumbs = toArray$9(children).map((element2, index2) => {
      if (!element2) {
        return element2;
      }
      const isLastItem = index2 === childrenLength - 1;
      return cloneElement$1(element2, {
        separator: isLastItem ? "" : separator,
        key: index2
      });
    });
  }
  const breadcrumbClassName = classNames(prefixCls, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId);
  return wrapSSR(/* @__PURE__ */ React.createElement("nav", Object.assign({
    className: breadcrumbClassName,
    style: style2
  }, restProps), /* @__PURE__ */ React.createElement("ol", null, crumbs)));
};
Breadcrumb.Item = BreadcrumbItem$1;
Breadcrumb.Separator = BreadcrumbSeparator$1;
var Breadcrumb$1 = Breadcrumb;
const genPlaceholderStyle$1 = (color2) => ({
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color: color2,
    userSelect: "none"
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
});
const genHoverStyle$1 = (token2) => ({
  borderColor: token2.inputBorderHoverColor,
  borderInlineEndWidth: token2.lineWidth
});
const genActiveStyle$1 = (token2) => ({
  borderColor: token2.inputBorderHoverColor,
  boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`,
  borderInlineEndWidth: token2.lineWidth,
  outline: 0
});
const genDisabledStyle$2 = (token2) => ({
  color: token2.colorTextDisabled,
  backgroundColor: token2.colorBgContainerDisabled,
  borderColor: token2.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "&:hover": Object.assign({}, genHoverStyle$1(merge$1(token2, {
    inputBorderHoverColor: token2.colorBorder
  })))
});
const genInputLargeStyle$1 = (token2) => {
  const {
    inputPaddingVerticalLG,
    fontSizeLG,
    lineHeightLG,
    borderRadiusLG,
    inputPaddingHorizontalLG
  } = token2;
  return {
    padding: `${inputPaddingVerticalLG}px ${inputPaddingHorizontalLG}px`,
    fontSize: fontSizeLG,
    lineHeight: lineHeightLG,
    borderRadius: borderRadiusLG
  };
};
const genInputSmallStyle$1 = (token2) => ({
  padding: `${token2.inputPaddingVerticalSM}px ${token2.controlPaddingHorizontalSM - 1}px`,
  borderRadius: token2.borderRadiusSM
});
const genBasicInputStyle$1 = (token2) => Object.assign(Object.assign({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${token2.inputPaddingVertical}px ${token2.inputPaddingHorizontal}px`,
  color: token2.colorText,
  fontSize: token2.fontSize,
  lineHeight: token2.lineHeight,
  backgroundColor: token2.colorBgContainer,
  backgroundImage: "none",
  borderWidth: token2.lineWidth,
  borderStyle: token2.lineType,
  borderColor: token2.colorBorder,
  borderRadius: token2.borderRadius,
  transition: `all ${token2.motionDurationMid}`
}, genPlaceholderStyle$1(token2.colorTextPlaceholder)), {
  "&:hover": Object.assign({}, genHoverStyle$1(token2)),
  "&:focus, &-focused": Object.assign({}, genActiveStyle$1(token2)),
  "&-disabled, &[disabled]": Object.assign({}, genDisabledStyle$2(token2)),
  "&-borderless": {
    "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
      backgroundColor: "transparent",
      border: "none",
      boxShadow: "none"
    }
  },
  "textarea&": {
    maxWidth: "100%",
    height: "auto",
    minHeight: token2.controlHeight,
    lineHeight: token2.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${token2.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  "&-lg": Object.assign({}, genInputLargeStyle$1(token2)),
  "&-sm": Object.assign({}, genInputSmallStyle$1(token2)),
  "&-rtl": {
    direction: "rtl"
  },
  "&-textarea-rtl": {
    direction: "rtl"
  }
});
function initInputToken$1(token2) {
  return merge$1(token2, {
    inputAffixPadding: token2.paddingXXS,
    inputPaddingVertical: Math.max(Math.round((token2.controlHeight - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 3),
    inputPaddingVerticalLG: Math.ceil((token2.controlHeightLG - token2.fontSizeLG * token2.lineHeightLG) / 2 * 10) / 10 - token2.lineWidth,
    inputPaddingVerticalSM: Math.max(Math.round((token2.controlHeightSM - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 0),
    inputPaddingHorizontal: token2.paddingSM - token2.lineWidth,
    inputPaddingHorizontalSM: token2.paddingXS - token2.lineWidth,
    inputPaddingHorizontalLG: token2.controlPaddingHorizontal - token2.lineWidth,
    inputBorderHoverColor: token2.colorPrimaryHover,
    inputBorderActiveColor: token2.colorPrimaryHover
  });
}
const Element$1 = (props) => {
  const {
    prefixCls,
    className,
    style: style2,
    size,
    shape
  } = props;
  const sizeCls = classNames({
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-sm`]: size === "small"
  });
  const shapeCls = classNames({
    [`${prefixCls}-circle`]: shape === "circle",
    [`${prefixCls}-square`]: shape === "square",
    [`${prefixCls}-round`]: shape === "round"
  });
  const sizeStyle = React.useMemo(() => typeof size === "number" ? {
    width: size,
    height: size,
    lineHeight: `${size}px`
  } : {}, [size]);
  return /* @__PURE__ */ React.createElement("span", {
    className: classNames(prefixCls, sizeCls, shapeCls, className),
    style: Object.assign(Object.assign({}, sizeStyle), style2)
  });
};
var Element$2 = Element$1;
const skeletonClsLoading = new Keyframe(`ant-skeleton-loading`, {
  "0%": {
    backgroundPosition: "100% 50%"
  },
  "100%": {
    backgroundPosition: "0 50%"
  }
});
const genSkeletonElementCommonSize = (size) => ({
  height: size,
  lineHeight: `${size}px`
});
const genSkeletonElementAvatarSize = (size) => Object.assign({
  width: size
}, genSkeletonElementCommonSize(size));
const genSkeletonColor = (token2) => ({
  background: token2.skeletonLoadingBackground,
  backgroundSize: "400% 100%",
  animationName: skeletonClsLoading,
  animationDuration: token2.skeletonLoadingMotionDuration,
  animationTimingFunction: "ease",
  animationIterationCount: "infinite"
});
const genSkeletonElementInputSize = (size) => Object.assign({
  width: size * 5,
  minWidth: size * 5
}, genSkeletonElementCommonSize(size));
const genSkeletonElementAvatar = (token2) => {
  const {
    skeletonAvatarCls,
    color: color2,
    controlHeight,
    controlHeightLG,
    controlHeightSM
  } = token2;
  return {
    [`${skeletonAvatarCls}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: color2
    }, genSkeletonElementAvatarSize(controlHeight)),
    [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
      borderRadius: "50%"
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
    [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
  };
};
const genSkeletonElementInput = (token2) => {
  const {
    controlHeight,
    borderRadiusSM,
    skeletonInputCls,
    controlHeightLG,
    controlHeightSM,
    color: color2
  } = token2;
  return {
    [`${skeletonInputCls}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: color2,
      borderRadius: borderRadiusSM
    }, genSkeletonElementInputSize(controlHeight)),
    [`${skeletonInputCls}-lg`]: Object.assign({}, genSkeletonElementInputSize(controlHeightLG)),
    [`${skeletonInputCls}-sm`]: Object.assign({}, genSkeletonElementInputSize(controlHeightSM))
  };
};
const genSkeletonElementImageSize = (size) => Object.assign({
  width: size
}, genSkeletonElementCommonSize(size));
const genSkeletonElementImage = (token2) => {
  const {
    skeletonImageCls,
    imageSizeBase,
    color: color2,
    borderRadiusSM
  } = token2;
  return {
    [`${skeletonImageCls}`]: Object.assign(Object.assign({
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      verticalAlign: "top",
      background: color2,
      borderRadius: borderRadiusSM
    }, genSkeletonElementImageSize(imageSizeBase * 2)), {
      [`${skeletonImageCls}-path`]: {
        fill: "#bfbfbf"
      },
      [`${skeletonImageCls}-svg`]: Object.assign(Object.assign({}, genSkeletonElementImageSize(imageSizeBase)), {
        maxWidth: imageSizeBase * 4,
        maxHeight: imageSizeBase * 4
      }),
      [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
        borderRadius: "50%"
      }
    }),
    [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
      borderRadius: "50%"
    }
  };
};
const genSkeletonElementButtonShape = (token2, size, buttonCls) => {
  const {
    skeletonButtonCls
  } = token2;
  return {
    [`${buttonCls}${skeletonButtonCls}-circle`]: {
      width: size,
      minWidth: size,
      borderRadius: "50%"
    },
    [`${buttonCls}${skeletonButtonCls}-round`]: {
      borderRadius: size
    }
  };
};
const genSkeletonElementButtonSize = (size) => Object.assign({
  width: size * 2,
  minWidth: size * 2
}, genSkeletonElementCommonSize(size));
const genSkeletonElementButton = (token2) => {
  const {
    borderRadiusSM,
    skeletonButtonCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    color: color2
  } = token2;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
    [`${skeletonButtonCls}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: color2,
      borderRadius: borderRadiusSM,
      width: controlHeight * 2,
      minWidth: controlHeight * 2
    }, genSkeletonElementButtonSize(controlHeight))
  }, genSkeletonElementButtonShape(token2, controlHeight, skeletonButtonCls)), {
    [`${skeletonButtonCls}-lg`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightLG))
  }), genSkeletonElementButtonShape(token2, controlHeightLG, `${skeletonButtonCls}-lg`)), {
    [`${skeletonButtonCls}-sm`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightSM))
  }), genSkeletonElementButtonShape(token2, controlHeightSM, `${skeletonButtonCls}-sm`));
};
const genBaseStyle$1 = (token2) => {
  const {
    componentCls,
    skeletonAvatarCls,
    skeletonTitleCls,
    skeletonParagraphCls,
    skeletonButtonCls,
    skeletonInputCls,
    skeletonImageCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    color: color2,
    padding,
    marginSM,
    borderRadius,
    skeletonTitleHeight,
    skeletonBlockRadius,
    skeletonParagraphLineHeight,
    controlHeightXS,
    skeletonParagraphMarginTop
  } = token2;
  return {
    [`${componentCls}`]: {
      display: "table",
      width: "100%",
      [`${componentCls}-header`]: {
        display: "table-cell",
        paddingInlineEnd: padding,
        verticalAlign: "top",
        [`${skeletonAvatarCls}`]: Object.assign({
          display: "inline-block",
          verticalAlign: "top",
          background: color2
        }, genSkeletonElementAvatarSize(controlHeight)),
        [`${skeletonAvatarCls}-circle`]: {
          borderRadius: "50%"
        },
        [`${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
        [`${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
      },
      [`${componentCls}-content`]: {
        display: "table-cell",
        width: "100%",
        verticalAlign: "top",
        [`${skeletonTitleCls}`]: {
          width: "100%",
          height: skeletonTitleHeight,
          background: color2,
          borderRadius: skeletonBlockRadius,
          [`+ ${skeletonParagraphCls}`]: {
            marginBlockStart: controlHeightSM
          }
        },
        [`${skeletonParagraphCls}`]: {
          padding: 0,
          "> li": {
            width: "100%",
            height: skeletonParagraphLineHeight,
            listStyle: "none",
            background: color2,
            borderRadius: skeletonBlockRadius,
            "+ li": {
              marginBlockStart: controlHeightXS
            }
          }
        },
        [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: "61%"
        }
      },
      [`&-round ${componentCls}-content`]: {
        [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
          borderRadius
        }
      }
    },
    [`${componentCls}-with-avatar ${componentCls}-content`]: {
      [`${skeletonTitleCls}`]: {
        marginBlockStart: marginSM,
        [`+ ${skeletonParagraphCls}`]: {
          marginBlockStart: skeletonParagraphMarginTop
        }
      }
    },
    [`${componentCls}${componentCls}-element`]: Object.assign(Object.assign(Object.assign(Object.assign({
      display: "inline-block",
      width: "auto"
    }, genSkeletonElementButton(token2)), genSkeletonElementAvatar(token2)), genSkeletonElementInput(token2)), genSkeletonElementImage(token2)),
    [`${componentCls}${componentCls}-block`]: {
      width: "100%",
      [`${skeletonButtonCls}`]: {
        width: "100%"
      },
      [`${skeletonInputCls}`]: {
        width: "100%"
      }
    },
    [`${componentCls}${componentCls}-active`]: {
      [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonImageCls}
      `]: Object.assign({}, genSkeletonColor(token2))
    }
  };
};
var useStyle$9 = genComponentStyleHook$2("Skeleton", (token2) => {
  const {
    componentCls
  } = token2;
  const skeletonToken = merge$1(token2, {
    skeletonAvatarCls: `${componentCls}-avatar`,
    skeletonTitleCls: `${componentCls}-title`,
    skeletonParagraphCls: `${componentCls}-paragraph`,
    skeletonButtonCls: `${componentCls}-button`,
    skeletonInputCls: `${componentCls}-input`,
    skeletonImageCls: `${componentCls}-image`,
    imageSizeBase: token2.controlHeight * 1.5,
    skeletonTitleHeight: token2.controlHeight / 2,
    skeletonBlockRadius: token2.borderRadiusSM,
    skeletonParagraphLineHeight: token2.controlHeight / 2,
    skeletonParagraphMarginTop: token2.marginLG + token2.marginXXS,
    borderRadius: 100,
    skeletonLoadingBackground: `linear-gradient(90deg, ${token2.color} 25%, ${token2.colorGradientEnd} 37%, ${token2.color} 63%)`,
    skeletonLoadingMotionDuration: "1.4s"
  });
  return [genBaseStyle$1(skeletonToken)];
}, (token2) => {
  const {
    colorFillContent,
    colorFill
  } = token2;
  return {
    color: colorFillContent,
    colorGradientEnd: colorFill
  };
});
const SkeletonAvatar = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    shape = "circle",
    size = "default"
  } = props;
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$9(prefixCls);
  const otherProps = omit$5(props, ["prefixCls", "className"]);
  const cls = classNames(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, className, rootClassName, hashId);
  return wrapSSR(/* @__PURE__ */ React.createElement("div", {
    className: cls
  }, /* @__PURE__ */ React.createElement(Element$2, Object.assign({
    prefixCls: `${prefixCls}-avatar`,
    shape,
    size
  }, otherProps))));
};
var SkeletonAvatar$1 = SkeletonAvatar;
const SkeletonButton = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    block: block2 = false,
    size = "default"
  } = props;
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$9(prefixCls);
  const otherProps = omit$5(props, ["prefixCls"]);
  const cls = classNames(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-block`]: block2
  }, className, rootClassName, hashId);
  return wrapSSR(/* @__PURE__ */ React.createElement("div", {
    className: cls
  }, /* @__PURE__ */ React.createElement(Element$2, Object.assign({
    prefixCls: `${prefixCls}-button`,
    size
  }, otherProps))));
};
var SkeletonButton$1 = SkeletonButton;
var DotChartOutlined = function DotChartOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: DotChartOutlinedSvg
  }));
};
DotChartOutlined.displayName = "DotChartOutlined";
var DotChartOutlined$1 = /* @__PURE__ */ React.forwardRef(DotChartOutlined);
const SkeletonNode = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    active,
    children
  } = props;
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$9(prefixCls);
  const cls = classNames(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, hashId, className, rootClassName);
  const content2 = children !== null && children !== void 0 ? children : /* @__PURE__ */ React.createElement(DotChartOutlined$1, null);
  return wrapSSR(/* @__PURE__ */ React.createElement("div", {
    className: cls
  }, /* @__PURE__ */ React.createElement("div", {
    className: classNames(`${prefixCls}-image`, className),
    style: style2
  }, content2)));
};
var SkeletonNode$1 = SkeletonNode;
const path = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
const SkeletonImage = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    active
  } = props;
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$9(prefixCls);
  const cls = classNames(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, className, rootClassName, hashId);
  return wrapSSR(/* @__PURE__ */ React.createElement("div", {
    className: cls
  }, /* @__PURE__ */ React.createElement("div", {
    className: classNames(`${prefixCls}-image`, className),
    style: style2
  }, /* @__PURE__ */ React.createElement("svg", {
    viewBox: "0 0 1098 1024",
    xmlns: "http://www.w3.org/2000/svg",
    className: `${prefixCls}-image-svg`
  }, /* @__PURE__ */ React.createElement("path", {
    d: path,
    className: `${prefixCls}-image-path`
  })))));
};
var SkeletonImage$1 = SkeletonImage;
const SkeletonInput = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    block: block2,
    size = "default"
  } = props;
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$9(prefixCls);
  const otherProps = omit$5(props, ["prefixCls"]);
  const cls = classNames(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-block`]: block2
  }, className, rootClassName, hashId);
  return wrapSSR(/* @__PURE__ */ React.createElement("div", {
    className: cls
  }, /* @__PURE__ */ React.createElement(Element$2, Object.assign({
    prefixCls: `${prefixCls}-input`,
    size
  }, otherProps))));
};
var SkeletonInput$1 = SkeletonInput;
const Paragraph = (props) => {
  const getWidth3 = (index2) => {
    const {
      width,
      rows: rows2 = 2
    } = props;
    if (Array.isArray(width)) {
      return width[index2];
    }
    if (rows2 - 1 === index2) {
      return width;
    }
    return void 0;
  };
  const {
    prefixCls,
    className,
    style: style2,
    rows
  } = props;
  const rowList = _toConsumableArray(Array(rows)).map((_24, index2) => /* @__PURE__ */ React.createElement("li", {
    key: index2,
    style: {
      width: getWidth3(index2)
    }
  }));
  return /* @__PURE__ */ React.createElement("ul", {
    className: classNames(prefixCls, className),
    style: style2
  }, rowList);
};
var Paragraph$1 = Paragraph;
const Title$2 = (_ref2) => {
  let {
    prefixCls,
    className,
    width,
    style: style2
  } = _ref2;
  return /* @__PURE__ */ React.createElement("h3", {
    className: classNames(prefixCls, className),
    style: Object.assign({
      width
    }, style2)
  });
};
var Title$3 = Title$2;
function getComponentProps(prop) {
  if (prop && typeof prop === "object") {
    return prop;
  }
  return {};
}
function getAvatarBasicProps(hasTitle, hasParagraph) {
  if (hasTitle && !hasParagraph) {
    return {
      size: "large",
      shape: "square"
    };
  }
  return {
    size: "large",
    shape: "circle"
  };
}
function getTitleBasicProps(hasAvatar, hasParagraph) {
  if (!hasAvatar && hasParagraph) {
    return {
      width: "38%"
    };
  }
  if (hasAvatar && hasParagraph) {
    return {
      width: "50%"
    };
  }
  return {};
}
function getParagraphBasicProps(hasAvatar, hasTitle) {
  const basicProps = {};
  if (!hasAvatar || !hasTitle) {
    basicProps.width = "61%";
  }
  if (!hasAvatar && hasTitle) {
    basicProps.rows = 3;
  } else {
    basicProps.rows = 2;
  }
  return basicProps;
}
const Skeleton = (props) => {
  const {
    prefixCls: customizePrefixCls,
    loading,
    className,
    rootClassName,
    style: style2,
    children,
    avatar = false,
    title = true,
    paragraph: paragraph2 = true,
    active,
    round
  } = props;
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$9(prefixCls);
  if (loading || !("loading" in props)) {
    const hasAvatar = !!avatar;
    const hasTitle = !!title;
    const hasParagraph = !!paragraph2;
    let avatarNode;
    if (hasAvatar) {
      const avatarProps = Object.assign(Object.assign({
        prefixCls: `${prefixCls}-avatar`
      }, getAvatarBasicProps(hasTitle, hasParagraph)), getComponentProps(avatar));
      avatarNode = /* @__PURE__ */ React.createElement("div", {
        className: `${prefixCls}-header`
      }, /* @__PURE__ */ React.createElement(Element$2, Object.assign({}, avatarProps)));
    }
    let contentNode;
    if (hasTitle || hasParagraph) {
      let $title;
      if (hasTitle) {
        const titleProps = Object.assign(Object.assign({
          prefixCls: `${prefixCls}-title`
        }, getTitleBasicProps(hasAvatar, hasParagraph)), getComponentProps(title));
        $title = /* @__PURE__ */ React.createElement(Title$3, Object.assign({}, titleProps));
      }
      let paragraphNode;
      if (hasParagraph) {
        const paragraphProps = Object.assign(Object.assign({
          prefixCls: `${prefixCls}-paragraph`
        }, getParagraphBasicProps(hasAvatar, hasTitle)), getComponentProps(paragraph2));
        paragraphNode = /* @__PURE__ */ React.createElement(Paragraph$1, Object.assign({}, paragraphProps));
      }
      contentNode = /* @__PURE__ */ React.createElement("div", {
        className: `${prefixCls}-content`
      }, $title, paragraphNode);
    }
    const cls = classNames(prefixCls, {
      [`${prefixCls}-with-avatar`]: hasAvatar,
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-round`]: round
    }, className, rootClassName, hashId);
    return wrapSSR(/* @__PURE__ */ React.createElement("div", {
      className: cls,
      style: style2
    }, avatarNode, contentNode));
  }
  return typeof children !== "undefined" ? children : null;
};
Skeleton.Button = SkeletonButton$1;
Skeleton.Avatar = SkeletonAvatar$1;
Skeleton.Input = SkeletonInput$1;
Skeleton.Image = SkeletonImage$1;
Skeleton.Node = SkeletonNode$1;
var Skeleton$1 = Skeleton;
var PlusOutlined2 = function PlusOutlined3(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: PlusOutlinedSvg
  }));
};
PlusOutlined2.displayName = "PlusOutlined";
var PlusOutlined$1 = /* @__PURE__ */ React.forwardRef(PlusOutlined2);
var isMobile = function() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
};
function useEvent$2(callback) {
  var fnRef = React.useRef();
  fnRef.current = callback;
  var memoFn = React.useCallback(function() {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
function canUseDom$5() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var useLayoutEffect$1 = canUseDom$5() ? React.useLayoutEffect : React.useEffect;
var useLayoutUpdateEffect4 = function useLayoutUpdateEffect5(callback, deps) {
  var firstMountRef = React.useRef(true);
  useLayoutEffect$1(function() {
    if (!firstMountRef.current) {
      return callback();
    }
  }, deps);
  useLayoutEffect$1(function() {
    firstMountRef.current = false;
    return function() {
      firstMountRef.current = true;
    };
  }, []);
};
function useSafeState(defaultValue) {
  var destroyRef = React.useRef(false);
  var _React$useState = React.useState(defaultValue), _React$useState2 = _slicedToArray$1(_React$useState, 2), value = _React$useState2[0], setValue2 = _React$useState2[1];
  React.useEffect(function() {
    destroyRef.current = false;
    return function() {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue2(updater);
  }
  return [value, safeSetState];
}
function hasValue$1(value) {
  return value !== void 0;
}
function useMergedState$1(defaultStateValue, option) {
  var _ref2 = option || {}, defaultValue = _ref2.defaultValue, value = _ref2.value, onChange = _ref2.onChange, postState = _ref2.postState;
  var _useState = useSafeState(function() {
    if (hasValue$1(value)) {
      return value;
    } else if (hasValue$1(defaultValue)) {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    } else {
      return typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
    }
  }), _useState2 = _slicedToArray$1(_useState, 2), innerValue = _useState2[0], setInnerValue = _useState2[1];
  var mergedValue = value !== void 0 ? value : innerValue;
  var postMergedValue = postState ? postState(mergedValue) : mergedValue;
  var onChangeFn = useEvent$2(onChange);
  var _useState3 = useSafeState([mergedValue]), _useState4 = _slicedToArray$1(_useState3, 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
  useLayoutUpdateEffect4(function() {
    var prev2 = prevValue[0];
    if (innerValue !== prev2) {
      onChangeFn(innerValue, prev2);
    }
  }, [prevValue]);
  useLayoutUpdateEffect4(function() {
    if (!hasValue$1(value)) {
      setInnerValue(value);
    }
  }, [value]);
  var triggerChange = useEvent$2(function(updater, ignoreDestroy) {
    setInnerValue(updater, ignoreDestroy);
    setPrevValue([mergedValue], ignoreDestroy);
  });
  return [postMergedValue, triggerChange];
}
var TabContext = /* @__PURE__ */ React.createContext(null);
var TabPane$3 = /* @__PURE__ */ React.forwardRef(function(_ref2, ref2) {
  var prefixCls = _ref2.prefixCls, className = _ref2.className, style2 = _ref2.style, id = _ref2.id, active = _ref2.active, tabKey = _ref2.tabKey, children = _ref2.children;
  return /* @__PURE__ */ React.createElement("div", {
    id: id && "".concat(id, "-panel-").concat(tabKey),
    role: "tabpanel",
    tabIndex: active ? 0 : -1,
    "aria-labelledby": id && "".concat(id, "-tab-").concat(tabKey),
    "aria-hidden": !active,
    style: style2,
    className: classNames(prefixCls, active && "".concat(prefixCls, "-active"), className),
    ref: ref2
  }, children);
});
var _excluded$k = ["key", "forceRender", "style", "className"];
function TabPanelList(_ref2) {
  var id = _ref2.id, activeKey = _ref2.activeKey, animated = _ref2.animated, tabPosition = _ref2.tabPosition, destroyInactiveTabPane = _ref2.destroyInactiveTabPane;
  var _React$useContext = React.useContext(TabContext), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
  var tabPaneAnimated = animated.tabPane;
  var tabPanePrefixCls = "".concat(prefixCls, "-tabpane");
  return /* @__PURE__ */ React.createElement("div", {
    className: classNames("".concat(prefixCls, "-content-holder"))
  }, /* @__PURE__ */ React.createElement("div", {
    className: classNames("".concat(prefixCls, "-content"), "".concat(prefixCls, "-content-").concat(tabPosition), _defineProperty$3({}, "".concat(prefixCls, "-content-animated"), tabPaneAnimated))
  }, tabs.map(function(_ref22) {
    var key = _ref22.key, forceRender = _ref22.forceRender, paneStyle = _ref22.style, paneClassName = _ref22.className, restTabProps = _objectWithoutProperties$1(_ref22, _excluded$k);
    var active = key === activeKey;
    return /* @__PURE__ */ React.createElement(CSSMotion, _extends$3({
      key,
      visible: active,
      forceRender,
      removeOnLeave: !!destroyInactiveTabPane,
      leavedClassName: "".concat(tabPanePrefixCls, "-hidden")
    }, animated.tabPaneMotion), function(_ref3, ref2) {
      var motionStyle = _ref3.style, motionClassName = _ref3.className;
      return /* @__PURE__ */ React.createElement(TabPane$3, _extends$3({}, restTabProps, {
        prefixCls: tabPanePrefixCls,
        id,
        tabKey: key,
        animated: tabPaneAnimated,
        active,
        style: _objectSpread2$d(_objectSpread2$d({}, paneStyle), motionStyle),
        className: classNames(paneClassName, motionClassName),
        ref: ref2
      }));
    });
  })));
}
var raf$3 = function raf6(callback) {
  return +setTimeout(callback, 16);
};
var caf$2 = function caf6(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf$3 = function raf10(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf$2 = function caf10(handle2) {
    return window.cancelAnimationFrame(handle2);
  };
}
var rafUUID$2 = 0;
var rafIds$2 = /* @__PURE__ */ new Map();
function cleanup$2(id) {
  rafIds$2.delete(id);
}
var wrapperRaf$2 = function wrapperRaf2(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID$2 += 1;
  var id = rafUUID$2;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup$2(id);
      callback();
    } else {
      var realId = raf$3(function() {
        callRef(leftTimes - 1);
      });
      rafIds$2.set(id, realId);
    }
  }
  callRef(times);
  return id;
};
wrapperRaf$2.cancel = function(id) {
  var realId = rafIds$2.get(id);
  cleanup$2(realId);
  return caf$2(realId);
};
function useMemo$2(getValue2, condition, shouldUpdate) {
  var cacheRef = React.useRef({});
  if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue2();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
function fillRef$1(ref2, node2) {
  if (typeof ref2 === "function") {
    ref2(node2);
  } else if (_typeof$8(ref2) === "object" && ref2 && "current" in ref2) {
    ref2.current = node2;
  }
}
function composeRef$1() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function(ref2) {
    return ref2;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function(node2) {
    refs.forEach(function(ref2) {
      fillRef$1(ref2, node2);
    });
  };
}
function useComposeRef$1() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }
  return useMemo$2(function() {
    return composeRef$1.apply(void 0, refs);
  }, refs, function(prev2, next2) {
    return prev2.length === next2.length && prev2.every(function(ref2, i) {
      return ref2 === next2[i];
    });
  });
}
var DEFAULT_SIZE$1 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function useOffsets(tabs, tabSizes, holderScrollWidth) {
  return React.useMemo(function() {
    var _tabs$;
    var map = /* @__PURE__ */ new Map();
    var lastOffset = tabSizes.get((_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key) || DEFAULT_SIZE$1;
    var rightOffset = lastOffset.left + lastOffset.width;
    for (var i = 0; i < tabs.length; i += 1) {
      var key = tabs[i].key;
      var data2 = tabSizes.get(key);
      if (!data2) {
        var _tabs;
        data2 = tabSizes.get((_tabs = tabs[i - 1]) === null || _tabs === void 0 ? void 0 : _tabs.key) || DEFAULT_SIZE$1;
      }
      var entity = map.get(key) || _objectSpread2$d({}, data2);
      entity.right = rightOffset - entity.left - entity.width;
      map.set(key, entity);
    }
    return map;
  }, [tabs.map(function(tab2) {
    return tab2.key;
  }).join("_"), tabSizes, holderScrollWidth]);
}
function useSyncState(defaultState, onChange) {
  var stateRef = React.useRef(defaultState);
  var _React$useState = React.useState({}), _React$useState2 = _slicedToArray$1(_React$useState, 2), forceUpdate = _React$useState2[1];
  function setState(updater) {
    var newValue = typeof updater === "function" ? updater(stateRef.current) : updater;
    if (newValue !== stateRef.current) {
      onChange(newValue, stateRef.current);
    }
    stateRef.current = newValue;
    forceUpdate({});
  }
  return [stateRef.current, setState];
}
var MIN_SWIPE_DISTANCE = 0.1;
var STOP_SWIPE_DISTANCE = 0.01;
var REFRESH_INTERVAL = 20;
var SPEED_OFF_MULTIPLE = Math.pow(0.995, REFRESH_INTERVAL);
function useTouchMove(ref2, onOffset) {
  var _useState = React.useState(), _useState2 = _slicedToArray$1(_useState, 2), touchPosition = _useState2[0], setTouchPosition = _useState2[1];
  var _useState3 = React.useState(0), _useState4 = _slicedToArray$1(_useState3, 2), lastTimestamp = _useState4[0], setLastTimestamp = _useState4[1];
  var _useState5 = React.useState(0), _useState6 = _slicedToArray$1(_useState5, 2), lastTimeDiff = _useState6[0], setLastTimeDiff = _useState6[1];
  var _useState7 = React.useState(), _useState8 = _slicedToArray$1(_useState7, 2), lastOffset = _useState8[0], setLastOffset = _useState8[1];
  var motionRef = React.useRef();
  function onTouchStart(e2) {
    var _e$touches$ = e2.touches[0], screenX = _e$touches$.screenX, screenY = _e$touches$.screenY;
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    window.clearInterval(motionRef.current);
  }
  function onTouchMove(e2) {
    if (!touchPosition)
      return;
    e2.preventDefault();
    var _e$touches$2 = e2.touches[0], screenX = _e$touches$2.screenX, screenY = _e$touches$2.screenY;
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    var offsetX = screenX - touchPosition.x;
    var offsetY = screenY - touchPosition.y;
    onOffset(offsetX, offsetY);
    var now = Date.now();
    setLastTimestamp(now);
    setLastTimeDiff(now - lastTimestamp);
    setLastOffset({
      x: offsetX,
      y: offsetY
    });
  }
  function onTouchEnd() {
    if (!touchPosition)
      return;
    setTouchPosition(null);
    setLastOffset(null);
    if (lastOffset) {
      var distanceX = lastOffset.x / lastTimeDiff;
      var distanceY = lastOffset.y / lastTimeDiff;
      var absX = Math.abs(distanceX);
      var absY = Math.abs(distanceY);
      if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE)
        return;
      var currentX = distanceX;
      var currentY = distanceY;
      motionRef.current = window.setInterval(function() {
        if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
          window.clearInterval(motionRef.current);
          return;
        }
        currentX *= SPEED_OFF_MULTIPLE;
        currentY *= SPEED_OFF_MULTIPLE;
        onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
      }, REFRESH_INTERVAL);
    }
  }
  var lastWheelDirectionRef = React.useRef();
  function onWheel(e2) {
    var deltaX = e2.deltaX, deltaY = e2.deltaY;
    var mixed = 0;
    var absX = Math.abs(deltaX);
    var absY = Math.abs(deltaY);
    if (absX === absY) {
      mixed = lastWheelDirectionRef.current === "x" ? deltaX : deltaY;
    } else if (absX > absY) {
      mixed = deltaX;
      lastWheelDirectionRef.current = "x";
    } else {
      mixed = deltaY;
      lastWheelDirectionRef.current = "y";
    }
    if (onOffset(-mixed, -mixed)) {
      e2.preventDefault();
    }
  }
  var touchEventsRef = React.useRef(null);
  touchEventsRef.current = {
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    onWheel
  };
  React.useEffect(function() {
    function onProxyTouchStart(e2) {
      touchEventsRef.current.onTouchStart(e2);
    }
    function onProxyTouchMove(e2) {
      touchEventsRef.current.onTouchMove(e2);
    }
    function onProxyTouchEnd(e2) {
      touchEventsRef.current.onTouchEnd(e2);
    }
    function onProxyWheel(e2) {
      touchEventsRef.current.onWheel(e2);
    }
    document.addEventListener("touchmove", onProxyTouchMove, {
      passive: false
    });
    document.addEventListener("touchend", onProxyTouchEnd, {
      passive: false
    });
    ref2.current.addEventListener("touchstart", onProxyTouchStart, {
      passive: false
    });
    ref2.current.addEventListener("wheel", onProxyWheel);
    return function() {
      document.removeEventListener("touchmove", onProxyTouchMove);
      document.removeEventListener("touchend", onProxyTouchEnd);
    };
  }, []);
}
function useUpdate(callback) {
  var _useState = React.useState(0), _useState2 = _slicedToArray$1(_useState, 2), count = _useState2[0], setCount = _useState2[1];
  var effectRef = React.useRef(0);
  var callbackRef = React.useRef();
  callbackRef.current = callback;
  useLayoutUpdateEffect4(function() {
    var _callbackRef$current;
    (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef);
  }, [count]);
  return function() {
    if (effectRef.current !== count) {
      return;
    }
    effectRef.current += 1;
    setCount(effectRef.current);
  };
}
function useUpdateState(defaultState) {
  var batchRef = React.useRef([]);
  var _useState3 = React.useState({}), _useState4 = _slicedToArray$1(_useState3, 2), forceUpdate = _useState4[1];
  var state = React.useRef(typeof defaultState === "function" ? defaultState() : defaultState);
  var flushUpdate = useUpdate(function() {
    var current = state.current;
    batchRef.current.forEach(function(callback) {
      current = callback(current);
    });
    batchRef.current = [];
    state.current = current;
    forceUpdate({});
  });
  function updater(callback) {
    batchRef.current.push(callback);
    flushUpdate();
  }
  return [state.current, updater];
}
var DEFAULT_SIZE = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
function useVisibleRange(tabOffsets, visibleTabContentValue, transform3, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, _ref2) {
  var tabs = _ref2.tabs, tabPosition = _ref2.tabPosition, rtl = _ref2.rtl;
  var charUnit;
  var position2;
  var transformSize;
  if (["top", "bottom"].includes(tabPosition)) {
    charUnit = "width";
    position2 = rtl ? "right" : "left";
    transformSize = Math.abs(transform3);
  } else {
    charUnit = "height";
    position2 = "top";
    transformSize = -transform3;
  }
  return React.useMemo(function() {
    if (!tabs.length) {
      return [0, 0];
    }
    var len = tabs.length;
    var endIndex = len;
    for (var i = 0; i < len; i += 1) {
      var offset3 = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE;
      if (offset3[position2] + offset3[charUnit] > transformSize + visibleTabContentValue) {
        endIndex = i - 1;
        break;
      }
    }
    var startIndex = 0;
    for (var _i2 = len - 1; _i2 >= 0; _i2 -= 1) {
      var _offset = tabOffsets.get(tabs[_i2].key) || DEFAULT_SIZE;
      if (_offset[position2] < transformSize) {
        startIndex = _i2 + 1;
        break;
      }
    }
    return [startIndex, endIndex];
  }, [tabOffsets, visibleTabContentValue, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, transformSize, tabPosition, tabs.map(function(tab2) {
    return tab2.key;
  }).join("_"), rtl]);
}
function stringify(obj) {
  var tgt;
  if (obj instanceof Map) {
    tgt = {};
    obj.forEach(function(v2, k2) {
      tgt[k2] = v2;
    });
  } else {
    tgt = obj;
  }
  return JSON.stringify(tgt);
}
var RC_TABS_DOUBLE_QUOTE = "TABS_DQ";
function genDataNodeKey(key) {
  return String(key).replace(/"/g, RC_TABS_DOUBLE_QUOTE);
}
function AddButton(_ref2, ref2) {
  var prefixCls = _ref2.prefixCls, editable = _ref2.editable, locale2 = _ref2.locale, style2 = _ref2.style;
  if (!editable || editable.showAdd === false) {
    return null;
  }
  return /* @__PURE__ */ React.createElement("button", {
    ref: ref2,
    type: "button",
    className: "".concat(prefixCls, "-nav-add"),
    style: style2,
    "aria-label": (locale2 === null || locale2 === void 0 ? void 0 : locale2.addAriaLabel) || "Add tab",
    onClick: function onClick(event) {
      editable.onEdit("add", {
        event
      });
    }
  }, editable.addIcon || "+");
}
var AddButton$1 = /* @__PURE__ */ React.forwardRef(AddButton);
var ExtraContent = /* @__PURE__ */ React.forwardRef(function(_ref2, ref2) {
  var position2 = _ref2.position, prefixCls = _ref2.prefixCls, extra = _ref2.extra;
  if (!extra)
    return null;
  var content2;
  var assertExtra = {};
  if (_typeof$8(extra) === "object" && !/* @__PURE__ */ React.isValidElement(extra)) {
    assertExtra = extra;
  } else {
    assertExtra.right = extra;
  }
  if (position2 === "right") {
    content2 = assertExtra.right;
  }
  if (position2 === "left") {
    content2 = assertExtra.left;
  }
  return content2 ? /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-extra-content"),
    ref: ref2
  }, content2) : null;
});
function canUseDom$4() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var useLayoutEffect = canUseDom$4() ? React.useLayoutEffect : React.useEffect;
var _excluded$j = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];
var UNDEFINED = void 0;
function InternalItem$1(props, ref2) {
  var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey2 = props.itemKey, className = props.className, style2 = props.style, children = props.children, display = props.display, order2 = props.order, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties$1(props, _excluded$j);
  var mergedHidden = responsive && !display;
  function internalRegisterSize(width) {
    registerSize(itemKey2, width);
  }
  React.useEffect(function() {
    return function() {
      internalRegisterSize(null);
    };
  }, []);
  var childNode = renderItem && item !== UNDEFINED ? renderItem(item) : children;
  var overflowStyle;
  if (!invalidate) {
    overflowStyle = {
      opacity: mergedHidden ? 0 : 1,
      height: mergedHidden ? 0 : UNDEFINED,
      overflowY: mergedHidden ? "hidden" : UNDEFINED,
      order: responsive ? order2 : UNDEFINED,
      pointerEvents: mergedHidden ? "none" : UNDEFINED,
      position: mergedHidden ? "absolute" : UNDEFINED
    };
  }
  var overflowProps = {};
  if (mergedHidden) {
    overflowProps["aria-hidden"] = true;
  }
  var itemNode = /* @__PURE__ */ React.createElement(Component, _extends$3({
    className: classNames(!invalidate && prefixCls, className),
    style: _objectSpread2$d(_objectSpread2$d({}, overflowStyle), style2)
  }, overflowProps, restProps, {
    ref: ref2
  }), childNode);
  if (responsive) {
    itemNode = /* @__PURE__ */ React.createElement(ResizeObserver$2, {
      onResize: function onResize2(_ref2) {
        var offsetWidth = _ref2.offsetWidth;
        internalRegisterSize(offsetWidth);
      },
      disabled: responsiveDisabled
    }, itemNode);
  }
  return itemNode;
}
var Item$2 = /* @__PURE__ */ React.forwardRef(InternalItem$1);
Item$2.displayName = "Item";
function useEvent$1(callback) {
  var fnRef = React.useRef();
  fnRef.current = callback;
  var memoFn = React.useCallback(function() {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
var raf$2 = function raf7(callback) {
  return +setTimeout(callback, 16);
};
var caf$1 = function caf7(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf$2 = function raf10(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf$1 = function caf10(handle2) {
    return window.cancelAnimationFrame(handle2);
  };
}
var rafUUID$1 = 0;
var rafIds$1 = /* @__PURE__ */ new Map();
function cleanup$1(id) {
  rafIds$1.delete(id);
}
function wrapperRaf$1(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID$1 += 1;
  var id = rafUUID$1;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup$1(id);
      callback();
    } else {
      var realId = raf$2(function() {
        callRef(leftTimes - 1);
      });
      rafIds$1.set(id, realId);
    }
  }
  callRef(times);
  return id;
}
wrapperRaf$1.cancel = function(id) {
  var realId = rafIds$1.get(id);
  cleanup$1(realId);
  return caf$1(realId);
};
function channelUpdate(callback) {
  if (typeof MessageChannel === "undefined") {
    wrapperRaf$1(callback);
  } else {
    var channel = new MessageChannel();
    channel.port1.onmessage = function() {
      return callback();
    };
    channel.port2.postMessage(void 0);
  }
}
function useBatcher() {
  var updateFuncRef = React.useRef(null);
  var notifyEffectUpdate = function notifyEffectUpdate2(callback) {
    if (!updateFuncRef.current) {
      updateFuncRef.current = [];
      channelUpdate(function() {
        ReactDOM.unstable_batchedUpdates(function() {
          updateFuncRef.current.forEach(function(fn2) {
            fn2();
          });
          updateFuncRef.current = null;
        });
      });
    }
    updateFuncRef.current.push(callback);
  };
  return notifyEffectUpdate;
}
function useEffectState(notifyEffectUpdate, defaultValue) {
  var _React$useState = React.useState(defaultValue), _React$useState2 = _slicedToArray$1(_React$useState, 2), stateValue = _React$useState2[0], setStateValue = _React$useState2[1];
  var setEffectVal = useEvent$1(function(nextValue) {
    notifyEffectUpdate(function() {
      setStateValue(nextValue);
    });
  });
  return [stateValue, setEffectVal];
}
var _excluded$i = ["component"], _excluded2$5 = ["className"], _excluded3$1 = ["className"];
var InternalRawItem3 = function InternalRawItem4(props, ref2) {
  var context2 = React.useContext(OverflowContext);
  if (!context2) {
    var _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties$1(props, _excluded$i);
    return /* @__PURE__ */ React.createElement(Component, _extends$3({}, _restProps, {
      ref: ref2
    }));
  }
  var contextClassName = context2.className, restContext = _objectWithoutProperties$1(context2, _excluded2$5);
  var className = props.className, restProps = _objectWithoutProperties$1(props, _excluded3$1);
  return /* @__PURE__ */ React.createElement(OverflowContext.Provider, {
    value: null
  }, /* @__PURE__ */ React.createElement(Item$2, _extends$3({
    ref: ref2,
    className: classNames(contextClassName, className)
  }, restContext, restProps)));
};
var RawItem = /* @__PURE__ */ React.forwardRef(InternalRawItem3);
RawItem.displayName = "RawItem";
var _excluded$h = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];
var OverflowContext = /* @__PURE__ */ React.createContext(null);
var RESPONSIVE = "responsive";
var INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
  return "+ ".concat(omittedItems.length, " ...");
}
function Overflow(props, ref2) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data2 = _props$data === void 0 ? [] : _props$data, renderItem = props.renderItem, renderRawItem = props.renderRawItem, itemKey2 = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style2 = props.style, className = props.className, maxCount = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix = props.suffix, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties$1(props, _excluded$h);
  var fullySSR = ssr === "full";
  var notifyEffectUpdate = useBatcher();
  var _useEffectState = useEffectState(notifyEffectUpdate, null), _useEffectState2 = _slicedToArray$1(_useEffectState, 2), containerWidth = _useEffectState2[0], setContainerWidth = _useEffectState2[1];
  var mergedContainerWidth = containerWidth || 0;
  var _useEffectState3 = useEffectState(notifyEffectUpdate, /* @__PURE__ */ new Map()), _useEffectState4 = _slicedToArray$1(_useEffectState3, 2), itemWidths = _useEffectState4[0], setItemWidths = _useEffectState4[1];
  var _useEffectState5 = useEffectState(notifyEffectUpdate, 0), _useEffectState6 = _slicedToArray$1(_useEffectState5, 2), prevRestWidth = _useEffectState6[0], setPrevRestWidth = _useEffectState6[1];
  var _useEffectState7 = useEffectState(notifyEffectUpdate, 0), _useEffectState8 = _slicedToArray$1(_useEffectState7, 2), restWidth = _useEffectState8[0], setRestWidth = _useEffectState8[1];
  var _useEffectState9 = useEffectState(notifyEffectUpdate, 0), _useEffectState10 = _slicedToArray$1(_useEffectState9, 2), suffixWidth = _useEffectState10[0], setSuffixWidth = _useEffectState10[1];
  var _useState = React.useState(null), _useState2 = _slicedToArray$1(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1];
  var _useState3 = React.useState(null), _useState4 = _slicedToArray$1(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1];
  var mergedDisplayCount = React.useMemo(function() {
    if (displayCount === null && fullySSR) {
      return Number.MAX_SAFE_INTEGER;
    }
    return displayCount || 0;
  }, [displayCount, containerWidth]);
  var _useState5 = React.useState(false), _useState6 = _slicedToArray$1(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1];
  var itemPrefixCls = "".concat(prefixCls, "-item");
  var mergedRestWidth = Math.max(prevRestWidth, restWidth);
  var isResponsive = maxCount === RESPONSIVE;
  var shouldResponsive = data2.length && isResponsive;
  var invalidate = maxCount === INVALIDATE;
  var showRest = shouldResponsive || typeof maxCount === "number" && data2.length > maxCount;
  var mergedData = React.useMemo(function() {
    var items = data2;
    if (shouldResponsive) {
      if (containerWidth === null && fullySSR) {
        items = data2;
      } else {
        items = data2.slice(0, Math.min(data2.length, mergedContainerWidth / itemWidth));
      }
    } else if (typeof maxCount === "number") {
      items = data2.slice(0, maxCount);
    }
    return items;
  }, [data2, itemWidth, containerWidth, maxCount, shouldResponsive]);
  var omittedItems = React.useMemo(function() {
    if (shouldResponsive) {
      return data2.slice(mergedDisplayCount + 1);
    }
    return data2.slice(mergedData.length);
  }, [data2, mergedData, shouldResponsive, mergedDisplayCount]);
  var getKey3 = React.useCallback(function(item, index2) {
    var _ref2;
    if (typeof itemKey2 === "function") {
      return itemKey2(item);
    }
    return (_ref2 = itemKey2 && (item === null || item === void 0 ? void 0 : item[itemKey2])) !== null && _ref2 !== void 0 ? _ref2 : index2;
  }, [itemKey2]);
  var mergedRenderItem = React.useCallback(renderItem || function(item) {
    return item;
  }, [renderItem]);
  function updateDisplayCount(count, suffixFixedStartVal, notReady) {
    if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
      return;
    }
    setDisplayCount(count);
    if (!notReady) {
      setRestReady(count < data2.length - 1);
      onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(count);
    }
    if (suffixFixedStartVal !== void 0) {
      setSuffixFixedStart(suffixFixedStartVal);
    }
  }
  function onOverflowResize(_24, element2) {
    setContainerWidth(element2.clientWidth);
  }
  function registerSize(key, width) {
    setItemWidths(function(origin) {
      var clone2 = new Map(origin);
      if (width === null) {
        clone2.delete(key);
      } else {
        clone2.set(key, width);
      }
      return clone2;
    });
  }
  function registerOverflowSize(_24, width) {
    setRestWidth(width);
    setPrevRestWidth(restWidth);
  }
  function registerSuffixSize(_24, width) {
    setSuffixWidth(width);
  }
  function getItemWidth(index2) {
    return itemWidths.get(getKey3(mergedData[index2], index2));
  }
  useLayoutEffect(function() {
    if (mergedContainerWidth && typeof mergedRestWidth === "number" && mergedData) {
      var totalWidth = suffixWidth;
      var len = mergedData.length;
      var lastIndex = len - 1;
      if (!len) {
        updateDisplayCount(0, null);
        return;
      }
      for (var i = 0; i < len; i += 1) {
        var currentItemWidth = getItemWidth(i);
        if (fullySSR) {
          currentItemWidth = currentItemWidth || 0;
        }
        if (currentItemWidth === void 0) {
          updateDisplayCount(i - 1, void 0, true);
          break;
        }
        totalWidth += currentItemWidth;
        if (lastIndex === 0 && totalWidth <= mergedContainerWidth || i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth) {
          updateDisplayCount(lastIndex, null);
          break;
        } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
          updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
          break;
        }
      }
      if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
        setSuffixFixedStart(null);
      }
    }
  }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey3, mergedData]);
  var displayRest = restReady && !!omittedItems.length;
  var suffixStyle = {};
  if (suffixFixedStart !== null && shouldResponsive) {
    suffixStyle = {
      position: "absolute",
      left: suffixFixedStart,
      top: 0
    };
  }
  var itemSharedProps = {
    prefixCls: itemPrefixCls,
    responsive: shouldResponsive,
    component: itemComponent,
    invalidate
  };
  var internalRenderItemNode = renderRawItem ? function(item, index2) {
    var key = getKey3(item, index2);
    return /* @__PURE__ */ React.createElement(OverflowContext.Provider, {
      key,
      value: _objectSpread2$d(_objectSpread2$d({}, itemSharedProps), {}, {
        order: index2,
        item,
        itemKey: key,
        registerSize,
        display: index2 <= mergedDisplayCount
      })
    }, renderRawItem(item, index2));
  } : function(item, index2) {
    var key = getKey3(item, index2);
    return /* @__PURE__ */ React.createElement(Item$2, _extends$3({}, itemSharedProps, {
      order: index2,
      key,
      item,
      renderItem: mergedRenderItem,
      itemKey: key,
      registerSize,
      display: index2 <= mergedDisplayCount
    }));
  };
  var restNode;
  var restContextProps = {
    order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
    className: "".concat(itemPrefixCls, "-rest"),
    registerSize: registerOverflowSize,
    display: displayRest
  };
  if (!renderRawRest) {
    var mergedRenderRest = renderRest || defaultRenderRest;
    restNode = /* @__PURE__ */ React.createElement(Item$2, _extends$3({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
  } else if (renderRawRest) {
    restNode = /* @__PURE__ */ React.createElement(OverflowContext.Provider, {
      value: _objectSpread2$d(_objectSpread2$d({}, itemSharedProps), restContextProps)
    }, renderRawRest(omittedItems));
  }
  var overflowNode = /* @__PURE__ */ React.createElement(Component, _extends$3({
    className: classNames(!invalidate && prefixCls, className),
    style: style2,
    ref: ref2
  }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ React.createElement(Item$2, _extends$3({}, itemSharedProps, {
    responsive: isResponsive,
    responsiveDisabled: !shouldResponsive,
    order: mergedDisplayCount,
    className: "".concat(itemPrefixCls, "-suffix"),
    registerSize: registerSuffixSize,
    display: true,
    style: suffixStyle
  }), suffix));
  if (isResponsive) {
    overflowNode = /* @__PURE__ */ React.createElement(ResizeObserver$2, {
      onResize: onOverflowResize,
      disabled: !shouldResponsive
    }, overflowNode);
  }
  return overflowNode;
}
var ForwardOverflow = /* @__PURE__ */ React.forwardRef(Overflow);
ForwardOverflow.displayName = "Overflow";
ForwardOverflow.Item = RawItem;
ForwardOverflow.RESPONSIVE = RESPONSIVE;
ForwardOverflow.INVALIDATE = INVALIDATE;
var warned$2 = {};
function warning$6(valid2, message) {
}
function call$2(method4, valid2, message) {
  if (!valid2 && !warned$2[message]) {
    method4(false, message);
    warned$2[message] = true;
  }
}
function warningOnce$2(valid2, message) {
  call$2(warning$6, valid2, message);
}
function isEqual$2(obj1, obj2) {
  var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var refSet = /* @__PURE__ */ new Set();
  function deepEqual(a, b2) {
    var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    var circular = refSet.has(a);
    warningOnce$2(!circular, "Warning: There may be circular references");
    if (circular) {
      return false;
    }
    if (a === b2) {
      return true;
    }
    if (shallow && level > 1) {
      return false;
    }
    refSet.add(a);
    var newLevel = level + 1;
    if (Array.isArray(a)) {
      if (!Array.isArray(b2) || a.length !== b2.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!deepEqual(a[i], b2[i], newLevel)) {
          return false;
        }
      }
      return true;
    }
    if (a && b2 && _typeof$8(a) === "object" && _typeof$8(b2) === "object") {
      var keys2 = Object.keys(a);
      if (keys2.length !== Object.keys(b2).length) {
        return false;
      }
      return keys2.every(function(key) {
        return deepEqual(a[key], b2[key], newLevel);
      });
    }
    return false;
  }
  return deepEqual(obj1, obj2);
}
var IdContext = /* @__PURE__ */ React.createContext(null);
function getMenuId(uuid2, eventKey) {
  if (uuid2 === void 0) {
    return null;
  }
  return "".concat(uuid2, "-").concat(eventKey);
}
function useMenuId(eventKey) {
  var id = React.useContext(IdContext);
  return getMenuId(id, eventKey);
}
var _excluded$g = ["children", "locked"];
var MenuContext = /* @__PURE__ */ React.createContext(null);
function mergeProps(origin, target) {
  var clone2 = _objectSpread2$d({}, origin);
  Object.keys(target).forEach(function(key) {
    var value = target[key];
    if (value !== void 0) {
      clone2[key] = value;
    }
  });
  return clone2;
}
function InheritableContextProvider(_ref2) {
  var children = _ref2.children, locked = _ref2.locked, restProps = _objectWithoutProperties$1(_ref2, _excluded$g);
  var context2 = React.useContext(MenuContext);
  var inheritableContext = useMemo$2(function() {
    return mergeProps(context2, restProps);
  }, [context2, restProps], function(prev2, next2) {
    return !locked && (prev2[0] !== next2[0] || !isEqual$2(prev2[1], next2[1], true));
  });
  return /* @__PURE__ */ React.createElement(MenuContext.Provider, {
    value: inheritableContext
  }, children);
}
var EmptyList = [];
var PathRegisterContext = /* @__PURE__ */ React.createContext(null);
function useMeasure() {
  return React.useContext(PathRegisterContext);
}
var PathTrackerContext = /* @__PURE__ */ React.createContext(EmptyList);
function useFullPath(eventKey) {
  var parentKeyPath = React.useContext(PathTrackerContext);
  return React.useMemo(function() {
    return eventKey !== void 0 ? [].concat(_toConsumableArray(parentKeyPath), [eventKey]) : parentKeyPath;
  }, [parentKeyPath, eventKey]);
}
var PathUserContext = /* @__PURE__ */ React.createContext(null);
var PrivateContext = /* @__PURE__ */ React.createContext({});
var KeyCode$1 = {
  MAC_ENTER: 3,
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  PRINT_SCREEN: 44,
  INSERT: 45,
  DELETE: 46,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  QUESTION_MARK: 63,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  META: 91,
  WIN_KEY_RIGHT: 92,
  CONTEXT_MENU: 93,
  NUM_ZERO: 96,
  NUM_ONE: 97,
  NUM_TWO: 98,
  NUM_THREE: 99,
  NUM_FOUR: 100,
  NUM_FIVE: 101,
  NUM_SIX: 102,
  NUM_SEVEN: 103,
  NUM_EIGHT: 104,
  NUM_NINE: 105,
  NUM_MULTIPLY: 106,
  NUM_PLUS: 107,
  NUM_MINUS: 109,
  NUM_PERIOD: 110,
  NUM_DIVISION: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SEMICOLON: 186,
  DASH: 189,
  EQUALS: 187,
  COMMA: 188,
  PERIOD: 190,
  SLASH: 191,
  APOSTROPHE: 192,
  SINGLE_QUOTE: 222,
  OPEN_SQUARE_BRACKET: 219,
  BACKSLASH: 220,
  CLOSE_SQUARE_BRACKET: 221,
  WIN_KEY: 224,
  MAC_FF_META: 224,
  WIN_IME: 229,
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent5(e2) {
    var keyCode = e2.keyCode;
    if (e2.altKey && !e2.ctrlKey || e2.metaKey || keyCode >= KeyCode$1.F1 && keyCode <= KeyCode$1.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode$1.ALT:
      case KeyCode$1.CAPS_LOCK:
      case KeyCode$1.CONTEXT_MENU:
      case KeyCode$1.CTRL:
      case KeyCode$1.DOWN:
      case KeyCode$1.END:
      case KeyCode$1.ESC:
      case KeyCode$1.HOME:
      case KeyCode$1.INSERT:
      case KeyCode$1.LEFT:
      case KeyCode$1.MAC_FF_META:
      case KeyCode$1.META:
      case KeyCode$1.NUMLOCK:
      case KeyCode$1.NUM_CENTER:
      case KeyCode$1.PAGE_DOWN:
      case KeyCode$1.PAGE_UP:
      case KeyCode$1.PAUSE:
      case KeyCode$1.PRINT_SCREEN:
      case KeyCode$1.RIGHT:
      case KeyCode$1.SHIFT:
      case KeyCode$1.UP:
      case KeyCode$1.WIN_KEY:
      case KeyCode$1.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  isCharacterKey: function isCharacterKey5(keyCode) {
    if (keyCode >= KeyCode$1.ZERO && keyCode <= KeyCode$1.NINE) {
      return true;
    }
    if (keyCode >= KeyCode$1.NUM_ZERO && keyCode <= KeyCode$1.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode$1.A && keyCode <= KeyCode$1.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode$1.SPACE:
      case KeyCode$1.QUESTION_MARK:
      case KeyCode$1.NUM_PLUS:
      case KeyCode$1.NUM_MINUS:
      case KeyCode$1.NUM_PERIOD:
      case KeyCode$1.NUM_DIVISION:
      case KeyCode$1.SEMICOLON:
      case KeyCode$1.DASH:
      case KeyCode$1.EQUALS:
      case KeyCode$1.COMMA:
      case KeyCode$1.PERIOD:
      case KeyCode$1.SLASH:
      case KeyCode$1.APOSTROPHE:
      case KeyCode$1.SINGLE_QUOTE:
      case KeyCode$1.OPEN_SQUARE_BRACKET:
      case KeyCode$1.BACKSLASH:
      case KeyCode$1.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
var isVisible$1 = function(element2) {
  if (!element2) {
    return false;
  }
  if (element2 instanceof Element) {
    if (element2.offsetParent) {
      return true;
    }
    if (element2.getBBox) {
      var _getBBox = element2.getBBox(), width = _getBBox.width, height = _getBBox.height;
      if (width || height) {
        return true;
      }
    }
    if (element2.getBoundingClientRect) {
      var _element$getBoundingC = element2.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
      if (_width || _height) {
        return true;
      }
    }
  }
  return false;
};
function focusable(node2) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (isVisible$1(node2)) {
    var nodeName = node2.nodeName.toLowerCase();
    var isFocusableElement = ["input", "select", "textarea", "button"].includes(nodeName) || node2.isContentEditable || nodeName === "a" && !!node2.getAttribute("href");
    var tabIndexAttr = node2.getAttribute("tabindex");
    var tabIndexNum = Number(tabIndexAttr);
    var tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
      tabIndex = tabIndexNum;
    } else if (isFocusableElement && tabIndex === null) {
      tabIndex = 0;
    }
    if (isFocusableElement && node2.disabled) {
      tabIndex = null;
    }
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
function getFocusNodeList(node2) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var res = _toConsumableArray(node2.querySelectorAll("*")).filter(function(child) {
    return focusable(child, includePositive);
  });
  if (focusable(node2, includePositive)) {
    res.unshift(node2);
  }
  return res;
}
var LEFT = KeyCode$1.LEFT, RIGHT = KeyCode$1.RIGHT, UP = KeyCode$1.UP, DOWN = KeyCode$1.DOWN, ENTER = KeyCode$1.ENTER, ESC = KeyCode$1.ESC, HOME = KeyCode$1.HOME, END = KeyCode$1.END;
var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
function getOffset$1(mode, isRootLevel, isRtl, which) {
  var _inline, _horizontal, _vertical, _offsets;
  var prev2 = "prev";
  var next2 = "next";
  var children = "children";
  var parent = "parent";
  if (mode === "inline" && which === ENTER) {
    return {
      inlineTrigger: true
    };
  }
  var inline2 = (_inline = {}, _defineProperty$3(_inline, UP, prev2), _defineProperty$3(_inline, DOWN, next2), _inline);
  var horizontal = (_horizontal = {}, _defineProperty$3(_horizontal, LEFT, isRtl ? next2 : prev2), _defineProperty$3(_horizontal, RIGHT, isRtl ? prev2 : next2), _defineProperty$3(_horizontal, DOWN, children), _defineProperty$3(_horizontal, ENTER, children), _horizontal);
  var vertical = (_vertical = {}, _defineProperty$3(_vertical, UP, prev2), _defineProperty$3(_vertical, DOWN, next2), _defineProperty$3(_vertical, ENTER, children), _defineProperty$3(_vertical, ESC, parent), _defineProperty$3(_vertical, LEFT, isRtl ? children : parent), _defineProperty$3(_vertical, RIGHT, isRtl ? parent : children), _vertical);
  var offsets = {
    inline: inline2,
    horizontal,
    vertical,
    inlineSub: inline2,
    horizontalSub: vertical,
    verticalSub: vertical
  };
  var type4 = (_offsets = offsets["".concat(mode).concat(isRootLevel ? "" : "Sub")]) === null || _offsets === void 0 ? void 0 : _offsets[which];
  switch (type4) {
    case prev2:
      return {
        offset: -1,
        sibling: true
      };
    case next2:
      return {
        offset: 1,
        sibling: true
      };
    case parent:
      return {
        offset: -1,
        sibling: false
      };
    case children:
      return {
        offset: 1,
        sibling: false
      };
    default:
      return null;
  }
}
function findContainerUL(element2) {
  var current = element2;
  while (current) {
    if (current.getAttribute("data-menu-list")) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusElement(activeElement, elements) {
  var current = activeElement || document.activeElement;
  while (current) {
    if (elements.has(current)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusableElements(container, elements) {
  var list2 = getFocusNodeList(container, true);
  return list2.filter(function(ele) {
    return elements.has(ele);
  });
}
function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
  var offset3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  if (!parentQueryContainer) {
    return null;
  }
  var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
  var count = sameLevelFocusableMenuElementList.length;
  var focusIndex = sameLevelFocusableMenuElementList.findIndex(function(ele) {
    return focusMenuElement === ele;
  });
  if (offset3 < 0) {
    if (focusIndex === -1) {
      focusIndex = count - 1;
    } else {
      focusIndex -= 1;
    }
  } else if (offset3 > 0) {
    focusIndex += 1;
  }
  focusIndex = (focusIndex + count) % count;
  return sameLevelFocusableMenuElementList[focusIndex];
}
function useAccessibility(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
  var rafRef = React.useRef();
  var activeRef = React.useRef();
  activeRef.current = activeKey;
  var cleanRaf = function cleanRaf2() {
    wrapperRaf$2.cancel(rafRef.current);
  };
  React.useEffect(function() {
    return function() {
      cleanRaf();
    };
  }, []);
  return function(e2) {
    var which = e2.which;
    if ([].concat(ArrowKeys, [ENTER, ESC, HOME, END]).includes(which)) {
      var elements;
      var key2element;
      var element2key;
      var refreshElements = function refreshElements2() {
        elements = /* @__PURE__ */ new Set();
        key2element = /* @__PURE__ */ new Map();
        element2key = /* @__PURE__ */ new Map();
        var keys2 = getKeys();
        keys2.forEach(function(key) {
          var element2 = document.querySelector("[data-menu-id='".concat(getMenuId(id, key), "']"));
          if (element2) {
            elements.add(element2);
            element2key.set(element2, key);
            key2element.set(key, element2);
          }
        });
        return elements;
      };
      refreshElements();
      var activeElement = key2element.get(activeKey);
      var focusMenuElement = getFocusElement(activeElement, elements);
      var focusMenuKey = element2key.get(focusMenuElement);
      var offsetObj = getOffset$1(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
      if (!offsetObj && which !== HOME && which !== END) {
        return;
      }
      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
        e2.preventDefault();
      }
      var tryFocus = function tryFocus2(menuElement) {
        if (menuElement) {
          var focusTargetElement = menuElement;
          var link2 = menuElement.querySelector("a");
          if (link2 !== null && link2 !== void 0 && link2.getAttribute("href")) {
            focusTargetElement = link2;
          }
          var targetKey = element2key.get(menuElement);
          triggerActiveKey(targetKey);
          cleanRaf();
          rafRef.current = wrapperRaf$2(function() {
            if (activeRef.current === targetKey) {
              focusTargetElement.focus();
            }
          });
        }
      };
      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
        var parentQueryContainer;
        if (!focusMenuElement || mode === "inline") {
          parentQueryContainer = containerRef.current;
        } else {
          parentQueryContainer = findContainerUL(focusMenuElement);
        }
        var targetElement;
        var focusableElements = getFocusableElements(parentQueryContainer, elements);
        if (which === HOME) {
          targetElement = focusableElements[0];
        } else if (which === END) {
          targetElement = focusableElements[focusableElements.length - 1];
        } else {
          targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
        }
        tryFocus(targetElement);
      } else if (offsetObj.inlineTrigger) {
        triggerAccessibilityOpen(focusMenuKey);
      } else if (offsetObj.offset > 0) {
        triggerAccessibilityOpen(focusMenuKey, true);
        cleanRaf();
        rafRef.current = wrapperRaf$2(function() {
          refreshElements();
          var controlId = focusMenuElement.getAttribute("aria-controls");
          var subQueryContainer = document.getElementById(controlId);
          var targetElement2 = getNextFocusElement(subQueryContainer, elements);
          tryFocus(targetElement2);
        }, 5);
      } else if (offsetObj.offset < 0) {
        var keyPath = getKeyPath(focusMenuKey, true);
        var parentKey = keyPath[keyPath.length - 2];
        var parentMenuElement = key2element.get(parentKey);
        triggerAccessibilityOpen(parentKey, false);
        tryFocus(parentMenuElement);
      }
    }
    originOnKeyDown === null || originOnKeyDown === void 0 ? void 0 : originOnKeyDown(e2);
  };
}
function nextSlice(callback) {
  Promise.resolve().then(callback);
}
var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
var getPathStr2 = function getPathStr3(keyPath) {
  return keyPath.join(PATH_SPLIT);
};
var getPathKeys2 = function getPathKeys3(keyPathStr) {
  return keyPathStr.split(PATH_SPLIT);
};
var OVERFLOW_KEY = "rc-menu-more";
function useKeyRecords() {
  var _React$useState = React.useState({}), _React$useState2 = _slicedToArray$1(_React$useState, 2), internalForceUpdate = _React$useState2[1];
  var key2pathRef = React.useRef(/* @__PURE__ */ new Map());
  var path2keyRef = React.useRef(/* @__PURE__ */ new Map());
  var _React$useState3 = React.useState([]), _React$useState4 = _slicedToArray$1(_React$useState3, 2), overflowKeys = _React$useState4[0], setOverflowKeys = _React$useState4[1];
  var updateRef = React.useRef(0);
  var destroyRef = React.useRef(false);
  var forceUpdate = function forceUpdate2() {
    if (!destroyRef.current) {
      internalForceUpdate({});
    }
  };
  var registerPath = React.useCallback(function(key, keyPath) {
    var connectedPath = getPathStr2(keyPath);
    path2keyRef.current.set(connectedPath, key);
    key2pathRef.current.set(key, connectedPath);
    updateRef.current += 1;
    var id = updateRef.current;
    nextSlice(function() {
      if (id === updateRef.current) {
        forceUpdate();
      }
    });
  }, []);
  var unregisterPath = React.useCallback(function(key, keyPath) {
    var connectedPath = getPathStr2(keyPath);
    path2keyRef.current.delete(connectedPath);
    key2pathRef.current.delete(key);
  }, []);
  var refreshOverflowKeys = React.useCallback(function(keys2) {
    setOverflowKeys(keys2);
  }, []);
  var getKeyPath = React.useCallback(function(eventKey, includeOverflow) {
    var fullPath = key2pathRef.current.get(eventKey) || "";
    var keys2 = getPathKeys2(fullPath);
    if (includeOverflow && overflowKeys.includes(keys2[0])) {
      keys2.unshift(OVERFLOW_KEY);
    }
    return keys2;
  }, [overflowKeys]);
  var isSubPathKey = React.useCallback(function(pathKeys, eventKey) {
    return pathKeys.some(function(pathKey) {
      var pathKeyList = getKeyPath(pathKey, true);
      return pathKeyList.includes(eventKey);
    });
  }, [getKeyPath]);
  var getKeys = function getKeys2() {
    var keys2 = _toConsumableArray(key2pathRef.current.keys());
    if (overflowKeys.length) {
      keys2.push(OVERFLOW_KEY);
    }
    return keys2;
  };
  var getSubPathKeys = React.useCallback(function(key) {
    var connectedPath = "".concat(key2pathRef.current.get(key)).concat(PATH_SPLIT);
    var pathKeys = /* @__PURE__ */ new Set();
    _toConsumableArray(path2keyRef.current.keys()).forEach(function(pathKey) {
      if (pathKey.startsWith(connectedPath)) {
        pathKeys.add(path2keyRef.current.get(pathKey));
      }
    });
    return pathKeys;
  }, []);
  React.useEffect(function() {
    return function() {
      destroyRef.current = true;
    };
  }, []);
  return {
    registerPath,
    unregisterPath,
    refreshOverflowKeys,
    isSubPathKey,
    getKeyPath,
    getKeys,
    getSubPathKeys
  };
}
function useMemoCallback(func) {
  var funRef = React.useRef(func);
  funRef.current = func;
  var callback = React.useCallback(function() {
    var _funRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
  }, []);
  return func ? callback : void 0;
}
var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
var internalId = 0;
function useUUID(id) {
  var _useMergedState = useMergedState$1(id, {
    value: id
  }), _useMergedState2 = _slicedToArray$1(_useMergedState, 2), uuid2 = _useMergedState2[0], setUUID = _useMergedState2[1];
  React.useEffect(function() {
    internalId += 1;
    var newId = "".concat(uniquePrefix, "-").concat(internalId);
    setUUID("rc-menu-uuid-".concat(newId));
  }, []);
  return uuid2;
}
function omit$3(obj, fields) {
  var clone2 = _objectSpread2$d({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function(key) {
      delete clone2[key];
    });
  }
  return clone2;
}
function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
  var _React$useContext = React.useContext(MenuContext), activeKey = _React$useContext.activeKey, onActive = _React$useContext.onActive, onInactive = _React$useContext.onInactive;
  var ret = {
    active: activeKey === eventKey
  };
  if (!disabled) {
    ret.onMouseEnter = function(domEvent) {
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
        key: eventKey,
        domEvent
      });
      onActive(eventKey);
    };
    ret.onMouseLeave = function(domEvent) {
      onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
        key: eventKey,
        domEvent
      });
      onInactive(eventKey);
    };
  }
  return ret;
}
function useDirectionStyle(level) {
  var _React$useContext = React.useContext(MenuContext), mode = _React$useContext.mode, rtl = _React$useContext.rtl, inlineIndent = _React$useContext.inlineIndent;
  if (mode !== "inline") {
    return null;
  }
  var len = level;
  return rtl ? {
    paddingRight: len * inlineIndent
  } : {
    paddingLeft: len * inlineIndent
  };
}
function Icon$1(_ref2) {
  var icon = _ref2.icon, props = _ref2.props, children = _ref2.children;
  var iconNode;
  if (typeof icon === "function") {
    iconNode = /* @__PURE__ */ React.createElement(icon, _objectSpread2$d({}, props));
  } else {
    iconNode = icon;
  }
  return iconNode || children || null;
}
var _excluded$f = ["item"];
function warnItemProp(_ref2) {
  var item = _ref2.item, restInfo = _objectWithoutProperties$1(_ref2, _excluded$f);
  Object.defineProperty(restInfo, "item", {
    get: function get2() {
      warningOnce$2(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
      return item;
    }
  });
  return restInfo;
}
var _excluded$e = ["title", "attribute", "elementRef"], _excluded2$4 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"], _excluded3 = ["active"];
var LegacyMenuItem = /* @__PURE__ */ function(_React$Component) {
  _inherits$2(LegacyMenuItem2, _React$Component);
  var _super = _createSuper$2(LegacyMenuItem2);
  function LegacyMenuItem2() {
    _classCallCheck$2(this, LegacyMenuItem2);
    return _super.apply(this, arguments);
  }
  _createClass$2(LegacyMenuItem2, [{
    key: "render",
    value: function render2() {
      var _this$props = this.props, title = _this$props.title, attribute = _this$props.attribute, elementRef = _this$props.elementRef, restProps = _objectWithoutProperties$1(_this$props, _excluded$e);
      var passedProps = omit$3(restProps, ["eventKey", "popupClassName", "popupOffset", "onTitleClick"]);
      warningOnce$2(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
      return /* @__PURE__ */ React.createElement(ForwardOverflow.Item, _extends$3({}, attribute, {
        title: typeof title === "string" ? title : void 0
      }, passedProps, {
        ref: elementRef
      }));
    }
  }]);
  return LegacyMenuItem2;
}(React.Component);
var InternalMenuItem = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var _classNames;
  var style2 = props.style, className = props.className, eventKey = props.eventKey;
  props.warnKey;
  var disabled = props.disabled, itemIcon = props.itemIcon, children = props.children, role = props.role, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown = props.onKeyDown, onFocus = props.onFocus, restProps = _objectWithoutProperties$1(props, _excluded2$4);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = React.useContext(MenuContext), prefixCls = _React$useContext.prefixCls, onItemClick = _React$useContext.onItemClick, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, contextItemIcon = _React$useContext.itemIcon, selectedKeys = _React$useContext.selectedKeys, onActive = _React$useContext.onActive;
  var _React$useContext2 = React.useContext(PrivateContext), _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
  var itemCls = "".concat(prefixCls, "-item");
  var legacyMenuItemRef = React.useRef();
  var elementRef = React.useRef();
  var mergedDisabled = contextDisabled || disabled;
  var mergedEleRef = useComposeRef$1(ref2, elementRef);
  var connectedKeys = useFullPath(eventKey);
  var getEventInfo = function getEventInfo2(e2) {
    return {
      key: eventKey,
      keyPath: _toConsumableArray(connectedKeys).reverse(),
      item: legacyMenuItemRef.current,
      domEvent: e2
    };
  };
  var mergedItemIcon = itemIcon || contextItemIcon;
  var _useActive = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties$1(_useActive, _excluded3);
  var selected = selectedKeys.includes(eventKey);
  var directionStyle = useDirectionStyle(connectedKeys.length);
  var onInternalClick = function onInternalClick2(e2) {
    if (mergedDisabled) {
      return;
    }
    var info = getEventInfo(e2);
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
    onItemClick(info);
  };
  var onInternalKeyDown = function onInternalKeyDown2(e2) {
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e2);
    if (e2.which === KeyCode$1.ENTER) {
      var info = getEventInfo(e2);
      onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
      onItemClick(info);
    }
  };
  var onInternalFocus = function onInternalFocus2(e2) {
    onActive(eventKey);
    onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
  };
  var optionRoleProps = {};
  if (props.role === "option") {
    optionRoleProps["aria-selected"] = selected;
  }
  var renderNode = /* @__PURE__ */ React.createElement(LegacyMenuItem, _extends$3({
    ref: legacyMenuItemRef,
    elementRef: mergedEleRef,
    role: role === null ? "none" : role || "menuitem",
    tabIndex: disabled ? null : -1,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId
  }, restProps, activeProps, optionRoleProps, {
    component: "li",
    "aria-disabled": disabled,
    style: _objectSpread2$d(_objectSpread2$d({}, directionStyle), style2),
    className: classNames(itemCls, (_classNames = {}, _defineProperty$3(_classNames, "".concat(itemCls, "-active"), active), _defineProperty$3(_classNames, "".concat(itemCls, "-selected"), selected), _defineProperty$3(_classNames, "".concat(itemCls, "-disabled"), mergedDisabled), _classNames), className),
    onClick: onInternalClick,
    onKeyDown: onInternalKeyDown,
    onFocus: onInternalFocus
  }), children, /* @__PURE__ */ React.createElement(Icon$1, {
    props: _objectSpread2$d(_objectSpread2$d({}, props), {}, {
      isSelected: selected
    }),
    icon: mergedItemIcon
  }));
  if (_internalRenderMenuItem) {
    renderNode = _internalRenderMenuItem(renderNode, props, {
      selected
    });
  }
  return renderNode;
});
function MenuItem(props, ref2) {
  var eventKey = props.eventKey;
  var measure = useMeasure();
  var connectedKeyPath = useFullPath(eventKey);
  React.useEffect(function() {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function() {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  if (measure) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(InternalMenuItem, _extends$3({}, props, {
    ref: ref2
  }));
}
var MenuItem$1 = /* @__PURE__ */ React.forwardRef(MenuItem);
var _excluded$d = ["className", "children"];
var InternalSubMenuList2 = function InternalSubMenuList3(_ref2, ref2) {
  var className = _ref2.className, children = _ref2.children, restProps = _objectWithoutProperties$1(_ref2, _excluded$d);
  var _React$useContext = React.useContext(MenuContext), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, rtl = _React$useContext.rtl;
  return /* @__PURE__ */ React.createElement("ul", _extends$3({
    className: classNames(prefixCls, rtl && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === "inline" ? "inline" : "vertical"), className),
    role: "menu"
  }, restProps, {
    "data-menu-list": true,
    ref: ref2
  }), children);
};
var SubMenuList = /* @__PURE__ */ React.forwardRef(InternalSubMenuList2);
SubMenuList.displayName = "SubMenuList";
function toArray$4(children) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var ret = [];
  React.Children.forEach(children, function(child) {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray$4(child));
    } else if (reactIs$2.exports.isFragment(child) && child.props) {
      ret = ret.concat(toArray$4(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}
var _excluded$c = ["label", "children", "key", "type"];
function parseChildren(children, keyPath) {
  return toArray$4(children).map(function(child, index2) {
    if (/* @__PURE__ */ React.isValidElement(child)) {
      var _eventKey, _child$props;
      var key = child.key;
      var eventKey = (_eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _eventKey !== void 0 ? _eventKey : key;
      var emptyKey = eventKey === null || eventKey === void 0;
      if (emptyKey) {
        eventKey = "tmp_key-".concat([].concat(_toConsumableArray(keyPath), [index2]).join("-"));
      }
      var cloneProps = {
        key: eventKey,
        eventKey
      };
      return /* @__PURE__ */ React.cloneElement(child, cloneProps);
    }
    return child;
  });
}
function convertItemsToNodes(list2) {
  return (list2 || []).map(function(opt, index2) {
    if (opt && _typeof$8(opt) === "object") {
      var _ref2 = opt, label = _ref2.label, children = _ref2.children, key = _ref2.key, type4 = _ref2.type, restProps = _objectWithoutProperties$1(_ref2, _excluded$c);
      var mergedKey = key !== null && key !== void 0 ? key : "tmp-".concat(index2);
      if (children || type4 === "group") {
        if (type4 === "group") {
          return /* @__PURE__ */ React.createElement(MenuItemGroup, _extends$3({
            key: mergedKey
          }, restProps, {
            title: label
          }), convertItemsToNodes(children));
        }
        return /* @__PURE__ */ React.createElement(SubMenu, _extends$3({
          key: mergedKey
        }, restProps, {
          title: label
        }), convertItemsToNodes(children));
      }
      if (type4 === "divider") {
        return /* @__PURE__ */ React.createElement(Divider$2, _extends$3({
          key: mergedKey
        }, restProps));
      }
      return /* @__PURE__ */ React.createElement(MenuItem$1, _extends$3({
        key: mergedKey
      }, restProps), label);
    }
    return null;
  }).filter(function(opt) {
    return opt;
  });
}
function parseItems(children, items, keyPath) {
  var childNodes = children;
  if (items) {
    childNodes = convertItemsToNodes(items);
  }
  return parseChildren(childNodes, keyPath);
}
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var placements = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 7]
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow,
    offset: [-4, 0]
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow,
    offset: [4, 0]
  }
};
var placementsRtl = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 7]
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow,
    offset: [-4, 0]
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow,
    offset: [4, 0]
  }
};
function getMotion(mode, motion2, defaultMotions) {
  if (motion2) {
    return motion2;
  }
  if (defaultMotions) {
    return defaultMotions[mode] || defaultMotions.other;
  }
  return void 0;
}
var popupPlacementMap = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
function PopupTrigger(_ref2) {
  var prefixCls = _ref2.prefixCls, visible = _ref2.visible, children = _ref2.children, popup = _ref2.popup, popupClassName = _ref2.popupClassName, popupOffset = _ref2.popupOffset, disabled = _ref2.disabled, mode = _ref2.mode, onVisibleChange = _ref2.onVisibleChange;
  var _React$useContext = React.useContext(MenuContext), getPopupContainer = _React$useContext.getPopupContainer, rtl = _React$useContext.rtl, subMenuOpenDelay = _React$useContext.subMenuOpenDelay, subMenuCloseDelay = _React$useContext.subMenuCloseDelay, builtinPlacements = _React$useContext.builtinPlacements, triggerSubMenuAction = _React$useContext.triggerSubMenuAction, forceSubMenuRender = _React$useContext.forceSubMenuRender, rootClassName = _React$useContext.rootClassName, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions;
  var _React$useState = React.useState(false), _React$useState2 = _slicedToArray$1(_React$useState, 2), innerVisible = _React$useState2[0], setInnerVisible = _React$useState2[1];
  var placement = rtl ? _objectSpread2$d(_objectSpread2$d({}, placementsRtl), builtinPlacements) : _objectSpread2$d(_objectSpread2$d({}, placements), builtinPlacements);
  var popupPlacement = popupPlacementMap[mode];
  var targetMotion = getMotion(mode, motion2, defaultMotions);
  var targetMotionRef = React.useRef(targetMotion);
  if (mode !== "inline") {
    targetMotionRef.current = targetMotion;
  }
  var mergedMotion = _objectSpread2$d(_objectSpread2$d({}, targetMotionRef.current), {}, {
    leavedClassName: "".concat(prefixCls, "-hidden"),
    removeOnLeave: false,
    motionAppear: true
  });
  var visibleRef = React.useRef();
  React.useEffect(function() {
    visibleRef.current = wrapperRaf$2(function() {
      setInnerVisible(visible);
    });
    return function() {
      wrapperRaf$2.cancel(visibleRef.current);
    };
  }, [visible]);
  return /* @__PURE__ */ React.createElement(Trigger$1, {
    prefixCls,
    popupClassName: classNames("".concat(prefixCls, "-popup"), _defineProperty$3({}, "".concat(prefixCls, "-rtl"), rtl), popupClassName, rootClassName),
    stretch: mode === "horizontal" ? "minWidth" : null,
    getPopupContainer,
    builtinPlacements: placement,
    popupPlacement,
    popupVisible: innerVisible,
    popup,
    popupAlign: popupOffset && {
      offset: popupOffset
    },
    action: disabled ? [] : [triggerSubMenuAction],
    mouseEnterDelay: subMenuOpenDelay,
    mouseLeaveDelay: subMenuCloseDelay,
    onPopupVisibleChange: onVisibleChange,
    forceRender: forceSubMenuRender,
    popupMotion: mergedMotion
  }, children);
}
function InlineSubMenuList(_ref2) {
  var id = _ref2.id, open = _ref2.open, keyPath = _ref2.keyPath, children = _ref2.children;
  var fixedMode = "inline";
  var _React$useContext = React.useContext(MenuContext), prefixCls = _React$useContext.prefixCls, forceSubMenuRender = _React$useContext.forceSubMenuRender, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions, mode = _React$useContext.mode;
  var sameModeRef = React.useRef(false);
  sameModeRef.current = mode === fixedMode;
  var _React$useState = React.useState(!sameModeRef.current), _React$useState2 = _slicedToArray$1(_React$useState, 2), destroy = _React$useState2[0], setDestroy = _React$useState2[1];
  var mergedOpen = sameModeRef.current ? open : false;
  React.useEffect(function() {
    if (sameModeRef.current) {
      setDestroy(false);
    }
  }, [mode]);
  var mergedMotion = _objectSpread2$d({}, getMotion(fixedMode, motion2, defaultMotions));
  if (keyPath.length > 1) {
    mergedMotion.motionAppear = false;
  }
  var originOnVisibleChanged = mergedMotion.onVisibleChanged;
  mergedMotion.onVisibleChanged = function(newVisible) {
    if (!sameModeRef.current && !newVisible) {
      setDestroy(true);
    }
    return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
  };
  if (destroy) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(InheritableContextProvider, {
    mode: fixedMode,
    locked: !sameModeRef.current
  }, /* @__PURE__ */ React.createElement(CSSMotion, _extends$3({
    visible: mergedOpen
  }, mergedMotion, {
    forceRender: forceSubMenuRender,
    removeOnLeave: false,
    leavedClassName: "".concat(prefixCls, "-hidden")
  }), function(_ref22) {
    var motionClassName = _ref22.className, motionStyle = _ref22.style;
    return /* @__PURE__ */ React.createElement(SubMenuList, {
      id,
      className: motionClassName,
      style: motionStyle
    }, children);
  }));
}
var _excluded$b = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"], _excluded2$3 = ["active"];
var InternalSubMenu2 = function InternalSubMenu3(props) {
  var _classNames;
  var style2 = props.style, className = props.className, title = props.title, eventKey = props.eventKey;
  props.warnKey;
  var disabled = props.disabled, internalPopupClose = props.internalPopupClose, children = props.children, itemIcon = props.itemIcon, expandIcon = props.expandIcon, popupClassName = props.popupClassName, popupOffset = props.popupOffset, onClick = props.onClick, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onTitleClick = props.onTitleClick, onTitleMouseEnter = props.onTitleMouseEnter, onTitleMouseLeave = props.onTitleMouseLeave, restProps = _objectWithoutProperties$1(props, _excluded$b);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = React.useContext(MenuContext), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, openKeys = _React$useContext.openKeys, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, activeKey = _React$useContext.activeKey, selectedKeys = _React$useContext.selectedKeys, contextItemIcon = _React$useContext.itemIcon, contextExpandIcon = _React$useContext.expandIcon, onItemClick = _React$useContext.onItemClick, onOpenChange = _React$useContext.onOpenChange, onActive = _React$useContext.onActive;
  var _React$useContext2 = React.useContext(PrivateContext), _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
  var _React$useContext3 = React.useContext(PathUserContext), isSubPathKey = _React$useContext3.isSubPathKey;
  var connectedPath = useFullPath();
  var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
  var mergedDisabled = contextDisabled || disabled;
  var elementRef = React.useRef();
  var popupRef = React.useRef();
  var mergedItemIcon = itemIcon || contextItemIcon;
  var mergedExpandIcon = expandIcon || contextExpandIcon;
  var originOpen = openKeys.includes(eventKey);
  var open = !overflowDisabled && originOpen;
  var childrenSelected = isSubPathKey(selectedKeys, eventKey);
  var _useActive = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties$1(_useActive, _excluded2$3);
  var _React$useState = React.useState(false), _React$useState2 = _slicedToArray$1(_React$useState, 2), childrenActive = _React$useState2[0], setChildrenActive = _React$useState2[1];
  var triggerChildrenActive = function triggerChildrenActive2(newActive) {
    if (!mergedDisabled) {
      setChildrenActive(newActive);
    }
  };
  var onInternalMouseEnter = function onInternalMouseEnter2(domEvent) {
    triggerChildrenActive(true);
    onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
      key: eventKey,
      domEvent
    });
  };
  var onInternalMouseLeave = function onInternalMouseLeave2(domEvent) {
    triggerChildrenActive(false);
    onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
      key: eventKey,
      domEvent
    });
  };
  var mergedActive = React.useMemo(function() {
    if (active) {
      return active;
    }
    if (mode !== "inline") {
      return childrenActive || isSubPathKey([activeKey], eventKey);
    }
    return false;
  }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
  var directionStyle = useDirectionStyle(connectedPath.length);
  var onInternalTitleClick = function onInternalTitleClick2(e2) {
    if (mergedDisabled) {
      return;
    }
    onTitleClick === null || onTitleClick === void 0 ? void 0 : onTitleClick({
      key: eventKey,
      domEvent: e2
    });
    if (mode === "inline") {
      onOpenChange(eventKey, !originOpen);
    }
  };
  var onMergedItemClick = useMemoCallback(function(info) {
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
    onItemClick(info);
  });
  var onPopupVisibleChange = function onPopupVisibleChange2(newVisible) {
    if (mode !== "inline") {
      onOpenChange(eventKey, newVisible);
    }
  };
  var onInternalFocus = function onInternalFocus2() {
    onActive(eventKey);
  };
  var popupId = domDataId && "".concat(domDataId, "-popup");
  var titleNode = /* @__PURE__ */ React.createElement("div", _extends$3({
    role: "menuitem",
    style: directionStyle,
    className: "".concat(subMenuPrefixCls, "-title"),
    tabIndex: mergedDisabled ? null : -1,
    ref: elementRef,
    title: typeof title === "string" ? title : null,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
    "aria-expanded": open,
    "aria-haspopup": true,
    "aria-controls": popupId,
    "aria-disabled": mergedDisabled,
    onClick: onInternalTitleClick,
    onFocus: onInternalFocus
  }, activeProps), title, /* @__PURE__ */ React.createElement(Icon$1, {
    icon: mode !== "horizontal" ? mergedExpandIcon : null,
    props: _objectSpread2$d(_objectSpread2$d({}, props), {}, {
      isOpen: open,
      isSubMenu: true
    })
  }, /* @__PURE__ */ React.createElement("i", {
    className: "".concat(subMenuPrefixCls, "-arrow")
  })));
  var triggerModeRef = React.useRef(mode);
  if (mode !== "inline" && connectedPath.length > 1) {
    triggerModeRef.current = "vertical";
  } else {
    triggerModeRef.current = mode;
  }
  if (!overflowDisabled) {
    var triggerMode = triggerModeRef.current;
    titleNode = /* @__PURE__ */ React.createElement(PopupTrigger, {
      mode: triggerMode,
      prefixCls: subMenuPrefixCls,
      visible: !internalPopupClose && open && mode !== "inline",
      popupClassName,
      popupOffset,
      popup: /* @__PURE__ */ React.createElement(
        InheritableContextProvider,
        {
          mode: triggerMode === "horizontal" ? "vertical" : triggerMode
        },
        /* @__PURE__ */ React.createElement(SubMenuList, {
          id: popupId,
          ref: popupRef
        }, children)
      ),
      disabled: mergedDisabled,
      onVisibleChange: onPopupVisibleChange
    }, titleNode);
  }
  var listNode = /* @__PURE__ */ React.createElement(ForwardOverflow.Item, _extends$3({
    role: "none"
  }, restProps, {
    component: "li",
    style: style2,
    className: classNames(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, (_classNames = {}, _defineProperty$3(_classNames, "".concat(subMenuPrefixCls, "-open"), open), _defineProperty$3(_classNames, "".concat(subMenuPrefixCls, "-active"), mergedActive), _defineProperty$3(_classNames, "".concat(subMenuPrefixCls, "-selected"), childrenSelected), _defineProperty$3(_classNames, "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled), _classNames)),
    onMouseEnter: onInternalMouseEnter,
    onMouseLeave: onInternalMouseLeave
  }), titleNode, !overflowDisabled && /* @__PURE__ */ React.createElement(InlineSubMenuList, {
    id: popupId,
    open,
    keyPath: connectedPath
  }, children));
  if (_internalRenderSubMenuItem) {
    listNode = _internalRenderSubMenuItem(listNode, props, {
      selected: childrenSelected,
      active: mergedActive,
      open,
      disabled: mergedDisabled
    });
  }
  return /* @__PURE__ */ React.createElement(InheritableContextProvider, {
    onItemClick: onMergedItemClick,
    mode: mode === "horizontal" ? "vertical" : mode,
    itemIcon: mergedItemIcon,
    expandIcon: mergedExpandIcon
  }, listNode);
};
function SubMenu(props) {
  var eventKey = props.eventKey, children = props.children;
  var connectedKeyPath = useFullPath(eventKey);
  var childList = parseChildren(children, connectedKeyPath);
  var measure = useMeasure();
  React.useEffect(function() {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function() {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  var renderNode;
  if (measure) {
    renderNode = childList;
  } else {
    renderNode = /* @__PURE__ */ React.createElement(InternalSubMenu2, props, childList);
  }
  return /* @__PURE__ */ React.createElement(PathTrackerContext.Provider, {
    value: connectedKeyPath
  }, renderNode);
}
var _excluded$a = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem"];
var EMPTY_LIST = [];
var Menu = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var _childList$, _classNames;
  var _ref2 = props, _ref$prefixCls = _ref2.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-menu" : _ref$prefixCls, rootClassName = _ref2.rootClassName, style2 = _ref2.style, className = _ref2.className, _ref$tabIndex = _ref2.tabIndex, tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, items = _ref2.items, children = _ref2.children, direction = _ref2.direction, id = _ref2.id, _ref$mode = _ref2.mode, mode = _ref$mode === void 0 ? "vertical" : _ref$mode, inlineCollapsed = _ref2.inlineCollapsed, disabled = _ref2.disabled, disabledOverflow = _ref2.disabledOverflow, _ref$subMenuOpenDelay = _ref2.subMenuOpenDelay, subMenuOpenDelay = _ref$subMenuOpenDelay === void 0 ? 0.1 : _ref$subMenuOpenDelay, _ref$subMenuCloseDela = _ref2.subMenuCloseDelay, subMenuCloseDelay = _ref$subMenuCloseDela === void 0 ? 0.1 : _ref$subMenuCloseDela, forceSubMenuRender = _ref2.forceSubMenuRender, defaultOpenKeys = _ref2.defaultOpenKeys, openKeys = _ref2.openKeys, activeKey = _ref2.activeKey, defaultActiveFirst = _ref2.defaultActiveFirst, _ref$selectable = _ref2.selectable, selectable = _ref$selectable === void 0 ? true : _ref$selectable, _ref$multiple = _ref2.multiple, multiple = _ref$multiple === void 0 ? false : _ref$multiple, defaultSelectedKeys = _ref2.defaultSelectedKeys, selectedKeys = _ref2.selectedKeys, onSelect = _ref2.onSelect, onDeselect = _ref2.onDeselect, _ref$inlineIndent = _ref2.inlineIndent, inlineIndent = _ref$inlineIndent === void 0 ? 24 : _ref$inlineIndent, motion2 = _ref2.motion, defaultMotions = _ref2.defaultMotions, _ref$triggerSubMenuAc = _ref2.triggerSubMenuAction, triggerSubMenuAction = _ref$triggerSubMenuAc === void 0 ? "hover" : _ref$triggerSubMenuAc, builtinPlacements = _ref2.builtinPlacements, itemIcon = _ref2.itemIcon, expandIcon = _ref2.expandIcon, _ref$overflowedIndica = _ref2.overflowedIndicator, overflowedIndicator = _ref$overflowedIndica === void 0 ? "..." : _ref$overflowedIndica, overflowedIndicatorPopupClassName = _ref2.overflowedIndicatorPopupClassName, getPopupContainer = _ref2.getPopupContainer, onClick = _ref2.onClick, onOpenChange = _ref2.onOpenChange, onKeyDown = _ref2.onKeyDown;
  _ref2.openAnimation;
  _ref2.openTransitionName;
  var _internalRenderMenuItem = _ref2._internalRenderMenuItem, _internalRenderSubMenuItem = _ref2._internalRenderSubMenuItem, restProps = _objectWithoutProperties$1(_ref2, _excluded$a);
  var childList = React.useMemo(function() {
    return parseItems(children, items, EMPTY_LIST);
  }, [children, items]);
  var _React$useState = React.useState(false), _React$useState2 = _slicedToArray$1(_React$useState, 2), mounted = _React$useState2[0], setMounted = _React$useState2[1];
  var containerRef = React.useRef();
  var uuid2 = useUUID(id);
  var isRtl = direction === "rtl";
  var _useMergedState = useMergedState$1(defaultOpenKeys, {
    value: openKeys,
    postState: function postState(keys2) {
      return keys2 || EMPTY_LIST;
    }
  }), _useMergedState2 = _slicedToArray$1(_useMergedState, 2), mergedOpenKeys = _useMergedState2[0], setMergedOpenKeys = _useMergedState2[1];
  var triggerOpenKeys = function triggerOpenKeys2(keys2) {
    var forceFlush = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    function doUpdate() {
      setMergedOpenKeys(keys2);
      onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(keys2);
    }
    if (forceFlush) {
      ReactDOM.flushSync(doUpdate);
    } else {
      doUpdate();
    }
  };
  var _React$useState3 = React.useState(mergedOpenKeys), _React$useState4 = _slicedToArray$1(_React$useState3, 2), inlineCacheOpenKeys = _React$useState4[0], setInlineCacheOpenKeys = _React$useState4[1];
  var mountRef = React.useRef(false);
  var _React$useMemo = React.useMemo(function() {
    if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
      return ["vertical", inlineCollapsed];
    }
    return [mode, false];
  }, [mode, inlineCollapsed]), _React$useMemo2 = _slicedToArray$1(_React$useMemo, 2), mergedMode = _React$useMemo2[0], mergedInlineCollapsed = _React$useMemo2[1];
  var isInlineMode = mergedMode === "inline";
  var _React$useState5 = React.useState(mergedMode), _React$useState6 = _slicedToArray$1(_React$useState5, 2), internalMode = _React$useState6[0], setInternalMode = _React$useState6[1];
  var _React$useState7 = React.useState(mergedInlineCollapsed), _React$useState8 = _slicedToArray$1(_React$useState7, 2), internalInlineCollapsed = _React$useState8[0], setInternalInlineCollapsed = _React$useState8[1];
  React.useEffect(function() {
    setInternalMode(mergedMode);
    setInternalInlineCollapsed(mergedInlineCollapsed);
    if (!mountRef.current) {
      return;
    }
    if (isInlineMode) {
      setMergedOpenKeys(inlineCacheOpenKeys);
    } else {
      triggerOpenKeys(EMPTY_LIST);
    }
  }, [mergedMode, mergedInlineCollapsed]);
  var _React$useState9 = React.useState(0), _React$useState10 = _slicedToArray$1(_React$useState9, 2), lastVisibleIndex = _React$useState10[0], setLastVisibleIndex = _React$useState10[1];
  var allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
  React.useEffect(function() {
    if (isInlineMode) {
      setInlineCacheOpenKeys(mergedOpenKeys);
    }
  }, [mergedOpenKeys]);
  React.useEffect(function() {
    mountRef.current = true;
    return function() {
      mountRef.current = false;
    };
  }, []);
  var _useKeyRecords = useKeyRecords(), registerPath = _useKeyRecords.registerPath, unregisterPath = _useKeyRecords.unregisterPath, refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys, isSubPathKey = _useKeyRecords.isSubPathKey, getKeyPath = _useKeyRecords.getKeyPath, getKeys = _useKeyRecords.getKeys, getSubPathKeys = _useKeyRecords.getSubPathKeys;
  var registerPathContext = React.useMemo(function() {
    return {
      registerPath,
      unregisterPath
    };
  }, [registerPath, unregisterPath]);
  var pathUserContext = React.useMemo(function() {
    return {
      isSubPathKey
    };
  }, [isSubPathKey]);
  React.useEffect(function() {
    refreshOverflowKeys(allVisible ? EMPTY_LIST : childList.slice(lastVisibleIndex + 1).map(function(child) {
      return child.key;
    }));
  }, [lastVisibleIndex, allVisible]);
  var _useMergedState3 = useMergedState$1(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
    value: activeKey
  }), _useMergedState4 = _slicedToArray$1(_useMergedState3, 2), mergedActiveKey = _useMergedState4[0], setMergedActiveKey = _useMergedState4[1];
  var onActive = useMemoCallback(function(key) {
    setMergedActiveKey(key);
  });
  var onInactive = useMemoCallback(function() {
    setMergedActiveKey(void 0);
  });
  React.useImperativeHandle(ref2, function() {
    return {
      list: containerRef.current,
      focus: function focus(options) {
        var _childList$find;
        var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : (_childList$find = childList.find(function(node2) {
          return !node2.props.disabled;
        })) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
        if (shouldFocusKey) {
          var _containerRef$current, _containerRef$current2, _containerRef$current3;
          (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.querySelector("li[data-menu-id='".concat(getMenuId(uuid2, shouldFocusKey), "']"))) === null || _containerRef$current2 === void 0 ? void 0 : (_containerRef$current3 = _containerRef$current2.focus) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.call(_containerRef$current2, options);
        }
      }
    };
  });
  var _useMergedState5 = useMergedState$1(defaultSelectedKeys || [], {
    value: selectedKeys,
    postState: function postState(keys2) {
      if (Array.isArray(keys2)) {
        return keys2;
      }
      if (keys2 === null || keys2 === void 0) {
        return EMPTY_LIST;
      }
      return [keys2];
    }
  }), _useMergedState6 = _slicedToArray$1(_useMergedState5, 2), mergedSelectKeys = _useMergedState6[0], setMergedSelectKeys = _useMergedState6[1];
  var triggerSelection = function triggerSelection2(info) {
    if (selectable) {
      var targetKey = info.key;
      var exist = mergedSelectKeys.includes(targetKey);
      var newSelectKeys;
      if (multiple) {
        if (exist) {
          newSelectKeys = mergedSelectKeys.filter(function(key) {
            return key !== targetKey;
          });
        } else {
          newSelectKeys = [].concat(_toConsumableArray(mergedSelectKeys), [targetKey]);
        }
      } else {
        newSelectKeys = [targetKey];
      }
      setMergedSelectKeys(newSelectKeys);
      var selectInfo = _objectSpread2$d(_objectSpread2$d({}, info), {}, {
        selectedKeys: newSelectKeys
      });
      if (exist) {
        onDeselect === null || onDeselect === void 0 ? void 0 : onDeselect(selectInfo);
      } else {
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectInfo);
      }
    }
    if (!multiple && mergedOpenKeys.length && internalMode !== "inline") {
      triggerOpenKeys(EMPTY_LIST);
    }
  };
  var onInternalClick = useMemoCallback(function(info) {
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
    triggerSelection(info);
  });
  var onInternalOpenChange = useMemoCallback(function(key, open) {
    var newOpenKeys = mergedOpenKeys.filter(function(k2) {
      return k2 !== key;
    });
    if (open) {
      newOpenKeys.push(key);
    } else if (internalMode !== "inline") {
      var subPathKeys = getSubPathKeys(key);
      newOpenKeys = newOpenKeys.filter(function(k2) {
        return !subPathKeys.has(k2);
      });
    }
    if (!isEqual$2(mergedOpenKeys, newOpenKeys, true)) {
      triggerOpenKeys(newOpenKeys, true);
    }
  });
  var getInternalPopupContainer = useMemoCallback(getPopupContainer);
  var triggerAccessibilityOpen = function triggerAccessibilityOpen2(key, open) {
    var nextOpen = open !== null && open !== void 0 ? open : !mergedOpenKeys.includes(key);
    onInternalOpenChange(key, nextOpen);
  };
  var onInternalKeyDown = useAccessibility(internalMode, mergedActiveKey, isRtl, uuid2, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown);
  React.useEffect(function() {
    setMounted(true);
  }, []);
  var privateContext = React.useMemo(function() {
    return {
      _internalRenderMenuItem,
      _internalRenderSubMenuItem
    };
  }, [_internalRenderMenuItem, _internalRenderSubMenuItem]);
  var wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : childList.map(function(child, index2) {
    return /* @__PURE__ */ React.createElement(InheritableContextProvider, {
      key: child.key,
      overflowDisabled: index2 > lastVisibleIndex
    }, child);
  });
  var container = /* @__PURE__ */ React.createElement(ForwardOverflow, _extends$3({
    id,
    ref: containerRef,
    prefixCls: "".concat(prefixCls, "-overflow"),
    component: "ul",
    itemComponent: MenuItem$1,
    className: classNames(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(internalMode), className, (_classNames = {}, _defineProperty$3(_classNames, "".concat(prefixCls, "-inline-collapsed"), internalInlineCollapsed), _defineProperty$3(_classNames, "".concat(prefixCls, "-rtl"), isRtl), _classNames), rootClassName),
    dir: direction,
    style: style2,
    role: "menu",
    tabIndex,
    data: wrappedChildList,
    renderRawItem: function renderRawItem(node2) {
      return node2;
    },
    renderRawRest: function renderRawRest(omitItems) {
      var len = omitItems.length;
      var originOmitItems = len ? childList.slice(-len) : null;
      return /* @__PURE__ */ React.createElement(SubMenu, {
        eventKey: OVERFLOW_KEY,
        title: overflowedIndicator,
        disabled: allVisible,
        internalPopupClose: len === 0,
        popupClassName: overflowedIndicatorPopupClassName
      }, originOmitItems);
    },
    maxCount: internalMode !== "horizontal" || disabledOverflow ? ForwardOverflow.INVALIDATE : ForwardOverflow.RESPONSIVE,
    ssr: "full",
    "data-menu-list": true,
    onVisibleChange: function onVisibleChange(newLastIndex) {
      setLastVisibleIndex(newLastIndex);
    },
    onKeyDown: onInternalKeyDown
  }, restProps));
  return /* @__PURE__ */ React.createElement(PrivateContext.Provider, {
    value: privateContext
  }, /* @__PURE__ */ React.createElement(IdContext.Provider, {
    value: uuid2
  }, /* @__PURE__ */ React.createElement(InheritableContextProvider, {
    prefixCls,
    rootClassName,
    mode: internalMode,
    openKeys: mergedOpenKeys,
    rtl: isRtl,
    disabled,
    motion: mounted ? motion2 : null,
    defaultMotions: mounted ? defaultMotions : null,
    activeKey: mergedActiveKey,
    onActive,
    onInactive,
    selectedKeys: mergedSelectKeys,
    inlineIndent,
    subMenuOpenDelay,
    subMenuCloseDelay,
    forceSubMenuRender,
    builtinPlacements,
    triggerSubMenuAction,
    getPopupContainer: getInternalPopupContainer,
    itemIcon,
    expandIcon,
    onItemClick: onInternalClick,
    onOpenChange: onInternalOpenChange
  }, /* @__PURE__ */ React.createElement(PathUserContext.Provider, {
    value: pathUserContext
  }, container), /* @__PURE__ */ React.createElement("div", {
    style: {
      display: "none"
    },
    "aria-hidden": true
  }, /* @__PURE__ */ React.createElement(PathRegisterContext.Provider, {
    value: registerPathContext
  }, childList)))));
});
var _excluded$9 = ["className", "title", "eventKey", "children"], _excluded2$2 = ["children"];
var InternalMenuItemGroup2 = function InternalMenuItemGroup3(_ref2) {
  var className = _ref2.className, title = _ref2.title;
  _ref2.eventKey;
  var children = _ref2.children, restProps = _objectWithoutProperties$1(_ref2, _excluded$9);
  var _React$useContext = React.useContext(MenuContext), prefixCls = _React$useContext.prefixCls;
  var groupPrefixCls = "".concat(prefixCls, "-item-group");
  return /* @__PURE__ */ React.createElement("li", _extends$3({
    role: "presentation"
  }, restProps, {
    onClick: function onClick(e2) {
      return e2.stopPropagation();
    },
    className: classNames(groupPrefixCls, className)
  }), /* @__PURE__ */ React.createElement("div", {
    role: "presentation",
    className: "".concat(groupPrefixCls, "-title"),
    title: typeof title === "string" ? title : void 0
  }, title), /* @__PURE__ */ React.createElement("ul", {
    role: "group",
    className: "".concat(groupPrefixCls, "-list")
  }, children));
};
function MenuItemGroup(_ref2) {
  var children = _ref2.children, props = _objectWithoutProperties$1(_ref2, _excluded2$2);
  var connectedKeyPath = useFullPath(props.eventKey);
  var childList = parseChildren(children, connectedKeyPath);
  var measure = useMeasure();
  if (measure) {
    return childList;
  }
  return /* @__PURE__ */ React.createElement(InternalMenuItemGroup2, omit$3(props, ["warnKey"]), childList);
}
function Divider$2(_ref2) {
  var className = _ref2.className, style2 = _ref2.style;
  var _React$useContext = React.useContext(MenuContext), prefixCls = _React$useContext.prefixCls;
  var measure = useMeasure();
  if (measure) {
    return null;
  }
  return /* @__PURE__ */ React.createElement("li", {
    className: classNames("".concat(prefixCls, "-item-divider"), className),
    style: style2
  });
}
var ExportMenu = Menu;
ExportMenu.Item = MenuItem$1;
ExportMenu.SubMenu = SubMenu;
ExportMenu.ItemGroup = MenuItemGroup;
ExportMenu.Divider = Divider$2;
function OperationNode(_ref2, ref2) {
  var prefixCls = _ref2.prefixCls, id = _ref2.id, tabs = _ref2.tabs, locale2 = _ref2.locale, mobile = _ref2.mobile, _ref$moreIcon = _ref2.moreIcon, moreIcon = _ref$moreIcon === void 0 ? "More" : _ref$moreIcon, moreTransitionName = _ref2.moreTransitionName, style2 = _ref2.style, className = _ref2.className, editable = _ref2.editable, tabBarGutter = _ref2.tabBarGutter, rtl = _ref2.rtl, removeAriaLabel = _ref2.removeAriaLabel, onTabClick = _ref2.onTabClick, getPopupContainer = _ref2.getPopupContainer, popupClassName = _ref2.popupClassName;
  var _useState = React.useState(false), _useState2 = _slicedToArray$1(_useState, 2), open = _useState2[0], setOpen = _useState2[1];
  var _useState3 = React.useState(null), _useState4 = _slicedToArray$1(_useState3, 2), selectedKey = _useState4[0], setSelectedKey = _useState4[1];
  var popupId = "".concat(id, "-more-popup");
  var dropdownPrefix = "".concat(prefixCls, "-dropdown");
  var selectedItemId = selectedKey !== null ? "".concat(popupId, "-").concat(selectedKey) : null;
  var dropdownAriaLabel = locale2 === null || locale2 === void 0 ? void 0 : locale2.dropdownAriaLabel;
  function onRemoveTab(event, key) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit("remove", {
      key,
      event
    });
  }
  var menu = /* @__PURE__ */ React.createElement(ExportMenu, {
    onClick: function onClick(_ref22) {
      var key = _ref22.key, domEvent = _ref22.domEvent;
      onTabClick(key, domEvent);
      setOpen(false);
    },
    prefixCls: "".concat(dropdownPrefix, "-menu"),
    id: popupId,
    tabIndex: -1,
    role: "listbox",
    "aria-activedescendant": selectedItemId,
    selectedKeys: [selectedKey],
    "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
  }, tabs.map(function(tab2) {
    var removable = editable && tab2.closable !== false && !tab2.disabled;
    return /* @__PURE__ */ React.createElement(MenuItem$1, {
      key: tab2.key,
      id: "".concat(popupId, "-").concat(tab2.key),
      role: "option",
      "aria-controls": id && "".concat(id, "-panel-").concat(tab2.key),
      disabled: tab2.disabled
    }, /* @__PURE__ */ React.createElement("span", null, tab2.label), removable && /* @__PURE__ */ React.createElement("button", {
      type: "button",
      "aria-label": removeAriaLabel || "remove",
      tabIndex: 0,
      className: "".concat(dropdownPrefix, "-menu-item-remove"),
      onClick: function onClick(e2) {
        e2.stopPropagation();
        onRemoveTab(e2, tab2.key);
      }
    }, tab2.closeIcon || editable.removeIcon || "\xD7"));
  }));
  function selectOffset(offset3) {
    var enabledTabs = tabs.filter(function(tab3) {
      return !tab3.disabled;
    });
    var selectedIndex = enabledTabs.findIndex(function(tab3) {
      return tab3.key === selectedKey;
    }) || 0;
    var len = enabledTabs.length;
    for (var i = 0; i < len; i += 1) {
      selectedIndex = (selectedIndex + offset3 + len) % len;
      var tab2 = enabledTabs[selectedIndex];
      if (!tab2.disabled) {
        setSelectedKey(tab2.key);
        return;
      }
    }
  }
  function onKeyDown(e2) {
    var which = e2.which;
    if (!open) {
      if ([KeyCode$1.DOWN, KeyCode$1.SPACE, KeyCode$1.ENTER].includes(which)) {
        setOpen(true);
        e2.preventDefault();
      }
      return;
    }
    switch (which) {
      case KeyCode$1.UP:
        selectOffset(-1);
        e2.preventDefault();
        break;
      case KeyCode$1.DOWN:
        selectOffset(1);
        e2.preventDefault();
        break;
      case KeyCode$1.ESC:
        setOpen(false);
        break;
      case KeyCode$1.SPACE:
      case KeyCode$1.ENTER:
        if (selectedKey !== null)
          onTabClick(selectedKey, e2);
        break;
    }
  }
  React.useEffect(function() {
    var ele = document.getElementById(selectedItemId);
    if (ele && ele.scrollIntoView) {
      ele.scrollIntoView(false);
    }
  }, [selectedKey]);
  React.useEffect(function() {
    if (!open) {
      setSelectedKey(null);
    }
  }, [open]);
  var moreStyle = _defineProperty$3({}, rtl ? "marginRight" : "marginLeft", tabBarGutter);
  if (!tabs.length) {
    moreStyle.visibility = "hidden";
    moreStyle.order = 1;
  }
  var overlayClassName = classNames(_defineProperty$3({}, "".concat(dropdownPrefix, "-rtl"), rtl));
  var moreNode = mobile ? null : /* @__PURE__ */ React.createElement(Dropdown$3, {
    prefixCls: dropdownPrefix,
    overlay: menu,
    trigger: ["hover"],
    visible: tabs.length ? open : false,
    transitionName: moreTransitionName,
    onVisibleChange: setOpen,
    overlayClassName: classNames(overlayClassName, popupClassName),
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    getPopupContainer
  }, /* @__PURE__ */ React.createElement("button", {
    type: "button",
    className: "".concat(prefixCls, "-nav-more"),
    style: moreStyle,
    tabIndex: -1,
    "aria-hidden": "true",
    "aria-haspopup": "listbox",
    "aria-controls": popupId,
    id: "".concat(id, "-more"),
    "aria-expanded": open,
    onKeyDown
  }, moreIcon));
  return /* @__PURE__ */ React.createElement("div", {
    className: classNames("".concat(prefixCls, "-nav-operations"), className),
    style: style2,
    ref: ref2
  }, moreNode, /* @__PURE__ */ React.createElement(AddButton$1, {
    prefixCls,
    locale: locale2,
    editable
  }));
}
var OperationNode$1 = /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef(OperationNode), function(_24, next2) {
  return next2.tabMoving;
});
function TabNode(_ref2) {
  var _classNames;
  var prefixCls = _ref2.prefixCls, id = _ref2.id, active = _ref2.active, _ref$tab = _ref2.tab, key = _ref$tab.key, label = _ref$tab.label, disabled = _ref$tab.disabled, closeIcon = _ref$tab.closeIcon, closable = _ref2.closable, renderWrapper = _ref2.renderWrapper, removeAriaLabel = _ref2.removeAriaLabel, editable = _ref2.editable, onClick = _ref2.onClick, onFocus = _ref2.onFocus, style2 = _ref2.style;
  var tabPrefix = "".concat(prefixCls, "-tab");
  var removable = editable && closable !== false && !disabled;
  function onInternalClick(e2) {
    if (disabled) {
      return;
    }
    onClick(e2);
  }
  function onRemoveTab(event) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit("remove", {
      key,
      event
    });
  }
  var node2 = /* @__PURE__ */ React.createElement("div", {
    key,
    "data-node-key": genDataNodeKey(key),
    className: classNames(tabPrefix, (_classNames = {}, _defineProperty$3(_classNames, "".concat(tabPrefix, "-with-remove"), removable), _defineProperty$3(_classNames, "".concat(tabPrefix, "-active"), active), _defineProperty$3(_classNames, "".concat(tabPrefix, "-disabled"), disabled), _classNames)),
    style: style2,
    onClick: onInternalClick
  }, /* @__PURE__ */ React.createElement("div", {
    role: "tab",
    "aria-selected": active,
    id: id && "".concat(id, "-tab-").concat(key),
    className: "".concat(tabPrefix, "-btn"),
    "aria-controls": id && "".concat(id, "-panel-").concat(key),
    "aria-disabled": disabled,
    tabIndex: disabled ? null : 0,
    onClick: function onClick2(e2) {
      e2.stopPropagation();
      onInternalClick(e2);
    },
    onKeyDown: function onKeyDown(e2) {
      if ([KeyCode$1.SPACE, KeyCode$1.ENTER].includes(e2.which)) {
        e2.preventDefault();
        onInternalClick(e2);
      }
    },
    onFocus
  }, label), removable && /* @__PURE__ */ React.createElement("button", {
    type: "button",
    "aria-label": removeAriaLabel || "remove",
    tabIndex: 0,
    className: "".concat(tabPrefix, "-remove"),
    onClick: function onClick2(e2) {
      e2.stopPropagation();
      onRemoveTab(e2);
    }
  }, closeIcon || editable.removeIcon || "\xD7"));
  return renderWrapper ? renderWrapper(node2) : node2;
}
var getSize = function getSize2(refObj) {
  var _ref2 = refObj.current || {}, _ref$offsetWidth = _ref2.offsetWidth, offsetWidth = _ref$offsetWidth === void 0 ? 0 : _ref$offsetWidth, _ref$offsetHeight = _ref2.offsetHeight, offsetHeight = _ref$offsetHeight === void 0 ? 0 : _ref$offsetHeight;
  return [offsetWidth, offsetHeight];
};
var getUnitValue = function getUnitValue2(size, tabPositionTopOrBottom) {
  return size[tabPositionTopOrBottom ? 0 : 1];
};
function TabNavList(props, ref2) {
  var _classNames;
  var _React$useContext = React.useContext(TabContext), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
  var className = props.className, style2 = props.style, id = props.id, animated = props.animated, activeKey = props.activeKey, rtl = props.rtl, extra = props.extra, editable = props.editable, locale2 = props.locale, tabPosition = props.tabPosition, tabBarGutter = props.tabBarGutter, children = props.children, onTabClick = props.onTabClick, onTabScroll = props.onTabScroll;
  var containerRef = React.useRef();
  var extraLeftRef = React.useRef();
  var extraRightRef = React.useRef();
  var tabsWrapperRef = React.useRef();
  var tabListRef = React.useRef();
  var operationsRef = React.useRef();
  var innerAddButtonRef = React.useRef();
  var tabPositionTopOrBottom = tabPosition === "top" || tabPosition === "bottom";
  var _useSyncState = useSyncState(0, function(next2, prev2) {
    if (tabPositionTopOrBottom && onTabScroll) {
      onTabScroll({
        direction: next2 > prev2 ? "left" : "right"
      });
    }
  }), _useSyncState2 = _slicedToArray$1(_useSyncState, 2), transformLeft = _useSyncState2[0], setTransformLeft = _useSyncState2[1];
  var _useSyncState3 = useSyncState(0, function(next2, prev2) {
    if (!tabPositionTopOrBottom && onTabScroll) {
      onTabScroll({
        direction: next2 > prev2 ? "top" : "bottom"
      });
    }
  }), _useSyncState4 = _slicedToArray$1(_useSyncState3, 2), transformTop = _useSyncState4[0], setTransformTop = _useSyncState4[1];
  var _useState = React.useState([0, 0]), _useState2 = _slicedToArray$1(_useState, 2), containerExcludeExtraSize = _useState2[0], setContainerExcludeExtraSize = _useState2[1];
  var _useState3 = React.useState([0, 0]), _useState4 = _slicedToArray$1(_useState3, 2), tabContentSize = _useState4[0], setTabContentSize = _useState4[1];
  var _useState5 = React.useState([0, 0]), _useState6 = _slicedToArray$1(_useState5, 2), addSize = _useState6[0], setAddSize = _useState6[1];
  var _useState7 = React.useState([0, 0]), _useState8 = _slicedToArray$1(_useState7, 2), operationSize = _useState8[0], setOperationSize = _useState8[1];
  var _useUpdateState = useUpdateState(/* @__PURE__ */ new Map()), _useUpdateState2 = _slicedToArray$1(_useUpdateState, 2), tabSizes = _useUpdateState2[0], setTabSizes = _useUpdateState2[1];
  var tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);
  var containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);
  var tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
  var addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
  var operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
  var needScroll = containerExcludeExtraSizeValue < tabContentSizeValue + addSizeValue;
  var visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;
  var operationsHiddenClassName = "".concat(prefixCls, "-nav-operations-hidden");
  var transformMin = 0;
  var transformMax = 0;
  if (!tabPositionTopOrBottom) {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  } else if (rtl) {
    transformMin = 0;
    transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
  } else {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  }
  function alignInRange(value) {
    if (value < transformMin) {
      return transformMin;
    }
    if (value > transformMax) {
      return transformMax;
    }
    return value;
  }
  var touchMovingRef = React.useRef();
  var _useState9 = React.useState(), _useState10 = _slicedToArray$1(_useState9, 2), lockAnimation = _useState10[0], setLockAnimation = _useState10[1];
  function doLockAnimation() {
    setLockAnimation(Date.now());
  }
  function clearTouchMoving() {
    window.clearTimeout(touchMovingRef.current);
  }
  useTouchMove(tabsWrapperRef, function(offsetX, offsetY) {
    function doMove(setState, offset3) {
      setState(function(value) {
        var newValue = alignInRange(value + offset3);
        return newValue;
      });
    }
    if (!needScroll) {
      return false;
    }
    if (tabPositionTopOrBottom) {
      doMove(setTransformLeft, offsetX);
    } else {
      doMove(setTransformTop, offsetY);
    }
    clearTouchMoving();
    doLockAnimation();
    return true;
  });
  React.useEffect(function() {
    clearTouchMoving();
    if (lockAnimation) {
      touchMovingRef.current = window.setTimeout(function() {
        setLockAnimation(0);
      }, 100);
    }
    return clearTouchMoving;
  }, [lockAnimation]);
  var _useVisibleRange = useVisibleRange(
    tabOffsets,
    visibleTabContentValue,
    tabPositionTopOrBottom ? transformLeft : transformTop,
    tabContentSizeValue,
    addSizeValue,
    operationSizeValue,
    _objectSpread2$d(_objectSpread2$d({}, props), {}, {
      tabs
    })
  ), _useVisibleRange2 = _slicedToArray$1(_useVisibleRange, 2), visibleStart = _useVisibleRange2[0], visibleEnd = _useVisibleRange2[1];
  var scrollToTab = useEvent$2(function() {
    var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : activeKey;
    var tabOffset = tabOffsets.get(key) || {
      width: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0
    };
    if (tabPositionTopOrBottom) {
      var newTransform = transformLeft;
      if (rtl) {
        if (tabOffset.right < transformLeft) {
          newTransform = tabOffset.right;
        } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {
          newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
        }
      } else if (tabOffset.left < -transformLeft) {
        newTransform = -tabOffset.left;
      } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {
        newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
      }
      setTransformTop(0);
      setTransformLeft(alignInRange(newTransform));
    } else {
      var _newTransform = transformTop;
      if (tabOffset.top < -transformTop) {
        _newTransform = -tabOffset.top;
      } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {
        _newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
      }
      setTransformLeft(0);
      setTransformTop(alignInRange(_newTransform));
    }
  });
  var tabNodeStyle = {};
  if (tabPosition === "top" || tabPosition === "bottom") {
    tabNodeStyle[rtl ? "marginRight" : "marginLeft"] = tabBarGutter;
  } else {
    tabNodeStyle.marginTop = tabBarGutter;
  }
  var tabNodes = tabs.map(function(tab2, i) {
    var key = tab2.key;
    return /* @__PURE__ */ React.createElement(TabNode, {
      id,
      prefixCls,
      key,
      tab: tab2,
      style: i === 0 ? void 0 : tabNodeStyle,
      closable: tab2.closable,
      editable,
      active: key === activeKey,
      renderWrapper: children,
      removeAriaLabel: locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
      onClick: function onClick(e2) {
        onTabClick(key, e2);
      },
      onFocus: function onFocus() {
        scrollToTab(key);
        doLockAnimation();
        if (!tabsWrapperRef.current) {
          return;
        }
        if (!rtl) {
          tabsWrapperRef.current.scrollLeft = 0;
        }
        tabsWrapperRef.current.scrollTop = 0;
      }
    });
  });
  var updateTabSizes = function updateTabSizes2() {
    return setTabSizes(function() {
      var newSizes = /* @__PURE__ */ new Map();
      tabs.forEach(function(_ref2) {
        var _tabListRef$current;
        var key = _ref2.key;
        var btnNode = (_tabListRef$current = tabListRef.current) === null || _tabListRef$current === void 0 ? void 0 : _tabListRef$current.querySelector('[data-node-key="'.concat(genDataNodeKey(key), '"]'));
        if (btnNode) {
          newSizes.set(key, {
            width: btnNode.offsetWidth,
            height: btnNode.offsetHeight,
            left: btnNode.offsetLeft,
            top: btnNode.offsetTop
          });
        }
      });
      return newSizes;
    });
  };
  React.useEffect(function() {
    updateTabSizes();
  }, [tabs.map(function(tab2) {
    return tab2.key;
  }).join("_")]);
  var onListHolderResize = useUpdate(function() {
    var containerSize = getSize(containerRef);
    var extraLeftSize = getSize(extraLeftRef);
    var extraRightSize = getSize(extraRightRef);
    setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
    var newAddSize = getSize(innerAddButtonRef);
    setAddSize(newAddSize);
    var newOperationSize = getSize(operationsRef);
    setOperationSize(newOperationSize);
    var tabContentFullSize = getSize(tabListRef);
    setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);
    updateTabSizes();
  });
  var startHiddenTabs = tabs.slice(0, visibleStart);
  var endHiddenTabs = tabs.slice(visibleEnd + 1);
  var hiddenTabs = [].concat(_toConsumableArray(startHiddenTabs), _toConsumableArray(endHiddenTabs));
  var _useState11 = React.useState(), _useState12 = _slicedToArray$1(_useState11, 2), inkStyle = _useState12[0], setInkStyle = _useState12[1];
  var activeTabOffset = tabOffsets.get(activeKey);
  var inkBarRafRef = React.useRef();
  function cleanInkBarRaf() {
    wrapperRaf$2.cancel(inkBarRafRef.current);
  }
  React.useEffect(function() {
    var newInkStyle = {};
    if (activeTabOffset) {
      if (tabPositionTopOrBottom) {
        if (rtl) {
          newInkStyle.right = activeTabOffset.right;
        } else {
          newInkStyle.left = activeTabOffset.left;
        }
        newInkStyle.width = activeTabOffset.width;
      } else {
        newInkStyle.top = activeTabOffset.top;
        newInkStyle.height = activeTabOffset.height;
      }
    }
    cleanInkBarRaf();
    inkBarRafRef.current = wrapperRaf$2(function() {
      setInkStyle(newInkStyle);
    });
    return cleanInkBarRaf;
  }, [activeTabOffset, tabPositionTopOrBottom, rtl]);
  React.useEffect(function() {
    scrollToTab();
  }, [activeKey, transformMin, transformMax, stringify(activeTabOffset), stringify(tabOffsets), tabPositionTopOrBottom]);
  React.useEffect(function() {
    onListHolderResize();
  }, [rtl]);
  var hasDropdown = !!hiddenTabs.length;
  var wrapPrefix = "".concat(prefixCls, "-nav-wrap");
  var pingLeft;
  var pingRight;
  var pingTop;
  var pingBottom;
  if (tabPositionTopOrBottom) {
    if (rtl) {
      pingRight = transformLeft > 0;
      pingLeft = transformLeft !== transformMax;
    } else {
      pingLeft = transformLeft < 0;
      pingRight = transformLeft !== transformMin;
    }
  } else {
    pingTop = transformTop < 0;
    pingBottom = transformTop !== transformMin;
  }
  return /* @__PURE__ */ React.createElement(ResizeObserver$2, {
    onResize: onListHolderResize
  }, /* @__PURE__ */ React.createElement("div", {
    ref: useComposeRef$1(ref2, containerRef),
    role: "tablist",
    className: classNames("".concat(prefixCls, "-nav"), className),
    style: style2,
    onKeyDown: function onKeyDown() {
      doLockAnimation();
    }
  }, /* @__PURE__ */ React.createElement(ExtraContent, {
    ref: extraLeftRef,
    position: "left",
    extra,
    prefixCls
  }), /* @__PURE__ */ React.createElement("div", {
    className: classNames(wrapPrefix, (_classNames = {}, _defineProperty$3(_classNames, "".concat(wrapPrefix, "-ping-left"), pingLeft), _defineProperty$3(_classNames, "".concat(wrapPrefix, "-ping-right"), pingRight), _defineProperty$3(_classNames, "".concat(wrapPrefix, "-ping-top"), pingTop), _defineProperty$3(_classNames, "".concat(wrapPrefix, "-ping-bottom"), pingBottom), _classNames)),
    ref: tabsWrapperRef
  }, /* @__PURE__ */ React.createElement(ResizeObserver$2, {
    onResize: onListHolderResize
  }, /* @__PURE__ */ React.createElement("div", {
    ref: tabListRef,
    className: "".concat(prefixCls, "-nav-list"),
    style: {
      transform: "translate(".concat(transformLeft, "px, ").concat(transformTop, "px)"),
      transition: lockAnimation ? "none" : void 0
    }
  }, tabNodes, /* @__PURE__ */ React.createElement(AddButton$1, {
    ref: innerAddButtonRef,
    prefixCls,
    locale: locale2,
    editable,
    style: _objectSpread2$d(_objectSpread2$d({}, tabNodes.length === 0 ? void 0 : tabNodeStyle), {}, {
      visibility: hasDropdown ? "hidden" : null
    })
  }), /* @__PURE__ */ React.createElement("div", {
    className: classNames("".concat(prefixCls, "-ink-bar"), _defineProperty$3({}, "".concat(prefixCls, "-ink-bar-animated"), animated.inkBar)),
    style: inkStyle
  })))), /* @__PURE__ */ React.createElement(OperationNode$1, _extends$3({}, props, {
    removeAriaLabel: locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
    ref: operationsRef,
    prefixCls,
    tabs: hiddenTabs,
    className: !hasDropdown && operationsHiddenClassName,
    tabMoving: !!lockAnimation
  })), /* @__PURE__ */ React.createElement(ExtraContent, {
    ref: extraRightRef,
    position: "right",
    extra,
    prefixCls
  })));
}
var TabNavList$1 = /* @__PURE__ */ React.forwardRef(TabNavList);
var _excluded$8 = ["renderTabBar"], _excluded2$1 = ["label", "key"];
function TabNavListWrapper(_ref2) {
  var renderTabBar = _ref2.renderTabBar, restProps = _objectWithoutProperties$1(_ref2, _excluded$8);
  var _React$useContext = React.useContext(TabContext), tabs = _React$useContext.tabs;
  if (renderTabBar) {
    var tabNavBarProps = _objectSpread2$d(_objectSpread2$d({}, restProps), {}, {
      panes: tabs.map(function(_ref22) {
        var label = _ref22.label, key = _ref22.key, restTabProps = _objectWithoutProperties$1(_ref22, _excluded2$1);
        return /* @__PURE__ */ React.createElement(TabPane$3, _extends$3({
          tab: label,
          key,
          tabKey: key
        }, restTabProps));
      })
    });
    return renderTabBar(tabNavBarProps, TabNavList$1);
  }
  return /* @__PURE__ */ React.createElement(TabNavList$1, restProps);
}
function useAnimateConfig$1() {
  var animated = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    inkBar: true,
    tabPane: false
  };
  var mergedAnimated;
  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: false
    };
  } else {
    mergedAnimated = _objectSpread2$d({
      inkBar: true
    }, _typeof$8(animated) === "object" ? animated : {});
  }
  if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === void 0) {
    mergedAnimated.tabPane = true;
  }
  if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {
    mergedAnimated.tabPane = false;
  }
  return mergedAnimated;
}
var _excluded$7 = ["id", "prefixCls", "className", "items", "direction", "activeKey", "defaultActiveKey", "editable", "animated", "tabPosition", "tabBarGutter", "tabBarStyle", "tabBarExtraContent", "locale", "moreIcon", "moreTransitionName", "destroyInactiveTabPane", "renderTabBar", "onChange", "onTabClick", "onTabScroll", "getPopupContainer", "popupClassName"];
var uuid$2 = 0;
function Tabs$1(_ref2, ref2) {
  var _classNames;
  var id = _ref2.id, _ref$prefixCls = _ref2.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-tabs" : _ref$prefixCls, className = _ref2.className, items = _ref2.items, direction = _ref2.direction, activeKey = _ref2.activeKey, defaultActiveKey = _ref2.defaultActiveKey, editable = _ref2.editable, animated = _ref2.animated, _ref$tabPosition = _ref2.tabPosition, tabPosition = _ref$tabPosition === void 0 ? "top" : _ref$tabPosition, tabBarGutter = _ref2.tabBarGutter, tabBarStyle = _ref2.tabBarStyle, tabBarExtraContent = _ref2.tabBarExtraContent, locale2 = _ref2.locale, moreIcon = _ref2.moreIcon, moreTransitionName = _ref2.moreTransitionName, destroyInactiveTabPane = _ref2.destroyInactiveTabPane, renderTabBar = _ref2.renderTabBar, onChange = _ref2.onChange, onTabClick = _ref2.onTabClick, onTabScroll = _ref2.onTabScroll, getPopupContainer = _ref2.getPopupContainer, popupClassName = _ref2.popupClassName, restProps = _objectWithoutProperties$1(_ref2, _excluded$7);
  var tabs = React.useMemo(function() {
    return (items || []).filter(function(item) {
      return item && _typeof$8(item) === "object" && "key" in item;
    });
  }, [items]);
  var rtl = direction === "rtl";
  var mergedAnimated = useAnimateConfig$1(animated);
  var _useState = React.useState(false), _useState2 = _slicedToArray$1(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
  React.useEffect(function() {
    setMobile(isMobile());
  }, []);
  var _useMergedState = useMergedState$1(function() {
    var _tabs$;
    return (_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key;
  }, {
    value: activeKey,
    defaultValue: defaultActiveKey
  }), _useMergedState2 = _slicedToArray$1(_useMergedState, 2), mergedActiveKey = _useMergedState2[0], setMergedActiveKey = _useMergedState2[1];
  var _useState3 = React.useState(function() {
    return tabs.findIndex(function(tab2) {
      return tab2.key === mergedActiveKey;
    });
  }), _useState4 = _slicedToArray$1(_useState3, 2), activeIndex = _useState4[0], setActiveIndex = _useState4[1];
  React.useEffect(function() {
    var newActiveIndex = tabs.findIndex(function(tab2) {
      return tab2.key === mergedActiveKey;
    });
    if (newActiveIndex === -1) {
      var _tabs$newActiveIndex;
      newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
      setMergedActiveKey((_tabs$newActiveIndex = tabs[newActiveIndex]) === null || _tabs$newActiveIndex === void 0 ? void 0 : _tabs$newActiveIndex.key);
    }
    setActiveIndex(newActiveIndex);
  }, [tabs.map(function(tab2) {
    return tab2.key;
  }).join("_"), mergedActiveKey, activeIndex]);
  var _useMergedState3 = useMergedState$1(null, {
    value: id
  }), _useMergedState4 = _slicedToArray$1(_useMergedState3, 2), mergedId = _useMergedState4[0], setMergedId = _useMergedState4[1];
  React.useEffect(function() {
    if (!id) {
      setMergedId("rc-tabs-".concat(uuid$2));
      uuid$2 += 1;
    }
  }, []);
  function onInternalTabClick(key, e2) {
    onTabClick === null || onTabClick === void 0 ? void 0 : onTabClick(key, e2);
    var isActiveChanged = key !== mergedActiveKey;
    setMergedActiveKey(key);
    if (isActiveChanged) {
      onChange === null || onChange === void 0 ? void 0 : onChange(key);
    }
  }
  var sharedProps = {
    id: mergedId,
    activeKey: mergedActiveKey,
    animated: mergedAnimated,
    tabPosition,
    rtl,
    mobile
  };
  var tabNavBar;
  var tabNavBarProps = _objectSpread2$d(_objectSpread2$d({}, sharedProps), {}, {
    editable,
    locale: locale2,
    moreIcon,
    moreTransitionName,
    tabBarGutter,
    onTabClick: onInternalTabClick,
    onTabScroll,
    extra: tabBarExtraContent,
    style: tabBarStyle,
    panes: null,
    getPopupContainer,
    popupClassName
  });
  return /* @__PURE__ */ React.createElement(TabContext.Provider, {
    value: {
      tabs,
      prefixCls
    }
  }, /* @__PURE__ */ React.createElement("div", _extends$3({
    ref: ref2,
    id,
    className: classNames(prefixCls, "".concat(prefixCls, "-").concat(tabPosition), (_classNames = {}, _defineProperty$3(_classNames, "".concat(prefixCls, "-mobile"), mobile), _defineProperty$3(_classNames, "".concat(prefixCls, "-editable"), editable), _defineProperty$3(_classNames, "".concat(prefixCls, "-rtl"), rtl), _classNames), className)
  }, restProps), tabNavBar, /* @__PURE__ */ React.createElement(TabNavListWrapper, _extends$3({}, tabNavBarProps, {
    renderTabBar
  })), /* @__PURE__ */ React.createElement(TabPanelList, _extends$3({
    destroyInactiveTabPane
  }, sharedProps, {
    animated: mergedAnimated
  }))));
}
var ForwardTabs = /* @__PURE__ */ React.forwardRef(Tabs$1);
const motion = {
  motionAppear: false,
  motionEnter: true,
  motionLeave: true
};
function useAnimateConfig(prefixCls) {
  let animated = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inkBar: true,
    tabPane: false
  };
  let mergedAnimated;
  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: true
    };
  } else {
    mergedAnimated = Object.assign({
      inkBar: true
    }, typeof animated === "object" ? animated : {});
  }
  if (mergedAnimated.tabPane) {
    mergedAnimated.tabPaneMotion = Object.assign(Object.assign({}, motion), {
      motionName: getTransitionName$1(prefixCls, "switch")
    });
  }
  return mergedAnimated;
}
var __rest$l = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function filter(items) {
  return items.filter((item) => item);
}
function useLegacyItems(items, children) {
  if (items) {
    return items;
  }
  const childrenItems = toArray$9(children).map((node2) => {
    if (/* @__PURE__ */ React.isValidElement(node2)) {
      const {
        key,
        props
      } = node2;
      const _a2 = props || {}, {
        tab: tab2
      } = _a2, restProps = __rest$l(_a2, ["tab"]);
      const item = Object.assign(Object.assign({
        key: String(key)
      }, restProps), {
        label: tab2
      });
      return item;
    }
    return null;
  });
  return filter(childrenItems);
}
const TabPane$1 = () => null;
var TabPane$2 = TabPane$1;
const genMotionStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow
  } = token2;
  return [
    {
      [componentCls]: {
        [`${componentCls}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${motionDurationSlow}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${motionDurationSlow}`
            }
          }
        }
      }
    },
    [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down")]
  ];
};
var genMotionStyle$1 = genMotionStyle;
const genCardStyle$1 = (token2) => {
  const {
    componentCls,
    tabsCardHorizontalPadding,
    tabsCardHeadBackground,
    tabsCardGutter,
    colorBorderSecondary
  } = token2;
  return {
    [`${componentCls}-card`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: 0,
          padding: tabsCardHorizontalPadding,
          background: tabsCardHeadBackground,
          border: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
        },
        [`${componentCls}-tab-active`]: {
          color: token2.colorPrimary,
          background: token2.colorBgContainer
        },
        [`${componentCls}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginLeft: {
              _skip_check_: true,
              value: `${tabsCardGutter}px`
            }
          }
        }
      },
      [`&${componentCls}-top`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`
          },
          [`${componentCls}-tab-active`]: {
            borderBottomColor: token2.colorBgContainer
          }
        }
      },
      [`&${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`
          },
          [`${componentCls}-tab-active`]: {
            borderTopColor: token2.colorBgContainer
          }
        }
      },
      [`&${componentCls}-left, &${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginTop: `${tabsCardGutter}px`
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${token2.borderRadiusLG}px 0 0 ${token2.borderRadiusLG}px`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderRightColor: {
              _skip_check_: true,
              value: token2.colorBgContainer
            }
          }
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: true,
              value: token2.colorBgContainer
            }
          }
        }
      }
    }
  };
};
const genDropdownStyle = (token2) => {
  const {
    componentCls,
    tabsHoverColor,
    dropdownEdgeChildVerticalPadding
  } = token2;
  return {
    [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: true,
        value: -9999
      },
      zIndex: token2.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${componentCls}-dropdown-menu`]: {
        maxHeight: token2.tabsDropdownHeight,
        margin: 0,
        padding: `${dropdownEdgeChildVerticalPadding}px 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: true,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: token2.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: token2.borderRadiusLG,
        outline: "none",
        boxShadow: token2.boxShadowSecondary,
        "&-item": Object.assign(Object.assign({}, textEllipsis), {
          display: "flex",
          alignItems: "center",
          minWidth: token2.tabsDropdownWidth,
          margin: 0,
          padding: `${token2.paddingXXS}px ${token2.paddingSM}px`,
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight,
          cursor: "pointer",
          transition: `all ${token2.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: true,
              value: token2.marginSM
            },
            color: token2.colorTextDescription,
            fontSize: token2.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: tabsHoverColor
            }
          },
          "&:hover": {
            background: token2.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: token2.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        })
      }
    })
  };
};
const genPositionStyle = (token2) => {
  const {
    componentCls,
    margin,
    colorBorderSecondary
  } = token2;
  return {
    [`${componentCls}-top, ${componentCls}-bottom`]: {
      flexDirection: "column",
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        margin: `0 0 ${margin}px 0`,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: true,
            value: 0
          },
          left: {
            _skip_check_: true,
            value: 0
          },
          borderBottom: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
          content: "''"
        },
        [`${componentCls}-ink-bar`]: {
          height: token2.lineWidthBold,
          "&-animated": {
            transition: `width ${token2.motionDurationSlow}, left ${token2.motionDurationSlow},
            right ${token2.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: token2.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token2.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token2.boxShadowTabsOverflowRight
          },
          [`&${componentCls}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${componentCls}-top`]: {
      [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${componentCls}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${componentCls}-bottom`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        marginTop: `${margin}px`,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${componentCls}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0
      }
    },
    [`${componentCls}-left, ${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        flexDirection: "column",
        minWidth: token2.controlHeight * 1.25,
        [`${componentCls}-tab`]: {
          padding: `${token2.paddingXS}px ${token2.paddingLG}px`,
          textAlign: "center"
        },
        [`${componentCls}-tab + ${componentCls}-tab`]: {
          margin: `${token2.margin}px 0 0 0`
        },
        [`${componentCls}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token2.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: token2.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: token2.boxShadowTabsOverflowBottom
          },
          [`&${componentCls}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        [`${componentCls}-ink-bar`]: {
          width: token2.lineWidthBold,
          "&-animated": {
            transition: `height ${token2.motionDurationSlow}, top ${token2.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
          flex: "1 0 auto",
          flexDirection: "column"
        }
      }
    },
    [`${componentCls}-left`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-ink-bar`]: {
          right: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        marginLeft: {
          _skip_check_: true,
          value: `-${token2.lineWidth}px`
        },
        borderLeft: {
          _skip_check_: true,
          value: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingLeft: {
            _skip_check_: true,
            value: token2.paddingLG
          }
        }
      }
    },
    [`${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        [`${componentCls}-ink-bar`]: {
          left: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: true,
          value: -token2.lineWidth
        },
        borderRight: {
          _skip_check_: true,
          value: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingRight: {
            _skip_check_: true,
            value: token2.paddingLG
          }
        }
      }
    }
  };
};
const genSizeStyle = (token2) => {
  const {
    componentCls,
    padding
  } = token2;
  return {
    [componentCls]: {
      "&-small": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${token2.paddingXS}px 0`,
            fontSize: token2.fontSize
          }
        }
      },
      "&-large": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${padding}px 0`,
            fontSize: token2.fontSizeLG
          }
        }
      }
    },
    [`${componentCls}-card`]: {
      [`&${componentCls}-small`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${token2.paddingXXS * 1.5}px ${padding}px`
          }
        },
        [`&${componentCls}-bottom`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `0 0 ${token2.borderRadius}px ${token2.borderRadius}px`
          }
        },
        [`&${componentCls}-top`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `${token2.borderRadius}px ${token2.borderRadius}px 0 0`
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${token2.borderRadius}px ${token2.borderRadius}px 0`
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${token2.borderRadius}px 0 0 ${token2.borderRadius}px`
            }
          }
        }
      },
      [`&${componentCls}-large`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${token2.paddingXS}px ${padding}px ${token2.paddingXXS * 1.5}px`
          }
        }
      }
    }
  };
};
const genTabStyle = (token2) => {
  const {
    componentCls,
    tabsActiveColor,
    tabsHoverColor,
    iconCls,
    tabsHorizontalGutter
  } = token2;
  const tabCls = `${componentCls}-tab`;
  return {
    [tabCls]: {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      padding: `${token2.paddingSM}px 0`,
      fontSize: `${token2.fontSize}px`,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      "&-btn, &-remove": Object.assign({
        "&:focus:not(:focus-visible), &:active": {
          color: tabsActiveColor
        }
      }, genFocusStyle(token2)),
      "&-btn": {
        outline: "none",
        transition: "all 0.3s"
      },
      "&-remove": {
        flex: "none",
        marginRight: {
          _skip_check_: true,
          value: -token2.marginXXS
        },
        marginLeft: {
          _skip_check_: true,
          value: token2.marginXS
        },
        color: token2.colorTextDescription,
        fontSize: token2.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${token2.motionDurationSlow}`,
        "&:hover": {
          color: token2.colorTextHeading
        }
      },
      "&:hover": {
        color: tabsHoverColor
      },
      [`&${tabCls}-active ${tabCls}-btn`]: {
        color: token2.colorPrimary,
        textShadow: token2.tabsActiveTextShadow
      },
      [`&${tabCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
        "&:focus, &:active": {
          color: token2.colorTextDisabled
        }
      },
      [`& ${tabCls}-remove ${iconCls}`]: {
        margin: 0
      },
      [iconCls]: {
        marginRight: {
          _skip_check_: true,
          value: token2.marginSM
        }
      }
    },
    [`${tabCls} + ${tabCls}`]: {
      margin: {
        _skip_check_: true,
        value: `0 0 0 ${tabsHorizontalGutter}px`
      }
    }
  };
};
const genRtlStyle = (token2) => {
  const {
    componentCls,
    tabsHorizontalGutter,
    iconCls,
    tabsCardGutter
  } = token2;
  const rtlCls = `${componentCls}-rtl`;
  return {
    [rtlCls]: {
      direction: "rtl",
      [`${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: {
            _skip_check_: true,
            value: `0 0 0 ${tabsHorizontalGutter}px`
          },
          [`${componentCls}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          },
          [iconCls]: {
            marginRight: {
              _skip_check_: true,
              value: 0
            },
            marginLeft: {
              _skip_check_: true,
              value: `${token2.marginSM}px`
            }
          },
          [`${componentCls}-tab-remove`]: {
            marginRight: {
              _skip_check_: true,
              value: `${token2.marginXS}px`
            },
            marginLeft: {
              _skip_check_: true,
              value: `-${token2.marginXXS}px`
            },
            [iconCls]: {
              margin: 0
            }
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav`]: {
          order: 1
        },
        [`> ${componentCls}-content-holder`]: {
          order: 0
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav`]: {
          order: 0
        },
        [`> ${componentCls}-content-holder`]: {
          order: 1
        }
      },
      [`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginRight: {
              _skip_check_: true,
              value: `${tabsCardGutter}px`
            },
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          }
        }
      }
    },
    [`${componentCls}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-menu-item`]: {
      [`${componentCls}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: true,
          value: "right"
        }
      }
    }
  };
};
const genTabsStyle = (token2) => {
  const {
    componentCls,
    tabsCardHorizontalPadding,
    tabsCardHeight,
    tabsCardGutter,
    tabsHoverColor,
    tabsActiveColor,
    colorBorderSecondary
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
      display: "flex",
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${componentCls}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${token2.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${componentCls}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${token2.motionDurationSlow}`
        },
        [`${componentCls}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${componentCls}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${componentCls}-nav-more`]: {
          position: "relative",
          padding: tabsCardHorizontalPadding,
          background: "transparent",
          border: 0,
          color: token2.colorText,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: true,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token2.controlHeightLG / 8,
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${componentCls}-nav-add`]: Object.assign({
          minWidth: `${tabsCardHeight}px`,
          marginLeft: {
            _skip_check_: true,
            value: `${tabsCardGutter}px`
          },
          padding: `0 ${token2.paddingXS}px`,
          background: "transparent",
          border: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
          borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`,
          outline: "none",
          cursor: "pointer",
          color: token2.colorText,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
          "&:hover": {
            color: tabsHoverColor
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: tabsActiveColor
          }
        }, genFocusStyle(token2))
      },
      [`${componentCls}-extra-content`]: {
        flex: "none"
      },
      [`${componentCls}-ink-bar`]: {
        position: "absolute",
        background: token2.colorPrimary,
        pointerEvents: "none"
      }
    }), genTabStyle(token2)), {
      [`${componentCls}-content`]: {
        position: "relative",
        width: "100%"
      },
      [`${componentCls}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${componentCls}-tabpane`]: {
        outline: "none",
        "&-hidden": {
          display: "none"
        }
      }
    }),
    [`${componentCls}-centered`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-nav-wrap`]: {
          [`&:not([class*='${componentCls}-nav-wrap-ping'])`]: {
            justifyContent: "center"
          }
        }
      }
    }
  };
};
var useStyle$8 = genComponentStyleHook$2("Tabs", (token2) => {
  const tabsCardHeight = token2.controlHeightLG;
  const tabsToken = merge$1(token2, {
    tabsHoverColor: token2.colorPrimaryHover,
    tabsActiveColor: token2.colorPrimaryActive,
    tabsCardHorizontalPadding: `${(tabsCardHeight - Math.round(token2.fontSize * token2.lineHeight)) / 2 - token2.lineWidth}px ${token2.padding}px`,
    tabsCardHeight,
    tabsCardGutter: token2.marginXXS / 2,
    tabsHorizontalGutter: 32,
    tabsCardHeadBackground: token2.colorFillAlter,
    dropdownEdgeChildVerticalPadding: token2.paddingXXS,
    tabsActiveTextShadow: "0 0 0.25px currentcolor",
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120
  });
  return [genSizeStyle(tabsToken), genRtlStyle(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle$1(tabsToken), genTabsStyle(tabsToken), genMotionStyle$1(tabsToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 50
}));
var __rest$k = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function Tabs(_a2) {
  var {
    type: type4,
    className,
    rootClassName,
    size: propSize,
    onEdit,
    hideAdd,
    centered,
    addIcon,
    popupClassName,
    children,
    items,
    animated
  } = _a2, props = __rest$k(_a2, ["type", "className", "rootClassName", "size", "onEdit", "hideAdd", "centered", "addIcon", "popupClassName", "children", "items", "animated"]);
  const {
    prefixCls: customizePrefixCls,
    moreIcon = /* @__PURE__ */ React.createElement(EllipsisOutlined$1, null)
  } = props;
  const {
    direction,
    getPrefixCls,
    getPopupContainer
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("tabs", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$8(prefixCls);
  let editable;
  if (type4 === "editable-card") {
    editable = {
      onEdit: (editType, _ref2) => {
        let {
          key,
          event
        } = _ref2;
        onEdit === null || onEdit === void 0 ? void 0 : onEdit(editType === "add" ? event : key, editType);
      },
      removeIcon: /* @__PURE__ */ React.createElement(CloseOutlined$1, null),
      addIcon: addIcon || /* @__PURE__ */ React.createElement(PlusOutlined$1, null),
      showAdd: hideAdd !== true
    };
  }
  const rootPrefixCls = getPrefixCls();
  const mergedItems = useLegacyItems(items, children);
  const mergedAnimated = useAnimateConfig(prefixCls, animated);
  const contextSize = React.useContext(SizeContext$3);
  const size = propSize !== void 0 ? propSize : contextSize;
  return wrapSSR(/* @__PURE__ */ React.createElement(ForwardTabs, Object.assign({
    direction,
    getPopupContainer,
    moreTransitionName: `${rootPrefixCls}-slide-up`
  }, props, {
    items: mergedItems,
    className: classNames({
      [`${prefixCls}-${size}`]: size,
      [`${prefixCls}-card`]: ["card", "editable-card"].includes(type4),
      [`${prefixCls}-editable-card`]: type4 === "editable-card",
      [`${prefixCls}-centered`]: centered
    }, className, rootClassName, hashId),
    popupClassName: classNames(popupClassName, hashId),
    editable,
    moreIcon,
    prefixCls,
    animated: mergedAnimated
  })));
}
Tabs.TabPane = TabPane$2;
var __rest$j = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const Grid = (_a2) => {
  var {
    prefixCls,
    className,
    hoverable = true
  } = _a2, props = __rest$j(_a2, ["prefixCls", "className", "hoverable"]);
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefix2 = getPrefixCls("card", prefixCls);
  const classString = classNames(`${prefix2}-grid`, className, {
    [`${prefix2}-grid-hoverable`]: hoverable
  });
  return /* @__PURE__ */ React.createElement("div", Object.assign({}, props, {
    className: classString
  }));
};
var Grid$1 = Grid;
const genCardHeadStyle = (token2) => {
  const {
    antCls,
    componentCls,
    cardHeadHeight,
    cardPaddingBase,
    cardHeadTabsMarginBottom
  } = token2;
  return Object.assign(Object.assign({
    display: "flex",
    justifyContent: "center",
    flexDirection: "column",
    minHeight: cardHeadHeight,
    marginBottom: -1,
    padding: `0 ${cardPaddingBase}px`,
    color: token2.colorTextHeading,
    fontWeight: token2.fontWeightStrong,
    fontSize: token2.fontSizeLG,
    background: "transparent",
    borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorderSecondary}`,
    borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`
  }, clearFix()), {
    "&-wrapper": {
      width: "100%",
      display: "flex",
      alignItems: "center"
    },
    "&-title": Object.assign(Object.assign({
      display: "inline-block",
      flex: 1
    }, textEllipsis), {
      [`
          > ${componentCls}-typography,
          > ${componentCls}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    }),
    [`${antCls}-tabs-top`]: {
      clear: "both",
      marginBottom: cardHeadTabsMarginBottom,
      color: token2.colorText,
      fontWeight: "normal",
      fontSize: token2.fontSize,
      "&-bar": {
        borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorderSecondary}`
      }
    }
  });
};
const genCardGridStyle = (token2) => {
  const {
    cardPaddingBase,
    colorBorderSecondary,
    cardShadow,
    lineWidth
  } = token2;
  return {
    width: "33.33%",
    padding: cardPaddingBase,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${lineWidth}px 0 0 0 ${colorBorderSecondary},
      0 ${lineWidth}px 0 0 ${colorBorderSecondary},
      ${lineWidth}px ${lineWidth}px 0 0 ${colorBorderSecondary},
      ${lineWidth}px 0 0 0 ${colorBorderSecondary} inset,
      0 ${lineWidth}px 0 0 ${colorBorderSecondary} inset;
    `,
    transition: `all ${token2.motionDurationMid}`,
    "&-hoverable:hover": {
      position: "relative",
      zIndex: 1,
      boxShadow: cardShadow
    }
  };
};
const genCardActionsStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    cardActionsLiMargin,
    cardActionsIconSize,
    colorBorderSecondary
  } = token2;
  return Object.assign(Object.assign({
    margin: 0,
    padding: 0,
    listStyle: "none",
    background: token2.colorBgContainer,
    borderTop: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
    display: "flex",
    borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px `
  }, clearFix()), {
    "& > li": {
      margin: cardActionsLiMargin,
      color: token2.colorTextDescription,
      textAlign: "center",
      "> span": {
        position: "relative",
        display: "block",
        minWidth: token2.cardActionsIconSize * 2,
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        cursor: "pointer",
        "&:hover": {
          color: token2.colorPrimary,
          transition: `color ${token2.motionDurationMid}`
        },
        [`a:not(${componentCls}-btn), > ${iconCls}`]: {
          display: "inline-block",
          width: "100%",
          color: token2.colorTextDescription,
          lineHeight: `${token2.fontSize * token2.lineHeight}px`,
          transition: `color ${token2.motionDurationMid}`,
          "&:hover": {
            color: token2.colorPrimary
          }
        },
        [`> ${iconCls}`]: {
          fontSize: cardActionsIconSize,
          lineHeight: `${cardActionsIconSize * token2.lineHeight}px`
        }
      },
      "&:not(:last-child)": {
        borderInlineEnd: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`
      }
    }
  });
};
const genCardMetaStyle = (token2) => Object.assign(Object.assign({
  margin: `-${token2.marginXXS}px 0`,
  display: "flex"
}, clearFix()), {
  "&-avatar": {
    paddingInlineEnd: token2.padding
  },
  "&-detail": {
    overflow: "hidden",
    flex: 1,
    "> div:not(:last-child)": {
      marginBottom: token2.marginXS
    }
  },
  "&-title": Object.assign({
    color: token2.colorTextHeading,
    fontWeight: token2.fontWeightStrong,
    fontSize: token2.fontSizeLG
  }, textEllipsis),
  "&-description": {
    color: token2.colorTextDescription
  }
});
const genCardTypeInnerStyle = (token2) => {
  const {
    componentCls,
    cardPaddingBase,
    colorFillAlter
  } = token2;
  return {
    [`${componentCls}-head`]: {
      padding: `0 ${cardPaddingBase}px`,
      background: colorFillAlter,
      "&-title": {
        fontSize: token2.fontSize
      }
    },
    [`${componentCls}-body`]: {
      padding: `${token2.padding}px ${cardPaddingBase}px`
    }
  };
};
const genCardLoadingStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    overflow: "hidden",
    [`${componentCls}-body`]: {
      userSelect: "none"
    }
  };
};
const genCardStyle = (token2) => {
  const {
    componentCls,
    cardShadow,
    cardHeadPadding,
    colorBorderSecondary,
    boxShadowTertiary,
    cardPaddingBase
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "relative",
      background: token2.colorBgContainer,
      borderRadius: token2.borderRadiusLG,
      [`&:not(${componentCls}-bordered)`]: {
        boxShadow: boxShadowTertiary
      },
      [`${componentCls}-head`]: genCardHeadStyle(token2),
      [`${componentCls}-extra`]: {
        marginInlineStart: "auto",
        color: "",
        fontWeight: "normal",
        fontSize: token2.fontSize
      },
      [`${componentCls}-body`]: Object.assign({
        padding: cardPaddingBase,
        borderRadius: ` 0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`
      }, clearFix()),
      [`${componentCls}-grid`]: genCardGridStyle(token2),
      [`${componentCls}-cover`]: {
        "> *": {
          display: "block",
          width: "100%"
        },
        img: {
          borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`
        }
      },
      [`${componentCls}-actions`]: genCardActionsStyle(token2),
      [`${componentCls}-meta`]: genCardMetaStyle(token2)
    }),
    [`${componentCls}-bordered`]: {
      border: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
      [`${componentCls}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${componentCls}-hoverable`]: {
      cursor: "pointer",
      transition: `box-shadow ${token2.motionDurationMid}, border-color ${token2.motionDurationMid}`,
      "&:hover": {
        borderColor: "transparent",
        boxShadow: cardShadow
      }
    },
    [`${componentCls}-contain-grid`]: {
      [`${componentCls}-body`]: {
        display: "flex",
        flexWrap: "wrap"
      },
      [`&:not(${componentCls}-loading) ${componentCls}-body`]: {
        marginBlockStart: -token2.lineWidth,
        marginInlineStart: -token2.lineWidth,
        padding: 0
      }
    },
    [`${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: cardHeadPadding
        }
      }
    },
    [`${componentCls}-type-inner`]: genCardTypeInnerStyle(token2),
    [`${componentCls}-loading`]: genCardLoadingStyle(token2),
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
const genCardSizeStyle = (token2) => {
  const {
    componentCls,
    cardPaddingSM,
    cardHeadHeightSM
  } = token2;
  return {
    [`${componentCls}-small`]: {
      [`> ${componentCls}-head`]: {
        minHeight: cardHeadHeightSM,
        padding: `0 ${cardPaddingSM}px`,
        fontSize: token2.fontSize,
        [`> ${componentCls}-head-wrapper`]: {
          [`> ${componentCls}-extra`]: {
            fontSize: token2.fontSize
          }
        }
      },
      [`> ${componentCls}-body`]: {
        padding: cardPaddingSM
      }
    },
    [`${componentCls}-small${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          minHeight: cardHeadHeightSM,
          paddingTop: 0,
          display: "flex",
          alignItems: "center"
        }
      }
    }
  };
};
var useStyle$7 = genComponentStyleHook$2("Card", (token2) => {
  const cardToken = merge$1(token2, {
    cardShadow: token2.boxShadowCard,
    cardHeadHeight: token2.fontSizeLG * token2.lineHeightLG + token2.padding * 2,
    cardHeadHeightSM: token2.fontSize * token2.lineHeight + token2.paddingXS * 2,
    cardHeadPadding: token2.padding,
    cardPaddingBase: token2.paddingLG,
    cardHeadTabsMarginBottom: -token2.padding - token2.lineWidth,
    cardActionsLiMargin: `${token2.paddingSM}px 0`,
    cardActionsIconSize: token2.fontSize,
    cardPaddingSM: 12
  });
  return [
    genCardStyle(cardToken),
    genCardSizeStyle(cardToken)
  ];
});
var __rest$i = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function getAction(actions) {
  const actionList = actions.map((action, index2) => /* @__PURE__ */ React.createElement("li", {
    style: {
      width: `${100 / actions.length}%`
    },
    key: `action-${index2}`
  }, /* @__PURE__ */ React.createElement("span", null, action)));
  return actionList;
}
const Card$2 = /* @__PURE__ */ React.forwardRef((props, ref2) => {
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext$1);
  const size = React.useContext(SizeContext$3);
  const onTabChange = (key) => {
    var _a2;
    (_a2 = props.onTabChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, key);
  };
  const isContainGrid = () => {
    let containGrid;
    React.Children.forEach(props.children, (element2) => {
      if (element2 && element2.type && element2.type === Grid$1) {
        containGrid = true;
      }
    });
    return containGrid;
  };
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    extra,
    headStyle = {},
    bodyStyle = {},
    title,
    loading,
    bordered = true,
    size: customizeSize,
    type: type4,
    cover,
    actions,
    tabList,
    children,
    activeTabKey,
    defaultActiveTabKey,
    tabBarExtraContent,
    hoverable,
    tabProps = {}
  } = props, others = __rest$i(props, ["prefixCls", "className", "rootClassName", "extra", "headStyle", "bodyStyle", "title", "loading", "bordered", "size", "type", "cover", "actions", "tabList", "children", "activeTabKey", "defaultActiveTabKey", "tabBarExtraContent", "hoverable", "tabProps"]);
  const prefixCls = getPrefixCls("card", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$7(prefixCls);
  const loadingBlock = /* @__PURE__ */ React.createElement(Skeleton$1, {
    loading: true,
    active: true,
    paragraph: {
      rows: 4
    },
    title: false
  }, children);
  const hasActiveTabKey = activeTabKey !== void 0;
  const extraProps = Object.assign(Object.assign({}, tabProps), {
    [hasActiveTabKey ? "activeKey" : "defaultActiveKey"]: hasActiveTabKey ? activeTabKey : defaultActiveTabKey,
    tabBarExtraContent
  });
  let head;
  const tabs = tabList && tabList.length ? /* @__PURE__ */ React.createElement(Tabs, Object.assign({
    size: "large"
  }, extraProps, {
    className: `${prefixCls}-head-tabs`,
    onChange: onTabChange,
    items: tabList.map((item) => {
      var _a2;
      return {
        label: item.tab,
        key: item.key,
        disabled: (_a2 = item.disabled) !== null && _a2 !== void 0 ? _a2 : false
      };
    })
  })) : null;
  if (title || extra || tabs) {
    head = /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-head`,
      style: headStyle
    }, /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-head-wrapper`
    }, title && /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-head-title`
    }, title), extra && /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-extra`
    }, extra)), tabs);
  }
  const coverDom = cover ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-cover`
  }, cover) : null;
  const body = /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-body`,
    style: bodyStyle
  }, loading ? loadingBlock : children);
  const actionDom = actions && actions.length ? /* @__PURE__ */ React.createElement("ul", {
    className: `${prefixCls}-actions`
  }, getAction(actions)) : null;
  const divProps = omit$5(others, ["onTabChange"]);
  const mergedSize = customizeSize || size;
  const classString = classNames(prefixCls, {
    [`${prefixCls}-loading`]: loading,
    [`${prefixCls}-bordered`]: bordered,
    [`${prefixCls}-hoverable`]: hoverable,
    [`${prefixCls}-contain-grid`]: isContainGrid(),
    [`${prefixCls}-contain-tabs`]: tabList && tabList.length,
    [`${prefixCls}-${mergedSize}`]: mergedSize,
    [`${prefixCls}-type-${type4}`]: !!type4,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId);
  return wrapSSR(/* @__PURE__ */ React.createElement("div", Object.assign({
    ref: ref2
  }, divProps, {
    className: classString
  }), head, coverDom, body, actionDom));
});
var InternalCard = Card$2;
var __rest$h = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const Meta$2 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    avatar,
    title,
    description
  } = props, others = __rest$h(props, ["prefixCls", "className", "avatar", "title", "description"]);
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("card", customizePrefixCls);
  const classString = classNames(`${prefixCls}-meta`, className);
  const avatarDom = avatar ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-meta-avatar`
  }, avatar) : null;
  const titleDom = title ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-meta-title`
  }, title) : null;
  const descriptionDom = description ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-meta-description`
  }, description) : null;
  const MetaDetail = titleDom || descriptionDom ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-meta-detail`
  }, titleDom, descriptionDom) : null;
  return /* @__PURE__ */ React.createElement("div", Object.assign({}, others, {
    className: classString
  }), avatarDom, MetaDetail);
};
var Meta$3 = Meta$2;
const Card = InternalCard;
Card.Grid = Grid$1;
Card.Meta = Meta$3;
var Card$1 = Card;
var initialState = {
  animating: false,
  autoplaying: null,
  currentDirection: 0,
  currentLeft: null,
  currentSlide: 0,
  direction: 1,
  dragging: false,
  edgeDragged: false,
  initialized: false,
  lazyLoadedList: [],
  listHeight: null,
  listWidth: null,
  scrolling: false,
  slideCount: null,
  slideHeight: null,
  slideWidth: null,
  swipeLeft: null,
  swiped: false,
  swiping: false,
  touchObject: {
    startX: 0,
    startY: 0,
    curX: 0,
    curY: 0
  },
  trackStyle: {},
  trackWidth: 0,
  targetSlide: 0
};
var cjs = {};
Object.defineProperty(cjs, "__esModule", { value: true });
function throttle(delay, callback, options) {
  var _ref2 = options || {}, _ref$noTrailing = _ref2.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref2.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref2.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel(options2) {
    var _ref22 = options2 || {}, _ref2$upcomingOnly = _ref22.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (!noLeading && debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      if (noLeading) {
        lastExec = Date.now();
        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        exec();
      }
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function debounce(delay, callback, options) {
  var _ref2 = options || {}, _ref$atBegin = _ref2.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
  return throttle(delay, callback, {
    debounceMode: atBegin !== false
  });
}
var debounce_1 = cjs.debounce = debounce;
cjs.throttle = throttle;
function clamp(number4, lowerBound, upperBound) {
  return Math.max(lowerBound, Math.min(number4, upperBound));
}
var safePreventDefault = function safePreventDefault2(event) {
  var passiveEvents = ["onTouchStart", "onTouchMove", "onWheel"];
  if (!passiveEvents.includes(event._reactName)) {
    event.preventDefault();
  }
};
var getOnDemandLazySlides = function getOnDemandLazySlides2(spec) {
  var onDemandSlides = [];
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);
  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {
    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {
      onDemandSlides.push(slideIndex);
    }
  }
  return onDemandSlides;
};
var lazyStartIndex = function lazyStartIndex2(spec) {
  return spec.currentSlide - lazySlidesOnLeft(spec);
};
var lazyEndIndex = function lazyEndIndex2(spec) {
  return spec.currentSlide + lazySlidesOnRight(spec);
};
var lazySlidesOnLeft = function lazySlidesOnLeft2(spec) {
  return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;
};
var lazySlidesOnRight = function lazySlidesOnRight2(spec) {
  return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;
};
var getWidth = function getWidth2(elem) {
  return elem && elem.offsetWidth || 0;
};
var getHeight = function getHeight2(elem) {
  return elem && elem.offsetHeight || 0;
};
var getSwipeDirection = function getSwipeDirection2(touchObject) {
  var verticalSwiping = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var xDist, yDist, r2, swipeAngle;
  xDist = touchObject.startX - touchObject.curX;
  yDist = touchObject.startY - touchObject.curY;
  r2 = Math.atan2(yDist, xDist);
  swipeAngle = Math.round(r2 * 180 / Math.PI);
  if (swipeAngle < 0) {
    swipeAngle = 360 - Math.abs(swipeAngle);
  }
  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {
    return "left";
  }
  if (swipeAngle >= 135 && swipeAngle <= 225) {
    return "right";
  }
  if (verticalSwiping === true) {
    if (swipeAngle >= 35 && swipeAngle <= 135) {
      return "up";
    } else {
      return "down";
    }
  }
  return "vertical";
};
var canGoNext = function canGoNext2(spec) {
  var canGo = true;
  if (!spec.infinite) {
    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {
      canGo = false;
    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {
      canGo = false;
    }
  }
  return canGo;
};
var extractObject = function extractObject2(spec, keys2) {
  var newObject = {};
  keys2.forEach(function(key) {
    return newObject[key] = spec[key];
  });
  return newObject;
};
var initializedState = function initializedState2(spec) {
  var slideCount = React.Children.count(spec.children);
  var listNode = spec.listRef;
  var listWidth = Math.ceil(getWidth(listNode));
  var trackNode = spec.trackRef && spec.trackRef.node;
  var trackWidth = Math.ceil(getWidth(trackNode));
  var slideWidth;
  if (!spec.vertical) {
    var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;
    if (typeof spec.centerPadding === "string" && spec.centerPadding.slice(-1) === "%") {
      centerPaddingAdj *= listWidth / 100;
    }
    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);
  } else {
    slideWidth = listWidth;
  }
  var slideHeight = listNode && getHeight(listNode.querySelector('[data-index="0"]'));
  var listHeight = slideHeight * spec.slidesToShow;
  var currentSlide = spec.currentSlide === void 0 ? spec.initialSlide : spec.currentSlide;
  if (spec.rtl && spec.currentSlide === void 0) {
    currentSlide = slideCount - 1 - spec.initialSlide;
  }
  var lazyLoadedList = spec.lazyLoadedList || [];
  var slidesToLoad = getOnDemandLazySlides(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
    currentSlide,
    lazyLoadedList
  }));
  lazyLoadedList = lazyLoadedList.concat(slidesToLoad);
  var state = {
    slideCount,
    slideWidth,
    listWidth,
    trackWidth,
    currentSlide,
    slideHeight,
    listHeight,
    lazyLoadedList
  };
  if (spec.autoplaying === null && spec.autoplay) {
    state["autoplaying"] = "playing";
  }
  return state;
};
var slideHandler = function slideHandler2(spec) {
  var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index2 = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;
  var lazyLoadedList = spec.lazyLoadedList;
  if (waitForAnimate && animating)
    return {};
  var animationSlide = index2, finalSlide, animationLeft, finalLeft;
  var state = {}, nextState = {};
  var targetSlide = infinite ? index2 : clamp(index2, 0, slideCount - 1);
  if (fade) {
    if (!infinite && (index2 < 0 || index2 >= slideCount))
      return {};
    if (index2 < 0) {
      animationSlide = index2 + slideCount;
    } else if (index2 >= slideCount) {
      animationSlide = index2 - slideCount;
    }
    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {
      lazyLoadedList = lazyLoadedList.concat(animationSlide);
    }
    state = {
      animating: true,
      currentSlide: animationSlide,
      lazyLoadedList,
      targetSlide: animationSlide
    };
    nextState = {
      animating: false,
      targetSlide: animationSlide
    };
  } else {
    finalSlide = animationSlide;
    if (animationSlide < 0) {
      finalSlide = animationSlide + slideCount;
      if (!infinite)
        finalSlide = 0;
      else if (slideCount % slidesToScroll !== 0)
        finalSlide = slideCount - slideCount % slidesToScroll;
    } else if (!canGoNext(spec) && animationSlide > currentSlide) {
      animationSlide = finalSlide = currentSlide;
    } else if (centerMode && animationSlide >= slideCount) {
      animationSlide = infinite ? slideCount : slideCount - 1;
      finalSlide = infinite ? 0 : slideCount - 1;
    } else if (animationSlide >= slideCount) {
      finalSlide = animationSlide - slideCount;
      if (!infinite)
        finalSlide = slideCount - slidesToShow;
      else if (slideCount % slidesToScroll !== 0)
        finalSlide = 0;
    }
    if (!infinite && animationSlide + slidesToShow >= slideCount) {
      finalSlide = slideCount - slidesToShow;
    }
    animationLeft = getTrackLeft(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
      slideIndex: animationSlide
    }));
    finalLeft = getTrackLeft(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
      slideIndex: finalSlide
    }));
    if (!infinite) {
      if (animationLeft === finalLeft)
        animationSlide = finalSlide;
      animationLeft = finalLeft;
    }
    if (lazyLoad) {
      lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
        currentSlide: animationSlide
      })));
    }
    if (!useCSS) {
      state = {
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
          left: finalLeft
        })),
        lazyLoadedList,
        targetSlide
      };
    } else {
      state = {
        animating: true,
        currentSlide: finalSlide,
        trackStyle: getTrackAnimateCSS(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
          left: animationLeft
        })),
        lazyLoadedList,
        targetSlide
      };
      nextState = {
        animating: false,
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
          left: finalLeft
        })),
        swipeLeft: null,
        targetSlide
      };
    }
  }
  return {
    state,
    nextState
  };
};
var changeSlide = function changeSlide2(spec, options) {
  var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;
  var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;
  unevenOffset = slideCount % slidesToScroll !== 0;
  indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;
  if (options.message === "previous") {
    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;
    targetSlide = currentSlide - slideOffset;
    if (lazyLoad && !infinite) {
      previousInt = currentSlide - slideOffset;
      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide - slidesToScroll;
    }
  } else if (options.message === "next") {
    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;
    targetSlide = currentSlide + slideOffset;
    if (lazyLoad && !infinite) {
      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide + slidesToScroll;
    }
  } else if (options.message === "dots") {
    targetSlide = options.index * options.slidesToScroll;
  } else if (options.message === "children") {
    targetSlide = options.index;
    if (infinite) {
      var direction = siblingDirection(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
        targetSlide
      }));
      if (targetSlide > options.currentSlide && direction === "left") {
        targetSlide = targetSlide - slideCount;
      } else if (targetSlide < options.currentSlide && direction === "right") {
        targetSlide = targetSlide + slideCount;
      }
    }
  } else if (options.message === "index") {
    targetSlide = Number(options.index);
  }
  return targetSlide;
};
var keyHandler = function keyHandler2(e2, accessibility, rtl) {
  if (e2.target.tagName.match("TEXTAREA|INPUT|SELECT") || !accessibility)
    return "";
  if (e2.keyCode === 37)
    return rtl ? "next" : "previous";
  if (e2.keyCode === 39)
    return rtl ? "previous" : "next";
  return "";
};
var swipeStart = function swipeStart2(e2, swipe, draggable) {
  e2.target.tagName === "IMG" && safePreventDefault(e2);
  if (!swipe || !draggable && e2.type.indexOf("mouse") !== -1)
    return "";
  return {
    dragging: true,
    touchObject: {
      startX: e2.touches ? e2.touches[0].pageX : e2.clientX,
      startY: e2.touches ? e2.touches[0].pageY : e2.clientY,
      curX: e2.touches ? e2.touches[0].pageX : e2.clientX,
      curY: e2.touches ? e2.touches[0].pageY : e2.clientY
    }
  };
};
var swipeMove = function swipeMove2(e2, spec) {
  var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;
  if (scrolling)
    return;
  if (animating)
    return safePreventDefault(e2);
  if (vertical && swipeToSlide && verticalSwiping)
    safePreventDefault(e2);
  var swipeLeft, state = {};
  var curLeft = getTrackLeft(spec);
  touchObject.curX = e2.touches ? e2.touches[0].pageX : e2.clientX;
  touchObject.curY = e2.touches ? e2.touches[0].pageY : e2.clientY;
  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));
  var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));
  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {
    return {
      scrolling: true
    };
  }
  if (verticalSwiping)
    touchObject.swipeLength = verticalSwipeLength;
  var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);
  if (verticalSwiping)
    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;
  var dotCount = Math.ceil(slideCount / slidesToScroll);
  var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);
  var touchSwipeLength = touchObject.swipeLength;
  if (!infinite) {
    if (currentSlide === 0 && (swipeDirection === "right" || swipeDirection === "down") || currentSlide + 1 >= dotCount && (swipeDirection === "left" || swipeDirection === "up") || !canGoNext(spec) && (swipeDirection === "left" || swipeDirection === "up")) {
      touchSwipeLength = touchObject.swipeLength * edgeFriction;
      if (edgeDragged === false && onEdge) {
        onEdge(swipeDirection);
        state["edgeDragged"] = true;
      }
    }
  }
  if (!swiped && swipeEvent) {
    swipeEvent(swipeDirection);
    state["swiped"] = true;
  }
  if (!vertical) {
    if (!rtl) {
      swipeLeft = curLeft + touchSwipeLength * positionOffset;
    } else {
      swipeLeft = curLeft - touchSwipeLength * positionOffset;
    }
  } else {
    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;
  }
  if (verticalSwiping) {
    swipeLeft = curLeft + touchSwipeLength * positionOffset;
  }
  state = _objectSpread2$d(_objectSpread2$d({}, state), {}, {
    touchObject,
    swipeLeft,
    trackStyle: getTrackCSS(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
      left: swipeLeft
    }))
  });
  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {
    return state;
  }
  if (touchObject.swipeLength > 10) {
    state["swiping"] = true;
    safePreventDefault(e2);
  }
  return state;
};
var swipeEnd = function swipeEnd2(e2, spec) {
  var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;
  if (!dragging) {
    if (swipe)
      safePreventDefault(e2);
    return {};
  }
  var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;
  var swipeDirection = getSwipeDirection(touchObject, verticalSwiping);
  var state = {
    dragging: false,
    edgeDragged: false,
    scrolling: false,
    swiping: false,
    swiped: false,
    swipeLeft: null,
    touchObject: {}
  };
  if (scrolling) {
    return state;
  }
  if (!touchObject.swipeLength) {
    return state;
  }
  if (touchObject.swipeLength > minSwipe) {
    safePreventDefault(e2);
    if (onSwipe) {
      onSwipe(swipeDirection);
    }
    var slideCount, newSlide;
    var activeSlide = infinite ? currentSlide : targetSlide;
    switch (swipeDirection) {
      case "left":
      case "up":
        newSlide = activeSlide + getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 0;
        break;
      case "right":
      case "down":
        newSlide = activeSlide - getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 1;
        break;
      default:
        slideCount = activeSlide;
    }
    state["triggerSlideHandler"] = slideCount;
  } else {
    var currentLeft = getTrackLeft(spec);
    state["trackStyle"] = getTrackAnimateCSS(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
      left: currentLeft
    }));
  }
  return state;
};
var getNavigableIndexes = function getNavigableIndexes2(spec) {
  var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;
  var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;
  var counter2 = spec.infinite ? spec.slidesToShow * -1 : 0;
  var indexes = [];
  while (breakpoint < max) {
    indexes.push(breakpoint);
    breakpoint = counter2 + spec.slidesToScroll;
    counter2 += Math.min(spec.slidesToScroll, spec.slidesToShow);
  }
  return indexes;
};
var checkNavigable = function checkNavigable2(spec, index2) {
  var navigables = getNavigableIndexes(spec);
  var prevNavigable = 0;
  if (index2 > navigables[navigables.length - 1]) {
    index2 = navigables[navigables.length - 1];
  } else {
    for (var n2 in navigables) {
      if (index2 < navigables[n2]) {
        index2 = prevNavigable;
        break;
      }
      prevNavigable = navigables[n2];
    }
  }
  return index2;
};
var getSlideCount = function getSlideCount2(spec) {
  var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;
  if (spec.swipeToSlide) {
    var swipedSlide;
    var slickList = spec.listRef;
    var slides = slickList.querySelectorAll && slickList.querySelectorAll(".slick-slide") || [];
    Array.from(slides).every(function(slide) {
      if (!spec.vertical) {
        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      } else {
        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      }
      return true;
    });
    if (!swipedSlide) {
      return 0;
    }
    var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;
    var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;
    return slidesTraversed;
  } else {
    return spec.slidesToScroll;
  }
};
var checkSpecKeys = function checkSpecKeys2(spec, keysArray) {
  return keysArray.reduce(function(value, key) {
    return value && spec.hasOwnProperty(key);
  }, true) ? null : console.error("Keys Missing:", spec);
};
var getTrackCSS = function getTrackCSS2(spec) {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth"]);
  var trackWidth, trackHeight;
  var trackChildren = spec.slideCount + 2 * spec.slidesToShow;
  if (!spec.vertical) {
    trackWidth = getTotalSlides(spec) * spec.slideWidth;
  } else {
    trackHeight = trackChildren * spec.slideHeight;
  }
  var style2 = {
    opacity: 1,
    transition: "",
    WebkitTransition: ""
  };
  if (spec.useTransform) {
    var WebkitTransform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    var transform3 = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    var msTransform = !spec.vertical ? "translateX(" + spec.left + "px)" : "translateY(" + spec.left + "px)";
    style2 = _objectSpread2$d(_objectSpread2$d({}, style2), {}, {
      WebkitTransform,
      transform: transform3,
      msTransform
    });
  } else {
    if (spec.vertical) {
      style2["top"] = spec.left;
    } else {
      style2["left"] = spec.left;
    }
  }
  if (spec.fade)
    style2 = {
      opacity: 1
    };
  if (trackWidth)
    style2.width = trackWidth;
  if (trackHeight)
    style2.height = trackHeight;
  if (window && !window.addEventListener && window.attachEvent) {
    if (!spec.vertical) {
      style2.marginLeft = spec.left + "px";
    } else {
      style2.marginTop = spec.left + "px";
    }
  }
  return style2;
};
var getTrackAnimateCSS = function getTrackAnimateCSS2(spec) {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth", "speed", "cssEase"]);
  var style2 = getTrackCSS(spec);
  if (spec.useTransform) {
    style2.WebkitTransition = "-webkit-transform " + spec.speed + "ms " + spec.cssEase;
    style2.transition = "transform " + spec.speed + "ms " + spec.cssEase;
  } else {
    if (spec.vertical) {
      style2.transition = "top " + spec.speed + "ms " + spec.cssEase;
    } else {
      style2.transition = "left " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style2;
};
var getTrackLeft = function getTrackLeft2(spec) {
  if (spec.unslick) {
    return 0;
  }
  checkSpecKeys(spec, ["slideIndex", "trackRef", "infinite", "centerMode", "slideCount", "slidesToShow", "slidesToScroll", "slideWidth", "listWidth", "variableWidth", "slideHeight"]);
  var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;
  var slideOffset = 0;
  var targetLeft;
  var targetSlide;
  var verticalOffset = 0;
  if (fade || spec.slideCount === 1) {
    return 0;
  }
  var slidesToOffset = 0;
  if (infinite) {
    slidesToOffset = -getPreClones(spec);
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);
    }
    if (centerMode) {
      slidesToOffset += parseInt(slidesToShow / 2);
    }
  } else {
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = slidesToShow - slideCount % slidesToScroll;
    }
    if (centerMode) {
      slidesToOffset = parseInt(slidesToShow / 2);
    }
  }
  slideOffset = slidesToOffset * slideWidth;
  verticalOffset = slidesToOffset * slideHeight;
  if (!vertical) {
    targetLeft = slideIndex * slideWidth * -1 + slideOffset;
  } else {
    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;
  }
  if (variableWidth === true) {
    var targetSlideIndex;
    var trackElem = trackRef && trackRef.node;
    targetSlideIndex = slideIndex + getPreClones(spec);
    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];
    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;
    if (centerMode === true) {
      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;
      targetSlide = trackElem && trackElem.children[targetSlideIndex];
      targetLeft = 0;
      for (var slide = 0; slide < targetSlideIndex; slide++) {
        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;
      }
      targetLeft -= parseInt(spec.centerPadding);
      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;
    }
  }
  return targetLeft;
};
var getPreClones = function getPreClones2(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  if (spec.variableWidth) {
    return spec.slideCount;
  }
  return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getPostClones = function getPostClones2(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  return spec.slideCount;
};
var getTotalSlides = function getTotalSlides2(spec) {
  return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);
};
var siblingDirection = function siblingDirection2(spec) {
  if (spec.targetSlide > spec.currentSlide) {
    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {
      return "left";
    }
    return "right";
  } else {
    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {
      return "right";
    }
    return "left";
  }
};
var slidesOnRight = function slidesOnRight2(_ref2) {
  var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;
  if (centerMode) {
    var right = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      right += 1;
    if (rtl && slidesToShow % 2 === 0)
      right += 1;
    return right;
  }
  if (rtl) {
    return 0;
  }
  return slidesToShow - 1;
};
var slidesOnLeft = function slidesOnLeft2(_ref2) {
  var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;
  if (centerMode) {
    var left = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      left += 1;
    if (!rtl && slidesToShow % 2 === 0)
      left += 1;
    return left;
  }
  if (rtl) {
    return slidesToShow - 1;
  }
  return 0;
};
var canUseDOM = function canUseDOM2() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
};
var getSlideClasses = function getSlideClasses2(spec) {
  var slickActive, slickCenter, slickCloned;
  var centerOffset, index2;
  if (spec.rtl) {
    index2 = spec.slideCount - 1 - spec.index;
  } else {
    index2 = spec.index;
  }
  slickCloned = index2 < 0 || index2 >= spec.slideCount;
  if (spec.centerMode) {
    centerOffset = Math.floor(spec.slidesToShow / 2);
    slickCenter = (index2 - spec.currentSlide) % spec.slideCount === 0;
    if (index2 > spec.currentSlide - centerOffset - 1 && index2 <= spec.currentSlide + centerOffset) {
      slickActive = true;
    }
  } else {
    slickActive = spec.currentSlide <= index2 && index2 < spec.currentSlide + spec.slidesToShow;
  }
  var focusedSlide;
  if (spec.targetSlide < 0) {
    focusedSlide = spec.targetSlide + spec.slideCount;
  } else if (spec.targetSlide >= spec.slideCount) {
    focusedSlide = spec.targetSlide - spec.slideCount;
  } else {
    focusedSlide = spec.targetSlide;
  }
  var slickCurrent = index2 === focusedSlide;
  return {
    "slick-slide": true,
    "slick-active": slickActive,
    "slick-center": slickCenter,
    "slick-cloned": slickCloned,
    "slick-current": slickCurrent
  };
};
var getSlideStyle = function getSlideStyle2(spec) {
  var style2 = {};
  if (spec.variableWidth === void 0 || spec.variableWidth === false) {
    style2.width = spec.slideWidth;
  }
  if (spec.fade) {
    style2.position = "relative";
    if (spec.vertical) {
      style2.top = -spec.index * parseInt(spec.slideHeight);
    } else {
      style2.left = -spec.index * parseInt(spec.slideWidth);
    }
    style2.opacity = spec.currentSlide === spec.index ? 1 : 0;
    if (spec.useCSS) {
      style2.transition = "opacity " + spec.speed + "ms " + spec.cssEase + ", visibility " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style2;
};
var getKey = function getKey2(child, fallbackKey) {
  return child.key + "-" + fallbackKey;
};
var renderSlides = function renderSlides2(spec) {
  var key;
  var slides = [];
  var preCloneSlides = [];
  var postCloneSlides = [];
  var childrenCount = React.Children.count(spec.children);
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);
  React.Children.forEach(spec.children, function(elem, index2) {
    var child;
    var childOnClickOptions = {
      message: "children",
      index: index2,
      slidesToScroll: spec.slidesToScroll,
      currentSlide: spec.currentSlide
    };
    if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index2) >= 0) {
      child = elem;
    } else {
      child = /* @__PURE__ */ React.createElement("div", null);
    }
    var childStyle = getSlideStyle(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
      index: index2
    }));
    var slideClass = child.props.className || "";
    var slideClasses = getSlideClasses(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
      index: index2
    }));
    slides.push(/* @__PURE__ */ React.cloneElement(child, {
      key: "original" + getKey(child, index2),
      "data-index": index2,
      className: classNames(slideClasses, slideClass),
      tabIndex: "-1",
      "aria-hidden": !slideClasses["slick-active"],
      style: _objectSpread2$d(_objectSpread2$d({
        outline: "none"
      }, child.props.style || {}), childStyle),
      onClick: function onClick(e2) {
        child.props && child.props.onClick && child.props.onClick(e2);
        if (spec.focusOnSelect) {
          spec.focusOnSelect(childOnClickOptions);
        }
      }
    }));
    if (spec.infinite && spec.fade === false) {
      var preCloneNo = childrenCount - index2;
      if (preCloneNo <= getPreClones(spec) && childrenCount !== spec.slidesToShow) {
        key = -preCloneNo;
        if (key >= startIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
          index: key
        }));
        preCloneSlides.push(/* @__PURE__ */ React.cloneElement(child, {
          key: "precloned" + getKey(child, key),
          "data-index": key,
          tabIndex: "-1",
          className: classNames(slideClasses, slideClass),
          "aria-hidden": !slideClasses["slick-active"],
          style: _objectSpread2$d(_objectSpread2$d({}, child.props.style || {}), childStyle),
          onClick: function onClick(e2) {
            child.props && child.props.onClick && child.props.onClick(e2);
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }
        }));
      }
      if (childrenCount !== spec.slidesToShow) {
        key = childrenCount + index2;
        if (key < endIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses(_objectSpread2$d(_objectSpread2$d({}, spec), {}, {
          index: key
        }));
        postCloneSlides.push(/* @__PURE__ */ React.cloneElement(child, {
          key: "postcloned" + getKey(child, key),
          "data-index": key,
          tabIndex: "-1",
          className: classNames(slideClasses, slideClass),
          "aria-hidden": !slideClasses["slick-active"],
          style: _objectSpread2$d(_objectSpread2$d({}, child.props.style || {}), childStyle),
          onClick: function onClick(e2) {
            child.props && child.props.onClick && child.props.onClick(e2);
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }
        }));
      }
    }
  });
  if (spec.rtl) {
    return preCloneSlides.concat(slides, postCloneSlides).reverse();
  } else {
    return preCloneSlides.concat(slides, postCloneSlides);
  }
};
var Track = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits$2(Track2, _React$PureComponent);
  var _super = _createSuper$2(Track2);
  function Track2() {
    var _this;
    _classCallCheck$2(this, Track2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$3(_assertThisInitialized$2(_this), "node", null);
    _defineProperty$3(_assertThisInitialized$2(_this), "handleRef", function(ref2) {
      _this.node = ref2;
    });
    return _this;
  }
  _createClass$2(Track2, [{
    key: "render",
    value: function render2() {
      var slides = renderSlides(this.props);
      var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave;
      var mouseEvents = {
        onMouseEnter,
        onMouseOver,
        onMouseLeave
      };
      return /* @__PURE__ */ React.createElement("div", _extends$3({
        ref: this.handleRef,
        className: "slick-track",
        style: this.props.trackStyle
      }, mouseEvents), slides);
    }
  }]);
  return Track2;
}(React.PureComponent);
var getDotCount = function getDotCount2(spec) {
  var dots;
  if (spec.infinite) {
    dots = Math.ceil(spec.slideCount / spec.slidesToScroll);
  } else {
    dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;
  }
  return dots;
};
var Dots = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits$2(Dots2, _React$PureComponent);
  var _super = _createSuper$2(Dots2);
  function Dots2() {
    _classCallCheck$2(this, Dots2);
    return _super.apply(this, arguments);
  }
  _createClass$2(Dots2, [{
    key: "clickHandler",
    value: function clickHandler(options, e2) {
      e2.preventDefault();
      this.props.clickHandler(options);
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave, infinite = _this$props.infinite, slidesToScroll = _this$props.slidesToScroll, slidesToShow = _this$props.slidesToShow, slideCount = _this$props.slideCount, currentSlide = _this$props.currentSlide;
      var dotCount = getDotCount({
        slideCount,
        slidesToScroll,
        slidesToShow,
        infinite
      });
      var mouseEvents = {
        onMouseEnter,
        onMouseOver,
        onMouseLeave
      };
      var dots = [];
      for (var i = 0; i < dotCount; i++) {
        var _rightBound = (i + 1) * slidesToScroll - 1;
        var rightBound = infinite ? _rightBound : clamp(_rightBound, 0, slideCount - 1);
        var _leftBound = rightBound - (slidesToScroll - 1);
        var leftBound = infinite ? _leftBound : clamp(_leftBound, 0, slideCount - 1);
        var className = classNames({
          "slick-active": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound
        });
        var dotOptions = {
          message: "dots",
          index: i,
          slidesToScroll,
          currentSlide
        };
        var onClick = this.clickHandler.bind(this, dotOptions);
        dots = dots.concat(/* @__PURE__ */ React.createElement("li", {
          key: i,
          className
        }, /* @__PURE__ */ React.cloneElement(this.props.customPaging(i), {
          onClick
        })));
      }
      return /* @__PURE__ */ React.cloneElement(this.props.appendDots(dots), _objectSpread2$d({
        className: this.props.dotsClass
      }, mouseEvents));
    }
  }]);
  return Dots2;
}(React.PureComponent);
var PrevArrow = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits$2(PrevArrow2, _React$PureComponent);
  var _super = _createSuper$2(PrevArrow2);
  function PrevArrow2() {
    _classCallCheck$2(this, PrevArrow2);
    return _super.apply(this, arguments);
  }
  _createClass$2(PrevArrow2, [{
    key: "clickHandler",
    value: function clickHandler(options, e2) {
      if (e2) {
        e2.preventDefault();
      }
      this.props.clickHandler(options, e2);
    }
  }, {
    key: "render",
    value: function render2() {
      var prevClasses = {
        "slick-arrow": true,
        "slick-prev": true
      };
      var prevHandler = this.clickHandler.bind(this, {
        message: "previous"
      });
      if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {
        prevClasses["slick-disabled"] = true;
        prevHandler = null;
      }
      var prevArrowProps = {
        key: "0",
        "data-role": "none",
        className: classNames(prevClasses),
        style: {
          display: "block"
        },
        onClick: prevHandler
      };
      var customProps = {
        currentSlide: this.props.currentSlide,
        slideCount: this.props.slideCount
      };
      var prevArrow;
      if (this.props.prevArrow) {
        prevArrow = /* @__PURE__ */ React.cloneElement(this.props.prevArrow, _objectSpread2$d(_objectSpread2$d({}, prevArrowProps), customProps));
      } else {
        prevArrow = /* @__PURE__ */ React.createElement("button", _extends$3({
          key: "0",
          type: "button"
        }, prevArrowProps), " ", "Previous");
      }
      return prevArrow;
    }
  }]);
  return PrevArrow2;
}(React.PureComponent);
var NextArrow = /* @__PURE__ */ function(_React$PureComponent2) {
  _inherits$2(NextArrow2, _React$PureComponent2);
  var _super2 = _createSuper$2(NextArrow2);
  function NextArrow2() {
    _classCallCheck$2(this, NextArrow2);
    return _super2.apply(this, arguments);
  }
  _createClass$2(NextArrow2, [{
    key: "clickHandler",
    value: function clickHandler(options, e2) {
      if (e2) {
        e2.preventDefault();
      }
      this.props.clickHandler(options, e2);
    }
  }, {
    key: "render",
    value: function render2() {
      var nextClasses = {
        "slick-arrow": true,
        "slick-next": true
      };
      var nextHandler = this.clickHandler.bind(this, {
        message: "next"
      });
      if (!canGoNext(this.props)) {
        nextClasses["slick-disabled"] = true;
        nextHandler = null;
      }
      var nextArrowProps = {
        key: "1",
        "data-role": "none",
        className: classNames(nextClasses),
        style: {
          display: "block"
        },
        onClick: nextHandler
      };
      var customProps = {
        currentSlide: this.props.currentSlide,
        slideCount: this.props.slideCount
      };
      var nextArrow;
      if (this.props.nextArrow) {
        nextArrow = /* @__PURE__ */ React.cloneElement(this.props.nextArrow, _objectSpread2$d(_objectSpread2$d({}, nextArrowProps), customProps));
      } else {
        nextArrow = /* @__PURE__ */ React.createElement("button", _extends$3({
          key: "1",
          type: "button"
        }, nextArrowProps), " ", "Next");
      }
      return nextArrow;
    }
  }]);
  return NextArrow2;
}(React.PureComponent);
var _excluded$6 = ["animating"];
var InnerSlider = /* @__PURE__ */ function(_React$Component) {
  _inherits$2(InnerSlider2, _React$Component);
  var _super = _createSuper$2(InnerSlider2);
  function InnerSlider2(props) {
    var _this;
    _classCallCheck$2(this, InnerSlider2);
    _this = _super.call(this, props);
    _defineProperty$3(_assertThisInitialized$2(_this), "listRefHandler", function(ref2) {
      return _this.list = ref2;
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "trackRefHandler", function(ref2) {
      return _this.track = ref2;
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "adaptHeight", function() {
      if (_this.props.adaptiveHeight && _this.list) {
        var elem = _this.list.querySelector('[data-index="'.concat(_this.state.currentSlide, '"]'));
        _this.list.style.height = getHeight(elem) + "px";
      }
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "componentDidMount", function() {
      _this.props.onInit && _this.props.onInit();
      if (_this.props.lazyLoad) {
        var slidesToLoad = getOnDemandLazySlides(_objectSpread2$d(_objectSpread2$d({}, _this.props), _this.state));
        if (slidesToLoad.length > 0) {
          _this.setState(function(prevState) {
            return {
              lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
            };
          });
          if (_this.props.onLazyLoad) {
            _this.props.onLazyLoad(slidesToLoad);
          }
        }
      }
      var spec = _objectSpread2$d({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props);
      _this.updateState(spec, true, function() {
        _this.adaptHeight();
        _this.props.autoplay && _this.autoPlay("playing");
      });
      if (_this.props.lazyLoad === "progressive") {
        _this.lazyLoadTimer = setInterval(_this.progressiveLazyLoad, 1e3);
      }
      _this.ro = new index(function() {
        if (_this.state.animating) {
          _this.onWindowResized(false);
          _this.callbackTimers.push(setTimeout(function() {
            return _this.onWindowResized();
          }, _this.props.speed));
        } else {
          _this.onWindowResized();
        }
      });
      _this.ro.observe(_this.list);
      document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), function(slide) {
        slide.onfocus = _this.props.pauseOnFocus ? _this.onSlideFocus : null;
        slide.onblur = _this.props.pauseOnFocus ? _this.onSlideBlur : null;
      });
      if (window.addEventListener) {
        window.addEventListener("resize", _this.onWindowResized);
      } else {
        window.attachEvent("onresize", _this.onWindowResized);
      }
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "componentWillUnmount", function() {
      if (_this.animationEndCallback) {
        clearTimeout(_this.animationEndCallback);
      }
      if (_this.lazyLoadTimer) {
        clearInterval(_this.lazyLoadTimer);
      }
      if (_this.callbackTimers.length) {
        _this.callbackTimers.forEach(function(timer) {
          return clearTimeout(timer);
        });
        _this.callbackTimers = [];
      }
      if (window.addEventListener) {
        window.removeEventListener("resize", _this.onWindowResized);
      } else {
        window.detachEvent("onresize", _this.onWindowResized);
      }
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
      }
      _this.ro.disconnect();
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "componentDidUpdate", function(prevProps) {
      _this.checkImagesLoad();
      _this.props.onReInit && _this.props.onReInit();
      if (_this.props.lazyLoad) {
        var slidesToLoad = getOnDemandLazySlides(_objectSpread2$d(_objectSpread2$d({}, _this.props), _this.state));
        if (slidesToLoad.length > 0) {
          _this.setState(function(prevState) {
            return {
              lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
            };
          });
          if (_this.props.onLazyLoad) {
            _this.props.onLazyLoad(slidesToLoad);
          }
        }
      }
      _this.adaptHeight();
      var spec = _objectSpread2$d(_objectSpread2$d({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props), _this.state);
      var setTrackStyle = _this.didPropsChange(prevProps);
      setTrackStyle && _this.updateState(spec, setTrackStyle, function() {
        if (_this.state.currentSlide >= React.Children.count(_this.props.children)) {
          _this.changeSlide({
            message: "index",
            index: React.Children.count(_this.props.children) - _this.props.slidesToShow,
            currentSlide: _this.state.currentSlide
          });
        }
        if (prevProps.autoplay !== _this.props.autoplay || prevProps.autoplaySpeed !== _this.props.autoplaySpeed) {
          if (!prevProps.autoplay && _this.props.autoplay) {
            _this.autoPlay("playing");
          } else if (_this.props.autoplay) {
            _this.autoPlay("update");
          } else {
            _this.pause("paused");
          }
        }
      });
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "onWindowResized", function(setTrackStyle) {
      if (_this.debouncedResize)
        _this.debouncedResize.cancel();
      _this.debouncedResize = debounce_1(50, function() {
        return _this.resizeWindow(setTrackStyle);
      });
      _this.debouncedResize();
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "resizeWindow", function() {
      var setTrackStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var isTrackMounted = Boolean(_this.track && _this.track.node);
      if (!isTrackMounted)
        return;
      var spec = _objectSpread2$d(_objectSpread2$d({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props), _this.state);
      _this.updateState(spec, setTrackStyle, function() {
        if (_this.props.autoplay)
          _this.autoPlay("update");
        else
          _this.pause("paused");
      });
      _this.setState({
        animating: false
      });
      clearTimeout(_this.animationEndCallback);
      delete _this.animationEndCallback;
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "updateState", function(spec, setTrackStyle, callback) {
      var updatedState = initializedState(spec);
      spec = _objectSpread2$d(_objectSpread2$d(_objectSpread2$d({}, spec), updatedState), {}, {
        slideIndex: updatedState.currentSlide
      });
      var targetLeft = getTrackLeft(spec);
      spec = _objectSpread2$d(_objectSpread2$d({}, spec), {}, {
        left: targetLeft
      });
      var trackStyle = getTrackCSS(spec);
      if (setTrackStyle || React.Children.count(_this.props.children) !== React.Children.count(spec.children)) {
        updatedState["trackStyle"] = trackStyle;
      }
      _this.setState(updatedState, callback);
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "ssrInit", function() {
      if (_this.props.variableWidth) {
        var _trackWidth = 0, _trackLeft = 0;
        var childrenWidths = [];
        var preClones = getPreClones(_objectSpread2$d(_objectSpread2$d(_objectSpread2$d({}, _this.props), _this.state), {}, {
          slideCount: _this.props.children.length
        }));
        var postClones = getPostClones(_objectSpread2$d(_objectSpread2$d(_objectSpread2$d({}, _this.props), _this.state), {}, {
          slideCount: _this.props.children.length
        }));
        _this.props.children.forEach(function(child) {
          childrenWidths.push(child.props.style.width);
          _trackWidth += child.props.style.width;
        });
        for (var i = 0; i < preClones; i++) {
          _trackLeft += childrenWidths[childrenWidths.length - 1 - i];
          _trackWidth += childrenWidths[childrenWidths.length - 1 - i];
        }
        for (var _i2 = 0; _i2 < postClones; _i2++) {
          _trackWidth += childrenWidths[_i2];
        }
        for (var _i22 = 0; _i22 < _this.state.currentSlide; _i22++) {
          _trackLeft += childrenWidths[_i22];
        }
        var _trackStyle = {
          width: _trackWidth + "px",
          left: -_trackLeft + "px"
        };
        if (_this.props.centerMode) {
          var currentWidth = "".concat(childrenWidths[_this.state.currentSlide], "px");
          _trackStyle.left = "calc(".concat(_trackStyle.left, " + (100% - ").concat(currentWidth, ") / 2 ) ");
        }
        return {
          trackStyle: _trackStyle
        };
      }
      var childrenCount = React.Children.count(_this.props.children);
      var spec = _objectSpread2$d(_objectSpread2$d(_objectSpread2$d({}, _this.props), _this.state), {}, {
        slideCount: childrenCount
      });
      var slideCount = getPreClones(spec) + getPostClones(spec) + childrenCount;
      var trackWidth = 100 / _this.props.slidesToShow * slideCount;
      var slideWidth = 100 / slideCount;
      var trackLeft = -slideWidth * (getPreClones(spec) + _this.state.currentSlide) * trackWidth / 100;
      if (_this.props.centerMode) {
        trackLeft += (100 - slideWidth * trackWidth / 100) / 2;
      }
      var trackStyle = {
        width: trackWidth + "%",
        left: trackLeft + "%"
      };
      return {
        slideWidth: slideWidth + "%",
        trackStyle
      };
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "checkImagesLoad", function() {
      var images = _this.list && _this.list.querySelectorAll && _this.list.querySelectorAll(".slick-slide img") || [];
      var imagesCount = images.length, loadedCount = 0;
      Array.prototype.forEach.call(images, function(image2) {
        var handler = function handler2() {
          return ++loadedCount && loadedCount >= imagesCount && _this.onWindowResized();
        };
        if (!image2.onclick) {
          image2.onclick = function() {
            return image2.parentNode.focus();
          };
        } else {
          var prevClickHandler = image2.onclick;
          image2.onclick = function(e2) {
            prevClickHandler(e2);
            image2.parentNode.focus();
          };
        }
        if (!image2.onload) {
          if (_this.props.lazyLoad) {
            image2.onload = function() {
              _this.adaptHeight();
              _this.callbackTimers.push(setTimeout(_this.onWindowResized, _this.props.speed));
            };
          } else {
            image2.onload = handler;
            image2.onerror = function() {
              handler();
              _this.props.onLazyLoadError && _this.props.onLazyLoadError();
            };
          }
        }
      });
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "progressiveLazyLoad", function() {
      var slidesToLoad = [];
      var spec = _objectSpread2$d(_objectSpread2$d({}, _this.props), _this.state);
      for (var index2 = _this.state.currentSlide; index2 < _this.state.slideCount + getPostClones(spec); index2++) {
        if (_this.state.lazyLoadedList.indexOf(index2) < 0) {
          slidesToLoad.push(index2);
          break;
        }
      }
      for (var _index2 = _this.state.currentSlide - 1; _index2 >= -getPreClones(spec); _index2--) {
        if (_this.state.lazyLoadedList.indexOf(_index2) < 0) {
          slidesToLoad.push(_index2);
          break;
        }
      }
      if (slidesToLoad.length > 0) {
        _this.setState(function(state) {
          return {
            lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)
          };
        });
        if (_this.props.onLazyLoad) {
          _this.props.onLazyLoad(slidesToLoad);
        }
      } else {
        if (_this.lazyLoadTimer) {
          clearInterval(_this.lazyLoadTimer);
          delete _this.lazyLoadTimer;
        }
      }
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "slideHandler", function(index2) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _this$props = _this.props, asNavFor = _this$props.asNavFor, beforeChange = _this$props.beforeChange, onLazyLoad = _this$props.onLazyLoad, speed = _this$props.speed, afterChange = _this$props.afterChange;
      var currentSlide = _this.state.currentSlide;
      var _slideHandler = slideHandler(_objectSpread2$d(_objectSpread2$d(_objectSpread2$d({
        index: index2
      }, _this.props), _this.state), {}, {
        trackRef: _this.track,
        useCSS: _this.props.useCSS && !dontAnimate
      })), state = _slideHandler.state, nextState = _slideHandler.nextState;
      if (!state)
        return;
      beforeChange && beforeChange(currentSlide, state.currentSlide);
      var slidesToLoad = state.lazyLoadedList.filter(function(value) {
        return _this.state.lazyLoadedList.indexOf(value) < 0;
      });
      onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);
      if (!_this.props.waitForAnimate && _this.animationEndCallback) {
        clearTimeout(_this.animationEndCallback);
        afterChange && afterChange(currentSlide);
        delete _this.animationEndCallback;
      }
      _this.setState(state, function() {
        if (asNavFor && _this.asNavForIndex !== index2) {
          _this.asNavForIndex = index2;
          asNavFor.innerSlider.slideHandler(index2);
        }
        if (!nextState)
          return;
        _this.animationEndCallback = setTimeout(function() {
          var animating = nextState.animating, firstBatch = _objectWithoutProperties$1(nextState, _excluded$6);
          _this.setState(firstBatch, function() {
            _this.callbackTimers.push(setTimeout(function() {
              return _this.setState({
                animating
              });
            }, 10));
            afterChange && afterChange(state.currentSlide);
            delete _this.animationEndCallback;
          });
        }, speed);
      });
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "changeSlide", function(options) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var spec = _objectSpread2$d(_objectSpread2$d({}, _this.props), _this.state);
      var targetSlide = changeSlide(spec, options);
      if (targetSlide !== 0 && !targetSlide)
        return;
      if (dontAnimate === true) {
        _this.slideHandler(targetSlide, dontAnimate);
      } else {
        _this.slideHandler(targetSlide);
      }
      _this.props.autoplay && _this.autoPlay("update");
      if (_this.props.focusOnSelect) {
        var nodes = _this.list.querySelectorAll(".slick-current");
        nodes[0] && nodes[0].focus();
      }
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "clickHandler", function(e2) {
      if (_this.clickable === false) {
        e2.stopPropagation();
        e2.preventDefault();
      }
      _this.clickable = true;
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "keyHandler", function(e2) {
      var dir = keyHandler(e2, _this.props.accessibility, _this.props.rtl);
      dir !== "" && _this.changeSlide({
        message: dir
      });
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "selectHandler", function(options) {
      _this.changeSlide(options);
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "disableBodyScroll", function() {
      var preventDefault = function preventDefault2(e2) {
        e2 = e2 || window.event;
        if (e2.preventDefault)
          e2.preventDefault();
        e2.returnValue = false;
      };
      window.ontouchmove = preventDefault;
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "enableBodyScroll", function() {
      window.ontouchmove = null;
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "swipeStart", function(e2) {
      if (_this.props.verticalSwiping) {
        _this.disableBodyScroll();
      }
      var state = swipeStart(e2, _this.props.swipe, _this.props.draggable);
      state !== "" && _this.setState(state);
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "swipeMove", function(e2) {
      var state = swipeMove(e2, _objectSpread2$d(_objectSpread2$d(_objectSpread2$d({}, _this.props), _this.state), {}, {
        trackRef: _this.track,
        listRef: _this.list,
        slideIndex: _this.state.currentSlide
      }));
      if (!state)
        return;
      if (state["swiping"]) {
        _this.clickable = false;
      }
      _this.setState(state);
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "swipeEnd", function(e2) {
      var state = swipeEnd(e2, _objectSpread2$d(_objectSpread2$d(_objectSpread2$d({}, _this.props), _this.state), {}, {
        trackRef: _this.track,
        listRef: _this.list,
        slideIndex: _this.state.currentSlide
      }));
      if (!state)
        return;
      var triggerSlideHandler = state["triggerSlideHandler"];
      delete state["triggerSlideHandler"];
      _this.setState(state);
      if (triggerSlideHandler === void 0)
        return;
      _this.slideHandler(triggerSlideHandler);
      if (_this.props.verticalSwiping) {
        _this.enableBodyScroll();
      }
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "touchEnd", function(e2) {
      _this.swipeEnd(e2);
      _this.clickable = true;
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "slickPrev", function() {
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "previous"
        });
      }, 0));
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "slickNext", function() {
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "next"
        });
      }, 0));
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "slickGoTo", function(slide) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      slide = Number(slide);
      if (isNaN(slide))
        return "";
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "index",
          index: slide,
          currentSlide: _this.state.currentSlide
        }, dontAnimate);
      }, 0));
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "play", function() {
      var nextIndex;
      if (_this.props.rtl) {
        nextIndex = _this.state.currentSlide - _this.props.slidesToScroll;
      } else {
        if (canGoNext(_objectSpread2$d(_objectSpread2$d({}, _this.props), _this.state))) {
          nextIndex = _this.state.currentSlide + _this.props.slidesToScroll;
        } else {
          return false;
        }
      }
      _this.slideHandler(nextIndex);
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "autoPlay", function(playType) {
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
      }
      var autoplaying = _this.state.autoplaying;
      if (playType === "update") {
        if (autoplaying === "hovered" || autoplaying === "focused" || autoplaying === "paused") {
          return;
        }
      } else if (playType === "leave") {
        if (autoplaying === "paused" || autoplaying === "focused") {
          return;
        }
      } else if (playType === "blur") {
        if (autoplaying === "paused" || autoplaying === "hovered") {
          return;
        }
      }
      _this.autoplayTimer = setInterval(_this.play, _this.props.autoplaySpeed + 50);
      _this.setState({
        autoplaying: "playing"
      });
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "pause", function(pauseType) {
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
        _this.autoplayTimer = null;
      }
      var autoplaying = _this.state.autoplaying;
      if (pauseType === "paused") {
        _this.setState({
          autoplaying: "paused"
        });
      } else if (pauseType === "focused") {
        if (autoplaying === "hovered" || autoplaying === "playing") {
          _this.setState({
            autoplaying: "focused"
          });
        }
      } else {
        if (autoplaying === "playing") {
          _this.setState({
            autoplaying: "hovered"
          });
        }
      }
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "onDotsOver", function() {
      return _this.props.autoplay && _this.pause("hovered");
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "onDotsLeave", function() {
      return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "onTrackOver", function() {
      return _this.props.autoplay && _this.pause("hovered");
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "onTrackLeave", function() {
      return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "onSlideFocus", function() {
      return _this.props.autoplay && _this.pause("focused");
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "onSlideBlur", function() {
      return _this.props.autoplay && _this.state.autoplaying === "focused" && _this.autoPlay("blur");
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "render", function() {
      var className = classNames("slick-slider", _this.props.className, {
        "slick-vertical": _this.props.vertical,
        "slick-initialized": true
      });
      var spec = _objectSpread2$d(_objectSpread2$d({}, _this.props), _this.state);
      var trackProps = extractObject(spec, ["fade", "cssEase", "speed", "infinite", "centerMode", "focusOnSelect", "currentSlide", "lazyLoad", "lazyLoadedList", "rtl", "slideWidth", "slideHeight", "listHeight", "vertical", "slidesToShow", "slidesToScroll", "slideCount", "trackStyle", "variableWidth", "unslick", "centerPadding", "targetSlide", "useCSS"]);
      var pauseOnHover = _this.props.pauseOnHover;
      trackProps = _objectSpread2$d(_objectSpread2$d({}, trackProps), {}, {
        onMouseEnter: pauseOnHover ? _this.onTrackOver : null,
        onMouseLeave: pauseOnHover ? _this.onTrackLeave : null,
        onMouseOver: pauseOnHover ? _this.onTrackOver : null,
        focusOnSelect: _this.props.focusOnSelect && _this.clickable ? _this.selectHandler : null
      });
      var dots;
      if (_this.props.dots === true && _this.state.slideCount >= _this.props.slidesToShow) {
        var dotProps = extractObject(spec, ["dotsClass", "slideCount", "slidesToShow", "currentSlide", "slidesToScroll", "clickHandler", "children", "customPaging", "infinite", "appendDots"]);
        var pauseOnDotsHover = _this.props.pauseOnDotsHover;
        dotProps = _objectSpread2$d(_objectSpread2$d({}, dotProps), {}, {
          clickHandler: _this.changeSlide,
          onMouseEnter: pauseOnDotsHover ? _this.onDotsLeave : null,
          onMouseOver: pauseOnDotsHover ? _this.onDotsOver : null,
          onMouseLeave: pauseOnDotsHover ? _this.onDotsLeave : null
        });
        dots = /* @__PURE__ */ React.createElement(Dots, dotProps);
      }
      var prevArrow, nextArrow;
      var arrowProps = extractObject(spec, ["infinite", "centerMode", "currentSlide", "slideCount", "slidesToShow", "prevArrow", "nextArrow"]);
      arrowProps.clickHandler = _this.changeSlide;
      if (_this.props.arrows) {
        prevArrow = /* @__PURE__ */ React.createElement(PrevArrow, arrowProps);
        nextArrow = /* @__PURE__ */ React.createElement(NextArrow, arrowProps);
      }
      var verticalHeightStyle = null;
      if (_this.props.vertical) {
        verticalHeightStyle = {
          height: _this.state.listHeight
        };
      }
      var centerPaddingStyle = null;
      if (_this.props.vertical === false) {
        if (_this.props.centerMode === true) {
          centerPaddingStyle = {
            padding: "0px " + _this.props.centerPadding
          };
        }
      } else {
        if (_this.props.centerMode === true) {
          centerPaddingStyle = {
            padding: _this.props.centerPadding + " 0px"
          };
        }
      }
      var listStyle = _objectSpread2$d(_objectSpread2$d({}, verticalHeightStyle), centerPaddingStyle);
      var touchMove = _this.props.touchMove;
      var listProps = {
        className: "slick-list",
        style: listStyle,
        onClick: _this.clickHandler,
        onMouseDown: touchMove ? _this.swipeStart : null,
        onMouseMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
        onMouseUp: touchMove ? _this.swipeEnd : null,
        onMouseLeave: _this.state.dragging && touchMove ? _this.swipeEnd : null,
        onTouchStart: touchMove ? _this.swipeStart : null,
        onTouchMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
        onTouchEnd: touchMove ? _this.touchEnd : null,
        onTouchCancel: _this.state.dragging && touchMove ? _this.swipeEnd : null,
        onKeyDown: _this.props.accessibility ? _this.keyHandler : null
      };
      var innerSliderProps = {
        className,
        dir: "ltr",
        style: _this.props.style
      };
      if (_this.props.unslick) {
        listProps = {
          className: "slick-list"
        };
        innerSliderProps = {
          className
        };
      }
      return /* @__PURE__ */ React.createElement("div", innerSliderProps, !_this.props.unslick ? prevArrow : "", /* @__PURE__ */ React.createElement("div", _extends$3({
        ref: _this.listRefHandler
      }, listProps), /* @__PURE__ */ React.createElement(Track, _extends$3({
        ref: _this.trackRefHandler
      }, trackProps), _this.props.children)), !_this.props.unslick ? nextArrow : "", !_this.props.unslick ? dots : "");
    });
    _this.list = null;
    _this.track = null;
    _this.state = _objectSpread2$d(_objectSpread2$d({}, initialState), {}, {
      currentSlide: _this.props.initialSlide,
      slideCount: React.Children.count(_this.props.children)
    });
    _this.callbackTimers = [];
    _this.clickable = true;
    _this.debouncedResize = null;
    var ssrState = _this.ssrInit();
    _this.state = _objectSpread2$d(_objectSpread2$d({}, _this.state), ssrState);
    return _this;
  }
  _createClass$2(InnerSlider2, [{
    key: "didPropsChange",
    value: function didPropsChange(prevProps) {
      var setTrackStyle = false;
      for (var _i3 = 0, _Object$keys = Object.keys(this.props); _i3 < _Object$keys.length; _i3++) {
        var key = _Object$keys[_i3];
        if (!prevProps.hasOwnProperty(key)) {
          setTrackStyle = true;
          break;
        }
        if (_typeof$8(prevProps[key]) === "object" || typeof prevProps[key] === "function") {
          continue;
        }
        if (prevProps[key] !== this.props[key]) {
          setTrackStyle = true;
          break;
        }
      }
      return setTrackStyle || React.Children.count(this.props.children) !== React.Children.count(prevProps.children);
    }
  }]);
  return InnerSlider2;
}(React.Component);
var camel2hyphen$1 = function(str) {
  return str.replace(/[A-Z]/g, function(match2) {
    return "-" + match2.toLowerCase();
  }).toLowerCase();
};
var camel2hyphen_1 = camel2hyphen$1;
var camel2hyphen = camel2hyphen_1;
var isDimension = function(feature) {
  var re2 = /[height|width]$/;
  return re2.test(feature);
};
var obj2mq = function(obj) {
  var mq = "";
  var features = Object.keys(obj);
  features.forEach(function(feature, index2) {
    var value = obj[feature];
    feature = camel2hyphen(feature);
    if (isDimension(feature) && typeof value === "number") {
      value = value + "px";
    }
    if (value === true) {
      mq += feature;
    } else if (value === false) {
      mq += "not " + feature;
    } else {
      mq += "(" + feature + ": " + value + ")";
    }
    if (index2 < features.length - 1) {
      mq += " and ";
    }
  });
  return mq;
};
var json2mq = function(query) {
  var mq = "";
  if (typeof query === "string") {
    return query;
  }
  if (query instanceof Array) {
    query.forEach(function(q2, index2) {
      mq += obj2mq(q2);
      if (index2 < query.length - 1) {
        mq += ", ";
      }
    });
    return mq;
  }
  return obj2mq(query);
};
var json2mq_1 = json2mq;
var defaultProps = {
  accessibility: true,
  adaptiveHeight: false,
  afterChange: null,
  appendDots: function appendDots(dots) {
    return /* @__PURE__ */ React.createElement("ul", {
      style: {
        display: "block"
      }
    }, dots);
  },
  arrows: true,
  autoplay: false,
  autoplaySpeed: 3e3,
  beforeChange: null,
  centerMode: false,
  centerPadding: "50px",
  className: "",
  cssEase: "ease",
  customPaging: function customPaging(i) {
    return /* @__PURE__ */ React.createElement("button", null, i + 1);
  },
  dots: false,
  dotsClass: "slick-dots",
  draggable: true,
  easing: "linear",
  edgeFriction: 0.35,
  fade: false,
  focusOnSelect: false,
  infinite: true,
  initialSlide: 0,
  lazyLoad: null,
  nextArrow: null,
  onEdge: null,
  onInit: null,
  onLazyLoadError: null,
  onReInit: null,
  pauseOnDotsHover: false,
  pauseOnFocus: false,
  pauseOnHover: true,
  prevArrow: null,
  responsive: null,
  rows: 1,
  rtl: false,
  slide: "div",
  slidesPerRow: 1,
  slidesToScroll: 1,
  slidesToShow: 1,
  speed: 500,
  swipe: true,
  swipeEvent: null,
  swipeToSlide: false,
  touchMove: true,
  touchThreshold: 5,
  useCSS: true,
  useTransform: true,
  variableWidth: false,
  vertical: false,
  waitForAnimate: true
};
var Slider = /* @__PURE__ */ function(_React$Component) {
  _inherits$2(Slider2, _React$Component);
  var _super = _createSuper$2(Slider2);
  function Slider2(props) {
    var _this;
    _classCallCheck$2(this, Slider2);
    _this = _super.call(this, props);
    _defineProperty$3(_assertThisInitialized$2(_this), "innerSliderRefHandler", function(ref2) {
      return _this.innerSlider = ref2;
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "slickPrev", function() {
      return _this.innerSlider.slickPrev();
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "slickNext", function() {
      return _this.innerSlider.slickNext();
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "slickGoTo", function(slide) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return _this.innerSlider.slickGoTo(slide, dontAnimate);
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "slickPause", function() {
      return _this.innerSlider.pause("paused");
    });
    _defineProperty$3(_assertThisInitialized$2(_this), "slickPlay", function() {
      return _this.innerSlider.autoPlay("play");
    });
    _this.state = {
      breakpoint: null
    };
    _this._responsiveMediaHandlers = [];
    return _this;
  }
  _createClass$2(Slider2, [{
    key: "media",
    value: function media(query, handler) {
      var mql = window.matchMedia(query);
      var listener = function listener2(_ref2) {
        var matches = _ref2.matches;
        if (matches) {
          handler();
        }
      };
      mql.addListener(listener);
      listener(mql);
      this._responsiveMediaHandlers.push({
        mql,
        query,
        listener
      });
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      if (this.props.responsive) {
        var breakpoints = this.props.responsive.map(function(breakpt) {
          return breakpt.breakpoint;
        });
        breakpoints.sort(function(x2, y2) {
          return x2 - y2;
        });
        breakpoints.forEach(function(breakpoint, index2) {
          var bQuery;
          if (index2 === 0) {
            bQuery = json2mq_1({
              minWidth: 0,
              maxWidth: breakpoint
            });
          } else {
            bQuery = json2mq_1({
              minWidth: breakpoints[index2 - 1] + 1,
              maxWidth: breakpoint
            });
          }
          canUseDOM() && _this2.media(bQuery, function() {
            _this2.setState({
              breakpoint
            });
          });
        });
        var query = json2mq_1({
          minWidth: breakpoints.slice(-1)[0]
        });
        canUseDOM() && this.media(query, function() {
          _this2.setState({
            breakpoint: null
          });
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._responsiveMediaHandlers.forEach(function(obj) {
        obj.mql.removeListener(obj.listener);
      });
    }
  }, {
    key: "render",
    value: function render2() {
      var _this3 = this;
      var settings;
      var newProps;
      if (this.state.breakpoint) {
        newProps = this.props.responsive.filter(function(resp) {
          return resp.breakpoint === _this3.state.breakpoint;
        });
        settings = newProps[0].settings === "unslick" ? "unslick" : _objectSpread2$d(_objectSpread2$d(_objectSpread2$d({}, defaultProps), this.props), newProps[0].settings);
      } else {
        settings = _objectSpread2$d(_objectSpread2$d({}, defaultProps), this.props);
      }
      if (settings.centerMode) {
        if (settings.slidesToScroll > 1 && false) {
          console.warn("slidesToScroll should be equal to 1 in centerMode, you are using ".concat(settings.slidesToScroll));
        }
        settings.slidesToScroll = 1;
      }
      if (settings.fade) {
        if (settings.slidesToShow > 1 && false) {
          console.warn("slidesToShow should be equal to 1 when fade is true, you're using ".concat(settings.slidesToShow));
        }
        if (settings.slidesToScroll > 1 && false) {
          console.warn("slidesToScroll should be equal to 1 when fade is true, you're using ".concat(settings.slidesToScroll));
        }
        settings.slidesToShow = 1;
        settings.slidesToScroll = 1;
      }
      var children = React.Children.toArray(this.props.children);
      children = children.filter(function(child) {
        if (typeof child === "string") {
          return !!child.trim();
        }
        return !!child;
      });
      if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {
        console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1");
        settings.variableWidth = false;
      }
      var newChildren = [];
      var currentWidth = null;
      for (var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {
        var newSlide = [];
        for (var j2 = i; j2 < i + settings.rows * settings.slidesPerRow; j2 += settings.slidesPerRow) {
          var row = [];
          for (var k2 = j2; k2 < j2 + settings.slidesPerRow; k2 += 1) {
            if (settings.variableWidth && children[k2].props.style) {
              currentWidth = children[k2].props.style.width;
            }
            if (k2 >= children.length)
              break;
            row.push(/* @__PURE__ */ React.cloneElement(children[k2], {
              key: 100 * i + 10 * j2 + k2,
              tabIndex: -1,
              style: {
                width: "".concat(100 / settings.slidesPerRow, "%"),
                display: "inline-block"
              }
            }));
          }
          newSlide.push(/* @__PURE__ */ React.createElement("div", {
            key: 10 * i + j2
          }, row));
        }
        if (settings.variableWidth) {
          newChildren.push(/* @__PURE__ */ React.createElement("div", {
            key: i,
            style: {
              width: currentWidth
            }
          }, newSlide));
        } else {
          newChildren.push(/* @__PURE__ */ React.createElement("div", {
            key: i
          }, newSlide));
        }
      }
      if (settings === "unslick") {
        var className = "regular slider " + (this.props.className || "");
        return /* @__PURE__ */ React.createElement("div", {
          className
        }, children);
      } else if (newChildren.length <= settings.slidesToShow) {
        settings.unslick = true;
      }
      return /* @__PURE__ */ React.createElement(InnerSlider, _extends$3({
        style: this.props.style,
        ref: this.innerSliderRefHandler
      }, settings), newChildren);
    }
  }]);
  return Slider2;
}(React.Component);
const genCarouselStyle = (token2) => {
  const {
    componentCls,
    antCls,
    carouselArrowSize,
    carouselDotOffset,
    marginXXS
  } = token2;
  const arrowOffset = -carouselArrowSize * 1.25;
  const carouselDotMargin = marginXXS;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      ".slick-slider": {
        position: "relative",
        display: "block",
        boxSizing: "border-box",
        touchAction: "pan-y",
        WebkitTouchCallout: "none",
        WebkitTapHighlightColor: "transparent",
        ".slick-track, .slick-list": {
          transform: "translate3d(0, 0, 0)",
          touchAction: "pan-y"
        }
      },
      ".slick-list": {
        position: "relative",
        display: "block",
        margin: 0,
        padding: 0,
        overflow: "hidden",
        "&:focus": {
          outline: "none"
        },
        "&.dragging": {
          cursor: "pointer"
        },
        ".slick-slide": {
          pointerEvents: "none",
          [`input${antCls}-radio-input, input${antCls}-checkbox-input`]: {
            visibility: "hidden"
          },
          "&.slick-active": {
            pointerEvents: "auto",
            [`input${antCls}-radio-input, input${antCls}-checkbox-input`]: {
              visibility: "visible"
            }
          },
          "> div > div": {
            verticalAlign: "bottom"
          }
        }
      },
      ".slick-track": {
        position: "relative",
        top: 0,
        insetInlineStart: 0,
        display: "block",
        "&::before, &::after": {
          display: "table",
          content: '""'
        },
        "&::after": {
          clear: "both"
        }
      },
      ".slick-slide": {
        display: "none",
        float: "left",
        height: "100%",
        minHeight: 1,
        img: {
          display: "block"
        },
        "&.dragging img": {
          pointerEvents: "none"
        }
      },
      ".slick-initialized .slick-slide": {
        display: "block"
      },
      ".slick-vertical .slick-slide": {
        display: "block",
        height: "auto"
      },
      ".slick-arrow.slick-hidden": {
        display: "none"
      },
      ".slick-prev, .slick-next": {
        position: "absolute",
        top: "50%",
        display: "block",
        width: carouselArrowSize,
        height: carouselArrowSize,
        marginTop: -carouselArrowSize / 2,
        padding: 0,
        color: "transparent",
        fontSize: 0,
        lineHeight: 0,
        background: "transparent",
        border: 0,
        outline: "none",
        cursor: "pointer",
        "&:hover, &:focus": {
          color: "transparent",
          background: "transparent",
          outline: "none",
          "&::before": {
            opacity: 1
          }
        },
        "&.slick-disabled::before": {
          opacity: 0.25
        }
      },
      ".slick-prev": {
        insetInlineStart: arrowOffset,
        "&::before": {
          content: '"\u2190"'
        }
      },
      ".slick-next": {
        insetInlineEnd: arrowOffset,
        "&::before": {
          content: '"\u2192"'
        }
      },
      ".slick-dots": {
        position: "absolute",
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 15,
        display: "flex !important",
        justifyContent: "center",
        paddingInlineStart: 0,
        listStyle: "none",
        "&-bottom": {
          bottom: carouselDotOffset
        },
        "&-top": {
          top: carouselDotOffset,
          bottom: "auto"
        },
        li: {
          position: "relative",
          display: "inline-block",
          flex: "0 1 auto",
          boxSizing: "content-box",
          width: token2.dotWidth,
          height: token2.dotHeight,
          marginInline: carouselDotMargin,
          padding: 0,
          textAlign: "center",
          textIndent: -999,
          verticalAlign: "top",
          transition: `all ${token2.motionDurationSlow}`,
          button: {
            position: "relative",
            display: "block",
            width: "100%",
            height: token2.dotHeight,
            padding: 0,
            color: "transparent",
            fontSize: 0,
            background: token2.colorBgContainer,
            border: 0,
            borderRadius: 1,
            outline: "none",
            cursor: "pointer",
            opacity: 0.3,
            transition: `all ${token2.motionDurationSlow}`,
            "&: hover, &:focus": {
              opacity: 0.75
            },
            "&::after": {
              position: "absolute",
              inset: -carouselDotMargin,
              content: '""'
            }
          },
          "&.slick-active": {
            width: token2.dotWidthActive,
            "& button": {
              background: token2.colorBgContainer,
              opacity: 1
            },
            "&: hover, &:focus": {
              opacity: 1
            }
          }
        }
      }
    })
  };
};
const genCarouselVerticalStyle = (token2) => {
  const {
    componentCls,
    carouselDotOffset,
    marginXXS
  } = token2;
  const reverseSizeOfDot = {
    width: token2.dotHeight,
    height: token2.dotWidth
  };
  return {
    [`${componentCls}-vertical`]: {
      ".slick-dots": {
        top: "50%",
        bottom: "auto",
        flexDirection: "column",
        width: token2.dotHeight,
        height: "auto",
        margin: 0,
        transform: "translateY(-50%)",
        "&-left": {
          insetInlineEnd: "auto",
          insetInlineStart: carouselDotOffset
        },
        "&-right": {
          insetInlineEnd: carouselDotOffset,
          insetInlineStart: "auto"
        },
        li: Object.assign(Object.assign({}, reverseSizeOfDot), {
          margin: `${marginXXS}px 0`,
          verticalAlign: "baseline",
          button: reverseSizeOfDot,
          "&.slick-active": Object.assign(Object.assign({}, reverseSizeOfDot), {
            button: reverseSizeOfDot
          })
        })
      }
    }
  };
};
const genCarouselRtlStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return [{
    [`${componentCls}-rtl`]: {
      direction: "rtl",
      ".slick-dots": {
        [`${componentCls}-rtl&`]: {
          flexDirection: "row-reverse"
        }
      }
    }
  }, {
    [`${componentCls}-vertical`]: {
      ".slick-dots": {
        [`${componentCls}-rtl&`]: {
          flexDirection: "column"
        }
      }
    }
  }];
};
var useStyle$6 = genComponentStyleHook$2("Carousel", (token2) => {
  const {
    controlHeightLG,
    controlHeightSM
  } = token2;
  const carouselToken = merge$1(token2, {
    carouselArrowSize: controlHeightLG / 2,
    carouselDotOffset: controlHeightSM / 2
  });
  return [genCarouselStyle(carouselToken), genCarouselVerticalStyle(carouselToken), genCarouselRtlStyle(carouselToken)];
}, {
  dotWidth: 16,
  dotHeight: 3,
  dotWidthActive: 24
});
var __rest$g = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const Carousel = /* @__PURE__ */ React.forwardRef((_a2, ref2) => {
  var {
    dots = true,
    arrows = false,
    draggable = false,
    dotPosition = "bottom",
    vertical = dotPosition === "left" || dotPosition === "right",
    rootClassName
  } = _a2, props = __rest$g(_a2, ["dots", "arrows", "draggable", "dotPosition", "vertical", "rootClassName"]);
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext$1);
  const slickRef = React.useRef();
  const goTo = function(slide) {
    let dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    slickRef.current.slickGoTo(slide, dontAnimate);
  };
  React.useImperativeHandle(ref2, () => ({
    goTo,
    autoPlay: slickRef.current.innerSlider.autoPlay,
    innerSlider: slickRef.current.innerSlider,
    prev: slickRef.current.slickPrev,
    next: slickRef.current.slickNext
  }), [slickRef.current]);
  const prevCount = React.useRef(React.Children.count(props.children));
  React.useEffect(() => {
    if (prevCount.current !== React.Children.count(props.children)) {
      goTo(props.initialSlide || 0, false);
      prevCount.current = React.Children.count(props.children);
    }
  }, [props.children]);
  const newProps = Object.assign({
    vertical
  }, props);
  if (newProps.effect === "fade") {
    newProps.fade = true;
  }
  const prefixCls = getPrefixCls("carousel", newProps.prefixCls);
  const dotsClass = "slick-dots";
  const enableDots = !!dots;
  const dsClass = classNames(dotsClass, `${dotsClass}-${dotPosition}`, typeof dots === "boolean" ? false : dots === null || dots === void 0 ? void 0 : dots.className);
  const [wrapSSR, hashId] = useStyle$6(prefixCls);
  const className = classNames(prefixCls, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-vertical`]: newProps.vertical
  }, hashId, rootClassName);
  return wrapSSR(/* @__PURE__ */ React.createElement("div", {
    className
  }, /* @__PURE__ */ React.createElement(Slider, Object.assign({
    ref: slickRef
  }, newProps, {
    dots: enableDots,
    dotsClass: dsClass,
    arrows,
    draggable
  }))));
});
var Carousel$1 = Carousel;
function useEvent(callback) {
  var fnRef = React.useRef();
  fnRef.current = callback;
  var memoFn = React.useCallback(function() {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
var Source;
(function(Source2) {
  Source2[Source2["INNER"] = 0] = "INNER";
  Source2[Source2["PROP"] = 1] = "PROP";
})(Source || (Source = {}));
function hasValue(value) {
  return value !== void 0;
}
function useMergedState(defaultStateValue, option) {
  var _ref2 = option || {}, defaultValue = _ref2.defaultValue, value = _ref2.value, onChange = _ref2.onChange, postState = _ref2.postState;
  var _useState = useSafeState$4(function() {
    var finalValue = void 0;
    var source;
    if (hasValue(value)) {
      finalValue = value;
      source = Source.PROP;
    } else if (hasValue(defaultValue)) {
      finalValue = typeof defaultValue === "function" ? defaultValue() : defaultValue;
      source = Source.PROP;
    } else {
      finalValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
      source = Source.INNER;
    }
    return [finalValue, source, finalValue];
  }), _useState2 = _slicedToArray$1(_useState, 2), mergedValue = _useState2[0], setMergedValue = _useState2[1];
  var chosenValue = hasValue(value) ? value : mergedValue[0];
  var postMergedValue = postState ? postState(chosenValue) : chosenValue;
  useLayoutUpdateEffect$2(function() {
    setMergedValue(function(_ref22) {
      var _ref3 = _slicedToArray$1(_ref22, 1), prevValue = _ref3[0];
      return [value, Source.PROP, prevValue];
    });
  }, [value]);
  var changeEventPrevRef = React.useRef();
  var triggerChange = useEvent(function(updater, ignoreDestroy) {
    setMergedValue(function(prev2) {
      var _prev = _slicedToArray$1(prev2, 3), prevValue = _prev[0], prevSource = _prev[1], prevPrevValue = _prev[2];
      var nextValue = typeof updater === "function" ? updater(prevValue) : updater;
      if (nextValue === prevValue) {
        return prev2;
      }
      var overridePrevValue = prevSource === Source.INNER && changeEventPrevRef.current !== prevPrevValue ? prevPrevValue : prevValue;
      return [nextValue, Source.INNER, overridePrevValue];
    }, ignoreDestroy);
  });
  var onChangeFn = useEvent(onChange);
  useLayoutEffect$8(function() {
    var _mergedValue = _slicedToArray$1(mergedValue, 3), current = _mergedValue[0], source = _mergedValue[1], prev2 = _mergedValue[2];
    if (current !== prev2 && source === Source.INNER) {
      onChangeFn(current, prev2);
      changeEventPrevRef.current = prev2;
    }
  }, [mergedValue]);
  return [postMergedValue, triggerChange];
}
var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
var ariaPrefix = "aria-";
var dataPrefix = "data-";
function match(key, prefix2) {
  return key.indexOf(prefix2) === 0;
}
function pickAttrs(props) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _objectSpread2$d({}, ariaOnly);
  }
  var attrs = {};
  Object.keys(props).forEach(function(key) {
    if (mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || mergedConfig.data && match(key, dataPrefix) || mergedConfig.attr && propList.includes(key)) {
      attrs[key] = props[key];
    }
  });
  return attrs;
}
function omit$2(obj, fields) {
  var clone2 = _objectSpread2$d({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function(key) {
      delete clone2[key];
    });
  }
  return clone2;
}
const RowContext = /* @__PURE__ */ React.createContext({});
var RowContext$1 = RowContext;
const genGridRowStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "flex",
      flexFlow: "row wrap",
      minWidth: 0,
      "&::before, &::after": {
        display: "flex"
      },
      "&-no-wrap": {
        flexWrap: "nowrap"
      },
      "&-start": {
        justifyContent: "flex-start"
      },
      "&-center": {
        justifyContent: "center"
      },
      "&-end": {
        justifyContent: "flex-end"
      },
      "&-space-between": {
        justifyContent: "space-between"
      },
      "&-space-around ": {
        justifyContent: "space-around"
      },
      "&-top": {
        alignItems: "flex-start"
      },
      "&-middle": {
        alignItems: "center"
      },
      "&-bottom": {
        alignItems: "flex-end"
      }
    }
  };
};
const genGridColStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      position: "relative",
      maxWidth: "100%",
      minHeight: 1
    }
  };
};
const genLoopGridColumnsStyle = (token2, sizeCls) => {
  const {
    componentCls,
    gridColumns
  } = token2;
  const gridColumnsStyle = {};
  for (let i = gridColumns; i >= 0; i--) {
    if (i === 0) {
      gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = {
        display: "none"
      };
      gridColumnsStyle[`${componentCls}-push-${i}`] = {
        insetInlineStart: "auto"
      };
      gridColumnsStyle[`${componentCls}-pull-${i}`] = {
        insetInlineEnd: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
        insetInlineStart: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
        insetInlineEnd: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
        marginInlineStart: 0
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
        order: 0
      };
    } else {
      gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = {
        display: "block",
        flex: `0 0 ${i / gridColumns * 100}%`,
        maxWidth: `${i / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
        insetInlineStart: `${i / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
        insetInlineEnd: `${i / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
        marginInlineStart: `${i / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
        order: i
      };
    }
  }
  return gridColumnsStyle;
};
const genGridStyle = (token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls);
const genGridMediaStyle = (token2, screenSize, sizeCls) => ({
  [`@media (min-width: ${screenSize}px)`]: Object.assign({}, genGridStyle(token2, sizeCls))
});
const useRowStyle = genComponentStyleHook$2("Grid", (token2) => [genGridRowStyle(token2)]);
const useColStyle = genComponentStyleHook$2("Grid", (token2) => {
  const gridToken = merge$1(token2, {
    gridColumns: 24
  });
  const gridMediaSizesMap = {
    "-sm": gridToken.screenSMMin,
    "-md": gridToken.screenMDMin,
    "-lg": gridToken.screenLGMin,
    "-xl": gridToken.screenXLMin,
    "-xxl": gridToken.screenXXLMin
  };
  return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key) => genGridMediaStyle(gridToken, gridMediaSizesMap[key], key)).reduce((pre, cur) => Object.assign(Object.assign({}, pre), cur), {})];
});
var __rest$f = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function parseFlex(flex) {
  if (typeof flex === "number") {
    return `${flex} ${flex} auto`;
  }
  if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
    return `0 0 ${flex}`;
  }
  return flex;
}
const sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
const Col = /* @__PURE__ */ React.forwardRef((props, ref2) => {
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext$1);
  const {
    gutter,
    wrap: wrap2,
    supportFlexGap
  } = React.useContext(RowContext$1);
  const {
    prefixCls: customizePrefixCls,
    span,
    order: order2,
    offset: offset3,
    push: push2,
    pull,
    className,
    children,
    flex,
    style: style2
  } = props, others = __rest$f(props, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]);
  const prefixCls = getPrefixCls("col", customizePrefixCls);
  const [wrapSSR, hashId] = useColStyle(prefixCls);
  let sizeClassObj = {};
  sizes.forEach((size) => {
    let sizeProps = {};
    const propSize = props[size];
    if (typeof propSize === "number") {
      sizeProps.span = propSize;
    } else if (typeof propSize === "object") {
      sizeProps = propSize || {};
    }
    delete others[size];
    sizeClassObj = Object.assign(Object.assign({}, sizeClassObj), {
      [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
      [`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
      [`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
      [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
      [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
      [`${prefixCls}-rtl`]: direction === "rtl"
    });
  });
  const classes = classNames(prefixCls, {
    [`${prefixCls}-${span}`]: span !== void 0,
    [`${prefixCls}-order-${order2}`]: order2,
    [`${prefixCls}-offset-${offset3}`]: offset3,
    [`${prefixCls}-push-${push2}`]: push2,
    [`${prefixCls}-pull-${pull}`]: pull
  }, className, sizeClassObj, hashId);
  const mergedStyle = {};
  if (gutter && gutter[0] > 0) {
    const horizontalGutter = gutter[0] / 2;
    mergedStyle.paddingLeft = horizontalGutter;
    mergedStyle.paddingRight = horizontalGutter;
  }
  if (gutter && gutter[1] > 0 && !supportFlexGap) {
    const verticalGutter = gutter[1] / 2;
    mergedStyle.paddingTop = verticalGutter;
    mergedStyle.paddingBottom = verticalGutter;
  }
  if (flex) {
    mergedStyle.flex = parseFlex(flex);
    if (wrap2 === false && !mergedStyle.minWidth) {
      mergedStyle.minWidth = 0;
    }
  }
  return wrapSSR(/* @__PURE__ */ React.createElement("div", Object.assign({}, others, {
    style: Object.assign(Object.assign({}, mergedStyle), style2),
    className: classes,
    ref: ref2
  }), children));
});
var Col$1 = Col;
var __rest$e = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function useMergePropByScreen(oriProp, screen) {
  const [prop, setProp] = React.useState(typeof oriProp === "string" ? oriProp : "");
  const calcMergeAlignOrJustify = () => {
    if (typeof oriProp === "string") {
      setProp(oriProp);
    }
    if (typeof oriProp !== "object") {
      return;
    }
    for (let i = 0; i < responsiveArray.length; i++) {
      const breakpoint = responsiveArray[i];
      if (!screen[breakpoint])
        continue;
      const curVal = oriProp[breakpoint];
      if (curVal !== void 0) {
        setProp(curVal);
        return;
      }
    }
  };
  React.useEffect(() => {
    calcMergeAlignOrJustify();
  }, [JSON.stringify(oriProp), screen]);
  return prop;
}
const Row = /* @__PURE__ */ React.forwardRef((props, ref2) => {
  const {
    prefixCls: customizePrefixCls,
    justify,
    align,
    className,
    style: style2,
    children,
    gutter = 0,
    wrap: wrap2
  } = props, others = __rest$e(props, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]);
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext$1);
  const [screens, setScreens] = React.useState({
    xs: true,
    sm: true,
    md: true,
    lg: true,
    xl: true,
    xxl: true
  });
  const [curScreens, setCurScreens] = React.useState({
    xs: false,
    sm: false,
    md: false,
    lg: false,
    xl: false,
    xxl: false
  });
  const mergeAlign = useMergePropByScreen(align, curScreens);
  const mergeJustify = useMergePropByScreen(justify, curScreens);
  const supportFlexGap = useFlexGapSupport();
  const gutterRef = React.useRef(gutter);
  const responsiveObserver = useResponsiveObserver();
  React.useEffect(() => {
    const token2 = responsiveObserver.subscribe((screen) => {
      setCurScreens(screen);
      const currentGutter = gutterRef.current || 0;
      if (!Array.isArray(currentGutter) && typeof currentGutter === "object" || Array.isArray(currentGutter) && (typeof currentGutter[0] === "object" || typeof currentGutter[1] === "object")) {
        setScreens(screen);
      }
    });
    return () => responsiveObserver.unsubscribe(token2);
  }, []);
  const getGutter = () => {
    const results = [void 0, void 0];
    const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
    normalizedGutter.forEach((g2, index2) => {
      if (typeof g2 === "object") {
        for (let i = 0; i < responsiveArray.length; i++) {
          const breakpoint = responsiveArray[i];
          if (screens[breakpoint] && g2[breakpoint] !== void 0) {
            results[index2] = g2[breakpoint];
            break;
          }
        }
      } else {
        results[index2] = g2;
      }
    });
    return results;
  };
  const prefixCls = getPrefixCls("row", customizePrefixCls);
  const [wrapSSR, hashId] = useRowStyle(prefixCls);
  const gutters = getGutter();
  const classes = classNames(prefixCls, {
    [`${prefixCls}-no-wrap`]: wrap2 === false,
    [`${prefixCls}-${mergeJustify}`]: mergeJustify,
    [`${prefixCls}-${mergeAlign}`]: mergeAlign,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, hashId);
  const rowStyle = {};
  const horizontalGutter = gutters[0] != null && gutters[0] > 0 ? gutters[0] / -2 : void 0;
  const verticalGutter = gutters[1] != null && gutters[1] > 0 ? gutters[1] / -2 : void 0;
  if (horizontalGutter) {
    rowStyle.marginLeft = horizontalGutter;
    rowStyle.marginRight = horizontalGutter;
  }
  if (supportFlexGap) {
    [, rowStyle.rowGap] = gutters;
  } else if (verticalGutter) {
    rowStyle.marginTop = verticalGutter;
    rowStyle.marginBottom = verticalGutter;
  }
  const [gutterH, gutterV] = gutters;
  const rowContext = React.useMemo(() => ({
    gutter: [gutterH, gutterV],
    wrap: wrap2,
    supportFlexGap
  }), [gutterH, gutterV, wrap2, supportFlexGap]);
  return wrapSSR(/* @__PURE__ */ React.createElement(RowContext$1.Provider, {
    value: rowContext
  }, /* @__PURE__ */ React.createElement("div", Object.assign({}, others, {
    className: classes,
    style: Object.assign(Object.assign({}, rowStyle), style2),
    ref: ref2
  }), children)));
});
var Row$1 = Row;
const genSharedDividerStyle = (token2) => {
  const {
    componentCls,
    sizePaddingEdgeHorizontal,
    colorSplit,
    lineWidth
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      borderBlockStart: `${lineWidth}px solid ${colorSplit}`,
      "&-vertical": {
        position: "relative",
        top: "-0.06em",
        display: "inline-block",
        height: "0.9em",
        margin: `0 ${token2.dividerVerticalGutterMargin}px`,
        verticalAlign: "middle",
        borderTop: 0,
        borderInlineStart: `${lineWidth}px solid ${colorSplit}`
      },
      "&-horizontal": {
        display: "flex",
        clear: "both",
        width: "100%",
        minWidth: "100%",
        margin: `${token2.dividerHorizontalGutterMargin}px 0`
      },
      [`&-horizontal${componentCls}-with-text`]: {
        display: "flex",
        alignItems: "center",
        margin: `${token2.dividerHorizontalWithTextGutterMargin}px 0`,
        color: token2.colorTextHeading,
        fontWeight: 500,
        fontSize: token2.fontSizeLG,
        whiteSpace: "nowrap",
        textAlign: "center",
        borderBlockStart: `0 ${colorSplit}`,
        "&::before, &::after": {
          position: "relative",
          width: "50%",
          borderBlockStart: `${lineWidth}px solid transparent`,
          borderBlockStartColor: "inherit",
          borderBlockEnd: 0,
          transform: "translateY(50%)",
          content: "''"
        }
      },
      [`&-horizontal${componentCls}-with-text-left`]: {
        "&::before": {
          width: "5%"
        },
        "&::after": {
          width: "95%"
        }
      },
      [`&-horizontal${componentCls}-with-text-right`]: {
        "&::before": {
          width: "95%"
        },
        "&::after": {
          width: "5%"
        }
      },
      [`${componentCls}-inner-text`]: {
        display: "inline-block",
        padding: "0 1em"
      },
      "&-dashed": {
        background: "none",
        borderColor: colorSplit,
        borderStyle: "dashed",
        borderWidth: `${lineWidth}px 0 0`
      },
      [`&-horizontal${componentCls}-with-text${componentCls}-dashed`]: {
        "&::before, &::after": {
          borderStyle: "dashed none none"
        }
      },
      [`&-vertical${componentCls}-dashed`]: {
        borderInlineStart: lineWidth,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      [`&-plain${componentCls}-with-text`]: {
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.fontSize
      },
      [`&-horizontal${componentCls}-with-text-left${componentCls}-no-default-orientation-margin-left`]: {
        "&::before": {
          width: 0
        },
        "&::after": {
          width: "100%"
        },
        [`${componentCls}-inner-text`]: {
          paddingInlineStart: sizePaddingEdgeHorizontal
        }
      },
      [`&-horizontal${componentCls}-with-text-right${componentCls}-no-default-orientation-margin-right`]: {
        "&::before": {
          width: "100%"
        },
        "&::after": {
          width: 0
        },
        [`${componentCls}-inner-text`]: {
          paddingInlineEnd: sizePaddingEdgeHorizontal
        }
      }
    })
  };
};
var useStyle$5 = genComponentStyleHook$2("Divider", (token2) => {
  const dividerToken = merge$1(token2, {
    dividerVerticalGutterMargin: token2.marginXS,
    dividerHorizontalWithTextGutterMargin: token2.margin,
    dividerHorizontalGutterMargin: token2.marginLG
  });
  return [genSharedDividerStyle(dividerToken)];
}, {
  sizePaddingEdgeHorizontal: 0
});
var __rest$d = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const Divider = (props) => {
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext$1);
  const {
    prefixCls: customizePrefixCls,
    type: type4 = "horizontal",
    orientation = "center",
    orientationMargin,
    className,
    rootClassName,
    children,
    dashed,
    plain
  } = props, restProps = __rest$d(props, ["prefixCls", "type", "orientation", "orientationMargin", "className", "rootClassName", "children", "dashed", "plain"]);
  const prefixCls = getPrefixCls("divider", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$5(prefixCls);
  const orientationPrefix = orientation.length > 0 ? `-${orientation}` : orientation;
  const hasChildren = !!children;
  const hasCustomMarginLeft = orientation === "left" && orientationMargin != null;
  const hasCustomMarginRight = orientation === "right" && orientationMargin != null;
  const classString = classNames(prefixCls, hashId, `${prefixCls}-${type4}`, {
    [`${prefixCls}-with-text`]: hasChildren,
    [`${prefixCls}-with-text${orientationPrefix}`]: hasChildren,
    [`${prefixCls}-dashed`]: !!dashed,
    [`${prefixCls}-plain`]: !!plain,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-no-default-orientation-margin-left`]: hasCustomMarginLeft,
    [`${prefixCls}-no-default-orientation-margin-right`]: hasCustomMarginRight
  }, className, rootClassName);
  const innerStyle = Object.assign(Object.assign({}, hasCustomMarginLeft && {
    marginLeft: orientationMargin
  }), hasCustomMarginRight && {
    marginRight: orientationMargin
  });
  return wrapSSR(/* @__PURE__ */ React.createElement("div", Object.assign({
    className: classString
  }, restProps, {
    role: "separator"
  }), children && type4 !== "vertical" && /* @__PURE__ */ React.createElement("span", {
    className: `${prefixCls}-inner-text`,
    style: innerStyle
  }, children)));
};
var Divider$1 = Divider;
var EyeOutlined = function EyeOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: EyeOutlinedSvg
  }));
};
EyeOutlined.displayName = "EyeOutlined";
var EyeOutlined$1 = /* @__PURE__ */ React.forwardRef(EyeOutlined);
function getClientSize() {
  var width = document.documentElement.clientWidth;
  var height = window.innerHeight || document.documentElement.clientHeight;
  return {
    width,
    height
  };
}
function getOffset(node2) {
  var box2 = node2.getBoundingClientRect();
  var docElem = document.documentElement;
  return {
    left: box2.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box2.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}
function getUseId() {
  var fullClone2 = _objectSpread2$d({}, React);
  return fullClone2.useId;
}
var uuid$1 = 0;
function useId(id) {
  var _React$useState = React.useState("ssr-id"), _React$useState2 = _slicedToArray$1(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
  var useOriginId = getUseId();
  var reactNativeId = useOriginId === null || useOriginId === void 0 ? void 0 : useOriginId();
  React.useEffect(function() {
    if (!useOriginId) {
      var nextId = uuid$1;
      uuid$1 += 1;
      setInnerId("rc_unique_".concat(nextId));
    }
  }, []);
  if (id) {
    return id;
  }
  return reactNativeId || innerId;
}
function getMotionName(prefixCls, transitionName, animationName) {
  var motionName = transitionName;
  if (!motionName && animationName) {
    motionName = "".concat(prefixCls, "-").concat(animationName);
  }
  return motionName;
}
function getScroll(w2, top) {
  var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
  var method4 = "scroll".concat(top ? "Top" : "Left");
  if (typeof ret !== "number") {
    var d2 = w2.document;
    ret = d2.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d2.body[method4];
    }
  }
  return ret;
}
function offset2(el) {
  var rect = el.getBoundingClientRect();
  var pos = {
    left: rect.left,
    top: rect.top
  };
  var doc = el.ownerDocument;
  var w2 = doc.defaultView || doc.parentWindow;
  pos.left += getScroll(w2);
  pos.top += getScroll(w2, true);
  return pos;
}
var MemoChildren = /* @__PURE__ */ React.memo(function(_ref2) {
  var children = _ref2.children;
  return children;
}, function(_24, _ref2) {
  var shouldUpdate = _ref2.shouldUpdate;
  return !shouldUpdate;
});
var sentinelStyle = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
};
var Panel = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var prefixCls = props.prefixCls, className = props.className, style2 = props.style, title = props.title, ariaId = props.ariaId, footer2 = props.footer, closable = props.closable, closeIcon = props.closeIcon, onClose = props.onClose, children = props.children, bodyStyle = props.bodyStyle, bodyProps = props.bodyProps, modalRender = props.modalRender, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, holderRef = props.holderRef, visible = props.visible, forceRender = props.forceRender, width = props.width, height = props.height;
  var sentinelStartRef = React.useRef();
  var sentinelEndRef = React.useRef();
  React.useImperativeHandle(ref2, function() {
    return {
      focus: function focus() {
        var _sentinelStartRef$cur;
        (_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 ? void 0 : _sentinelStartRef$cur.focus();
      },
      changeActive: function changeActive(next2) {
        var _document = document, activeElement = _document.activeElement;
        if (next2 && activeElement === sentinelEndRef.current) {
          sentinelStartRef.current.focus();
        } else if (!next2 && activeElement === sentinelStartRef.current) {
          sentinelEndRef.current.focus();
        }
      }
    };
  });
  var contentStyle = {};
  if (width !== void 0) {
    contentStyle.width = width;
  }
  if (height !== void 0) {
    contentStyle.height = height;
  }
  var footerNode;
  if (footer2) {
    footerNode = /* @__PURE__ */ React.createElement("div", {
      className: "".concat(prefixCls, "-footer")
    }, footer2);
  }
  var headerNode;
  if (title) {
    headerNode = /* @__PURE__ */ React.createElement("div", {
      className: "".concat(prefixCls, "-header")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(prefixCls, "-title"),
      id: ariaId
    }, title));
  }
  var closer;
  if (closable) {
    closer = /* @__PURE__ */ React.createElement("button", {
      type: "button",
      onClick: onClose,
      "aria-label": "Close",
      className: "".concat(prefixCls, "-close")
    }, closeIcon || /* @__PURE__ */ React.createElement("span", {
      className: "".concat(prefixCls, "-close-x")
    }));
  }
  var content2 = /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-content")
  }, closer, headerNode, /* @__PURE__ */ React.createElement("div", _extends$3({
    className: "".concat(prefixCls, "-body"),
    style: bodyStyle
  }, bodyProps), children), footerNode);
  return /* @__PURE__ */ React.createElement("div", {
    key: "dialog-element",
    role: "dialog",
    "aria-labelledby": title ? ariaId : null,
    "aria-modal": "true",
    ref: holderRef,
    style: _objectSpread2$d(_objectSpread2$d({}, style2), contentStyle),
    className: classNames(prefixCls, className),
    onMouseDown,
    onMouseUp
  }, /* @__PURE__ */ React.createElement("div", {
    tabIndex: 0,
    ref: sentinelStartRef,
    style: sentinelStyle,
    "aria-hidden": "true"
  }), /* @__PURE__ */ React.createElement(MemoChildren, {
    shouldUpdate: visible || forceRender
  }, modalRender ? modalRender(content2) : content2), /* @__PURE__ */ React.createElement("div", {
    tabIndex: 0,
    ref: sentinelEndRef,
    style: sentinelStyle,
    "aria-hidden": "true"
  }));
});
var Content = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var prefixCls = props.prefixCls, title = props.title, style2 = props.style, className = props.className, visible = props.visible, forceRender = props.forceRender, destroyOnClose = props.destroyOnClose, motionName = props.motionName, ariaId = props.ariaId, onVisibleChanged = props.onVisibleChanged, mousePosition2 = props.mousePosition;
  var dialogRef = React.useRef();
  var _React$useState = React.useState(), _React$useState2 = _slicedToArray$1(_React$useState, 2), transformOrigin = _React$useState2[0], setTransformOrigin = _React$useState2[1];
  var contentStyle = {};
  if (transformOrigin) {
    contentStyle.transformOrigin = transformOrigin;
  }
  function onPrepare() {
    var elementOffset = offset2(dialogRef.current);
    setTransformOrigin(mousePosition2 ? "".concat(mousePosition2.x - elementOffset.left, "px ").concat(mousePosition2.y - elementOffset.top, "px") : "");
  }
  return /* @__PURE__ */ React.createElement(CSSMotion, {
    visible,
    onVisibleChanged,
    onAppearPrepare: onPrepare,
    onEnterPrepare: onPrepare,
    forceRender,
    motionName,
    removeOnLeave: destroyOnClose,
    ref: dialogRef
  }, function(_ref2, motionRef) {
    var motionClassName = _ref2.className, motionStyle = _ref2.style;
    return /* @__PURE__ */ React.createElement(Panel, _extends$3({}, props, {
      ref: ref2,
      title,
      ariaId,
      prefixCls,
      holderRef: motionRef,
      style: _objectSpread2$d(_objectSpread2$d(_objectSpread2$d({}, motionStyle), style2), contentStyle),
      className: classNames(className, motionClassName)
    }));
  });
});
Content.displayName = "Content";
function Mask(props) {
  var prefixCls = props.prefixCls, style2 = props.style, visible = props.visible, maskProps = props.maskProps, motionName = props.motionName;
  return /* @__PURE__ */ React.createElement(CSSMotion, {
    key: "mask",
    visible,
    motionName,
    leavedClassName: "".concat(prefixCls, "-mask-hidden")
  }, function(_ref2, ref2) {
    var motionClassName = _ref2.className, motionStyle = _ref2.style;
    return /* @__PURE__ */ React.createElement("div", _extends$3({
      ref: ref2,
      style: _objectSpread2$d(_objectSpread2$d({}, motionStyle), style2),
      className: classNames("".concat(prefixCls, "-mask"), motionClassName)
    }, maskProps));
  });
}
function Dialog(props) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dialog" : _props$prefixCls, zIndex = props.zIndex, _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$focusTriggerAf = props.focusTriggerAfterClose, focusTriggerAfterClose = _props$focusTriggerAf === void 0 ? true : _props$focusTriggerAf, wrapStyle = props.wrapStyle, wrapClassName = props.wrapClassName, wrapProps = props.wrapProps, onClose = props.onClose, afterOpenChange = props.afterOpenChange, afterClose = props.afterClose, transitionName = props.transitionName, animation = props.animation, _props$closable = props.closable, closable = _props$closable === void 0 ? true : _props$closable, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, maskStyle = props.maskStyle, maskProps = props.maskProps, rootClassName = props.rootClassName;
  var lastOutSideActiveElementRef = React.useRef();
  var wrapperRef = React.useRef();
  var contentRef = React.useRef();
  var _React$useState = React.useState(visible), _React$useState2 = _slicedToArray$1(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
  var ariaId = useId();
  function saveLastOutSideActiveElementRef() {
    if (!contains$a(wrapperRef.current, document.activeElement)) {
      lastOutSideActiveElementRef.current = document.activeElement;
    }
  }
  function focusDialogContent() {
    if (!contains$a(wrapperRef.current, document.activeElement)) {
      var _contentRef$current;
      (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 ? void 0 : _contentRef$current.focus();
    }
  }
  function onDialogVisibleChanged(newVisible) {
    if (newVisible) {
      focusDialogContent();
    } else {
      setAnimatedVisible(false);
      if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
        try {
          lastOutSideActiveElementRef.current.focus({
            preventScroll: true
          });
        } catch (e2) {
        }
        lastOutSideActiveElementRef.current = null;
      }
      if (animatedVisible) {
        afterClose === null || afterClose === void 0 ? void 0 : afterClose();
      }
    }
    afterOpenChange === null || afterOpenChange === void 0 ? void 0 : afterOpenChange(newVisible);
  }
  function onInternalClose(e2) {
    onClose === null || onClose === void 0 ? void 0 : onClose(e2);
  }
  var contentClickRef = React.useRef(false);
  var contentTimeoutRef = React.useRef();
  var onContentMouseDown = function onContentMouseDown2() {
    clearTimeout(contentTimeoutRef.current);
    contentClickRef.current = true;
  };
  var onContentMouseUp = function onContentMouseUp2() {
    contentTimeoutRef.current = setTimeout(function() {
      contentClickRef.current = false;
    });
  };
  var onWrapperClick = null;
  if (maskClosable) {
    onWrapperClick = function onWrapperClick2(e2) {
      if (contentClickRef.current) {
        contentClickRef.current = false;
      } else if (wrapperRef.current === e2.target) {
        onInternalClose(e2);
      }
    };
  }
  function onWrapperKeyDown(e2) {
    if (keyboard && e2.keyCode === KeyCode$5.ESC) {
      e2.stopPropagation();
      onInternalClose(e2);
      return;
    }
    if (visible) {
      if (e2.keyCode === KeyCode$5.TAB) {
        contentRef.current.changeActive(!e2.shiftKey);
      }
    }
  }
  React.useEffect(function() {
    if (visible) {
      setAnimatedVisible(true);
      saveLastOutSideActiveElementRef();
    }
  }, [visible]);
  React.useEffect(function() {
    return function() {
      clearTimeout(contentTimeoutRef.current);
    };
  }, []);
  return /* @__PURE__ */ React.createElement("div", _extends$3({
    className: classNames("".concat(prefixCls, "-root"), rootClassName)
  }, pickAttrs(props, {
    data: true
  })), /* @__PURE__ */ React.createElement(Mask, {
    prefixCls,
    visible: mask && visible,
    motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
    style: _objectSpread2$d({
      zIndex
    }, maskStyle),
    maskProps
  }), /* @__PURE__ */ React.createElement("div", _extends$3({
    tabIndex: -1,
    onKeyDown: onWrapperKeyDown,
    className: classNames("".concat(prefixCls, "-wrap"), wrapClassName),
    ref: wrapperRef,
    onClick: onWrapperClick,
    style: _objectSpread2$d(_objectSpread2$d({
      zIndex
    }, wrapStyle), {}, {
      display: !animatedVisible ? "none" : null
    })
  }, wrapProps), /* @__PURE__ */ React.createElement(Content, _extends$3({}, props, {
    onMouseDown: onContentMouseDown,
    onMouseUp: onContentMouseUp,
    ref: contentRef,
    closable,
    ariaId,
    prefixCls,
    visible: visible && animatedVisible,
    onClose: onInternalClose,
    onVisibleChanged: onDialogVisibleChanged,
    motionName: getMotionName(prefixCls, transitionName, animation)
  }))));
}
var DialogWrap2 = function DialogWrap3(props) {
  var visible = props.visible, getContainer2 = props.getContainer, forceRender = props.forceRender, _props$destroyOnClose = props.destroyOnClose, destroyOnClose = _props$destroyOnClose === void 0 ? false : _props$destroyOnClose, _afterClose = props.afterClose;
  var _React$useState = React.useState(visible), _React$useState2 = _slicedToArray$1(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
  React.useEffect(function() {
    if (visible) {
      setAnimatedVisible(true);
    }
  }, [visible]);
  if (!forceRender && destroyOnClose && !animatedVisible) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(Portal$2, {
    open: visible || forceRender || animatedVisible,
    autoDestroy: false,
    getContainer: getContainer2,
    autoLock: visible || animatedVisible
  }, /* @__PURE__ */ React.createElement(Dialog, _extends$3({}, props, {
    destroyOnClose,
    afterClose: function afterClose() {
      _afterClose === null || _afterClose === void 0 ? void 0 : _afterClose();
      setAnimatedVisible(false);
    }
  })));
};
DialogWrap2.displayName = "Dialog";
var _excluded$5 = ["visible", "onVisibleChange", "getContainer", "current", "countRender", "onChange"];
var context$3 = /* @__PURE__ */ React.createContext({
  previewUrls: /* @__PURE__ */ new Map(),
  setPreviewUrls: function setPreviewUrls() {
    return null;
  },
  current: null,
  setCurrent: function setCurrent() {
    return null;
  },
  setShowPreview: function setShowPreview() {
    return null;
  },
  setMousePosition: function setMousePosition() {
    return null;
  },
  registerImage: function registerImage() {
    return function() {
      return null;
    };
  },
  rootClassName: ""
});
var Provider2 = context$3.Provider;
function getSafeIndex(keys2, key) {
  if (key === void 0)
    return void 0;
  var index2 = keys2.indexOf(key);
  if (index2 === -1)
    return void 0;
  return index2;
}
var Group = function Group2(_ref2) {
  var _ref$previewPrefixCls = _ref2.previewPrefixCls, previewPrefixCls = _ref$previewPrefixCls === void 0 ? "rc-image-preview" : _ref$previewPrefixCls, children = _ref2.children, _ref$icons = _ref2.icons, icons2 = _ref$icons === void 0 ? {} : _ref$icons, preview = _ref2.preview;
  var _ref22 = _typeof$8(preview) === "object" ? preview : {}, _ref2$visible = _ref22.visible, previewVisible = _ref2$visible === void 0 ? void 0 : _ref2$visible, _ref2$onVisibleChange = _ref22.onVisibleChange, onPreviewVisibleChange = _ref2$onVisibleChange === void 0 ? void 0 : _ref2$onVisibleChange, _ref2$getContainer = _ref22.getContainer, getContainer2 = _ref2$getContainer === void 0 ? void 0 : _ref2$getContainer, _ref2$current = _ref22.current, currentIndex = _ref2$current === void 0 ? 0 : _ref2$current, _ref2$countRender = _ref22.countRender, countRender = _ref2$countRender === void 0 ? void 0 : _ref2$countRender, _ref2$onChange = _ref22.onChange, _onChange = _ref2$onChange === void 0 ? void 0 : _ref2$onChange, dialogProps = _objectWithoutProperties$1(_ref22, _excluded$5);
  var _useState = React.useState(/* @__PURE__ */ new Map()), _useState2 = _slicedToArray$1(_useState, 2), previewUrls = _useState2[0], setPreviewUrls2 = _useState2[1];
  var previewUrlsKeys = Array.from(previewUrls.keys());
  var prevCurrent = React.useRef();
  var _useMergedState = useMergedState(void 0, {
    onChange: function onChange(val, prev2) {
      if (prevCurrent.current !== void 0) {
        _onChange === null || _onChange === void 0 ? void 0 : _onChange(getSafeIndex(previewUrlsKeys, val), getSafeIndex(previewUrlsKeys, prev2));
      }
      prevCurrent.current = prev2;
    }
  }), _useMergedState2 = _slicedToArray$1(_useMergedState, 2), current = _useMergedState2[0], setCurrent2 = _useMergedState2[1];
  var _useMergedState3 = useMergedState(!!previewVisible, {
    value: previewVisible,
    onChange: function onChange(val, prevVal) {
      onPreviewVisibleChange === null || onPreviewVisibleChange === void 0 ? void 0 : onPreviewVisibleChange(val, prevVal, getSafeIndex(previewUrlsKeys, current));
      prevCurrent.current = val ? current : void 0;
    }
  }), _useMergedState4 = _slicedToArray$1(_useMergedState3, 2), isShowPreview = _useMergedState4[0], setShowPreview2 = _useMergedState4[1];
  var _useState3 = React.useState(null), _useState4 = _slicedToArray$1(_useState3, 2), mousePosition2 = _useState4[0], setMousePosition2 = _useState4[1];
  var isControlled = previewVisible !== void 0;
  var currentControlledKey = previewUrlsKeys[currentIndex];
  var canPreviewUrls = new Map(Array.from(previewUrls).filter(function(_ref3) {
    var _ref4 = _slicedToArray$1(_ref3, 2), canPreview = _ref4[1].canPreview;
    return !!canPreview;
  }).map(function(_ref5) {
    var _ref6 = _slicedToArray$1(_ref5, 2), id = _ref6[0], url2 = _ref6[1].url;
    return [id, url2];
  }));
  var registerImage2 = function registerImage3(id, url2) {
    var canPreview = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var unRegister = function unRegister2() {
      setPreviewUrls2(function(oldPreviewUrls) {
        var clonePreviewUrls = new Map(oldPreviewUrls);
        var deleteResult = clonePreviewUrls.delete(id);
        return deleteResult ? clonePreviewUrls : oldPreviewUrls;
      });
    };
    setPreviewUrls2(function(oldPreviewUrls) {
      return new Map(oldPreviewUrls).set(id, {
        url: url2,
        canPreview
      });
    });
    return unRegister;
  };
  var onPreviewClose = function onPreviewClose2(e2) {
    e2.stopPropagation();
    setShowPreview2(false);
    setMousePosition2(null);
  };
  React.useEffect(function() {
    setCurrent2(currentControlledKey);
  }, [currentControlledKey]);
  React.useEffect(function() {
    if (!isShowPreview && isControlled) {
      setCurrent2(currentControlledKey);
    }
  }, [currentControlledKey, isControlled, isShowPreview]);
  return /* @__PURE__ */ React.createElement(Provider2, {
    value: {
      isPreviewGroup: true,
      previewUrls: canPreviewUrls,
      setPreviewUrls: setPreviewUrls2,
      current,
      setCurrent: setCurrent2,
      setShowPreview: setShowPreview2,
      setMousePosition: setMousePosition2,
      registerImage: registerImage2
    }
  }, children, /* @__PURE__ */ React.createElement(Preview, _extends$3({
    "aria-hidden": !isShowPreview,
    visible: isShowPreview,
    prefixCls: previewPrefixCls,
    onClose: onPreviewClose,
    mousePosition: mousePosition2,
    src: canPreviewUrls.get(current),
    icons: icons2,
    getContainer: getContainer2,
    countRender
  }, dialogProps)));
};
var MIN_SCALE = 1;
var MAX_SCALE = 50;
var BASE_SCALE_RATIO = 1;
var WHEEL_MAX_SCALE_RATIO = 1;
var Operations = function Operations2(props) {
  var _countRender;
  var visible = props.visible, maskTransitionName = props.maskTransitionName, getContainer2 = props.getContainer, prefixCls = props.prefixCls, rootClassName = props.rootClassName, icons2 = props.icons, countRender = props.countRender, showSwitch = props.showSwitch, showProgress = props.showProgress, current = props.current, count = props.count, scale = props.scale, onSwitchLeft = props.onSwitchLeft, onSwitchRight = props.onSwitchRight, onClose = props.onClose, onZoomIn = props.onZoomIn, onZoomOut = props.onZoomOut, onRotateRight = props.onRotateRight, onRotateLeft = props.onRotateLeft, onFlipX = props.onFlipX, onFlipY = props.onFlipY;
  var rotateLeft = icons2.rotateLeft, rotateRight = icons2.rotateRight, zoomIn2 = icons2.zoomIn, zoomOut2 = icons2.zoomOut, close = icons2.close, left = icons2.left, right = icons2.right, flipX = icons2.flipX, flipY = icons2.flipY;
  var toolClassName = "".concat(prefixCls, "-operations-operation");
  var iconClassName = "".concat(prefixCls, "-operations-icon");
  var tools = [{
    icon: close,
    onClick: onClose,
    type: "close"
  }, {
    icon: zoomIn2,
    onClick: onZoomIn,
    type: "zoomIn",
    disabled: scale === MAX_SCALE
  }, {
    icon: zoomOut2,
    onClick: onZoomOut,
    type: "zoomOut",
    disabled: scale === MIN_SCALE
  }, {
    icon: rotateRight,
    onClick: onRotateRight,
    type: "rotateRight"
  }, {
    icon: rotateLeft,
    onClick: onRotateLeft,
    type: "rotateLeft"
  }, {
    icon: flipX,
    onClick: onFlipX,
    type: "flipX"
  }, {
    icon: flipY,
    onClick: onFlipY,
    type: "flipY"
  }];
  var operations = /* @__PURE__ */ React.createElement(React.Fragment, null, showSwitch && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: classNames("".concat(prefixCls, "-switch-left"), _defineProperty$3({}, "".concat(prefixCls, "-switch-left-disabled"), current === 0)),
    onClick: onSwitchLeft
  }, left), /* @__PURE__ */ React.createElement("div", {
    className: classNames("".concat(prefixCls, "-switch-right"), _defineProperty$3({}, "".concat(prefixCls, "-switch-right-disabled"), current === count - 1)),
    onClick: onSwitchRight
  }, right)), /* @__PURE__ */ React.createElement("ul", {
    className: "".concat(prefixCls, "-operations")
  }, showProgress && /* @__PURE__ */ React.createElement("li", {
    className: "".concat(prefixCls, "-operations-progress")
  }, (_countRender = countRender === null || countRender === void 0 ? void 0 : countRender(current + 1, count)) !== null && _countRender !== void 0 ? _countRender : "".concat(current + 1, " / ").concat(count)), tools.map(function(_ref2) {
    var _classnames3;
    var icon = _ref2.icon, onClick = _ref2.onClick, type4 = _ref2.type, disabled = _ref2.disabled;
    return /* @__PURE__ */ React.createElement("li", {
      className: classNames(toolClassName, (_classnames3 = {}, _defineProperty$3(_classnames3, "".concat(prefixCls, "-operations-operation-").concat(type4), true), _defineProperty$3(_classnames3, "".concat(prefixCls, "-operations-operation-disabled"), !!disabled), _classnames3)),
      onClick,
      key: type4
    }, /* @__PURE__ */ React.isValidElement(icon) ? /* @__PURE__ */ React.cloneElement(icon, {
      className: iconClassName
    }) : icon);
  })));
  return /* @__PURE__ */ React.createElement(CSSMotion, {
    visible,
    motionName: maskTransitionName
  }, function(_ref2) {
    var className = _ref2.className, style2 = _ref2.style;
    return /* @__PURE__ */ React.createElement(Portal$2, {
      open: true,
      getContainer: getContainer2 !== null && getContainer2 !== void 0 ? getContainer2 : document.body
    }, /* @__PURE__ */ React.createElement("div", {
      className: classNames("".concat(prefixCls, "-operations-wrapper"), className, rootClassName),
      style: style2
    }, operations));
  });
};
var initialTransform = {
  x: 0,
  y: 0,
  rotate: 0,
  scale: 1,
  flipX: false,
  flipY: false
};
function useImageTransform(imgRef) {
  var frame = React.useRef(null);
  var queue = React.useRef([]);
  var _useState = React.useState(initialTransform), _useState2 = _slicedToArray$1(_useState, 2), transform3 = _useState2[0], setTransform2 = _useState2[1];
  var resetTransform = function resetTransform2() {
    setTransform2(initialTransform);
  };
  var updateTransform = function updateTransform2(newTransform) {
    if (frame.current === null) {
      queue.current = [];
      frame.current = wrapperRaf$6(function() {
        setTransform2(function(preState) {
          var memoState = preState;
          queue.current.forEach(function(queueState) {
            memoState = _objectSpread2$d(_objectSpread2$d({}, memoState), queueState);
          });
          frame.current = null;
          return memoState;
        });
      });
    }
    queue.current.push(_objectSpread2$d(_objectSpread2$d({}, transform3), newTransform));
  };
  var dispatchZoomChange = function dispatchZoomChange2(ratio, clientX, clientY) {
    var _imgRef$current = imgRef.current, width = _imgRef$current.width, height = _imgRef$current.height, offsetWidth = _imgRef$current.offsetWidth, offsetHeight = _imgRef$current.offsetHeight, offsetLeft = _imgRef$current.offsetLeft, offsetTop = _imgRef$current.offsetTop;
    var newRatio = ratio;
    var newScale = transform3.scale * ratio;
    if (newScale > MAX_SCALE) {
      newRatio = MAX_SCALE / transform3.scale;
      newScale = MAX_SCALE;
    } else if (newScale < MIN_SCALE) {
      newRatio = MIN_SCALE / transform3.scale;
      newScale = MIN_SCALE;
    }
    var mergedClientX = clientX !== null && clientX !== void 0 ? clientX : innerWidth / 2;
    var mergedClientY = clientY !== null && clientY !== void 0 ? clientY : innerHeight / 2;
    var diffRatio = newRatio - 1;
    var diffImgX = diffRatio * width * 0.5;
    var diffImgY = diffRatio * height * 0.5;
    var diffOffsetLeft = diffRatio * (mergedClientX - transform3.x - offsetLeft);
    var diffOffsetTop = diffRatio * (mergedClientY - transform3.y - offsetTop);
    var newX = transform3.x - (diffOffsetLeft - diffImgX);
    var newY = transform3.y - (diffOffsetTop - diffImgY);
    if (ratio < 1 && newScale === 1) {
      var mergedWidth = offsetWidth * newScale;
      var mergedHeight = offsetHeight * newScale;
      var _getClientSize = getClientSize(), clientWidth = _getClientSize.width, clientHeight = _getClientSize.height;
      if (mergedWidth <= clientWidth && mergedHeight <= clientHeight) {
        newX = 0;
        newY = 0;
      }
    }
    updateTransform({
      x: newX,
      y: newY,
      scale: newScale
    });
  };
  return {
    transform: transform3,
    resetTransform,
    updateTransform,
    dispatchZoomChange
  };
}
function fixPoint(key, start, width, clientWidth) {
  var startAddWidth = start + width;
  var offsetStart = (width - clientWidth) / 2;
  if (width > clientWidth) {
    if (start > 0) {
      return _defineProperty$3({}, key, offsetStart);
    }
    if (start < 0 && startAddWidth < clientWidth) {
      return _defineProperty$3({}, key, -offsetStart);
    }
  } else if (start < 0 || startAddWidth > clientWidth) {
    return _defineProperty$3({}, key, start < 0 ? offsetStart : -offsetStart);
  }
  return {};
}
function getFixScaleEleTransPosition(width, height, left, top) {
  var _getClientSize = getClientSize(), clientWidth = _getClientSize.width, clientHeight = _getClientSize.height;
  var fixPos = null;
  if (width <= clientWidth && height <= clientHeight) {
    fixPos = {
      x: 0,
      y: 0
    };
  } else if (width > clientWidth || height > clientHeight) {
    fixPos = _objectSpread2$d(_objectSpread2$d({}, fixPoint("x", left, width, clientWidth)), fixPoint("y", top, height, clientHeight));
  }
  return fixPos;
}
var _excluded$4 = ["prefixCls", "src", "alt", "onClose", "visible", "icons", "rootClassName", "getContainer", "countRender", "scaleStep", "transitionName", "maskTransitionName"];
var Preview = function Preview2(props) {
  var prefixCls = props.prefixCls, src = props.src, alt = props.alt, onClose = props.onClose, visible = props.visible, _props$icons = props.icons, icons2 = _props$icons === void 0 ? {} : _props$icons, rootClassName = props.rootClassName, getContainer2 = props.getContainer, countRender = props.countRender, _props$scaleStep = props.scaleStep, scaleStep = _props$scaleStep === void 0 ? 0.5 : _props$scaleStep, _props$transitionName = props.transitionName, transitionName = _props$transitionName === void 0 ? "zoom" : _props$transitionName, _props$maskTransition = props.maskTransitionName, maskTransitionName = _props$maskTransition === void 0 ? "fade" : _props$maskTransition, restProps = _objectWithoutProperties$1(props, _excluded$4);
  var imgRef = React.useRef();
  var downPositionRef = React.useRef({
    deltaX: 0,
    deltaY: 0,
    transformX: 0,
    transformY: 0
  });
  var _useState = React.useState(false), _useState2 = _slicedToArray$1(_useState, 2), isMoving = _useState2[0], setMoving = _useState2[1];
  var _useContext = React.useContext(context$3), previewUrls = _useContext.previewUrls, current = _useContext.current, isPreviewGroup = _useContext.isPreviewGroup, setCurrent2 = _useContext.setCurrent;
  var previewGroupCount = previewUrls.size;
  var previewUrlsKeys = Array.from(previewUrls.keys());
  var currentPreviewIndex = previewUrlsKeys.indexOf(current);
  var combinationSrc = isPreviewGroup ? previewUrls.get(current) : src;
  var showLeftOrRightSwitches = isPreviewGroup && previewGroupCount > 1;
  var showOperationsProgress = isPreviewGroup && previewGroupCount >= 1;
  var _useImageTransform = useImageTransform(imgRef), transform3 = _useImageTransform.transform, resetTransform = _useImageTransform.resetTransform, updateTransform = _useImageTransform.updateTransform, dispatchZoomChange = _useImageTransform.dispatchZoomChange;
  var rotate = transform3.rotate, scale = transform3.scale;
  var wrapClassName = classNames(_defineProperty$3({}, "".concat(prefixCls, "-moving"), isMoving));
  var onAfterClose = function onAfterClose2() {
    resetTransform();
  };
  var onZoomIn = function onZoomIn2() {
    dispatchZoomChange(BASE_SCALE_RATIO + scaleStep);
  };
  var onZoomOut = function onZoomOut2() {
    dispatchZoomChange(BASE_SCALE_RATIO - scaleStep);
  };
  var onRotateRight = function onRotateRight2() {
    updateTransform({
      rotate: rotate + 90
    });
  };
  var onRotateLeft = function onRotateLeft2() {
    updateTransform({
      rotate: rotate - 90
    });
  };
  var onFlipX = function onFlipX2() {
    updateTransform({
      flipX: !transform3.flipX
    });
  };
  var onFlipY = function onFlipY2() {
    updateTransform({
      flipY: !transform3.flipY
    });
  };
  var onSwitchLeft = function onSwitchLeft2(event) {
    event.preventDefault();
    event.stopPropagation();
    if (currentPreviewIndex > 0) {
      setCurrent2(previewUrlsKeys[currentPreviewIndex - 1]);
    }
  };
  var onSwitchRight = function onSwitchRight2(event) {
    event.preventDefault();
    event.stopPropagation();
    if (currentPreviewIndex < previewGroupCount - 1) {
      setCurrent2(previewUrlsKeys[currentPreviewIndex + 1]);
    }
  };
  var onMouseUp = function onMouseUp2() {
    if (visible && isMoving) {
      setMoving(false);
      var _downPositionRef$curr = downPositionRef.current, transformX = _downPositionRef$curr.transformX, transformY = _downPositionRef$curr.transformY;
      var hasChangedPosition = transform3.x !== transformX && transform3.y !== transformY;
      if (!hasChangedPosition) {
        return;
      }
      var width = imgRef.current.offsetWidth * scale;
      var height = imgRef.current.offsetHeight * scale;
      var _imgRef$current$getBo = imgRef.current.getBoundingClientRect(), left = _imgRef$current$getBo.left, top = _imgRef$current$getBo.top;
      var isRotate = rotate % 180 !== 0;
      var fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, left, top);
      if (fixState) {
        updateTransform(_objectSpread2$d({}, fixState));
      }
    }
  };
  var onMouseDown = function onMouseDown2(event) {
    if (event.button !== 0)
      return;
    event.preventDefault();
    event.stopPropagation();
    downPositionRef.current = {
      deltaX: event.pageX - transform3.x,
      deltaY: event.pageY - transform3.y,
      transformX: transform3.x,
      transformY: transform3.y
    };
    setMoving(true);
  };
  var onMouseMove = function onMouseMove2(event) {
    if (visible && isMoving) {
      updateTransform({
        x: event.pageX - downPositionRef.current.deltaX,
        y: event.pageY - downPositionRef.current.deltaY
      });
    }
  };
  var onWheel = function onWheel2(event) {
    if (!visible || event.deltaY == 0)
      return;
    var scaleRatio = Math.abs(event.deltaY / 100);
    var mergedScaleRatio = Math.min(scaleRatio, WHEEL_MAX_SCALE_RATIO);
    var ratio = BASE_SCALE_RATIO + mergedScaleRatio * scaleStep;
    if (event.deltaY > 0) {
      ratio = BASE_SCALE_RATIO / ratio;
    }
    dispatchZoomChange(ratio, event.clientX, event.clientY);
  };
  var onKeyDown = React.useCallback(function(event) {
    if (!visible || !showLeftOrRightSwitches)
      return;
    if (event.keyCode === KeyCode$5.LEFT) {
      if (currentPreviewIndex > 0) {
        setCurrent2(previewUrlsKeys[currentPreviewIndex - 1]);
      }
    } else if (event.keyCode === KeyCode$5.RIGHT) {
      if (currentPreviewIndex < previewGroupCount - 1) {
        setCurrent2(previewUrlsKeys[currentPreviewIndex + 1]);
      }
    }
  }, [currentPreviewIndex, previewGroupCount, previewUrlsKeys, setCurrent2, showLeftOrRightSwitches, visible]);
  var onDoubleClick = function onDoubleClick2(event) {
    if (visible) {
      if (scale !== 1) {
        updateTransform({
          x: 0,
          y: 0,
          scale: 1
        });
      } else {
        dispatchZoomChange(BASE_SCALE_RATIO + scaleStep, event.clientX, event.clientY);
      }
    }
  };
  React.useEffect(function() {
    var onTopMouseUpListener;
    var onTopMouseMoveListener;
    var onMouseUpListener = addEventListenerWrap$1(window, "mouseup", onMouseUp, false);
    var onMouseMoveListener = addEventListenerWrap$1(window, "mousemove", onMouseMove, false);
    var onKeyDownListener = addEventListenerWrap$1(window, "keydown", onKeyDown, false);
    try {
      if (window.top !== window.self) {
        onTopMouseUpListener = addEventListenerWrap$1(window.top, "mouseup", onMouseUp, false);
        onTopMouseMoveListener = addEventListenerWrap$1(window.top, "mousemove", onMouseMove, false);
      }
    } catch (error3) {
    }
    return function() {
      var _onTopMouseUpListener, _onTopMouseMoveListen;
      onMouseUpListener.remove();
      onMouseMoveListener.remove();
      onKeyDownListener.remove();
      (_onTopMouseUpListener = onTopMouseUpListener) === null || _onTopMouseUpListener === void 0 ? void 0 : _onTopMouseUpListener.remove();
      (_onTopMouseMoveListen = onTopMouseMoveListener) === null || _onTopMouseMoveListen === void 0 ? void 0 : _onTopMouseMoveListen.remove();
    };
  }, [visible, isMoving, onKeyDown]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogWrap2, _extends$3({
    transitionName,
    maskTransitionName,
    closable: false,
    keyboard: true,
    prefixCls,
    onClose,
    visible,
    wrapClassName,
    rootClassName,
    getContainer: getContainer2
  }, restProps, {
    afterClose: onAfterClose
  }), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-img-wrapper")
  }, /* @__PURE__ */ React.createElement("img", {
    width: props.width,
    height: props.height,
    onWheel,
    onMouseDown,
    onDoubleClick,
    ref: imgRef,
    className: "".concat(prefixCls, "-img"),
    src: combinationSrc,
    alt,
    style: {
      transform: "translate3d(".concat(transform3.x, "px, ").concat(transform3.y, "px, 0) scale3d(").concat(transform3.flipX ? "-" : "").concat(scale, ", ").concat(transform3.flipY ? "-" : "").concat(scale, ", 1) rotate(").concat(rotate, "deg)")
    }
  }))), /* @__PURE__ */ React.createElement(Operations, {
    visible,
    maskTransitionName,
    getContainer: getContainer2,
    prefixCls,
    rootClassName,
    icons: icons2,
    countRender,
    showSwitch: showLeftOrRightSwitches,
    showProgress: showOperationsProgress,
    current: currentPreviewIndex,
    count: previewGroupCount,
    scale,
    onSwitchLeft,
    onSwitchRight,
    onZoomIn,
    onZoomOut,
    onRotateRight,
    onRotateLeft,
    onFlipX,
    onFlipY,
    onClose
  }));
};
var _excluded$3 = ["src", "alt", "onPreviewClose", "prefixCls", "previewPrefixCls", "placeholder", "fallback", "width", "height", "style", "preview", "className", "onClick", "onError", "wrapperClassName", "wrapperStyle", "rootClassName", "crossOrigin", "decoding", "loading", "referrerPolicy", "sizes", "srcSet", "useMap", "draggable"], _excluded2 = ["src", "visible", "onVisibleChange", "getContainer", "mask", "maskClassName", "icons", "scaleStep"];
var uuid = 0;
function isImageValid(src) {
  return new Promise(function(resolve) {
    var img = document.createElement("img");
    img.onerror = function() {
      return resolve(false);
    };
    img.onload = function() {
      return resolve(true);
    };
    img.src = src;
  });
}
var ImageInternal = function ImageInternal2(_ref2) {
  var _imgCommonProps$style;
  var imgSrc = _ref2.src, alt = _ref2.alt, onInitialPreviewClose = _ref2.onPreviewClose, _ref$prefixCls = _ref2.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-image" : _ref$prefixCls, _ref$previewPrefixCls = _ref2.previewPrefixCls, previewPrefixCls = _ref$previewPrefixCls === void 0 ? "".concat(prefixCls, "-preview") : _ref$previewPrefixCls, placeholder = _ref2.placeholder, fallback = _ref2.fallback, width = _ref2.width, height = _ref2.height, style2 = _ref2.style, _ref$preview = _ref2.preview, preview = _ref$preview === void 0 ? true : _ref$preview, className = _ref2.className, onClick = _ref2.onClick, onError2 = _ref2.onError, wrapperClassName = _ref2.wrapperClassName, wrapperStyle = _ref2.wrapperStyle, rootClassName = _ref2.rootClassName, crossOrigin = _ref2.crossOrigin, decoding = _ref2.decoding, loading = _ref2.loading, referrerPolicy = _ref2.referrerPolicy, sizes2 = _ref2.sizes, srcSet = _ref2.srcSet, useMap = _ref2.useMap, draggable = _ref2.draggable, otherProps = _objectWithoutProperties$1(_ref2, _excluded$3);
  var isCustomPlaceholder = placeholder && placeholder !== true;
  var _ref22 = _typeof$8(preview) === "object" ? preview : {}, previewSrc = _ref22.src, _ref2$visible = _ref22.visible, previewVisible = _ref2$visible === void 0 ? void 0 : _ref2$visible, _ref2$onVisibleChange = _ref22.onVisibleChange, onPreviewVisibleChange = _ref2$onVisibleChange === void 0 ? onInitialPreviewClose : _ref2$onVisibleChange, _ref2$getContainer = _ref22.getContainer, getPreviewContainer = _ref2$getContainer === void 0 ? void 0 : _ref2$getContainer, previewMask = _ref22.mask, maskClassName = _ref22.maskClassName, icons2 = _ref22.icons, scaleStep = _ref22.scaleStep, dialogProps = _objectWithoutProperties$1(_ref22, _excluded2);
  var src = previewSrc !== null && previewSrc !== void 0 ? previewSrc : imgSrc;
  var isControlled = previewVisible !== void 0;
  var _useMergedState = useMergedState(!!previewVisible, {
    value: previewVisible,
    onChange: onPreviewVisibleChange
  }), _useMergedState2 = _slicedToArray$1(_useMergedState, 2), isShowPreview = _useMergedState2[0], setShowPreview2 = _useMergedState2[1];
  var _useState = React.useState(isCustomPlaceholder ? "loading" : "normal"), _useState2 = _slicedToArray$1(_useState, 2), status = _useState2[0], setStatus = _useState2[1];
  var _useState3 = React.useState(null), _useState4 = _slicedToArray$1(_useState3, 2), mousePosition2 = _useState4[0], setMousePosition2 = _useState4[1];
  var isError = status === "error";
  var _React$useContext = React.useContext(context$3), isPreviewGroup = _React$useContext.isPreviewGroup, setCurrent2 = _React$useContext.setCurrent, setGroupShowPreview = _React$useContext.setShowPreview, setGroupMousePosition = _React$useContext.setMousePosition, registerImage2 = _React$useContext.registerImage;
  var _React$useState = React.useState(function() {
    uuid += 1;
    return uuid;
  }), _React$useState2 = _slicedToArray$1(_React$useState, 1), currentId = _React$useState2[0];
  var canPreview = !!preview;
  var isLoaded = React.useRef(false);
  var onLoad = function onLoad2() {
    setStatus("normal");
  };
  var onPreview = function onPreview2(e2) {
    if (!isControlled) {
      var _getOffset = getOffset(e2.target), left = _getOffset.left, top = _getOffset.top;
      if (isPreviewGroup) {
        setCurrent2(currentId);
        setGroupMousePosition({
          x: left,
          y: top
        });
      } else {
        setMousePosition2({
          x: left,
          y: top
        });
      }
    }
    if (isPreviewGroup) {
      setGroupShowPreview(true);
    } else {
      setShowPreview2(true);
    }
    onClick === null || onClick === void 0 ? void 0 : onClick(e2);
  };
  var onPreviewClose = function onPreviewClose2(e2) {
    e2.stopPropagation();
    setShowPreview2(false);
    if (!isControlled) {
      setMousePosition2(null);
    }
  };
  var getImgRef = function getImgRef2(img) {
    isLoaded.current = false;
    if (status !== "loading")
      return;
    if (img !== null && img !== void 0 && img.complete && (img.naturalWidth || img.naturalHeight)) {
      isLoaded.current = true;
      onLoad();
    }
  };
  React.useEffect(function() {
    isImageValid(src).then(function(isValid) {
      if (!isValid) {
        setStatus("error");
      }
    });
  }, [src]);
  React.useEffect(function() {
    var unRegister = registerImage2(currentId, src);
    return unRegister;
  }, []);
  React.useEffect(function() {
    registerImage2(currentId, src, canPreview);
  }, [src, canPreview]);
  React.useEffect(function() {
    if (isError) {
      setStatus("normal");
    }
    if (isCustomPlaceholder && !isLoaded.current) {
      setStatus("loading");
    }
  }, [imgSrc]);
  var wrapperClass = classNames(prefixCls, wrapperClassName, rootClassName, _defineProperty$3({}, "".concat(prefixCls, "-error"), isError));
  var mergedSrc = isError && fallback ? fallback : src;
  var imgCommonProps = {
    crossOrigin,
    decoding,
    draggable,
    loading,
    referrerPolicy,
    sizes: sizes2,
    srcSet,
    useMap,
    onError: onError2,
    alt,
    className: classNames("".concat(prefixCls, "-img"), _defineProperty$3({}, "".concat(prefixCls, "-img-placeholder"), placeholder === true), className),
    style: _objectSpread2$d({
      height
    }, style2)
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", _extends$3({}, otherProps, {
    className: wrapperClass,
    onClick: canPreview ? onPreview : onClick,
    style: _objectSpread2$d({
      width,
      height
    }, wrapperStyle)
  }), /* @__PURE__ */ React.createElement("img", _extends$3({}, imgCommonProps, {
    ref: getImgRef
  }, isError && fallback ? {
    src: fallback
  } : {
    onLoad,
    src: imgSrc
  }, {
    width,
    height
  })), status === "loading" && /* @__PURE__ */ React.createElement("div", {
    "aria-hidden": "true",
    className: "".concat(prefixCls, "-placeholder")
  }, placeholder), previewMask && canPreview && /* @__PURE__ */ React.createElement("div", {
    className: classNames("".concat(prefixCls, "-mask"), maskClassName),
    style: {
      display: ((_imgCommonProps$style = imgCommonProps.style) === null || _imgCommonProps$style === void 0 ? void 0 : _imgCommonProps$style.display) === "none" ? "none" : void 0
    }
  }, previewMask)), !isPreviewGroup && canPreview && /* @__PURE__ */ React.createElement(Preview, _extends$3({
    "aria-hidden": !isShowPreview,
    visible: isShowPreview,
    prefixCls: previewPrefixCls,
    onClose: onPreviewClose,
    mousePosition: mousePosition2,
    src: mergedSrc,
    alt,
    getContainer: getPreviewContainer,
    icons: icons2,
    scaleStep,
    rootClassName
  }, dialogProps)));
};
ImageInternal.PreviewGroup = Group;
ImageInternal.displayName = "Image";
var RotateLeftOutlined = function RotateLeftOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: RotateLeftOutlinedSvg
  }));
};
RotateLeftOutlined.displayName = "RotateLeftOutlined";
var RotateLeftOutlined$1 = /* @__PURE__ */ React.forwardRef(RotateLeftOutlined);
var RotateRightOutlined = function RotateRightOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: RotateRightOutlinedSvg
  }));
};
RotateRightOutlined.displayName = "RotateRightOutlined";
var RotateRightOutlined$1 = /* @__PURE__ */ React.forwardRef(RotateRightOutlined);
var SwapOutlined = function SwapOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: SwapOutlinedSvg
  }));
};
SwapOutlined.displayName = "SwapOutlined";
var SwapOutlined$1 = /* @__PURE__ */ React.forwardRef(SwapOutlined);
var ZoomInOutlined = function ZoomInOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: ZoomInOutlinedSvg
  }));
};
ZoomInOutlined.displayName = "ZoomInOutlined";
var ZoomInOutlined$1 = /* @__PURE__ */ React.forwardRef(ZoomInOutlined);
var ZoomOutOutlined = function ZoomOutOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: ZoomOutOutlinedSvg
  }));
};
ZoomOutOutlined.displayName = "ZoomOutOutlined";
var ZoomOutOutlined$1 = /* @__PURE__ */ React.forwardRef(ZoomOutOutlined);
const genBoxStyle = (position2) => ({
  position: position2 || "absolute",
  inset: 0
});
const genImageMaskStyle = (token2) => {
  const {
    iconCls,
    motionDurationSlow,
    paddingXXS,
    marginXXS,
    prefixCls
  } = token2;
  return {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    color: "#fff",
    background: new TinyColor("#000").setAlpha(0.5).toRgbString(),
    cursor: "pointer",
    opacity: 0,
    transition: `opacity ${motionDurationSlow}`,
    [`.${prefixCls}-mask-info`]: Object.assign(Object.assign({}, textEllipsis), {
      padding: `0 ${paddingXXS}px`,
      [iconCls]: {
        marginInlineEnd: marginXXS,
        svg: {
          verticalAlign: "baseline"
        }
      }
    })
  };
};
const genPreviewOperationsStyle = (token2) => {
  const {
    previewCls,
    modalMaskBg,
    paddingSM,
    imagePreviewOperationDisabledColor,
    motionDurationSlow
  } = token2;
  const operationBg = new TinyColor(modalMaskBg).setAlpha(0.1);
  const operationBgHover = operationBg.clone().setAlpha(0.2);
  return {
    [`${previewCls}-operations`]: Object.assign(Object.assign({}, resetComponent(token2)), {
      display: "flex",
      flexDirection: "row-reverse",
      alignItems: "center",
      color: token2.imagePreviewOperationColor,
      listStyle: "none",
      background: operationBg.toRgbString(),
      pointerEvents: "auto",
      "&-operation": {
        marginInlineStart: paddingSM,
        padding: paddingSM,
        cursor: "pointer",
        transition: `all ${motionDurationSlow}`,
        "&:hover": {
          background: operationBgHover.toRgbString()
        },
        "&-disabled": {
          color: imagePreviewOperationDisabledColor,
          pointerEvents: "none"
        },
        "&:last-of-type": {
          marginInlineStart: 0
        }
      },
      "&-progress": {
        position: "absolute",
        left: {
          _skip_check_: true,
          value: "50%"
        },
        transform: "translateX(-50%)"
      },
      "&-icon": {
        fontSize: token2.imagePreviewOperationSize
      }
    })
  };
};
const genPreviewSwitchStyle = (token2) => {
  const {
    modalMaskBg,
    iconCls,
    imagePreviewOperationDisabledColor,
    previewCls,
    zIndexPopup,
    motionDurationSlow
  } = token2;
  const operationBg = new TinyColor(modalMaskBg).setAlpha(0.1);
  const operationBgHover = operationBg.clone().setAlpha(0.2);
  return {
    [`${previewCls}-switch-left, ${previewCls}-switch-right`]: {
      position: "fixed",
      insetBlockStart: "50%",
      zIndex: zIndexPopup + 1,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: token2.imagePreviewSwitchSize,
      height: token2.imagePreviewSwitchSize,
      marginTop: -token2.imagePreviewSwitchSize / 2,
      color: token2.imagePreviewOperationColor,
      background: operationBg.toRgbString(),
      borderRadius: "50%",
      transform: `translateY(-50%)`,
      cursor: "pointer",
      transition: `all ${motionDurationSlow}`,
      pointerEvents: "auto",
      "&:hover": {
        background: operationBgHover.toRgbString()
      },
      [`&-disabled`]: {
        "&, &:hover": {
          color: imagePreviewOperationDisabledColor,
          background: "transparent",
          cursor: "not-allowed",
          [`> ${iconCls}`]: {
            cursor: "not-allowed"
          }
        }
      },
      [`> ${iconCls}`]: {
        fontSize: token2.imagePreviewOperationSize
      }
    },
    [`${previewCls}-switch-left`]: {
      insetInlineStart: token2.marginSM
    },
    [`${previewCls}-switch-right`]: {
      insetInlineEnd: token2.marginSM
    }
  };
};
const genImagePreviewStyle = (token2) => {
  const {
    motionEaseOut,
    previewCls,
    motionDurationSlow,
    componentCls
  } = token2;
  return [
    {
      [`${componentCls}-preview-root`]: {
        [previewCls]: {
          height: "100%",
          textAlign: "center",
          pointerEvents: "none"
        },
        [`${previewCls}-body`]: Object.assign(Object.assign({}, genBoxStyle()), {
          overflow: "hidden"
        }),
        [`${previewCls}-img`]: {
          maxWidth: "100%",
          maxHeight: "100%",
          verticalAlign: "middle",
          transform: "scale3d(1, 1, 1)",
          cursor: "grab",
          transition: `transform ${motionDurationSlow} ${motionEaseOut} 0s`,
          userSelect: "none",
          pointerEvents: "auto",
          "&-wrapper": Object.assign(Object.assign({}, genBoxStyle()), {
            transition: `transform ${motionDurationSlow} ${motionEaseOut} 0s`,
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            "&::before": {
              display: "inline-block",
              width: 1,
              height: "50%",
              marginInlineEnd: -1,
              content: '""'
            }
          })
        },
        [`${previewCls}-moving`]: {
          [`${previewCls}-preview-img`]: {
            cursor: "grabbing",
            "&-wrapper": {
              transitionDuration: "0s"
            }
          }
        }
      }
    },
    {
      [`${componentCls}-preview-root`]: {
        [`${previewCls}-wrap`]: {
          zIndex: token2.zIndexPopup
        }
      }
    },
    {
      [`${componentCls}-preview-operations-wrapper`]: {
        position: "fixed",
        insetBlockStart: 0,
        insetInlineEnd: 0,
        zIndex: token2.zIndexPopup + 1,
        width: "100%"
      },
      "&": [genPreviewOperationsStyle(token2), genPreviewSwitchStyle(token2)]
    }
  ];
};
const genImageStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      position: "relative",
      display: "inline-block",
      [`${componentCls}-img`]: {
        width: "100%",
        height: "auto",
        verticalAlign: "middle"
      },
      [`${componentCls}-img-placeholder`]: {
        backgroundColor: token2.colorBgContainerDisabled,
        backgroundImage: "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTQuNSAyLjVoLTEzQS41LjUgMCAwIDAgMSAzdjEwYS41LjUgMCAwIDAgLjUuNWgxM2EuNS41IDAgMCAwIC41LS41VjNhLjUuNSAwIDAgMC0uNS0uNXpNNS4yODEgNC43NWExIDEgMCAwIDEgMCAyIDEgMSAwIDAgMSAwLTJ6bTguMDMgNi44M2EuMTI3LjEyNyAwIDAgMS0uMDgxLjAzSDIuNzY5YS4xMjUuMTI1IDAgMCAxLS4wOTYtLjIwN2wyLjY2MS0zLjE1NmEuMTI2LjEyNiAwIDAgMSAuMTc3LS4wMTZsLjAxNi4wMTZMNy4wOCAxMC4wOWwyLjQ3LTIuOTNhLjEyNi4xMjYgMCAwIDEgLjE3Ny0uMDE2bC4wMTUuMDE2IDMuNTg4IDQuMjQ0YS4xMjcuMTI3IDAgMCAxLS4wMi4xNzV6IiBmaWxsPSIjOEM4QzhDIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=')",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center center",
        backgroundSize: "30%"
      },
      [`${componentCls}-mask`]: Object.assign({}, genImageMaskStyle(token2)),
      [`${componentCls}-mask:hover`]: {
        opacity: 1
      },
      [`${componentCls}-placeholder`]: Object.assign({}, genBoxStyle())
    }
  };
};
const genPreviewMotion = (token2) => {
  const {
    previewCls
  } = token2;
  return {
    [`${previewCls}-root`]: initZoomMotion(token2, "zoom"),
    [`&`]: initFadeMotion(token2, true)
  };
};
var useStyle$4 = genComponentStyleHook$2("Image", (token2) => {
  const imagePreviewOperationColor = new TinyColor(token2.colorTextLightSolid);
  const previewCls = `${token2.componentCls}-preview`;
  const imageToken = merge$1(token2, {
    previewCls,
    imagePreviewOperationColor: imagePreviewOperationColor.toRgbString(),
    imagePreviewOperationDisabledColor: new TinyColor(imagePreviewOperationColor).setAlpha(0.25).toRgbString(),
    modalMaskBg: new TinyColor("#000").setAlpha(0.45).toRgbString(),
    imagePreviewOperationSize: token2.fontSizeIcon * 1.5,
    imagePreviewSwitchSize: token2.controlHeightLG
  });
  return [genImageStyle(imageToken), genImagePreviewStyle(imageToken), genModalMaskStyle(merge$1(imageToken, {
    componentCls: previewCls
  })), genPreviewMotion(imageToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 80
}));
var __rest$c = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const icons = {
  rotateLeft: /* @__PURE__ */ React.createElement(RotateLeftOutlined$1, null),
  rotateRight: /* @__PURE__ */ React.createElement(RotateRightOutlined$1, null),
  zoomIn: /* @__PURE__ */ React.createElement(ZoomInOutlined$1, null),
  zoomOut: /* @__PURE__ */ React.createElement(ZoomOutOutlined$1, null),
  close: /* @__PURE__ */ React.createElement(CloseOutlined$1, null),
  left: /* @__PURE__ */ React.createElement(LeftOutlined$1, null),
  right: /* @__PURE__ */ React.createElement(RightOutlined$1, null),
  flipX: /* @__PURE__ */ React.createElement(SwapOutlined$1, null),
  flipY: /* @__PURE__ */ React.createElement(SwapOutlined$1, {
    rotate: 90
  })
};
const InternalPreviewGroup = (_a2) => {
  var {
    previewPrefixCls: customizePrefixCls,
    preview
  } = _a2, props = __rest$c(_a2, ["previewPrefixCls", "preview"]);
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("image", customizePrefixCls);
  const previewPrefixCls = `${prefixCls}-preview`;
  const rootPrefixCls = getPrefixCls();
  const [wrapSSR, hashId] = useStyle$4(prefixCls);
  const mergedPreview = React.useMemo(() => {
    var _a3;
    if (preview === false) {
      return preview;
    }
    const _preview = typeof preview === "object" ? preview : {};
    const mergedRootClassName = classNames(hashId, (_a3 = _preview.rootClassName) !== null && _a3 !== void 0 ? _a3 : "");
    return Object.assign(Object.assign({}, _preview), {
      transitionName: getTransitionName$1(rootPrefixCls, "zoom", _preview.transitionName),
      maskTransitionName: getTransitionName$1(rootPrefixCls, "fade", _preview.maskTransitionName),
      rootClassName: mergedRootClassName
    });
  }, [preview]);
  return wrapSSR(/* @__PURE__ */ React.createElement(ImageInternal.PreviewGroup, Object.assign({
    preview: mergedPreview,
    previewPrefixCls,
    icons
  }, props)));
};
var PreviewGroup = InternalPreviewGroup;
var __rest$b = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const Image = (_a2) => {
  var {
    prefixCls: customizePrefixCls,
    preview,
    rootClassName
  } = _a2, otherProps = __rest$b(_a2, ["prefixCls", "preview", "rootClassName"]);
  const {
    getPrefixCls,
    locale: contextLocale = defaultLocale,
    getPopupContainer: getContextPopupContainer
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("image", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const imageLocale = contextLocale.Image || defaultLocale.Image;
  const [wrapSSR, hashId] = useStyle$4(prefixCls);
  const mergedRootClassName = classNames(rootClassName, hashId);
  const mergedPreview = React.useMemo(() => {
    if (preview === false) {
      return preview;
    }
    const _preview = typeof preview === "object" ? preview : {};
    const {
      getContainer: getContainer2
    } = _preview, restPreviewProps = __rest$b(_preview, ["getContainer"]);
    return Object.assign(Object.assign({
      mask: /* @__PURE__ */ React.createElement("div", {
        className: `${prefixCls}-mask-info`
      }, /* @__PURE__ */ React.createElement(EyeOutlined$1, null), imageLocale === null || imageLocale === void 0 ? void 0 : imageLocale.preview),
      icons
    }, restPreviewProps), {
      getContainer: getContainer2 || getContextPopupContainer,
      transitionName: getTransitionName$1(rootPrefixCls, "zoom", _preview.transitionName),
      maskTransitionName: getTransitionName$1(rootPrefixCls, "fade", _preview.maskTransitionName)
    });
  }, [preview, imageLocale]);
  return wrapSSR(/* @__PURE__ */ React.createElement(ImageInternal, Object.assign({
    prefixCls: `${prefixCls}`,
    preview: mergedPreview,
    rootClassName: mergedRootClassName
  }, otherProps)));
};
Image.PreviewGroup = PreviewGroup;
var Image$1 = Image;
function hasAddon(props) {
  return !!(props.addonBefore || props.addonAfter);
}
function hasPrefixSuffix$1(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}
function resolveOnChange(target, e2, onChange, targetValue) {
  if (!onChange) {
    return;
  }
  var event = e2;
  if (e2.type === "click") {
    var currentTarget = target.cloneNode(true);
    event = Object.create(e2, {
      target: {
        value: currentTarget
      },
      currentTarget: {
        value: currentTarget
      }
    });
    currentTarget.value = "";
    onChange(event);
    return;
  }
  if (targetValue !== void 0) {
    event = Object.create(e2, {
      target: {
        value: target
      },
      currentTarget: {
        value: target
      }
    });
    target.value = targetValue;
    onChange(event);
    return;
  }
  onChange(event);
}
function triggerFocus$1(element2, option) {
  if (!element2)
    return;
  element2.focus(option);
  var _ref2 = option || {}, cursor2 = _ref2.cursor;
  if (cursor2) {
    var len = element2.value.length;
    switch (cursor2) {
      case "start":
        element2.setSelectionRange(0, 0);
        break;
      case "end":
        element2.setSelectionRange(len, len);
        break;
      default:
        element2.setSelectionRange(0, len);
    }
  }
}
function fixControlledValue(value) {
  if (typeof value === "undefined" || value === null) {
    return "";
  }
  return String(value);
}
var BaseInput = function BaseInput2(props) {
  var _inputElement$props, _inputElement$props2;
  var inputElement = props.inputElement, prefixCls = props.prefixCls, prefix2 = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style2 = props.style, disabled = props.disabled, readOnly = props.readOnly, focused = props.focused, triggerFocus2 = props.triggerFocus, allowClear = props.allowClear, value = props.value, handleReset = props.handleReset, hidden = props.hidden, classes = props.classes, classNames$1 = props.classNames, dataAttrs = props.dataAttrs, styles = props.styles;
  var containerRef = React.useRef(null);
  var onInputClick = function onInputClick2(e2) {
    var _containerRef$current;
    if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e2.target)) {
      triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();
    }
  };
  var getClearIcon = function getClearIcon2() {
    var _clsx;
    if (!allowClear) {
      return null;
    }
    var needClear = !disabled && !readOnly && value;
    var clearIconCls = "".concat(prefixCls, "-clear-icon");
    var iconNode = _typeof$8(allowClear) === "object" && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : "\u2716";
    return /* @__PURE__ */ React.createElement("span", {
      onClick: handleReset,
      onMouseDown: function onMouseDown(e2) {
        return e2.preventDefault();
      },
      className: classNames(clearIconCls, (_clsx = {}, _defineProperty$3(_clsx, "".concat(clearIconCls, "-hidden"), !needClear), _defineProperty$3(_clsx, "".concat(clearIconCls, "-has-suffix"), !!suffix), _clsx)),
      role: "button",
      tabIndex: -1
    }, iconNode);
  };
  var element2 = /* @__PURE__ */ React.cloneElement(inputElement, {
    value,
    hidden,
    className: classNames((_inputElement$props = inputElement.props) === null || _inputElement$props === void 0 ? void 0 : _inputElement$props.className, !hasPrefixSuffix$1(props) && !hasAddon(props) && className) || null,
    style: _objectSpread2$d(_objectSpread2$d({}, (_inputElement$props2 = inputElement.props) === null || _inputElement$props2 === void 0 ? void 0 : _inputElement$props2.style), !hasPrefixSuffix$1(props) && !hasAddon(props) ? style2 : {})
  });
  if (hasPrefixSuffix$1(props)) {
    var _clsx2;
    var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
    var affixWrapperCls = classNames(affixWrapperPrefixCls, (_clsx2 = {}, _defineProperty$3(_clsx2, "".concat(affixWrapperPrefixCls, "-disabled"), disabled), _defineProperty$3(_clsx2, "".concat(affixWrapperPrefixCls, "-focused"), focused), _defineProperty$3(_clsx2, "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), _defineProperty$3(_clsx2, "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value), _clsx2), !hasAddon(props) && className, classes === null || classes === void 0 ? void 0 : classes.affixWrapper);
    var suffixNode = (suffix || allowClear) && /* @__PURE__ */ React.createElement("span", {
      className: classNames("".concat(prefixCls, "-suffix"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.suffix),
      style: styles === null || styles === void 0 ? void 0 : styles.suffix
    }, getClearIcon(), suffix);
    element2 = /* @__PURE__ */ React.createElement("span", _extends$3({
      className: affixWrapperCls,
      style: !hasAddon(props) ? style2 : void 0,
      hidden: !hasAddon(props) && hidden,
      onClick: onInputClick
    }, dataAttrs === null || dataAttrs === void 0 ? void 0 : dataAttrs.affixWrapper, {
      ref: containerRef
    }), prefix2 && /* @__PURE__ */ React.createElement("span", {
      className: classNames("".concat(prefixCls, "-prefix"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.prefix),
      style: styles === null || styles === void 0 ? void 0 : styles.prefix
    }, prefix2), /* @__PURE__ */ React.cloneElement(inputElement, {
      value,
      hidden: null
    }), suffixNode);
  }
  if (hasAddon(props)) {
    var wrapperCls = "".concat(prefixCls, "-group");
    var addonCls = "".concat(wrapperCls, "-addon");
    var mergedWrapperClassName = classNames("".concat(prefixCls, "-wrapper"), wrapperCls, classes === null || classes === void 0 ? void 0 : classes.wrapper);
    var mergedGroupClassName = classNames("".concat(prefixCls, "-group-wrapper"), className, classes === null || classes === void 0 ? void 0 : classes.group);
    return /* @__PURE__ */ React.createElement("span", {
      className: mergedGroupClassName,
      style: style2,
      hidden
    }, /* @__PURE__ */ React.createElement("span", {
      className: mergedWrapperClassName
    }, addonBefore && /* @__PURE__ */ React.createElement("span", {
      className: addonCls
    }, addonBefore), /* @__PURE__ */ React.cloneElement(element2, {
      hidden: null
    }), addonAfter && /* @__PURE__ */ React.createElement("span", {
      className: addonCls
    }, addonAfter)));
  }
  return element2;
};
var _excluded$2 = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "type", "classes", "classNames", "styles"];
var Input$2 = /* @__PURE__ */ React.forwardRef(function(props, ref2) {
  var autoComplete = props.autoComplete, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown = props.onKeyDown, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input" : _props$prefixCls, disabled = props.disabled, htmlSize = props.htmlSize, className = props.className, maxLength = props.maxLength, suffix = props.suffix, showCount = props.showCount, _props$type = props.type, type4 = _props$type === void 0 ? "text" : _props$type, classes = props.classes, classNames$1 = props.classNames, styles = props.styles, rest = _objectWithoutProperties$1(props, _excluded$2);
  var _useMergedState = useMergedState(props.defaultValue, {
    value: props.value
  }), _useMergedState2 = _slicedToArray$1(_useMergedState, 2), value = _useMergedState2[0], setValue2 = _useMergedState2[1];
  var _useState = React.useState(false), _useState2 = _slicedToArray$1(_useState, 2), focused = _useState2[0], setFocused = _useState2[1];
  var inputRef = React.useRef(null);
  var focus = function focus2(option) {
    if (inputRef.current) {
      triggerFocus$1(inputRef.current, option);
    }
  };
  React.useImperativeHandle(ref2, function() {
    return {
      focus,
      blur: function blur() {
        var _inputRef$current;
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.blur();
      },
      setSelectionRange: function setSelectionRange(start, end, direction) {
        var _inputRef$current2;
        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.setSelectionRange(start, end, direction);
      },
      select: function select() {
        var _inputRef$current3;
        (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.select();
      },
      input: inputRef.current
    };
  });
  React.useEffect(function() {
    setFocused(function(prev2) {
      return prev2 && disabled ? false : prev2;
    });
  }, [disabled]);
  var handleChange = function handleChange2(e2) {
    if (props.value === void 0) {
      setValue2(e2.target.value);
    }
    if (inputRef.current) {
      resolveOnChange(inputRef.current, e2, onChange);
    }
  };
  var handleKeyDown = function handleKeyDown2(e2) {
    if (onPressEnter && e2.key === "Enter") {
      onPressEnter(e2);
    }
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e2);
  };
  var handleFocus = function handleFocus2(e2) {
    setFocused(true);
    onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
  };
  var handleBlur = function handleBlur2(e2) {
    setFocused(false);
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
  };
  var handleReset = function handleReset2(e2) {
    setValue2("");
    focus();
    if (inputRef.current) {
      resolveOnChange(inputRef.current, e2, onChange);
    }
  };
  var getInputElement2 = function getInputElement3() {
    var otherProps = omit$2(props, [
      "prefixCls",
      "onPressEnter",
      "addonBefore",
      "addonAfter",
      "prefix",
      "suffix",
      "allowClear",
      "defaultValue",
      "showCount",
      "classes",
      "htmlSize",
      "styles",
      "classNames"
    ]);
    return /* @__PURE__ */ React.createElement("input", _extends$3({
      autoComplete
    }, otherProps, {
      onChange: handleChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      className: classNames(prefixCls, _defineProperty$3({}, "".concat(prefixCls, "-disabled"), disabled), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.input),
      style: styles === null || styles === void 0 ? void 0 : styles.input,
      ref: inputRef,
      size: htmlSize,
      type: type4
    }));
  };
  var getSuffix = function getSuffix2() {
    var hasMaxLength = Number(maxLength) > 0;
    if (suffix || showCount) {
      var val = fixControlledValue(value);
      var valueLength = _toConsumableArray(val).length;
      var dataCount = _typeof$8(showCount) === "object" ? showCount.formatter({
        value: val,
        count: valueLength,
        maxLength
      }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
      return /* @__PURE__ */ React.createElement(React.Fragment, null, !!showCount && /* @__PURE__ */ React.createElement("span", {
        className: classNames("".concat(prefixCls, "-show-count-suffix"), _defineProperty$3({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.count),
        style: _objectSpread2$d({}, styles === null || styles === void 0 ? void 0 : styles.count)
      }, dataCount), suffix);
    }
    return null;
  };
  return /* @__PURE__ */ React.createElement(BaseInput, _extends$3({}, rest, {
    prefixCls,
    className,
    inputElement: getInputElement2(),
    handleReset,
    value: fixControlledValue(value),
    focused,
    triggerFocus: focus,
    suffix: getSuffix(),
    disabled,
    classes,
    classNames: classNames$1,
    styles
  }));
});
var es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseInput,
  "default": Input$2
}, Symbol.toStringTag, { value: "Module" }));
var DoubleLeftOutlined = function DoubleLeftOutlined2(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: DoubleLeftOutlinedSvg
  }));
};
DoubleLeftOutlined.displayName = "DoubleLeftOutlined";
var DoubleLeftOutlined$1 = /* @__PURE__ */ React.forwardRef(DoubleLeftOutlined);
var DoubleRightOutlined2 = function DoubleRightOutlined3(props, ref2) {
  return /* @__PURE__ */ React.createElement(AntdIcon$1, _objectSpread2$d(_objectSpread2$d({}, props), {}, {
    ref: ref2,
    icon: DoubleRightOutlinedSvg
  }));
};
DoubleRightOutlined2.displayName = "DoubleRightOutlined";
var DoubleRightOutlined$1 = /* @__PURE__ */ React.forwardRef(DoubleRightOutlined2);
var KeyCode = {
  ZERO: 48,
  NINE: 57,
  NUMPAD_ZERO: 96,
  NUMPAD_NINE: 105,
  BACKSPACE: 8,
  DELETE: 46,
  ENTER: 13,
  ARROW_UP: 38,
  ARROW_DOWN: 40
};
var LOCALE = {
  items_per_page: "\u6761/\u9875",
  jump_to: "\u8DF3\u81F3",
  jump_to_confirm: "\u786E\u5B9A",
  page: "\u9875",
  prev_page: "\u4E0A\u4E00\u9875",
  next_page: "\u4E0B\u4E00\u9875",
  prev_5: "\u5411\u524D 5 \u9875",
  next_5: "\u5411\u540E 5 \u9875",
  prev_3: "\u5411\u524D 3 \u9875",
  next_3: "\u5411\u540E 3 \u9875",
  page_size: "\u9875\u7801"
};
var Options = /* @__PURE__ */ function(_React$Component) {
  _inherits$2(Options2, _React$Component);
  var _super = _createSuper$2(Options2);
  function Options2() {
    var _this;
    _classCallCheck$2(this, Options2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      goInputText: ""
    };
    _this.getValidValue = function() {
      var goInputText = _this.state.goInputText;
      return !goInputText || Number.isNaN(goInputText) ? void 0 : Number(goInputText);
    };
    _this.buildOptionText = function(value) {
      return "".concat(value, " ").concat(_this.props.locale.items_per_page);
    };
    _this.changeSize = function(value) {
      _this.props.changeSize(Number(value));
    };
    _this.handleChange = function(e2) {
      _this.setState({
        goInputText: e2.target.value
      });
    };
    _this.handleBlur = function(e2) {
      var _this$props = _this.props, goButton = _this$props.goButton, quickGo = _this$props.quickGo, rootPrefixCls = _this$props.rootPrefixCls;
      var goInputText = _this.state.goInputText;
      if (goButton || goInputText === "") {
        return;
      }
      _this.setState({
        goInputText: ""
      });
      if (e2.relatedTarget && (e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item-link")) >= 0 || e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item")) >= 0)) {
        return;
      }
      quickGo(_this.getValidValue());
    };
    _this.go = function(e2) {
      var goInputText = _this.state.goInputText;
      if (goInputText === "") {
        return;
      }
      if (e2.keyCode === KeyCode.ENTER || e2.type === "click") {
        _this.setState({
          goInputText: ""
        });
        _this.props.quickGo(_this.getValidValue());
      }
    };
    return _this;
  }
  _createClass$2(Options2, [{
    key: "getPageSizeOptions",
    value: function getPageSizeOptions() {
      var _this$props2 = this.props, pageSize = _this$props2.pageSize, pageSizeOptions = _this$props2.pageSizeOptions;
      if (pageSizeOptions.some(function(option) {
        return option.toString() === pageSize.toString();
      })) {
        return pageSizeOptions;
      }
      return pageSizeOptions.concat([pageSize.toString()]).sort(function(a, b2) {
        var numberA = Number.isNaN(Number(a)) ? 0 : Number(a);
        var numberB = Number.isNaN(Number(b2)) ? 0 : Number(b2);
        return numberA - numberB;
      });
    }
  }, {
    key: "render",
    value: function render2() {
      var _this2 = this;
      var _this$props3 = this.props, pageSize = _this$props3.pageSize, locale2 = _this$props3.locale, rootPrefixCls = _this$props3.rootPrefixCls, changeSize = _this$props3.changeSize, quickGo = _this$props3.quickGo, goButton = _this$props3.goButton, selectComponentClass = _this$props3.selectComponentClass, buildOptionText = _this$props3.buildOptionText, selectPrefixCls = _this$props3.selectPrefixCls, disabled = _this$props3.disabled;
      var goInputText = this.state.goInputText;
      var prefixCls = "".concat(rootPrefixCls, "-options");
      var Select2 = selectComponentClass;
      var changeSelect = null;
      var goInput = null;
      var gotoButton = null;
      if (!changeSize && !quickGo) {
        return null;
      }
      var pageSizeOptions = this.getPageSizeOptions();
      if (changeSize && Select2) {
        var options = pageSizeOptions.map(function(opt, i) {
          return /* @__PURE__ */ React.createElement(Select2.Option, {
            key: i,
            value: opt.toString()
          }, (buildOptionText || _this2.buildOptionText)(opt));
        });
        changeSelect = /* @__PURE__ */ React.createElement(Select2, {
          disabled,
          prefixCls: selectPrefixCls,
          showSearch: false,
          className: "".concat(prefixCls, "-size-changer"),
          optionLabelProp: "children",
          dropdownMatchSelectWidth: false,
          value: (pageSize || pageSizeOptions[0]).toString(),
          onChange: this.changeSize,
          getPopupContainer: function getPopupContainer(triggerNode) {
            return triggerNode.parentNode;
          },
          "aria-label": locale2.page_size,
          defaultOpen: false
        }, options);
      }
      if (quickGo) {
        if (goButton) {
          gotoButton = typeof goButton === "boolean" ? /* @__PURE__ */ React.createElement("button", {
            type: "button",
            onClick: this.go,
            onKeyUp: this.go,
            disabled,
            className: "".concat(prefixCls, "-quick-jumper-button")
          }, locale2.jump_to_confirm) : /* @__PURE__ */ React.createElement("span", {
            onClick: this.go,
            onKeyUp: this.go
          }, goButton);
        }
        goInput = /* @__PURE__ */ React.createElement("div", {
          className: "".concat(prefixCls, "-quick-jumper")
        }, locale2.jump_to, /* @__PURE__ */ React.createElement("input", {
          disabled,
          type: "text",
          value: goInputText,
          onChange: this.handleChange,
          onKeyUp: this.go,
          onBlur: this.handleBlur,
          "aria-label": locale2.page
        }), locale2.page, gotoButton);
      }
      return /* @__PURE__ */ React.createElement("li", {
        className: "".concat(prefixCls)
      }, changeSelect, goInput);
    }
  }]);
  return Options2;
}(React.Component);
Options.defaultProps = {
  pageSizeOptions: ["10", "20", "50", "100"]
};
var Pager = function Pager2(props) {
  var _classNames;
  var rootPrefixCls = props.rootPrefixCls, page = props.page, active = props.active, className = props.className, showTitle = props.showTitle, onClick = props.onClick, onKeyPress = props.onKeyPress, itemRender = props.itemRender;
  var prefixCls = "".concat(rootPrefixCls, "-item");
  var cls = classNames(prefixCls, "".concat(prefixCls, "-").concat(page), (_classNames = {}, _defineProperty$3(_classNames, "".concat(prefixCls, "-active"), active), _defineProperty$3(_classNames, "".concat(prefixCls, "-disabled"), !page), _defineProperty$3(_classNames, props.className, className), _classNames));
  var handleClick = function handleClick2() {
    onClick(page);
  };
  var handleKeyPress = function handleKeyPress2(e2) {
    onKeyPress(e2, onClick, page);
  };
  return /* @__PURE__ */ React.createElement("li", {
    title: showTitle ? page.toString() : null,
    className: cls,
    onClick: handleClick,
    onKeyPress: handleKeyPress,
    tabIndex: 0
  }, itemRender(page, "page", /* @__PURE__ */ React.createElement("a", {
    rel: "nofollow"
  }, page)));
};
function noop$1() {
}
function isInteger(v2) {
  var value = Number(v2);
  return typeof value === "number" && !Number.isNaN(value) && isFinite(value) && Math.floor(value) === value;
}
var defaultItemRender = function defaultItemRender2(page, type4, element2) {
  return element2;
};
function calculatePage(p2, state, props) {
  var pageSize = typeof p2 === "undefined" ? state.pageSize : p2;
  return Math.floor((props.total - 1) / pageSize) + 1;
}
var Pagination$2 = /* @__PURE__ */ function(_React$Component) {
  _inherits$2(Pagination2, _React$Component);
  var _super = _createSuper$2(Pagination2);
  function Pagination2(props) {
    var _this;
    _classCallCheck$2(this, Pagination2);
    _this = _super.call(this, props);
    _this.paginationNode = /* @__PURE__ */ React.createRef();
    _this.getJumpPrevPage = function() {
      return Math.max(1, _this.state.current - (_this.props.showLessItems ? 3 : 5));
    };
    _this.getJumpNextPage = function() {
      return Math.min(calculatePage(void 0, _this.state, _this.props), _this.state.current + (_this.props.showLessItems ? 3 : 5));
    };
    _this.getItemIcon = function(icon, label) {
      var prefixCls = _this.props.prefixCls;
      var iconNode = icon || /* @__PURE__ */ React.createElement("button", {
        type: "button",
        "aria-label": label,
        className: "".concat(prefixCls, "-item-link")
      });
      if (typeof icon === "function") {
        iconNode = /* @__PURE__ */ React.createElement(icon, _objectSpread2$d({}, _this.props));
      }
      return iconNode;
    };
    _this.isValid = function(page) {
      var total = _this.props.total;
      return isInteger(page) && page !== _this.state.current && isInteger(total) && total > 0;
    };
    _this.shouldDisplayQuickJumper = function() {
      var _this$props = _this.props, showQuickJumper = _this$props.showQuickJumper, total = _this$props.total;
      var pageSize = _this.state.pageSize;
      if (total <= pageSize) {
        return false;
      }
      return showQuickJumper;
    };
    _this.handleKeyDown = function(e2) {
      if (e2.keyCode === KeyCode.ARROW_UP || e2.keyCode === KeyCode.ARROW_DOWN) {
        e2.preventDefault();
      }
    };
    _this.handleKeyUp = function(e2) {
      var value = _this.getValidValue(e2);
      var currentInputValue = _this.state.currentInputValue;
      if (value !== currentInputValue) {
        _this.setState({
          currentInputValue: value
        });
      }
      if (e2.keyCode === KeyCode.ENTER) {
        _this.handleChange(value);
      } else if (e2.keyCode === KeyCode.ARROW_UP) {
        _this.handleChange(value - 1);
      } else if (e2.keyCode === KeyCode.ARROW_DOWN) {
        _this.handleChange(value + 1);
      }
    };
    _this.handleBlur = function(e2) {
      var value = _this.getValidValue(e2);
      _this.handleChange(value);
    };
    _this.changePageSize = function(size) {
      var current = _this.state.current;
      var newCurrent = calculatePage(size, _this.state, _this.props);
      current = current > newCurrent ? newCurrent : current;
      if (newCurrent === 0) {
        current = _this.state.current;
      }
      if (typeof size === "number") {
        if (!("pageSize" in _this.props)) {
          _this.setState({
            pageSize: size
          });
        }
        if (!("current" in _this.props)) {
          _this.setState({
            current,
            currentInputValue: current
          });
        }
      }
      _this.props.onShowSizeChange(current, size);
      if ("onChange" in _this.props && _this.props.onChange) {
        _this.props.onChange(current, size);
      }
    };
    _this.handleChange = function(page) {
      var _this$props2 = _this.props, disabled = _this$props2.disabled, onChange = _this$props2.onChange;
      var _this$state = _this.state, pageSize = _this$state.pageSize, current = _this$state.current, currentInputValue = _this$state.currentInputValue;
      if (_this.isValid(page) && !disabled) {
        var currentPage = calculatePage(void 0, _this.state, _this.props);
        var newPage = page;
        if (page > currentPage) {
          newPage = currentPage;
        } else if (page < 1) {
          newPage = 1;
        }
        if (!("current" in _this.props)) {
          _this.setState({
            current: newPage
          });
        }
        if (newPage !== currentInputValue) {
          _this.setState({
            currentInputValue: newPage
          });
        }
        onChange(newPage, pageSize);
        return newPage;
      }
      return current;
    };
    _this.prev = function() {
      if (_this.hasPrev()) {
        _this.handleChange(_this.state.current - 1);
      }
    };
    _this.next = function() {
      if (_this.hasNext()) {
        _this.handleChange(_this.state.current + 1);
      }
    };
    _this.jumpPrev = function() {
      _this.handleChange(_this.getJumpPrevPage());
    };
    _this.jumpNext = function() {
      _this.handleChange(_this.getJumpNextPage());
    };
    _this.hasPrev = function() {
      return _this.state.current > 1;
    };
    _this.hasNext = function() {
      return _this.state.current < calculatePage(void 0, _this.state, _this.props);
    };
    _this.runIfEnter = function(event, callback) {
      if (event.key === "Enter" || event.charCode === 13) {
        for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          restParams[_key - 2] = arguments[_key];
        }
        callback.apply(void 0, restParams);
      }
    };
    _this.runIfEnterPrev = function(e2) {
      _this.runIfEnter(e2, _this.prev);
    };
    _this.runIfEnterNext = function(e2) {
      _this.runIfEnter(e2, _this.next);
    };
    _this.runIfEnterJumpPrev = function(e2) {
      _this.runIfEnter(e2, _this.jumpPrev);
    };
    _this.runIfEnterJumpNext = function(e2) {
      _this.runIfEnter(e2, _this.jumpNext);
    };
    _this.handleGoTO = function(e2) {
      if (e2.keyCode === KeyCode.ENTER || e2.type === "click") {
        _this.handleChange(_this.state.currentInputValue);
      }
    };
    _this.renderPrev = function(prevPage) {
      var _this$props3 = _this.props, prevIcon = _this$props3.prevIcon, itemRender = _this$props3.itemRender;
      var prevButton = itemRender(prevPage, "prev", _this.getItemIcon(prevIcon, "prev page"));
      var disabled = !_this.hasPrev();
      return /* @__PURE__ */ React.isValidElement(prevButton) ? /* @__PURE__ */ React.cloneElement(prevButton, {
        disabled
      }) : prevButton;
    };
    _this.renderNext = function(nextPage) {
      var _this$props4 = _this.props, nextIcon = _this$props4.nextIcon, itemRender = _this$props4.itemRender;
      var nextButton = itemRender(nextPage, "next", _this.getItemIcon(nextIcon, "next page"));
      var disabled = !_this.hasNext();
      return /* @__PURE__ */ React.isValidElement(nextButton) ? /* @__PURE__ */ React.cloneElement(nextButton, {
        disabled
      }) : nextButton;
    };
    var hasOnChange = props.onChange !== noop$1;
    var hasCurrent = "current" in props;
    if (hasCurrent && !hasOnChange) {
      console.warn("Warning: You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component.");
    }
    var _current = props.defaultCurrent;
    if ("current" in props) {
      _current = props.current;
    }
    var _pageSize = props.defaultPageSize;
    if ("pageSize" in props) {
      _pageSize = props.pageSize;
    }
    _current = Math.min(_current, calculatePage(_pageSize, void 0, props));
    _this.state = {
      current: _current,
      currentInputValue: _current,
      pageSize: _pageSize
    };
    return _this;
  }
  _createClass$2(Pagination2, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(_24, prevState) {
      var prefixCls = this.props.prefixCls;
      if (prevState.current !== this.state.current && this.paginationNode.current) {
        var lastCurrentNode = this.paginationNode.current.querySelector(".".concat(prefixCls, "-item-").concat(prevState.current));
        if (lastCurrentNode && document.activeElement === lastCurrentNode) {
          var _lastCurrentNode$blur;
          lastCurrentNode === null || lastCurrentNode === void 0 ? void 0 : (_lastCurrentNode$blur = lastCurrentNode.blur) === null || _lastCurrentNode$blur === void 0 ? void 0 : _lastCurrentNode$blur.call(lastCurrentNode);
        }
      }
    }
  }, {
    key: "getValidValue",
    value: function getValidValue(e2) {
      var inputValue = e2.target.value;
      var allPages = calculatePage(void 0, this.state, this.props);
      var currentInputValue = this.state.currentInputValue;
      var value;
      if (inputValue === "") {
        value = inputValue;
      } else if (Number.isNaN(Number(inputValue))) {
        value = currentInputValue;
      } else if (inputValue >= allPages) {
        value = allPages;
      } else {
        value = Number(inputValue);
      }
      return value;
    }
  }, {
    key: "getShowSizeChanger",
    value: function getShowSizeChanger() {
      var _this$props5 = this.props, showSizeChanger = _this$props5.showSizeChanger, total = _this$props5.total, totalBoundaryShowSizeChanger = _this$props5.totalBoundaryShowSizeChanger;
      if (typeof showSizeChanger !== "undefined") {
        return showSizeChanger;
      }
      return total > totalBoundaryShowSizeChanger;
    }
  }, {
    key: "render",
    value: function render2() {
      var _this2 = this;
      var _this$props6 = this.props, prefixCls = _this$props6.prefixCls, className = _this$props6.className, style2 = _this$props6.style, disabled = _this$props6.disabled, hideOnSinglePage = _this$props6.hideOnSinglePage, total = _this$props6.total, locale2 = _this$props6.locale, showQuickJumper = _this$props6.showQuickJumper, showLessItems = _this$props6.showLessItems, showTitle = _this$props6.showTitle, showTotal = _this$props6.showTotal, simple = _this$props6.simple, itemRender = _this$props6.itemRender, showPrevNextJumpers = _this$props6.showPrevNextJumpers, jumpPrevIcon = _this$props6.jumpPrevIcon, jumpNextIcon = _this$props6.jumpNextIcon, selectComponentClass = _this$props6.selectComponentClass, selectPrefixCls = _this$props6.selectPrefixCls, pageSizeOptions = _this$props6.pageSizeOptions;
      var _this$state2 = this.state, current = _this$state2.current, pageSize = _this$state2.pageSize, currentInputValue = _this$state2.currentInputValue;
      if (hideOnSinglePage === true && total <= pageSize) {
        return null;
      }
      var allPages = calculatePage(void 0, this.state, this.props);
      var pagerList = [];
      var jumpPrev = null;
      var jumpNext = null;
      var firstPager = null;
      var lastPager = null;
      var gotoButton = null;
      var goButton = showQuickJumper && showQuickJumper.goButton;
      var pageBufferSize = showLessItems ? 1 : 2;
      var prevPage = current - 1 > 0 ? current - 1 : 0;
      var nextPage = current + 1 < allPages ? current + 1 : allPages;
      var dataOrAriaAttributeProps = Object.keys(this.props).reduce(function(prev2, key) {
        if (key.substr(0, 5) === "data-" || key.substr(0, 5) === "aria-" || key === "role") {
          prev2[key] = _this2.props[key];
        }
        return prev2;
      }, {});
      var totalText = showTotal && /* @__PURE__ */ React.createElement("li", {
        className: "".concat(prefixCls, "-total-text")
      }, showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize]));
      if (simple) {
        if (goButton) {
          if (typeof goButton === "boolean") {
            gotoButton = /* @__PURE__ */ React.createElement("button", {
              type: "button",
              onClick: this.handleGoTO,
              onKeyUp: this.handleGoTO
            }, locale2.jump_to_confirm);
          } else {
            gotoButton = /* @__PURE__ */ React.createElement("span", {
              onClick: this.handleGoTO,
              onKeyUp: this.handleGoTO
            }, goButton);
          }
          gotoButton = /* @__PURE__ */ React.createElement("li", {
            title: showTitle ? "".concat(locale2.jump_to).concat(current, "/").concat(allPages) : null,
            className: "".concat(prefixCls, "-simple-pager")
          }, gotoButton);
        }
        return /* @__PURE__ */ React.createElement("ul", _extends$3({
          className: classNames(prefixCls, "".concat(prefixCls, "-simple"), _defineProperty$3({}, "".concat(prefixCls, "-disabled"), disabled), className),
          style: style2,
          ref: this.paginationNode
        }, dataOrAriaAttributeProps), totalText, /* @__PURE__ */ React.createElement("li", {
          title: showTitle ? locale2.prev_page : null,
          onClick: this.prev,
          tabIndex: this.hasPrev() ? 0 : null,
          onKeyPress: this.runIfEnterPrev,
          className: classNames("".concat(prefixCls, "-prev"), _defineProperty$3({}, "".concat(prefixCls, "-disabled"), !this.hasPrev())),
          "aria-disabled": !this.hasPrev()
        }, this.renderPrev(prevPage)), /* @__PURE__ */ React.createElement("li", {
          title: showTitle ? "".concat(current, "/").concat(allPages) : null,
          className: "".concat(prefixCls, "-simple-pager")
        }, /* @__PURE__ */ React.createElement("input", {
          type: "text",
          value: currentInputValue,
          disabled,
          onKeyDown: this.handleKeyDown,
          onKeyUp: this.handleKeyUp,
          onChange: this.handleKeyUp,
          onBlur: this.handleBlur,
          size: 3
        }), /* @__PURE__ */ React.createElement("span", {
          className: "".concat(prefixCls, "-slash")
        }, "/"), allPages), /* @__PURE__ */ React.createElement("li", {
          title: showTitle ? locale2.next_page : null,
          onClick: this.next,
          tabIndex: this.hasPrev() ? 0 : null,
          onKeyPress: this.runIfEnterNext,
          className: classNames("".concat(prefixCls, "-next"), _defineProperty$3({}, "".concat(prefixCls, "-disabled"), !this.hasNext())),
          "aria-disabled": !this.hasNext()
        }, this.renderNext(nextPage)), gotoButton);
      }
      if (allPages <= 3 + pageBufferSize * 2) {
        var pagerProps = {
          locale: locale2,
          rootPrefixCls: prefixCls,
          onClick: this.handleChange,
          onKeyPress: this.runIfEnter,
          showTitle,
          itemRender
        };
        if (!allPages) {
          pagerList.push(/* @__PURE__ */ React.createElement(Pager, _extends$3({}, pagerProps, {
            key: "noPager",
            page: 1,
            className: "".concat(prefixCls, "-item-disabled")
          })));
        }
        for (var i = 1; i <= allPages; i += 1) {
          var active = current === i;
          pagerList.push(/* @__PURE__ */ React.createElement(Pager, _extends$3({}, pagerProps, {
            key: i,
            page: i,
            active
          })));
        }
      } else {
        var prevItemTitle = showLessItems ? locale2.prev_3 : locale2.prev_5;
        var nextItemTitle = showLessItems ? locale2.next_3 : locale2.next_5;
        if (showPrevNextJumpers) {
          jumpPrev = /* @__PURE__ */ React.createElement("li", {
            title: showTitle ? prevItemTitle : null,
            key: "prev",
            onClick: this.jumpPrev,
            tabIndex: 0,
            onKeyPress: this.runIfEnterJumpPrev,
            className: classNames("".concat(prefixCls, "-jump-prev"), _defineProperty$3({}, "".concat(prefixCls, "-jump-prev-custom-icon"), !!jumpPrevIcon))
          }, itemRender(this.getJumpPrevPage(), "jump-prev", this.getItemIcon(jumpPrevIcon, "prev page")));
          jumpNext = /* @__PURE__ */ React.createElement("li", {
            title: showTitle ? nextItemTitle : null,
            key: "next",
            tabIndex: 0,
            onClick: this.jumpNext,
            onKeyPress: this.runIfEnterJumpNext,
            className: classNames("".concat(prefixCls, "-jump-next"), _defineProperty$3({}, "".concat(prefixCls, "-jump-next-custom-icon"), !!jumpNextIcon))
          }, itemRender(this.getJumpNextPage(), "jump-next", this.getItemIcon(jumpNextIcon, "next page")));
        }
        lastPager = /* @__PURE__ */ React.createElement(Pager, {
          locale: locale2,
          last: true,
          rootPrefixCls: prefixCls,
          onClick: this.handleChange,
          onKeyPress: this.runIfEnter,
          key: allPages,
          page: allPages,
          active: false,
          showTitle,
          itemRender
        });
        firstPager = /* @__PURE__ */ React.createElement(Pager, {
          locale: locale2,
          rootPrefixCls: prefixCls,
          onClick: this.handleChange,
          onKeyPress: this.runIfEnter,
          key: 1,
          page: 1,
          active: false,
          showTitle,
          itemRender
        });
        var left = Math.max(1, current - pageBufferSize);
        var right = Math.min(current + pageBufferSize, allPages);
        if (current - 1 <= pageBufferSize) {
          right = 1 + pageBufferSize * 2;
        }
        if (allPages - current <= pageBufferSize) {
          left = allPages - pageBufferSize * 2;
        }
        for (var _i2 = left; _i2 <= right; _i2 += 1) {
          var _active = current === _i2;
          pagerList.push(/* @__PURE__ */ React.createElement(Pager, {
            locale: locale2,
            rootPrefixCls: prefixCls,
            onClick: this.handleChange,
            onKeyPress: this.runIfEnter,
            key: _i2,
            page: _i2,
            active: _active,
            showTitle,
            itemRender
          }));
        }
        if (current - 1 >= pageBufferSize * 2 && current !== 1 + 2) {
          pagerList[0] = /* @__PURE__ */ React.cloneElement(pagerList[0], {
            className: "".concat(prefixCls, "-item-after-jump-prev")
          });
          pagerList.unshift(jumpPrev);
        }
        if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
          pagerList[pagerList.length - 1] = /* @__PURE__ */ React.cloneElement(pagerList[pagerList.length - 1], {
            className: "".concat(prefixCls, "-item-before-jump-next")
          });
          pagerList.push(jumpNext);
        }
        if (left !== 1) {
          pagerList.unshift(firstPager);
        }
        if (right !== allPages) {
          pagerList.push(lastPager);
        }
      }
      var prevDisabled = !this.hasPrev() || !allPages;
      var nextDisabled = !this.hasNext() || !allPages;
      return /* @__PURE__ */ React.createElement("ul", _extends$3({
        className: classNames(prefixCls, className, _defineProperty$3({}, "".concat(prefixCls, "-disabled"), disabled)),
        style: style2,
        ref: this.paginationNode
      }, dataOrAriaAttributeProps), totalText, /* @__PURE__ */ React.createElement("li", {
        title: showTitle ? locale2.prev_page : null,
        onClick: this.prev,
        tabIndex: prevDisabled ? null : 0,
        onKeyPress: this.runIfEnterPrev,
        className: classNames("".concat(prefixCls, "-prev"), _defineProperty$3({}, "".concat(prefixCls, "-disabled"), prevDisabled)),
        "aria-disabled": prevDisabled
      }, this.renderPrev(prevPage)), pagerList, /* @__PURE__ */ React.createElement("li", {
        title: showTitle ? locale2.next_page : null,
        onClick: this.next,
        tabIndex: nextDisabled ? null : 0,
        onKeyPress: this.runIfEnterNext,
        className: classNames("".concat(prefixCls, "-next"), _defineProperty$3({}, "".concat(prefixCls, "-disabled"), nextDisabled)),
        "aria-disabled": nextDisabled
      }, this.renderNext(nextPage)), /* @__PURE__ */ React.createElement(Options, {
        disabled,
        locale: locale2,
        rootPrefixCls: prefixCls,
        selectComponentClass,
        selectPrefixCls,
        changeSize: this.getShowSizeChanger() ? this.changePageSize : null,
        current,
        pageSize,
        pageSizeOptions,
        quickGo: this.shouldDisplayQuickJumper() ? this.handleChange : null,
        goButton
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, prevState) {
      var newState = {};
      if ("current" in props) {
        newState.current = props.current;
        if (props.current !== prevState.current) {
          newState.currentInputValue = newState.current;
        }
      }
      if ("pageSize" in props && props.pageSize !== prevState.pageSize) {
        var current = prevState.current;
        var newCurrent = calculatePage(props.pageSize, prevState, props);
        current = current > newCurrent ? newCurrent : current;
        if (!("current" in props)) {
          newState.current = current;
          newState.currentInputValue = current;
        }
        newState.pageSize = props.pageSize;
      }
      return newState;
    }
  }]);
  return Pagination2;
}(React.Component);
Pagination$2.defaultProps = {
  defaultCurrent: 1,
  total: 0,
  defaultPageSize: 10,
  onChange: noop$1,
  className: "",
  selectPrefixCls: "rc-select",
  prefixCls: "rc-pagination",
  selectComponentClass: null,
  hideOnSinglePage: false,
  showPrevNextJumpers: true,
  showQuickJumper: false,
  showLessItems: false,
  showTitle: true,
  onShowSizeChange: noop$1,
  locale: LOCALE,
  style: {},
  itemRender: defaultItemRender,
  totalBoundaryShowSizeChanger: 50
};
const MiniSelect = (props) => /* @__PURE__ */ React.createElement(Select$1, Object.assign({}, props, {
  size: "small"
}));
const MiddleSelect = (props) => /* @__PURE__ */ React.createElement(Select$1, Object.assign({}, props, {
  size: "middle"
}));
MiniSelect.Option = Select$1.Option;
MiddleSelect.Option = Select$1.Option;
const genPaginationDisabledStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-disabled`]: {
      "&, &:hover": {
        cursor: "not-allowed",
        [`${componentCls}-item-link`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      "&:focus-visible": {
        cursor: "not-allowed",
        [`${componentCls}-item-link`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      }
    },
    [`&${componentCls}-disabled`]: {
      cursor: "not-allowed",
      [`&${componentCls}-mini`]: {
        [`
          &:hover ${componentCls}-item:not(${componentCls}-item-active),
          &:active ${componentCls}-item:not(${componentCls}-item-active),
          &:hover ${componentCls}-item-link,
          &:active ${componentCls}-item-link
        `]: {
          backgroundColor: "transparent"
        }
      },
      [`${componentCls}-item`]: {
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        a: {
          color: token2.colorTextDisabled,
          backgroundColor: "transparent",
          border: "none",
          cursor: "not-allowed"
        },
        "&-active": {
          borderColor: token2.colorBorder,
          backgroundColor: token2.paginationItemDisabledBgActive,
          "&:hover, &:active": {
            backgroundColor: token2.paginationItemDisabledBgActive
          },
          a: {
            color: token2.paginationItemDisabledColorActive
          }
        }
      },
      [`${componentCls}-item-link`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        [`${componentCls}-simple&`]: {
          backgroundColor: "transparent"
        }
      },
      [`${componentCls}-item-link-icon`]: {
        opacity: 0
      },
      [`${componentCls}-item-ellipsis`]: {
        opacity: 1
      },
      [`${componentCls}-simple-pager`]: {
        color: token2.colorTextDisabled
      }
    }
  };
};
const genPaginationMiniStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`&${componentCls}-mini ${componentCls}-total-text, &${componentCls}-mini ${componentCls}-simple-pager`]: {
      height: token2.paginationItemSizeSM,
      lineHeight: `${token2.paginationItemSizeSM}px`
    },
    [`&${componentCls}-mini ${componentCls}-item`]: {
      minWidth: token2.paginationItemSizeSM,
      height: token2.paginationItemSizeSM,
      margin: 0,
      lineHeight: `${token2.paginationItemSizeSM - 2}px`
    },
    [`&${componentCls}-mini ${componentCls}-item:not(${componentCls}-item-active)`]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&:hover": {
        backgroundColor: token2.colorBgTextHover
      },
      "&:active": {
        backgroundColor: token2.colorBgTextActive
      }
    },
    [`&${componentCls}-mini ${componentCls}-prev, &${componentCls}-mini ${componentCls}-next`]: {
      minWidth: token2.paginationItemSizeSM,
      height: token2.paginationItemSizeSM,
      margin: 0,
      lineHeight: `${token2.paginationItemSizeSM}px`,
      [`&:hover ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextHover
      },
      [`&:active ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextActive
      },
      [`&${componentCls}-disabled:hover ${componentCls}-item-link`]: {
        backgroundColor: "transparent"
      }
    },
    [`
    &${componentCls}-mini ${componentCls}-prev ${componentCls}-item-link,
    &${componentCls}-mini ${componentCls}-next ${componentCls}-item-link
    `]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&::after": {
        height: token2.paginationItemSizeSM,
        lineHeight: `${token2.paginationItemSizeSM}px`
      }
    },
    [`&${componentCls}-mini ${componentCls}-jump-prev, &${componentCls}-mini ${componentCls}-jump-next`]: {
      height: token2.paginationItemSizeSM,
      marginInlineEnd: 0,
      lineHeight: `${token2.paginationItemSizeSM}px`
    },
    [`&${componentCls}-mini ${componentCls}-options`]: {
      marginInlineStart: token2.paginationMiniOptionsMarginInlineStart,
      [`&-size-changer`]: {
        top: token2.paginationMiniOptionsSizeChangerTop
      },
      [`&-quick-jumper`]: {
        height: token2.paginationItemSizeSM,
        lineHeight: `${token2.paginationItemSizeSM}px`,
        input: Object.assign(Object.assign({}, genInputSmallStyle$1(token2)), {
          width: token2.paginationMiniQuickJumperInputWidth,
          height: token2.controlHeightSM
        })
      }
    }
  };
};
const genPaginationSimpleStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`
    &${componentCls}-simple ${componentCls}-prev,
    &${componentCls}-simple ${componentCls}-next
    `]: {
      height: token2.paginationItemSizeSM,
      lineHeight: `${token2.paginationItemSizeSM}px`,
      verticalAlign: "top",
      [`${componentCls}-item-link`]: {
        height: token2.paginationItemSizeSM,
        backgroundColor: "transparent",
        border: 0,
        "&::after": {
          height: token2.paginationItemSizeSM,
          lineHeight: `${token2.paginationItemSizeSM}px`
        }
      }
    },
    [`&${componentCls}-simple ${componentCls}-simple-pager`]: {
      display: "inline-block",
      height: token2.paginationItemSizeSM,
      marginInlineEnd: token2.marginXS,
      input: {
        boxSizing: "border-box",
        height: "100%",
        marginInlineEnd: token2.marginXS,
        padding: `0 ${token2.paginationItemPaddingInline}px`,
        textAlign: "center",
        backgroundColor: token2.paginationItemInputBg,
        border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
        borderRadius: token2.borderRadius,
        outline: "none",
        transition: `border-color ${token2.motionDurationMid}`,
        color: "inherit",
        "&:hover": {
          borderColor: token2.colorPrimary
        },
        "&:focus": {
          borderColor: token2.colorPrimaryHover,
          boxShadow: `${token2.inputOutlineOffset}px 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`
        },
        "&[disabled]": {
          color: token2.colorTextDisabled,
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          cursor: "not-allowed"
        }
      }
    }
  };
};
const genPaginationJumpStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
      outline: 0,
      [`${componentCls}-item-container`]: {
        position: "relative",
        [`${componentCls}-item-link-icon`]: {
          color: token2.colorPrimary,
          fontSize: token2.fontSizeSM,
          opacity: 0,
          transition: `all ${token2.motionDurationMid}`,
          "&-svg": {
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            margin: "auto"
          }
        },
        [`${componentCls}-item-ellipsis`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          display: "block",
          margin: "auto",
          color: token2.colorTextDisabled,
          fontFamily: "Arial, Helvetica, sans-serif",
          letterSpacing: token2.paginationEllipsisLetterSpacing,
          textAlign: "center",
          textIndent: token2.paginationEllipsisTextIndent,
          opacity: 1,
          transition: `all ${token2.motionDurationMid}`
        }
      },
      "&:hover": {
        [`${componentCls}-item-link-icon`]: {
          opacity: 1
        },
        [`${componentCls}-item-ellipsis`]: {
          opacity: 0
        }
      },
      "&:focus-visible": Object.assign({
        [`${componentCls}-item-link-icon`]: {
          opacity: 1
        },
        [`${componentCls}-item-ellipsis`]: {
          opacity: 0
        }
      }, genFocusOutline(token2))
    },
    [`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
      marginInlineEnd: token2.marginXS
    },
    [`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
      display: "inline-block",
      minWidth: token2.paginationItemSize,
      height: token2.paginationItemSize,
      color: token2.colorText,
      fontFamily: token2.paginationFontFamily,
      lineHeight: `${token2.paginationItemSize}px`,
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      borderRadius: token2.borderRadius,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid}`
    },
    [`${componentCls}-prev, ${componentCls}-next`]: {
      fontFamily: "Arial, Helvetica, sans-serif",
      outline: 0,
      button: {
        color: token2.colorText,
        cursor: "pointer",
        userSelect: "none"
      },
      [`${componentCls}-item-link`]: {
        display: "block",
        width: "100%",
        height: "100%",
        padding: 0,
        fontSize: token2.fontSizeSM,
        textAlign: "center",
        backgroundColor: "transparent",
        border: `${token2.lineWidth}px ${token2.lineType} transparent`,
        borderRadius: token2.borderRadius,
        outline: "none",
        transition: `border ${token2.motionDurationMid}`
      },
      [`&:focus-visible ${componentCls}-item-link`]: Object.assign({}, genFocusOutline(token2)),
      [`&:hover ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextHover
      },
      [`&:active ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextActive
      },
      [`&${componentCls}-disabled:hover`]: {
        [`${componentCls}-item-link`]: {
          backgroundColor: "transparent"
        }
      }
    },
    [`${componentCls}-slash`]: {
      marginInlineEnd: token2.paginationSlashMarginInlineEnd,
      marginInlineStart: token2.paginationSlashMarginInlineStart
    },
    [`${componentCls}-options`]: {
      display: "inline-block",
      marginInlineStart: token2.margin,
      verticalAlign: "middle",
      "&-size-changer.-select": {
        display: "inline-block",
        width: "auto"
      },
      "&-quick-jumper": {
        display: "inline-block",
        height: token2.controlHeight,
        marginInlineStart: token2.marginXS,
        lineHeight: `${token2.controlHeight}px`,
        verticalAlign: "top",
        input: Object.assign(Object.assign({}, genBasicInputStyle$1(token2)), {
          width: token2.controlHeightLG * 1.25,
          height: token2.controlHeight,
          boxSizing: "border-box",
          margin: 0,
          marginInlineStart: token2.marginXS,
          marginInlineEnd: token2.marginXS
        })
      }
    }
  };
};
const genPaginationItemStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-item`]: Object.assign(Object.assign({
      display: "inline-block",
      minWidth: token2.paginationItemSize,
      height: token2.paginationItemSize,
      marginInlineEnd: token2.marginXS,
      fontFamily: token2.paginationFontFamily,
      lineHeight: `${token2.paginationItemSize - 2}px`,
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      backgroundColor: "transparent",
      border: `${token2.lineWidth}px ${token2.lineType} transparent`,
      borderRadius: token2.borderRadius,
      outline: 0,
      cursor: "pointer",
      userSelect: "none",
      a: {
        display: "block",
        padding: `0 ${token2.paginationItemPaddingInline}px`,
        color: token2.colorText,
        transition: "none",
        "&:hover": {
          textDecoration: "none"
        }
      },
      [`&:not(${componentCls}-item-active)`]: {
        "&:hover": {
          transition: `all ${token2.motionDurationMid}`,
          backgroundColor: token2.colorBgTextHover
        },
        "&:active": {
          backgroundColor: token2.colorBgTextActive
        }
      }
    }, genFocusStyle(token2)), {
      "&-active": {
        fontWeight: token2.paginationFontWeightActive,
        backgroundColor: token2.paginationItemBgActive,
        borderColor: token2.colorPrimary,
        a: {
          color: token2.colorPrimary
        },
        "&:hover": {
          borderColor: token2.colorPrimaryHover
        },
        "&:hover a": {
          color: token2.colorPrimaryHover
        }
      }
    })
  };
};
const genPaginationStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
      "ul, ol": {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        overflow: "hidden",
        visibility: "hidden",
        content: '""'
      },
      [`${componentCls}-total-text`]: {
        display: "inline-block",
        height: token2.paginationItemSize,
        marginInlineEnd: token2.marginXS,
        lineHeight: `${token2.paginationItemSize - 2}px`,
        verticalAlign: "middle"
      }
    }), genPaginationItemStyle(token2)), genPaginationJumpStyle(token2)), genPaginationSimpleStyle(token2)), genPaginationMiniStyle(token2)), genPaginationDisabledStyle(token2)), {
      [`@media only screen and (max-width: ${token2.screenLG}px)`]: {
        [`${componentCls}-item`]: {
          "&-after-jump-prev, &-before-jump-next": {
            display: "none"
          }
        }
      },
      [`@media only screen and (max-width: ${token2.screenSM}px)`]: {
        [`${componentCls}-options`]: {
          display: "none"
        }
      }
    }),
    [`&${token2.componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
const genBorderedStyle$1 = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}${componentCls}-disabled`]: {
      "&, &:hover": {
        [`${componentCls}-item-link`]: {
          borderColor: token2.colorBorder
        }
      },
      "&:focus-visible": {
        [`${componentCls}-item-link`]: {
          borderColor: token2.colorBorder
        }
      },
      [`${componentCls}-item, ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgContainerDisabled,
        borderColor: token2.colorBorder,
        [`&:hover:not(${componentCls}-item-active)`]: {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          a: {
            color: token2.colorTextDisabled
          }
        },
        [`&${componentCls}-item-active`]: {
          backgroundColor: token2.paginationItemDisabledBgActive
        }
      },
      [`${componentCls}-prev, ${componentCls}-next`]: {
        "&:hover button": {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          color: token2.colorTextDisabled
        },
        [`${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder
        }
      }
    },
    [componentCls]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        "&:hover button": {
          borderColor: token2.colorPrimaryHover,
          backgroundColor: token2.paginationItemBg
        },
        [`${componentCls}-item-link`]: {
          backgroundColor: token2.paginationItemLinkBg,
          borderColor: token2.colorBorder
        },
        [`&:hover ${componentCls}-item-link`]: {
          borderColor: token2.colorPrimary,
          backgroundColor: token2.paginationItemBg,
          color: token2.colorPrimary
        },
        [`&${componentCls}-disabled`]: {
          [`${componentCls}-item-link`]: {
            borderColor: token2.colorBorder,
            color: token2.colorTextDisabled
          }
        }
      },
      [`${componentCls}-item`]: {
        backgroundColor: token2.paginationItemBg,
        border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
        [`&:hover:not(${componentCls}-item-active)`]: {
          borderColor: token2.colorPrimary,
          backgroundColor: token2.paginationItemBg,
          a: {
            color: token2.colorPrimary
          }
        },
        "&-active": {
          borderColor: token2.colorPrimary
        }
      }
    }
  };
};
var useStyle$3 = genComponentStyleHook$2("Pagination", (token2) => {
  const paginationToken = merge$1(token2, {
    paginationItemSize: token2.controlHeight,
    paginationFontFamily: token2.fontFamily,
    paginationItemBg: token2.colorBgContainer,
    paginationItemBgActive: token2.colorBgContainer,
    paginationFontWeightActive: token2.fontWeightStrong,
    paginationItemSizeSM: token2.controlHeightSM,
    paginationItemInputBg: token2.colorBgContainer,
    paginationMiniOptionsSizeChangerTop: 0,
    paginationItemDisabledBgActive: token2.controlItemBgActiveDisabled,
    paginationItemDisabledColorActive: token2.colorTextDisabled,
    paginationItemLinkBg: token2.colorBgContainer,
    inputOutlineOffset: "0 0",
    paginationMiniOptionsMarginInlineStart: token2.marginXXS / 2,
    paginationMiniQuickJumperInputWidth: token2.controlHeightLG * 1.1,
    paginationItemPaddingInline: token2.marginXXS * 1.5,
    paginationEllipsisLetterSpacing: token2.marginXXS / 2,
    paginationSlashMarginInlineStart: token2.marginXXS,
    paginationSlashMarginInlineEnd: token2.marginSM,
    paginationEllipsisTextIndent: "0.13em"
  }, initInputToken$1(token2));
  return [genPaginationStyle(paginationToken), token2.wireframe && genBorderedStyle$1(paginationToken)];
});
var __rest$a = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const Pagination = (_a2) => {
  var {
    prefixCls: customizePrefixCls,
    selectPrefixCls: customizeSelectPrefixCls,
    className,
    rootClassName,
    size,
    locale: customLocale,
    selectComponentClass,
    responsive,
    showSizeChanger
  } = _a2, restProps = __rest$a(_a2, ["prefixCls", "selectPrefixCls", "className", "rootClassName", "size", "locale", "selectComponentClass", "responsive", "showSizeChanger"]);
  const {
    xs
  } = useBreakpoint(responsive);
  const {
    getPrefixCls,
    direction,
    pagination = {}
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("pagination", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$3(prefixCls);
  const mergedShowSizeChanger = showSizeChanger !== null && showSizeChanger !== void 0 ? showSizeChanger : pagination.showSizeChanger;
  const iconsProps = React.useMemo(() => {
    const ellipsis = /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-item-ellipsis`
    }, "\u2022\u2022\u2022");
    const prevIcon = /* @__PURE__ */ React.createElement("button", {
      className: `${prefixCls}-item-link`,
      type: "button",
      tabIndex: -1
    }, direction === "rtl" ? /* @__PURE__ */ React.createElement(RightOutlined$1, null) : /* @__PURE__ */ React.createElement(LeftOutlined$1, null));
    const nextIcon = /* @__PURE__ */ React.createElement("button", {
      className: `${prefixCls}-item-link`,
      type: "button",
      tabIndex: -1
    }, direction === "rtl" ? /* @__PURE__ */ React.createElement(LeftOutlined$1, null) : /* @__PURE__ */ React.createElement(RightOutlined$1, null));
    const jumpPrevIcon = /* @__PURE__ */ React.createElement("a", {
      className: `${prefixCls}-item-link`
    }, /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-item-container`
    }, direction === "rtl" ? /* @__PURE__ */ React.createElement(DoubleRightOutlined$1, {
      className: `${prefixCls}-item-link-icon`
    }) : /* @__PURE__ */ React.createElement(DoubleLeftOutlined$1, {
      className: `${prefixCls}-item-link-icon`
    }), ellipsis));
    const jumpNextIcon = /* @__PURE__ */ React.createElement("a", {
      className: `${prefixCls}-item-link`
    }, /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-item-container`
    }, direction === "rtl" ? /* @__PURE__ */ React.createElement(DoubleLeftOutlined$1, {
      className: `${prefixCls}-item-link-icon`
    }) : /* @__PURE__ */ React.createElement(DoubleRightOutlined$1, {
      className: `${prefixCls}-item-link-icon`
    }), ellipsis));
    return {
      prevIcon,
      nextIcon,
      jumpPrevIcon,
      jumpNextIcon
    };
  }, [direction, prefixCls]);
  const [contextLocale] = useLocale$3("Pagination", enUS$1);
  const locale2 = Object.assign(Object.assign({}, contextLocale), customLocale);
  const isSmall = size === "small" || !!(xs && !size && responsive);
  const selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls);
  const extendedClassName = classNames({
    [`${prefixCls}-mini`]: isSmall,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId);
  return wrapSSR(/* @__PURE__ */ React.createElement(Pagination$2, Object.assign({}, iconsProps, restProps, {
    prefixCls,
    selectPrefixCls,
    className: extendedClassName,
    selectComponentClass: selectComponentClass || (isSmall ? MiniSelect : MiddleSelect),
    locale: locale2,
    showSizeChanger: mergedShowSizeChanger
  })));
};
var Pagination$1 = Pagination;
const antSpinMove$1 = new Keyframe("antSpinMove", {
  to: {
    opacity: 1
  }
});
const antRotate$1 = new Keyframe("antRotate", {
  to: {
    transform: "rotate(405deg)"
  }
});
const genSpinStyle$1 = (token2) => ({
  [`${token2.componentCls}`]: Object.assign(Object.assign({}, resetComponent(token2)), {
    position: "absolute",
    display: "none",
    color: token2.colorPrimary,
    textAlign: "center",
    verticalAlign: "middle",
    opacity: 0,
    transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
    "&-spinning": {
      position: "static",
      display: "inline-block",
      opacity: 1
    },
    "&-nested-loading": {
      position: "relative",
      [`> div > ${token2.componentCls}`]: {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        zIndex: 4,
        display: "block",
        width: "100%",
        height: "100%",
        maxHeight: token2.contentHeight,
        [`${token2.componentCls}-dot`]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: "50%",
          margin: -token2.spinDotSize / 2
        },
        [`${token2.componentCls}-text`]: {
          position: "absolute",
          top: "50%",
          width: "100%",
          paddingTop: (token2.spinDotSize - token2.fontSize) / 2 + 2,
          textShadow: `0 1px 2px ${token2.colorBgContainer}`
        },
        [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
          marginTop: -(token2.spinDotSize / 2) - 10
        },
        "&-sm": {
          [`${token2.componentCls}-dot`]: {
            margin: -token2.spinDotSizeSM / 2
          },
          [`${token2.componentCls}-text`]: {
            paddingTop: (token2.spinDotSizeSM - token2.fontSize) / 2 + 2
          },
          [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
            marginTop: -(token2.spinDotSizeSM / 2) - 10
          }
        },
        "&-lg": {
          [`${token2.componentCls}-dot`]: {
            margin: -(token2.spinDotSizeLG / 2)
          },
          [`${token2.componentCls}-text`]: {
            paddingTop: (token2.spinDotSizeLG - token2.fontSize) / 2 + 2
          },
          [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
            marginTop: -(token2.spinDotSizeLG / 2) - 10
          }
        }
      },
      [`${token2.componentCls}-container`]: {
        position: "relative",
        transition: `opacity ${token2.motionDurationSlow}`,
        "&::after": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          height: "100%",
          background: token2.colorBgContainer,
          opacity: 0,
          transition: `all ${token2.motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        }
      },
      [`${token2.componentCls}-blur`]: {
        clear: "both",
        opacity: 0.5,
        userSelect: "none",
        pointerEvents: "none",
        [`&::after`]: {
          opacity: 0.4,
          pointerEvents: "auto"
        }
      }
    },
    [`&-tip`]: {
      color: token2.spinDotDefault
    },
    [`${token2.componentCls}-dot`]: {
      position: "relative",
      display: "inline-block",
      fontSize: token2.spinDotSize,
      width: "1em",
      height: "1em",
      "&-item": {
        position: "absolute",
        display: "block",
        width: (token2.spinDotSize - token2.marginXXS / 2) / 2,
        height: (token2.spinDotSize - token2.marginXXS / 2) / 2,
        backgroundColor: token2.colorPrimary,
        borderRadius: "100%",
        transform: "scale(0.75)",
        transformOrigin: "50% 50%",
        opacity: 0.3,
        animationName: antSpinMove$1,
        animationDuration: "1s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear",
        animationDirection: "alternate",
        "&:nth-child(1)": {
          top: 0,
          insetInlineStart: 0
        },
        "&:nth-child(2)": {
          top: 0,
          insetInlineEnd: 0,
          animationDelay: "0.4s"
        },
        "&:nth-child(3)": {
          insetInlineEnd: 0,
          bottom: 0,
          animationDelay: "0.8s"
        },
        "&:nth-child(4)": {
          bottom: 0,
          insetInlineStart: 0,
          animationDelay: "1.2s"
        }
      },
      "&-spin": {
        transform: "rotate(45deg)",
        animationName: antRotate$1,
        animationDuration: "1.2s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear"
      }
    },
    [`&-sm ${token2.componentCls}-dot`]: {
      fontSize: token2.spinDotSizeSM,
      i: {
        width: (token2.spinDotSizeSM - token2.marginXXS / 2) / 2,
        height: (token2.spinDotSizeSM - token2.marginXXS / 2) / 2
      }
    },
    [`&-lg ${token2.componentCls}-dot`]: {
      fontSize: token2.spinDotSizeLG,
      i: {
        width: (token2.spinDotSizeLG - token2.marginXXS) / 2,
        height: (token2.spinDotSizeLG - token2.marginXXS) / 2
      }
    },
    [`&${token2.componentCls}-show-text ${token2.componentCls}-text`]: {
      display: "block"
    }
  })
});
var useStyle$2 = genComponentStyleHook$2("Spin", (token2) => {
  const spinToken = merge$1(token2, {
    spinDotDefault: token2.colorTextDescription,
    spinDotSize: token2.controlHeightLG / 2,
    spinDotSizeSM: token2.controlHeightLG * 0.35,
    spinDotSizeLG: token2.controlHeight
  });
  return [genSpinStyle$1(spinToken)];
}, {
  contentHeight: 400
});
var __rest$9 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
let defaultIndicator$1 = null;
function renderIndicator$1(prefixCls, props) {
  const {
    indicator
  } = props;
  const dotClassName = `${prefixCls}-dot`;
  if (indicator === null) {
    return null;
  }
  if (isValidElement$1(indicator)) {
    return cloneElement$1(indicator, {
      className: classNames(indicator.props.className, dotClassName)
    });
  }
  if (isValidElement$1(defaultIndicator$1)) {
    return cloneElement$1(defaultIndicator$1, {
      className: classNames(defaultIndicator$1.props.className, dotClassName)
    });
  }
  return /* @__PURE__ */ React.createElement("span", {
    className: classNames(dotClassName, `${prefixCls}-dot-spin`)
  }, /* @__PURE__ */ React.createElement("i", {
    className: `${prefixCls}-dot-item`
  }), /* @__PURE__ */ React.createElement("i", {
    className: `${prefixCls}-dot-item`
  }), /* @__PURE__ */ React.createElement("i", {
    className: `${prefixCls}-dot-item`
  }), /* @__PURE__ */ React.createElement("i", {
    className: `${prefixCls}-dot-item`
  }));
}
function shouldDelay$1(spinning, delay) {
  return !!spinning && !!delay && !isNaN(Number(delay));
}
const Spin$1 = (props) => {
  const {
    spinPrefixCls: prefixCls,
    spinning: customSpinning = true,
    delay = 0,
    className,
    rootClassName,
    size = "default",
    tip,
    wrapperClassName,
    style: style2,
    children,
    hashId
  } = props, restProps = __rest$9(props, ["spinPrefixCls", "spinning", "delay", "className", "rootClassName", "size", "tip", "wrapperClassName", "style", "children", "hashId"]);
  const [spinning, setSpinning] = React.useState(() => customSpinning && !shouldDelay$1(customSpinning, delay));
  React.useEffect(() => {
    if (customSpinning) {
      const showSpinning = debounce_1(delay, () => {
        setSpinning(true);
      });
      showSpinning();
      return () => {
        var _a2;
        (_a2 = showSpinning === null || showSpinning === void 0 ? void 0 : showSpinning.cancel) === null || _a2 === void 0 ? void 0 : _a2.call(showSpinning);
      };
    }
    setSpinning(false);
  }, [delay, customSpinning]);
  const isNestedPattern = React.useMemo(() => typeof children !== "undefined", [children]);
  const {
    direction
  } = React.useContext(ConfigContext$1);
  const spinClassName = classNames(prefixCls, {
    [`${prefixCls}-sm`]: size === "small",
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-spinning`]: spinning,
    [`${prefixCls}-show-text`]: !!tip,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId);
  const containerClassName = classNames(`${prefixCls}-container`, {
    [`${prefixCls}-blur`]: spinning
  });
  const divProps = omit$5(restProps, ["indicator", "prefixCls"]);
  const spinElement = /* @__PURE__ */ React.createElement("div", Object.assign({}, divProps, {
    style: style2,
    className: spinClassName,
    "aria-live": "polite",
    "aria-busy": spinning
  }), renderIndicator$1(prefixCls, props), tip ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-text`
  }, tip) : null);
  if (isNestedPattern) {
    return /* @__PURE__ */ React.createElement("div", Object.assign({}, divProps, {
      className: classNames(`${prefixCls}-nested-loading`, wrapperClassName, hashId)
    }), spinning && /* @__PURE__ */ React.createElement("div", {
      key: "loading"
    }, spinElement), /* @__PURE__ */ React.createElement("div", {
      className: containerClassName,
      key: "container"
    }, children));
  }
  return spinElement;
};
const SpinFC$1 = (props) => {
  const {
    prefixCls: customizePrefixCls
  } = props;
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const spinPrefixCls = getPrefixCls("spin", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$2(spinPrefixCls);
  const spinClassProps = Object.assign(Object.assign({}, props), {
    spinPrefixCls,
    hashId
  });
  return wrapSSR(/* @__PURE__ */ React.createElement(Spin$1, Object.assign({}, spinClassProps)));
};
SpinFC$1.setDefaultIndicator = (indicator) => {
  defaultIndicator$1 = indicator;
};
var Spin$2 = SpinFC$1;
function extendsObject() {
  const result = Object.assign({}, arguments.length <= 0 ? void 0 : arguments[0]);
  for (let i = 1; i < arguments.length; i++) {
    const obj = i < 0 || arguments.length <= i ? void 0 : arguments[i];
    if (obj) {
      Object.keys(obj).forEach((key) => {
        const val = obj[key];
        if (val !== void 0) {
          result[key] = val;
        }
      });
    }
  }
  return result;
}
var __rest$8 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const Meta$1 = (_a2) => {
  var {
    prefixCls: customizePrefixCls,
    className,
    avatar,
    title,
    description
  } = _a2, others = __rest$8(_a2, ["prefixCls", "className", "avatar", "title", "description"]);
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const prefixCls = getPrefixCls("list", customizePrefixCls);
  const classString = classNames(`${prefixCls}-item-meta`, className);
  const content2 = /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-item-meta-content`
  }, title && /* @__PURE__ */ React.createElement("h4", {
    className: `${prefixCls}-item-meta-title`
  }, title), description && /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-item-meta-description`
  }, description));
  return /* @__PURE__ */ React.createElement("div", Object.assign({}, others, {
    className: classString
  }), avatar && /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-item-meta-avatar`
  }, avatar), (title || description) && content2);
};
const InternalItem = (_a2, ref2) => {
  var {
    prefixCls: customizePrefixCls,
    children,
    actions,
    extra,
    className,
    colStyle
  } = _a2, others = __rest$8(_a2, ["prefixCls", "children", "actions", "extra", "className", "colStyle"]);
  const {
    grid,
    itemLayout
  } = React.useContext(ListContext);
  const {
    getPrefixCls
  } = React.useContext(ConfigContext$1);
  const isItemContainsTextNodeAndNotSingular = () => {
    let result;
    React.Children.forEach(children, (element2) => {
      if (typeof element2 === "string") {
        result = true;
      }
    });
    return result && React.Children.count(children) > 1;
  };
  const isFlexMode = () => {
    if (itemLayout === "vertical") {
      return !!extra;
    }
    return !isItemContainsTextNodeAndNotSingular();
  };
  const prefixCls = getPrefixCls("list", customizePrefixCls);
  const actionsContent = actions && actions.length > 0 && /* @__PURE__ */ React.createElement("ul", {
    className: `${prefixCls}-item-action`,
    key: "actions"
  }, actions.map((action, i) => /* @__PURE__ */ React.createElement("li", {
    key: `${prefixCls}-item-action-${i}`
  }, action, i !== actions.length - 1 && /* @__PURE__ */ React.createElement("em", {
    className: `${prefixCls}-item-action-split`
  }))));
  const Element2 = grid ? "div" : "li";
  const itemChildren = /* @__PURE__ */ React.createElement(Element2, Object.assign({}, others, !grid ? {
    ref: ref2
  } : {}, {
    className: classNames(`${prefixCls}-item`, {
      [`${prefixCls}-item-no-flex`]: !isFlexMode()
    }, className)
  }), itemLayout === "vertical" && extra ? [/* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-item-main`,
    key: "content"
  }, children, actionsContent), /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-item-extra`,
    key: "extra"
  }, extra)] : [children, actionsContent, cloneElement$1(extra, {
    key: "extra"
  })]);
  return grid ? /* @__PURE__ */ React.createElement(Col$1, {
    ref: ref2,
    flex: 1,
    style: colStyle
  }, itemChildren) : itemChildren;
};
const Item = /* @__PURE__ */ React.forwardRef(InternalItem);
Item.Meta = Meta$1;
var Item$1 = Item;
const genBorderedStyle = (token2) => {
  const {
    listBorderedCls,
    componentCls,
    paddingLG,
    margin,
    padding,
    listItemPaddingSM,
    marginLG,
    borderRadiusLG
  } = token2;
  return {
    [`${listBorderedCls}`]: {
      border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
      borderRadius: borderRadiusLG,
      [`${componentCls}-header,${componentCls}-footer,${componentCls}-item`]: {
        paddingInline: paddingLG
      },
      [`${componentCls}-pagination`]: {
        margin: `${margin}px ${marginLG}px`
      }
    },
    [`${listBorderedCls}${componentCls}-sm`]: {
      [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
        padding: listItemPaddingSM
      }
    },
    [`${listBorderedCls}${componentCls}-lg`]: {
      [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
        padding: `${padding}px ${paddingLG}px`
      }
    }
  };
};
const genResponsiveStyle = (token2) => {
  const {
    componentCls,
    screenSM,
    screenMD,
    marginLG,
    marginSM,
    margin
  } = token2;
  return {
    [`@media screen and (max-width:${screenMD})`]: {
      [`${componentCls}`]: {
        [`${componentCls}-item`]: {
          [`${componentCls}-item-action`]: {
            marginInlineStart: marginLG
          }
        }
      },
      [`${componentCls}-vertical`]: {
        [`${componentCls}-item`]: {
          [`${componentCls}-item-extra`]: {
            marginInlineStart: marginLG
          }
        }
      }
    },
    [`@media screen and (max-width: ${screenSM})`]: {
      [`${componentCls}`]: {
        [`${componentCls}-item`]: {
          flexWrap: "wrap",
          [`${componentCls}-action`]: {
            marginInlineStart: marginSM
          }
        }
      },
      [`${componentCls}-vertical`]: {
        [`${componentCls}-item`]: {
          flexWrap: "wrap-reverse",
          [`${componentCls}-item-main`]: {
            minWidth: token2.contentWidth
          },
          [`${componentCls}-item-extra`]: {
            margin: `auto auto ${margin}px`
          }
        }
      }
    }
  };
};
const genBaseStyle = (token2) => {
  const {
    componentCls,
    antCls,
    controlHeight,
    minHeight,
    paddingSM,
    marginLG,
    padding,
    listItemPadding,
    colorPrimary,
    listItemPaddingSM,
    listItemPaddingLG,
    paddingXS,
    margin,
    colorText,
    colorTextDescription,
    motionDurationSlow,
    lineWidth
  } = token2;
  const alignCls = {};
  ["start", "center", "end"].forEach((item) => {
    alignCls[`&-align-${item}`] = {
      textAlign: item
    };
  });
  return {
    [`${componentCls}`]: Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "relative",
      "*": {
        outline: "none"
      },
      [`${componentCls}-header, ${componentCls}-footer`]: {
        background: "transparent",
        paddingBlock: paddingSM
      },
      [`${componentCls}-pagination`]: Object.assign(Object.assign({
        marginBlockStart: marginLG
      }, alignCls), {
        [`${antCls}-pagination-options`]: {
          textAlign: "start"
        }
      }),
      [`${componentCls}-spin`]: {
        minHeight,
        textAlign: "center"
      },
      [`${componentCls}-items`]: {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      [`${componentCls}-item`]: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: listItemPadding,
        color: colorText,
        [`${componentCls}-item-meta`]: {
          display: "flex",
          flex: 1,
          alignItems: "flex-start",
          maxWidth: "100%",
          [`${componentCls}-item-meta-avatar`]: {
            marginInlineEnd: padding
          },
          [`${componentCls}-item-meta-content`]: {
            flex: "1 0",
            width: 0,
            color: colorText
          },
          [`${componentCls}-item-meta-title`]: {
            marginBottom: token2.marginXXS,
            color: colorText,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            "> a": {
              color: colorText,
              transition: `all ${motionDurationSlow}`,
              [`&:hover`]: {
                color: colorPrimary
              }
            }
          },
          [`${componentCls}-item-meta-description`]: {
            color: colorTextDescription,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight
          }
        },
        [`${componentCls}-item-action`]: {
          flex: "0 0 auto",
          marginInlineStart: token2.marginXXL,
          padding: 0,
          fontSize: 0,
          listStyle: "none",
          [`& > li`]: {
            position: "relative",
            display: "inline-block",
            padding: `0 ${paddingXS}px`,
            color: colorTextDescription,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            textAlign: "center",
            [`&:first-child`]: {
              paddingInlineStart: 0
            }
          },
          [`${componentCls}-item-action-split`]: {
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineEnd: 0,
            width: lineWidth,
            height: Math.ceil(token2.fontSize * token2.lineHeight) - token2.marginXXS * 2,
            transform: "translateY(-50%)",
            backgroundColor: token2.colorSplit
          }
        }
      },
      [`${componentCls}-empty`]: {
        padding: `${padding}px 0`,
        color: colorTextDescription,
        fontSize: token2.fontSizeSM,
        textAlign: "center"
      },
      [`${componentCls}-empty-text`]: {
        padding,
        color: token2.colorTextDisabled,
        fontSize: token2.fontSize,
        textAlign: "center"
      },
      [`${componentCls}-item-no-flex`]: {
        display: "block"
      }
    }),
    [`${componentCls}-grid ${antCls}-col > ${componentCls}-item`]: {
      display: "block",
      maxWidth: "100%",
      marginBlockEnd: margin,
      paddingBlock: 0,
      borderBlockEnd: "none"
    },
    [`${componentCls}-vertical ${componentCls}-item`]: {
      alignItems: "initial",
      [`${componentCls}-item-main`]: {
        display: "block",
        flex: 1
      },
      [`${componentCls}-item-extra`]: {
        marginInlineStart: marginLG
      },
      [`${componentCls}-item-meta`]: {
        marginBlockEnd: padding,
        [`${componentCls}-item-meta-title`]: {
          marginBlockStart: 0,
          marginBlockEnd: paddingSM,
          color: colorText,
          fontSize: token2.fontSizeLG,
          lineHeight: token2.lineHeightLG
        }
      },
      [`${componentCls}-item-action`]: {
        marginBlockStart: padding,
        marginInlineStart: "auto",
        "> li": {
          padding: `0 ${padding}px`,
          [`&:first-child`]: {
            paddingInlineStart: 0
          }
        }
      }
    },
    [`${componentCls}-split ${componentCls}-item`]: {
      borderBlockEnd: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`,
      [`&:last-child`]: {
        borderBlockEnd: "none"
      }
    },
    [`${componentCls}-split ${componentCls}-header`]: {
      borderBlockEnd: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
    },
    [`${componentCls}-split${componentCls}-empty ${componentCls}-footer`]: {
      borderTop: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
    },
    [`${componentCls}-loading ${componentCls}-spin-nested-loading`]: {
      minHeight: controlHeight
    },
    [`${componentCls}-split${componentCls}-something-after-last-item ${antCls}-spin-container > ${componentCls}-items > ${componentCls}-item:last-child`]: {
      borderBlockEnd: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
    },
    [`${componentCls}-lg ${componentCls}-item`]: {
      padding: listItemPaddingLG
    },
    [`${componentCls}-sm ${componentCls}-item`]: {
      padding: listItemPaddingSM
    },
    [`${componentCls}:not(${componentCls}-vertical)`]: {
      [`${componentCls}-item-no-flex`]: {
        [`${componentCls}-item-action`]: {
          float: "right"
        }
      }
    }
  };
};
var useStyle$1 = genComponentStyleHook$2("List", (token2) => {
  const listToken = merge$1(token2, {
    listBorderedCls: `${token2.componentCls}-bordered`,
    minHeight: token2.controlHeightLG,
    listItemPadding: `${token2.paddingContentVertical}px 0`,
    listItemPaddingSM: `${token2.paddingContentVerticalSM}px ${token2.paddingContentHorizontal}px`,
    listItemPaddingLG: `${token2.paddingContentVerticalLG}px ${token2.paddingContentHorizontalLG}px`
  });
  return [genBaseStyle(listToken), genBorderedStyle(listToken), genResponsiveStyle(listToken)];
}, {
  contentWidth: 220
});
var __rest$7 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const ListContext = /* @__PURE__ */ React.createContext({});
ListContext.Consumer;
function List2(_a2) {
  var _b;
  var {
    pagination = false,
    prefixCls: customizePrefixCls,
    bordered = false,
    split: split2 = true,
    className,
    rootClassName,
    children,
    itemLayout,
    loadMore,
    grid,
    dataSource = [],
    size,
    header,
    footer: footer2,
    loading = false,
    rowKey,
    renderItem,
    locale: locale2
  } = _a2, rest = __rest$7(_a2, ["pagination", "prefixCls", "bordered", "split", "className", "rootClassName", "children", "itemLayout", "loadMore", "grid", "dataSource", "size", "header", "footer", "loading", "rowKey", "renderItem", "locale"]);
  const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
  const [paginationCurrent, setPaginationCurrent] = React.useState(paginationObj.defaultCurrent || 1);
  const [paginationSize, setPaginationSize] = React.useState(paginationObj.defaultPageSize || 10);
  const {
    getPrefixCls,
    renderEmpty,
    direction
  } = React.useContext(ConfigContext$1);
  const defaultPaginationProps = {
    current: 1,
    total: 0
  };
  const triggerPaginationEvent = (eventName) => (page, pageSize) => {
    setPaginationCurrent(page);
    setPaginationSize(pageSize);
    if (pagination && pagination[eventName]) {
      pagination[eventName](page, pageSize);
    }
  };
  const onPaginationChange = triggerPaginationEvent("onChange");
  const onPaginationShowSizeChange = triggerPaginationEvent("onShowSizeChange");
  const renderInnerItem = (item, index2) => {
    if (!renderItem)
      return null;
    let key;
    if (typeof rowKey === "function") {
      key = rowKey(item);
    } else if (rowKey) {
      key = item[rowKey];
    } else {
      key = item.key;
    }
    if (!key) {
      key = `list-item-${index2}`;
    }
    return /* @__PURE__ */ React.createElement(React.Fragment, {
      key
    }, renderItem(item, index2));
  };
  const isSomethingAfterLastItem = () => !!(loadMore || pagination || footer2);
  const prefixCls = getPrefixCls("list", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$1(prefixCls);
  let loadingProp = loading;
  if (typeof loadingProp === "boolean") {
    loadingProp = {
      spinning: loadingProp
    };
  }
  const isLoading = loadingProp && loadingProp.spinning;
  let sizeCls = "";
  switch (size) {
    case "large":
      sizeCls = "lg";
      break;
    case "small":
      sizeCls = "sm";
      break;
  }
  const classString = classNames(prefixCls, {
    [`${prefixCls}-vertical`]: itemLayout === "vertical",
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-split`]: split2,
    [`${prefixCls}-bordered`]: bordered,
    [`${prefixCls}-loading`]: isLoading,
    [`${prefixCls}-grid`]: !!grid,
    [`${prefixCls}-something-after-last-item`]: isSomethingAfterLastItem(),
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId);
  const paginationProps = extendsObject(defaultPaginationProps, {
    total: dataSource.length,
    current: paginationCurrent,
    pageSize: paginationSize
  }, pagination || {});
  const largestPage = Math.ceil(paginationProps.total / paginationProps.pageSize);
  if (paginationProps.current > largestPage) {
    paginationProps.current = largestPage;
  }
  const paginationContent = pagination ? /* @__PURE__ */ React.createElement("div", {
    className: classNames(`${prefixCls}-pagination`, `${prefixCls}-pagination-align-${(_b = paginationProps === null || paginationProps === void 0 ? void 0 : paginationProps.align) !== null && _b !== void 0 ? _b : "end"}`)
  }, /* @__PURE__ */ React.createElement(Pagination$1, Object.assign({}, paginationProps, {
    onChange: onPaginationChange,
    onShowSizeChange: onPaginationShowSizeChange
  }))) : null;
  let splitDataSource = _toConsumableArray(dataSource);
  if (pagination) {
    if (dataSource.length > (paginationProps.current - 1) * paginationProps.pageSize) {
      splitDataSource = _toConsumableArray(dataSource).splice((paginationProps.current - 1) * paginationProps.pageSize, paginationProps.pageSize);
    }
  }
  const needResponsive = Object.keys(grid || {}).some((key) => ["xs", "sm", "md", "lg", "xl", "xxl"].includes(key));
  const screens = useBreakpoint(needResponsive);
  const currentBreakpoint = React.useMemo(() => {
    for (let i = 0; i < responsiveArray.length; i += 1) {
      const breakpoint = responsiveArray[i];
      if (screens[breakpoint]) {
        return breakpoint;
      }
    }
    return void 0;
  }, [screens]);
  const colStyle = React.useMemo(() => {
    if (!grid) {
      return void 0;
    }
    const columnCount = currentBreakpoint && grid[currentBreakpoint] ? grid[currentBreakpoint] : grid.column;
    if (columnCount) {
      return {
        width: `${100 / columnCount}%`,
        maxWidth: `${100 / columnCount}%`
      };
    }
  }, [grid === null || grid === void 0 ? void 0 : grid.column, currentBreakpoint]);
  let childrenContent = isLoading && /* @__PURE__ */ React.createElement("div", {
    style: {
      minHeight: 53
    }
  });
  if (splitDataSource.length > 0) {
    const items = splitDataSource.map((item, index2) => renderInnerItem(item, index2));
    childrenContent = grid ? /* @__PURE__ */ React.createElement(Row$1, {
      gutter: grid.gutter
    }, React.Children.map(items, (child) => /* @__PURE__ */ React.createElement("div", {
      key: child === null || child === void 0 ? void 0 : child.key,
      style: colStyle
    }, child))) : /* @__PURE__ */ React.createElement("ul", {
      className: `${prefixCls}-items`
    }, items);
  } else if (!children && !isLoading) {
    childrenContent = /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-empty-text`
    }, locale2 && locale2.emptyText || (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("List")) || /* @__PURE__ */ React.createElement(DefaultRenderEmpty$1, {
      componentName: "List"
    }));
  }
  const paginationPosition = paginationProps.position || "bottom";
  const contextValue = React.useMemo(() => ({
    grid,
    itemLayout
  }), [JSON.stringify(grid), itemLayout]);
  return wrapSSR(/* @__PURE__ */ React.createElement(ListContext.Provider, {
    value: contextValue
  }, /* @__PURE__ */ React.createElement("div", Object.assign({
    className: classString
  }, rest), (paginationPosition === "top" || paginationPosition === "both") && paginationContent, header && /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-header`
  }, header), /* @__PURE__ */ React.createElement(Spin$2, Object.assign({}, loadingProp), childrenContent, children), footer2 && /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-footer`
  }, footer2), loadMore || (paginationPosition === "bottom" || paginationPosition === "both") && paginationContent)));
}
List2.Item = Item$1;
function modalWarn(props) {
  return confirm(withWarn(props));
}
const Modal = OriginModal;
Modal.useModal = useModal;
Modal.info = function infoFn(props) {
  return confirm(withInfo(props));
};
Modal.success = function successFn(props) {
  return confirm(withSuccess(props));
};
Modal.error = function errorFn(props) {
  return confirm(withError(props));
};
Modal.warning = modalWarn;
Modal.warn = modalWarn;
Modal.confirm = function confirmFn(props) {
  return confirm(withConfirm(props));
};
Modal.destroyAll = function destroyAllFn() {
  while (destroyFns$1.length) {
    const close = destroyFns$1.pop();
    if (close) {
      close();
    }
  }
};
Modal.config = modalGlobalConfig;
Modal._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$4;
var Modal$1 = Modal;
var spin = {};
var interopRequireWildcard = { exports: {} };
var _typeof$4 = { exports: {} };
(function(module2) {
  function _typeof4(obj) {
    "@babel/helpers - typeof";
    return module2.exports = _typeof4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof4(obj);
  }
  module2.exports = _typeof4, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(_typeof$4);
(function(module2) {
  var _typeof4 = _typeof$4.exports["default"];
  function _getRequireWildcardCache2(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache2 = function _getRequireWildcardCache3(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard2(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof4(obj) !== "object" && typeof obj !== "function") {
      return {
        "default": obj
      };
    }
    var cache2 = _getRequireWildcardCache2(nodeInterop);
    if (cache2 && cache2.has(obj)) {
      return cache2.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj["default"] = obj;
    if (cache2) {
      cache2.set(obj, newObj);
    }
    return newObj;
  }
  module2.exports = _interopRequireWildcard2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(interopRequireWildcard);
var interopRequireDefault = { exports: {} };
(function(module2) {
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module2.exports = _interopRequireDefault2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(interopRequireDefault);
var omit$1 = {};
var objectSpread2 = { exports: {} };
var defineProperty = { exports: {} };
(function(module2) {
  function _defineProperty3(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  module2.exports = _defineProperty3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(defineProperty);
(function(module2) {
  var defineProperty$12 = defineProperty.exports;
  function ownKeys2(object4, enumerableOnly) {
    var keys2 = Object.keys(object4);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object4);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread22(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
        defineProperty$12(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  module2.exports = _objectSpread22, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(objectSpread2);
var _interopRequireDefault$I = interopRequireDefault.exports.default;
Object.defineProperty(omit$1, "__esModule", {
  value: true
});
omit$1.default = omit;
var _objectSpread2$9 = _interopRequireDefault$I(objectSpread2.exports);
function omit(obj, fields) {
  var clone2 = (0, _objectSpread2$9.default)({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function(key) {
      delete clone2[key];
    });
  }
  return clone2;
}
const _global_React = React;
var configProvider = {};
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(es$4);
var Context = {};
Object.defineProperty(Context, "__esModule", {
  value: true
});
Context.default = void 0;
var _react$a = _global_React;
var IconContext = /* @__PURE__ */ (0, _react$a.createContext)({});
var _default$K = IconContext;
Context.default = _default$K;
var require$$2$2 = /* @__PURE__ */ getAugmentedNamespace(es$3);
var valueUtil = {};
var toConsumableArray = { exports: {} };
var arrayWithoutHoles = { exports: {} };
var arrayLikeToArray = { exports: {} };
(function(module2) {
  function _arrayLikeToArray2(arr2, len) {
    if (len == null || len > arr2.length)
      len = arr2.length;
    for (var i = 0, arr22 = new Array(len); i < len; i++) {
      arr22[i] = arr2[i];
    }
    return arr22;
  }
  module2.exports = _arrayLikeToArray2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(arrayLikeToArray);
(function(module2) {
  var arrayLikeToArray$1 = arrayLikeToArray.exports;
  function _arrayWithoutHoles2(arr2) {
    if (Array.isArray(arr2))
      return arrayLikeToArray$1(arr2);
  }
  module2.exports = _arrayWithoutHoles2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(arrayWithoutHoles);
var iterableToArray = { exports: {} };
(function(module2) {
  function _iterableToArray2(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  module2.exports = _iterableToArray2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(iterableToArray);
var unsupportedIterableToArray = { exports: {} };
(function(module2) {
  var arrayLikeToArray$1 = arrayLikeToArray.exports;
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return arrayLikeToArray$1(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return arrayLikeToArray$1(o, minLen);
  }
  module2.exports = _unsupportedIterableToArray2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(unsupportedIterableToArray);
var nonIterableSpread = { exports: {} };
(function(module2) {
  function _nonIterableSpread2() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module2.exports = _nonIterableSpread2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(nonIterableSpread);
(function(module2) {
  var arrayWithoutHoles$1 = arrayWithoutHoles.exports;
  var iterableToArray$1 = iterableToArray.exports;
  var unsupportedIterableToArray$1 = unsupportedIterableToArray.exports;
  var nonIterableSpread$1 = nonIterableSpread.exports;
  function _toConsumableArray3(arr2) {
    return arrayWithoutHoles$1(arr2) || iterableToArray$1(arr2) || unsupportedIterableToArray$1(arr2) || nonIterableSpread$1();
  }
  module2.exports = _toConsumableArray3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(toConsumableArray);
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(_typeof$9);
var get$1 = {};
Object.defineProperty(get$1, "__esModule", {
  value: true
});
get$1.default = get;
function get(entity, path2) {
  var current = entity;
  for (var i = 0; i < path2.length; i += 1) {
    if (current === null || current === void 0) {
      return void 0;
    }
    current = current[path2[i]];
  }
  return current;
}
var set$1 = {};
var toArray$3 = { exports: {} };
var arrayWithHoles = { exports: {} };
(function(module2) {
  function _arrayWithHoles2(arr2) {
    if (Array.isArray(arr2))
      return arr2;
  }
  module2.exports = _arrayWithHoles2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(arrayWithHoles);
var nonIterableRest = { exports: {} };
(function(module2) {
  function _nonIterableRest2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module2.exports = _nonIterableRest2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(nonIterableRest);
(function(module2) {
  var arrayWithHoles$1 = arrayWithHoles.exports;
  var iterableToArray$1 = iterableToArray.exports;
  var unsupportedIterableToArray$1 = unsupportedIterableToArray.exports;
  var nonIterableRest$1 = nonIterableRest.exports;
  function _toArray3(arr2) {
    return arrayWithHoles$1(arr2) || iterableToArray$1(arr2) || unsupportedIterableToArray$1(arr2) || nonIterableRest$1();
  }
  module2.exports = _toArray3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(toArray$3);
var _interopRequireDefault$H = interopRequireDefault.exports.default;
Object.defineProperty(set$1, "__esModule", {
  value: true
});
set$1.default = set;
var _objectSpread2$8 = _interopRequireDefault$H(objectSpread2.exports);
var _toConsumableArray2$1 = _interopRequireDefault$H(toConsumableArray.exports);
var _toArray2 = _interopRequireDefault$H(toArray$3.exports);
var _get$1 = _interopRequireDefault$H(get$1);
function internalSet(entity, paths, value, removeIfUndefined) {
  if (!paths.length) {
    return value;
  }
  var _paths = (0, _toArray2.default)(paths), path2 = _paths[0], restPath = _paths.slice(1);
  var clone2;
  if (!entity && typeof path2 === "number") {
    clone2 = [];
  } else if (Array.isArray(entity)) {
    clone2 = (0, _toConsumableArray2$1.default)(entity);
  } else {
    clone2 = (0, _objectSpread2$8.default)({}, entity);
  }
  if (removeIfUndefined && value === void 0 && restPath.length === 1) {
    delete clone2[path2][restPath[0]];
  } else {
    clone2[path2] = internalSet(clone2[path2], restPath, value, removeIfUndefined);
  }
  return clone2;
}
function set(entity, paths, value) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (paths.length && removeIfUndefined && value === void 0 && !(0, _get$1.default)(entity, paths.slice(0, -1))) {
    return entity;
  }
  return internalSet(entity, paths, value, removeIfUndefined);
}
var typeUtil = {};
Object.defineProperty(typeUtil, "__esModule", {
  value: true
});
typeUtil.isFormInstance = isFormInstance;
typeUtil.toArray = toArray$2;
function toArray$2(value) {
  if (value === void 0 || value === null) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function isFormInstance(form) {
  return form && !!form._init;
}
var cloneDeep$1 = {};
var _interopRequireDefault$G = interopRequireDefault.exports.default;
Object.defineProperty(cloneDeep$1, "__esModule", {
  value: true
});
cloneDeep$1.default = void 0;
var _typeof2$5 = _interopRequireDefault$G(require$$1);
function cloneDeep(val) {
  if (Array.isArray(val)) {
    return cloneArrayDeep(val);
  } else if ((0, _typeof2$5.default)(val) === "object" && val !== null) {
    return cloneObjectDeep(val);
  }
  return val;
}
function cloneObjectDeep(val) {
  if (Object.getPrototypeOf(val) === Object.prototype) {
    var res = {};
    for (var key in val) {
      res[key] = cloneDeep(val[key]);
    }
    return res;
  }
  return val;
}
function cloneArrayDeep(val) {
  return val.map(function(item) {
    return cloneDeep(item);
  });
}
var _default$J = cloneDeep;
cloneDeep$1.default = _default$J;
var _interopRequireDefault$F = interopRequireDefault.exports.default;
Object.defineProperty(valueUtil, "__esModule", {
  value: true
});
valueUtil.cloneByNamePathList = cloneByNamePathList;
valueUtil.containsNamePath = containsNamePath;
valueUtil.defaultGetValueFromEvent = defaultGetValueFromEvent;
valueUtil.getNamePath = getNamePath;
valueUtil.getValue = getValue;
valueUtil.isSimilar = isSimilar;
valueUtil.matchNamePath = matchNamePath;
valueUtil.move = move;
valueUtil.setValue = setValue;
valueUtil.setValues = setValues;
var _objectSpread2$7 = _interopRequireDefault$F(objectSpread2.exports);
var _toConsumableArray2 = _interopRequireDefault$F(toConsumableArray.exports);
var _typeof2$4 = _interopRequireDefault$F(require$$1);
var _get = _interopRequireDefault$F(get$1);
var _set = _interopRequireDefault$F(set$1);
var _typeUtil = typeUtil;
var _cloneDeep = _interopRequireDefault$F(cloneDeep$1);
function getNamePath(path2) {
  return (0, _typeUtil.toArray)(path2);
}
function getValue(store, namePath) {
  var value = (0, _get.default)(store, namePath);
  return value;
}
function setValue(store, namePath, value) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var newStore = (0, _set.default)(store, namePath, value, removeIfUndefined);
  return newStore;
}
function cloneByNamePathList(store, namePathList) {
  var newStore = {};
  namePathList.forEach(function(namePath) {
    var value = getValue(store, namePath);
    newStore = setValue(newStore, namePath, value);
  });
  return newStore;
}
function containsNamePath(namePathList, namePath) {
  return namePathList && namePathList.some(function(path2) {
    return matchNamePath(path2, namePath);
  });
}
function isObject(obj) {
  return (0, _typeof2$4.default)(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function internalSetValues(store, values) {
  var newStore = Array.isArray(store) ? (0, _toConsumableArray2.default)(store) : (0, _objectSpread2$7.default)({}, store);
  if (!values) {
    return newStore;
  }
  Object.keys(values).forEach(function(key) {
    var prevValue = newStore[key];
    var value = values[key];
    var recursive = isObject(prevValue) && isObject(value);
    newStore[key] = recursive ? internalSetValues(prevValue, value || {}) : (0, _cloneDeep.default)(value);
  });
  return newStore;
}
function setValues(store) {
  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    restValues[_key - 1] = arguments[_key];
  }
  return restValues.reduce(function(current, newStore) {
    return internalSetValues(current, newStore);
  }, store);
}
function matchNamePath(namePath, changedNamePath) {
  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
    return false;
  }
  return namePath.every(function(nameUnit, i) {
    return changedNamePath[i] === nameUnit;
  });
}
function isSimilar(source, target) {
  if (source === target) {
    return true;
  }
  if (!source && target || source && !target) {
    return false;
  }
  if (!source || !target || (0, _typeof2$4.default)(source) !== "object" || (0, _typeof2$4.default)(target) !== "object") {
    return false;
  }
  var sourceKeys = Object.keys(source);
  var targetKeys = Object.keys(target);
  var keys2 = new Set([].concat(sourceKeys, targetKeys));
  return (0, _toConsumableArray2.default)(keys2).every(function(key) {
    var sourceValue = source[key];
    var targetValue = target[key];
    if (typeof sourceValue === "function" && typeof targetValue === "function") {
      return true;
    }
    return sourceValue === targetValue;
  });
}
function defaultGetValueFromEvent(valuePropName) {
  var event = arguments.length <= 1 ? void 0 : arguments[1];
  if (event && event.target && (0, _typeof2$4.default)(event.target) === "object" && valuePropName in event.target) {
    return event.target[valuePropName];
  }
  return event;
}
function move(array4, moveIndex, toIndex) {
  var length2 = array4.length;
  if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
    return array4;
  }
  var item = array4[moveIndex];
  var diff = moveIndex - toIndex;
  if (diff > 0) {
    return [].concat((0, _toConsumableArray2.default)(array4.slice(0, toIndex)), [item], (0, _toConsumableArray2.default)(array4.slice(toIndex, moveIndex)), (0, _toConsumableArray2.default)(array4.slice(moveIndex + 1, length2)));
  }
  if (diff < 0) {
    return [].concat((0, _toConsumableArray2.default)(array4.slice(0, moveIndex)), (0, _toConsumableArray2.default)(array4.slice(moveIndex + 1, toIndex + 1)), [item], (0, _toConsumableArray2.default)(array4.slice(toIndex + 1, length2)));
  }
  return array4;
}
var useMemo$1 = {};
var _interopRequireWildcard$k = interopRequireWildcard.exports.default;
Object.defineProperty(useMemo$1, "__esModule", {
  value: true
});
useMemo$1.default = useMemo;
var React$h = _interopRequireWildcard$k(_global_React);
function useMemo(getValue2, condition, shouldUpdate) {
  var cacheRef = React$h.useRef({});
  if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue2();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
var locale$4 = {};
var warning$5 = {};
var warning$4 = {};
Object.defineProperty(warning$4, "__esModule", {
  value: true
});
warning$4.call = call$1;
warning$4.default = void 0;
warning$4.note = note$1;
warning$4.noteOnce = noteOnce$1;
warning$4.resetWarned = resetWarned$1;
warning$4.warning = warning$3;
warning$4.warningOnce = warningOnce$1;
var warned$1 = {};
function warning$3(valid2, message) {
}
function note$1(valid2, message) {
}
function resetWarned$1() {
  warned$1 = {};
}
function call$1(method4, valid2, message) {
  if (!valid2 && !warned$1[message]) {
    method4(false, message);
    warned$1[message] = true;
  }
}
function warningOnce$1(valid2, message) {
  call$1(warning$3, valid2, message);
}
function noteOnce$1(valid2, message) {
  call$1(note$1, valid2, message);
}
var _default$I = warningOnce$1;
warning$4.default = _default$I;
(function(exports) {
  var _interopRequireWildcard2 = interopRequireWildcard.exports.default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  exports.noop = noop2;
  Object.defineProperty(exports, "resetWarned", {
    enumerable: true,
    get: function() {
      return _warning2.resetWarned;
    }
  });
  var _warning2 = _interopRequireWildcard2(warning$4);
  function noop2() {
  }
  let warning3 = noop2;
  var _default3 = warning3;
  exports.default = _default3;
})(warning$5);
var locale$3 = {};
var en_US$5 = {};
var en_US$4 = {};
Object.defineProperty(en_US$4, "__esModule", {
  value: true
});
en_US$4.default = void 0;
var _default$H = {
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
};
en_US$4.default = _default$H;
var en_US$3 = {};
var en_US$2 = {};
var en_US$1 = {};
Object.defineProperty(en_US$1, "__esModule", {
  value: true
});
en_US$1.default = void 0;
var locale$2 = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: true,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
};
var _default$G = locale$2;
en_US$1.default = _default$G;
var en_US = {};
Object.defineProperty(en_US, "__esModule", {
  value: true
});
en_US.default = void 0;
const locale$1 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
var _default$F = locale$1;
en_US.default = _default$F;
var _interopRequireDefault$E = interopRequireDefault.exports.default;
Object.defineProperty(en_US$2, "__esModule", {
  value: true
});
en_US$2.default = void 0;
var _en_US$4 = _interopRequireDefault$E(en_US$1);
var _en_US2$1 = _interopRequireDefault$E(en_US);
const locale = {
  lang: Object.assign({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, _en_US$4.default),
  timePickerLocale: Object.assign({}, _en_US2$1.default)
};
var _default$E = locale;
en_US$2.default = _default$E;
var _interopRequireDefault$D = interopRequireDefault.exports.default;
Object.defineProperty(en_US$3, "__esModule", {
  value: true
});
en_US$3.default = void 0;
var _en_US$3 = _interopRequireDefault$D(en_US$2);
var _default$D = _en_US$3.default;
en_US$3.default = _default$D;
var _interopRequireDefault$C = interopRequireDefault.exports.default;
Object.defineProperty(en_US$5, "__esModule", {
  value: true
});
en_US$5.default = void 0;
var _en_US$2 = _interopRequireDefault$C(en_US$4);
var _en_US2 = _interopRequireDefault$C(en_US$3);
var _en_US3 = _interopRequireDefault$C(en_US$2);
var _en_US4 = _interopRequireDefault$C(en_US);
const typeTemplate = "${label} is not a valid ${type}";
const localeValues = {
  locale: "en",
  Pagination: _en_US$2.default,
  DatePicker: _en_US3.default,
  TimePicker: _en_US4.default,
  Calendar: _en_US2.default,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand"
  },
  PageHeader: {
    back: "Back"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        boolean: typeTemplate,
        integer: typeTemplate,
        float: typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh"
  }
};
var _default$C = localeValues;
en_US$5.default = _default$C;
var _interopRequireDefault$B = interopRequireDefault.exports.default;
Object.defineProperty(locale$3, "__esModule", {
  value: true
});
locale$3.changeConfirmLocale = changeConfirmLocale;
locale$3.getConfirmLocale = getConfirmLocale;
var _en_US$1 = _interopRequireDefault$B(en_US$5);
let runtimeLocale = Object.assign({}, _en_US$1.default.Modal);
function changeConfirmLocale(newLocale) {
  if (newLocale) {
    runtimeLocale = Object.assign(Object.assign({}, runtimeLocale), newLocale);
  } else {
    runtimeLocale = Object.assign({}, _en_US$1.default.Modal);
  }
}
function getConfirmLocale() {
  return runtimeLocale;
}
var context$2 = {};
Object.defineProperty(context$2, "__esModule", {
  value: true
});
context$2.default = void 0;
var _react$9 = _global_React;
const LocaleContext = /* @__PURE__ */ (0, _react$9.createContext)(void 0);
var _default$B = LocaleContext;
context$2.default = _default$B;
var useLocale$1 = {};
var _interopRequireDefault$A = interopRequireDefault.exports.default;
var _interopRequireWildcard$j = interopRequireWildcard.exports.default;
Object.defineProperty(useLocale$1, "__esModule", {
  value: true
});
useLocale$1.default = void 0;
var React$g = _interopRequireWildcard$j(_global_React);
var _context$2 = _interopRequireDefault$A(context$2);
var _en_US = _interopRequireDefault$A(en_US$5);
const useLocale = (componentName, defaultLocale2) => {
  const fullLocale = React$g.useContext(_context$2.default);
  const getLocale = React$g.useMemo(() => {
    var _a2;
    const locale2 = defaultLocale2 || _en_US.default[componentName];
    const localeFromContext = (_a2 = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale[componentName]) !== null && _a2 !== void 0 ? _a2 : {};
    return Object.assign(Object.assign({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {});
  }, [componentName, defaultLocale2, fullLocale]);
  const getLocaleCode = React$g.useMemo(() => {
    const localeCode = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.locale;
    if ((fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.exist) && !localeCode) {
      return _en_US.default.locale;
    }
    return localeCode;
  }, [fullLocale]);
  return [getLocale, getLocaleCode];
};
var _default$A = useLocale;
useLocale$1.default = _default$A;
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports.default;
  var _interopRequireWildcard2 = interopRequireWildcard.exports.default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.ANT_MARK = void 0;
  Object.defineProperty(exports, "useLocale", {
    enumerable: true,
    get: function() {
      return _useLocale.default;
    }
  });
  var React2 = _interopRequireWildcard2(_global_React);
  _interopRequireDefault2(warning$5);
  var _locale = locale$3;
  var _context2 = _interopRequireDefault2(context$2);
  var _useLocale = _interopRequireDefault2(useLocale$1);
  const ANT_MARK2 = "internalMark";
  exports.ANT_MARK = ANT_MARK2;
  const LocaleProvider2 = (props) => {
    const {
      locale: locale2 = {},
      children,
      _ANT_MARK__
    } = props;
    React2.useEffect(() => {
      (0, _locale.changeConfirmLocale)(locale2 && locale2.Modal);
      return () => {
        (0, _locale.changeConfirmLocale)();
      };
    }, [locale2]);
    const getMemoizedContextValue = React2.useMemo(() => Object.assign(Object.assign({}, locale2), {
      exist: true
    }), [locale2]);
    return /* @__PURE__ */ React2.createElement(_context2.default.Provider, {
      value: getMemoizedContextValue
    }, children);
  };
  var _default3 = LocaleProvider2;
  exports.default = _default3;
})(locale$4);
var internal = {};
var version$2 = {};
var version$1 = {};
Object.defineProperty(version$1, "__esModule", {
  value: true
});
version$1.default = void 0;
var _default$z = "5.4.0";
version$1.default = _default$z;
var _interopRequireDefault$z = interopRequireDefault.exports.default;
Object.defineProperty(version$2, "__esModule", {
  value: true
});
version$2.default = void 0;
var _version = _interopRequireDefault$z(version$1);
var _default$y = _version.default;
version$2.default = _default$y;
var _interface$1 = {};
var presetColors = {};
Object.defineProperty(presetColors, "__esModule", {
  value: true
});
presetColors.PresetColors = void 0;
const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
presetColors.PresetColors = PresetColors;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "PresetColors", {
    enumerable: true,
    get: function() {
      return _presetColors.PresetColors;
    }
  });
  var _presetColors = presetColors;
})(_interface$1);
var _default$x = {};
var require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(es$2);
var genControlHeight$1 = {};
Object.defineProperty(genControlHeight$1, "__esModule", {
  value: true
});
genControlHeight$1.default = void 0;
const genControlHeight = (token2) => {
  const {
    controlHeight
  } = token2;
  return {
    controlHeightSM: controlHeight * 0.75,
    controlHeightXS: controlHeight * 0.5,
    controlHeightLG: controlHeight * 1.25
  };
};
var _default$w = genControlHeight;
genControlHeight$1.default = _default$w;
var genSizeMapToken$1 = {};
Object.defineProperty(genSizeMapToken$1, "__esModule", {
  value: true
});
genSizeMapToken$1.default = genSizeMapToken;
function genSizeMapToken(token2) {
  const {
    sizeUnit,
    sizeStep
  } = token2;
  return {
    sizeXXL: sizeUnit * (sizeStep + 8),
    sizeXL: sizeUnit * (sizeStep + 4),
    sizeLG: sizeUnit * (sizeStep + 2),
    sizeMD: sizeUnit * (sizeStep + 1),
    sizeMS: sizeUnit * sizeStep,
    size: sizeUnit * sizeStep,
    sizeSM: sizeUnit * (sizeStep - 1),
    sizeXS: sizeUnit * (sizeStep - 2),
    sizeXXS: sizeUnit * (sizeStep - 3)
  };
}
var seed = {};
Object.defineProperty(seed, "__esModule", {
  value: true
});
seed.defaultPresetColors = seed.default = void 0;
const defaultPresetColors = {
  blue: "#1677ff",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  pink: "#eb2f96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
};
seed.defaultPresetColors = defaultPresetColors;
const seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorTextBase: "",
  colorBgBase: "",
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
  fontSize: 14,
  lineWidth: 1,
  lineType: "solid",
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  borderRadius: 6,
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  controlHeight: 32,
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  opacityImage: 1,
  wireframe: false
});
var _default$v = seedToken;
seed.default = _default$v;
var genColorMapToken$1 = {};
var require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(public_api);
Object.defineProperty(genColorMapToken$1, "__esModule", {
  value: true
});
genColorMapToken$1.default = genColorMapToken;
var _tinycolor$4 = require$$2$1;
function genColorMapToken(seed2, _ref2) {
  let {
    generateColorPalettes: generateColorPalettes2,
    generateNeutralColorPalettes: generateNeutralColorPalettes2
  } = _ref2;
  const {
    colorSuccess: colorSuccessBase,
    colorWarning: colorWarningBase,
    colorError: colorErrorBase,
    colorInfo: colorInfoBase,
    colorPrimary: colorPrimaryBase,
    colorBgBase,
    colorTextBase
  } = seed2;
  const primaryColors = generateColorPalettes2(colorPrimaryBase);
  const successColors = generateColorPalettes2(colorSuccessBase);
  const warningColors = generateColorPalettes2(colorWarningBase);
  const errorColors = generateColorPalettes2(colorErrorBase);
  const infoColors = generateColorPalettes2(colorInfoBase);
  const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
  return Object.assign(Object.assign({}, neutralColors), {
    colorPrimaryBg: primaryColors[1],
    colorPrimaryBgHover: primaryColors[2],
    colorPrimaryBorder: primaryColors[3],
    colorPrimaryBorderHover: primaryColors[4],
    colorPrimaryHover: primaryColors[5],
    colorPrimary: primaryColors[6],
    colorPrimaryActive: primaryColors[7],
    colorPrimaryTextHover: primaryColors[8],
    colorPrimaryText: primaryColors[9],
    colorPrimaryTextActive: primaryColors[10],
    colorSuccessBg: successColors[1],
    colorSuccessBgHover: successColors[2],
    colorSuccessBorder: successColors[3],
    colorSuccessBorderHover: successColors[4],
    colorSuccessHover: successColors[4],
    colorSuccess: successColors[6],
    colorSuccessActive: successColors[7],
    colorSuccessTextHover: successColors[8],
    colorSuccessText: successColors[9],
    colorSuccessTextActive: successColors[10],
    colorErrorBg: errorColors[1],
    colorErrorBgHover: errorColors[2],
    colorErrorBorder: errorColors[3],
    colorErrorBorderHover: errorColors[4],
    colorErrorHover: errorColors[5],
    colorError: errorColors[6],
    colorErrorActive: errorColors[7],
    colorErrorTextHover: errorColors[8],
    colorErrorText: errorColors[9],
    colorErrorTextActive: errorColors[10],
    colorWarningBg: warningColors[1],
    colorWarningBgHover: warningColors[2],
    colorWarningBorder: warningColors[3],
    colorWarningBorderHover: warningColors[4],
    colorWarningHover: warningColors[4],
    colorWarning: warningColors[6],
    colorWarningActive: warningColors[7],
    colorWarningTextHover: warningColors[8],
    colorWarningText: warningColors[9],
    colorWarningTextActive: warningColors[10],
    colorInfoBg: infoColors[1],
    colorInfoBgHover: infoColors[2],
    colorInfoBorder: infoColors[3],
    colorInfoBorderHover: infoColors[4],
    colorInfoHover: infoColors[4],
    colorInfo: infoColors[6],
    colorInfoActive: infoColors[7],
    colorInfoTextHover: infoColors[8],
    colorInfoText: infoColors[9],
    colorInfoTextActive: infoColors[10],
    colorBgMask: new _tinycolor$4.TinyColor("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
var genCommonMapToken$1 = {};
var genRadius$1 = {};
Object.defineProperty(genRadius$1, "__esModule", {
  value: true
});
genRadius$1.default = void 0;
const genRadius = (radiusBase) => {
  let radiusLG = radiusBase;
  let radiusSM = radiusBase;
  let radiusXS = radiusBase;
  let radiusOuter = radiusBase;
  if (radiusBase < 6 && radiusBase >= 5) {
    radiusLG = radiusBase + 1;
  } else if (radiusBase < 16 && radiusBase >= 6) {
    radiusLG = radiusBase + 2;
  } else if (radiusBase >= 16) {
    radiusLG = 16;
  }
  if (radiusBase < 7 && radiusBase >= 5) {
    radiusSM = 4;
  } else if (radiusBase < 8 && radiusBase >= 7) {
    radiusSM = 5;
  } else if (radiusBase < 14 && radiusBase >= 8) {
    radiusSM = 6;
  } else if (radiusBase < 16 && radiusBase >= 14) {
    radiusSM = 7;
  } else if (radiusBase >= 16) {
    radiusSM = 8;
  }
  if (radiusBase < 6 && radiusBase >= 2) {
    radiusXS = 1;
  } else if (radiusBase >= 6) {
    radiusXS = 2;
  }
  if (radiusBase > 4 && radiusBase < 8) {
    radiusOuter = 4;
  } else if (radiusBase >= 8) {
    radiusOuter = 6;
  }
  return {
    borderRadius: radiusBase > 16 ? 16 : radiusBase,
    borderRadiusXS: radiusXS,
    borderRadiusSM: radiusSM,
    borderRadiusLG: radiusLG,
    borderRadiusOuter: radiusOuter
  };
};
var _default$u = genRadius;
genRadius$1.default = _default$u;
var _interopRequireDefault$y = interopRequireDefault.exports.default;
Object.defineProperty(genCommonMapToken$1, "__esModule", {
  value: true
});
genCommonMapToken$1.default = genCommonMapToken;
var _genRadius = _interopRequireDefault$y(genRadius$1);
function genCommonMapToken(token2) {
  const {
    motionUnit,
    motionBase,
    borderRadius,
    lineWidth
  } = token2;
  return Object.assign({
    motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
    motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
    motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
    lineWidthBold: lineWidth + 1
  }, (0, _genRadius.default)(borderRadius));
}
var colors = {};
var colorAlgorithm = {};
Object.defineProperty(colorAlgorithm, "__esModule", {
  value: true
});
colorAlgorithm.getSolidColor = colorAlgorithm.getAlphaColor = void 0;
var _tinycolor$3 = require$$2$1;
const getAlphaColor$2 = (baseColor, alpha) => new _tinycolor$3.TinyColor(baseColor).setAlpha(alpha).toRgbString();
colorAlgorithm.getAlphaColor = getAlphaColor$2;
const getSolidColor = (baseColor, brightness) => {
  const instance2 = new _tinycolor$3.TinyColor(baseColor);
  return instance2.darken(brightness).toHexString();
};
colorAlgorithm.getSolidColor = getSolidColor;
Object.defineProperty(colors, "__esModule", {
  value: true
});
colors.generateNeutralColorPalettes = colors.generateColorPalettes = void 0;
var _colors$3 = require$$3$1;
var _colorAlgorithm = colorAlgorithm;
const generateColorPalettes = (baseColor) => {
  const colors2 = (0, _colors$3.generate)(baseColor);
  return {
    1: colors2[0],
    2: colors2[1],
    3: colors2[2],
    4: colors2[3],
    5: colors2[4],
    6: colors2[5],
    7: colors2[6],
    8: colors2[4],
    9: colors2[5],
    10: colors2[6]
  };
};
colors.generateColorPalettes = generateColorPalettes;
const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#fff";
  const colorTextBase = textBaseColor || "#000";
  return {
    colorBgBase,
    colorTextBase,
    colorText: (0, _colorAlgorithm.getAlphaColor)(colorTextBase, 0.88),
    colorTextSecondary: (0, _colorAlgorithm.getAlphaColor)(colorTextBase, 0.65),
    colorTextTertiary: (0, _colorAlgorithm.getAlphaColor)(colorTextBase, 0.45),
    colorTextQuaternary: (0, _colorAlgorithm.getAlphaColor)(colorTextBase, 0.25),
    colorFill: (0, _colorAlgorithm.getAlphaColor)(colorTextBase, 0.15),
    colorFillSecondary: (0, _colorAlgorithm.getAlphaColor)(colorTextBase, 0.06),
    colorFillTertiary: (0, _colorAlgorithm.getAlphaColor)(colorTextBase, 0.04),
    colorFillQuaternary: (0, _colorAlgorithm.getAlphaColor)(colorTextBase, 0.02),
    colorBgLayout: (0, _colorAlgorithm.getSolidColor)(colorBgBase, 4),
    colorBgContainer: (0, _colorAlgorithm.getSolidColor)(colorBgBase, 0),
    colorBgElevated: (0, _colorAlgorithm.getSolidColor)(colorBgBase, 0),
    colorBgSpotlight: (0, _colorAlgorithm.getAlphaColor)(colorTextBase, 0.85),
    colorBorder: (0, _colorAlgorithm.getSolidColor)(colorBgBase, 15),
    colorBorderSecondary: (0, _colorAlgorithm.getSolidColor)(colorBgBase, 6)
  };
};
colors.generateNeutralColorPalettes = generateNeutralColorPalettes;
var genFontMapToken$1 = {};
var genFontSizes = {};
Object.defineProperty(genFontSizes, "__esModule", {
  value: true
});
genFontSizes.default = getFontSizes;
function getFontSizes(base2) {
  const fontSizes = new Array(10).fill(null).map((_24, index2) => {
    const i = index2 - 1;
    const baseSize = base2 * Math.pow(2.71828, i / 5);
    const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
    return Math.floor(intSize / 2) * 2;
  });
  fontSizes[1] = base2;
  return fontSizes.map((size) => {
    const height = size + 8;
    return {
      size,
      lineHeight: height / size
    };
  });
}
var _interopRequireDefault$x = interopRequireDefault.exports.default;
Object.defineProperty(genFontMapToken$1, "__esModule", {
  value: true
});
genFontMapToken$1.default = void 0;
var _genFontSizes = _interopRequireDefault$x(genFontSizes);
const genFontMapToken = (fontSize) => {
  const fontSizePairs = (0, _genFontSizes.default)(fontSize);
  const fontSizes = fontSizePairs.map((pair) => pair.size);
  const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
  return {
    fontSizeSM: fontSizes[0],
    fontSize: fontSizes[1],
    fontSizeLG: fontSizes[2],
    fontSizeXL: fontSizes[3],
    fontSizeHeading1: fontSizes[6],
    fontSizeHeading2: fontSizes[5],
    fontSizeHeading3: fontSizes[4],
    fontSizeHeading4: fontSizes[3],
    fontSizeHeading5: fontSizes[2],
    lineHeight: lineHeights[1],
    lineHeightLG: lineHeights[2],
    lineHeightSM: lineHeights[0],
    lineHeightHeading1: lineHeights[6],
    lineHeightHeading2: lineHeights[5],
    lineHeightHeading3: lineHeights[4],
    lineHeightHeading4: lineHeights[3],
    lineHeightHeading5: lineHeights[2]
  };
};
var _default$t = genFontMapToken;
genFontMapToken$1.default = _default$t;
var _interopRequireDefault$w = interopRequireDefault.exports.default;
Object.defineProperty(_default$x, "__esModule", {
  value: true
});
_default$x.default = derivative;
var _colors$2 = require$$3$1;
var _genControlHeight = _interopRequireDefault$w(genControlHeight$1);
var _genSizeMapToken = _interopRequireDefault$w(genSizeMapToken$1);
var _seed$1 = seed;
var _genColorMapToken = _interopRequireDefault$w(genColorMapToken$1);
var _genCommonMapToken = _interopRequireDefault$w(genCommonMapToken$1);
var _colors2 = colors;
var _genFontMapToken = _interopRequireDefault$w(genFontMapToken$1);
function derivative(token2) {
  const colorPalettes = Object.keys(_seed$1.defaultPresetColors).map((colorKey) => {
    const colors2 = (0, _colors$2.generate)(token2[colorKey]);
    return new Array(10).fill(1).reduce((prev2, _24, i) => {
      prev2[`${colorKey}-${i + 1}`] = colors2[i];
      prev2[`${colorKey}${i + 1}`] = colors2[i];
      return prev2;
    }, {});
  }).reduce((prev2, cur) => {
    prev2 = Object.assign(Object.assign({}, prev2), cur);
    return prev2;
  }, {});
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token2), colorPalettes), (0, _genColorMapToken.default)(token2, {
    generateColorPalettes: _colors2.generateColorPalettes,
    generateNeutralColorPalettes: _colors2.generateNeutralColorPalettes
  })), (0, _genFontMapToken.default)(token2.fontSize)), (0, _genSizeMapToken.default)(token2)), (0, _genControlHeight.default)(token2)), (0, _genCommonMapToken.default)(token2));
}
var alias = {};
var getAlphaColor$1 = {};
Object.defineProperty(getAlphaColor$1, "__esModule", {
  value: true
});
getAlphaColor$1.default = void 0;
var _tinycolor$2 = require$$2$1;
function isStableColor(color2) {
  return color2 >= 0 && color2 <= 255;
}
function getAlphaColor(frontColor, backgroundColor) {
  const {
    r: fR,
    g: fG,
    b: fB,
    a: originAlpha
  } = new _tinycolor$2.TinyColor(frontColor).toRgb();
  if (originAlpha < 1) {
    return frontColor;
  }
  const {
    r: bR,
    g: bG,
    b: bB
  } = new _tinycolor$2.TinyColor(backgroundColor).toRgb();
  for (let fA = 0.01; fA <= 1; fA += 0.01) {
    const r2 = Math.round((fR - bR * (1 - fA)) / fA);
    const g2 = Math.round((fG - bG * (1 - fA)) / fA);
    const b2 = Math.round((fB - bB * (1 - fA)) / fA);
    if (isStableColor(r2) && isStableColor(g2) && isStableColor(b2)) {
      return new _tinycolor$2.TinyColor({
        r: r2,
        g: g2,
        b: b2,
        a: Math.round(fA * 100) / 100
      }).toRgbString();
    }
  }
  return new _tinycolor$2.TinyColor({
    r: fR,
    g: fG,
    b: fB,
    a: 1
  }).toRgbString();
}
var _default$s = getAlphaColor;
getAlphaColor$1.default = _default$s;
var _interopRequireDefault$v = interopRequireDefault.exports.default;
Object.defineProperty(alias, "__esModule", {
  value: true
});
alias.default = formatToken;
var _tinycolor$1 = require$$2$1;
var _getAlphaColor = _interopRequireDefault$v(getAlphaColor$1);
var _seed = _interopRequireDefault$v(seed);
var __rest$6 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function formatToken(derivativeToken) {
  const {
    override
  } = derivativeToken, restToken = __rest$6(derivativeToken, ["override"]);
  const overrideTokens = Object.assign({}, override);
  Object.keys(_seed.default).forEach((token2) => {
    delete overrideTokens[token2];
  });
  const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
  const screenXS = 480;
  const screenSM = 576;
  const screenMD = 768;
  const screenLG = 992;
  const screenXL = 1200;
  const screenXXL = 1600;
  const aliasToken = Object.assign(Object.assign(Object.assign({}, mergedToken), {
    colorLink: mergedToken.colorInfoText,
    colorLinkHover: mergedToken.colorInfoHover,
    colorLinkActive: mergedToken.colorInfoActive,
    colorFillContent: mergedToken.colorFillSecondary,
    colorFillContentHover: mergedToken.colorFill,
    colorFillAlter: mergedToken.colorFillQuaternary,
    colorBgContainerDisabled: mergedToken.colorFillTertiary,
    colorBorderBg: mergedToken.colorBgContainer,
    colorSplit: (0, _getAlphaColor.default)(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
    colorTextPlaceholder: mergedToken.colorTextQuaternary,
    colorTextDisabled: mergedToken.colorTextQuaternary,
    colorTextHeading: mergedToken.colorText,
    colorTextLabel: mergedToken.colorTextSecondary,
    colorTextDescription: mergedToken.colorTextTertiary,
    colorTextLightSolid: mergedToken.colorWhite,
    colorHighlight: mergedToken.colorError,
    colorBgTextHover: mergedToken.colorFillSecondary,
    colorBgTextActive: mergedToken.colorFill,
    colorIcon: mergedToken.colorTextTertiary,
    colorIconHover: mergedToken.colorText,
    colorErrorOutline: (0, _getAlphaColor.default)(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
    colorWarningOutline: (0, _getAlphaColor.default)(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
    fontSizeIcon: mergedToken.fontSizeSM,
    lineWidthFocus: mergedToken.lineWidth * 4,
    lineWidth: mergedToken.lineWidth,
    controlOutlineWidth: mergedToken.lineWidth * 2,
    controlInteractiveSize: mergedToken.controlHeight / 2,
    controlItemBgHover: mergedToken.colorFillTertiary,
    controlItemBgActive: mergedToken.colorPrimaryBg,
    controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
    controlItemBgActiveDisabled: mergedToken.colorFill,
    controlTmpOutline: mergedToken.colorFillQuaternary,
    controlOutline: (0, _getAlphaColor.default)(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
    lineType: mergedToken.lineType,
    borderRadius: mergedToken.borderRadius,
    borderRadiusXS: mergedToken.borderRadiusXS,
    borderRadiusSM: mergedToken.borderRadiusSM,
    borderRadiusLG: mergedToken.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: mergedToken.sizeXXS,
    paddingXS: mergedToken.sizeXS,
    paddingSM: mergedToken.sizeSM,
    padding: mergedToken.size,
    paddingMD: mergedToken.sizeMD,
    paddingLG: mergedToken.sizeLG,
    paddingXL: mergedToken.sizeXL,
    paddingContentHorizontalLG: mergedToken.sizeLG,
    paddingContentVerticalLG: mergedToken.sizeMS,
    paddingContentHorizontal: mergedToken.sizeMS,
    paddingContentVertical: mergedToken.sizeSM,
    paddingContentHorizontalSM: mergedToken.size,
    paddingContentVerticalSM: mergedToken.sizeXS,
    marginXXS: mergedToken.sizeXXS,
    marginXS: mergedToken.sizeXS,
    marginSM: mergedToken.sizeSM,
    margin: mergedToken.size,
    marginMD: mergedToken.sizeMD,
    marginLG: mergedToken.sizeLG,
    marginXL: mergedToken.sizeXL,
    marginXXL: mergedToken.sizeXXL,
    boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS,
    screenXSMin: screenXS,
    screenXSMax: screenSM - 1,
    screenSM,
    screenSMMin: screenSM,
    screenSMMax: screenMD - 1,
    screenMD,
    screenMDMin: screenMD,
    screenMDMax: screenLG - 1,
    screenLG,
    screenLGMin: screenLG,
    screenLGMax: screenXL - 1,
    screenXL,
    screenXLMin: screenXL,
    screenXLMax: screenXXL - 1,
    screenXXL,
    screenXXLMin: screenXXL,
    boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
    boxShadowCard: `
      0 1px 2px -2px ${new _tinycolor$1.TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new _tinycolor$1.TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new _tinycolor$1.TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), overrideTokens);
  return aliasToken;
}
var genComponentStyleHook$1 = {};
var context$1 = {};
var _interopRequireWildcard$i = interopRequireWildcard.exports.default;
Object.defineProperty(context$1, "__esModule", {
  value: true
});
context$1.defaultIconPrefixCls = context$1.ConfigContext = context$1.ConfigConsumer = void 0;
var React$f = _interopRequireWildcard$i(_global_React);
const defaultIconPrefixCls = "anticon";
context$1.defaultIconPrefixCls = defaultIconPrefixCls;
const defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
  if (customizePrefixCls)
    return customizePrefixCls;
  return suffixCls ? `ant-${suffixCls}` : "ant";
};
const ConfigContext = /* @__PURE__ */ React$f.createContext({
  getPrefixCls: defaultGetPrefixCls,
  iconPrefixCls: defaultIconPrefixCls
});
context$1.ConfigContext = ConfigContext;
const {
  Consumer: ConfigConsumer
} = ConfigContext;
context$1.ConfigConsumer = ConfigConsumer;
var style$6 = {};
var operationUnit$1 = {};
Object.defineProperty(operationUnit$1, "__esModule", {
  value: true
});
operationUnit$1.operationUnit = void 0;
const operationUnit = (token2) => ({
  color: token2.colorLink,
  textDecoration: "none",
  outline: "none",
  cursor: "pointer",
  transition: `color ${token2.motionDurationSlow}`,
  "&:focus, &:hover": {
    color: token2.colorLinkHover
  },
  "&:active": {
    color: token2.colorLinkActive
  }
});
operationUnit$1.operationUnit = operationUnit;
var roundedArrow$1 = {};
Object.defineProperty(roundedArrow$1, "__esModule", {
  value: true
});
roundedArrow$1.roundedArrow = void 0;
const roundedArrow = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
  const unitWidth = width / 2;
  const ax = 0;
  const ay = unitWidth;
  const bx = outerRadius * 1 / Math.sqrt(2);
  const by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2));
  const cx = unitWidth - innerRadius * (1 / Math.sqrt(2));
  const cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2));
  const dx = 2 * unitWidth - cx;
  const dy = cy;
  const ex = 2 * unitWidth - bx;
  const ey = by;
  const fx = 2 * unitWidth - ax;
  const fy = ay;
  const shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2);
  return {
    pointerEvents: "none",
    width,
    height: width,
    overflow: "hidden",
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width,
      height: width / 2,
      background: bgColor,
      clipPath: `path('M ${ax} ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')`,
      content: '""'
    },
    "&::after": {
      content: '""',
      position: "absolute",
      width: shadowWidth,
      height: shadowWidth,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: true,
        value: `0 0 ${innerRadius}px 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow,
      zIndex: 0,
      background: "transparent"
    }
  };
};
roundedArrow$1.roundedArrow = roundedArrow;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.genLinkStyle = exports.genFocusStyle = exports.genFocusOutline = exports.genCommonStyle = exports.clearFix = void 0;
  Object.defineProperty(exports, "operationUnit", {
    enumerable: true,
    get: function() {
      return _operationUnit.operationUnit;
    }
  });
  exports.resetIcon = exports.resetComponent = void 0;
  Object.defineProperty(exports, "roundedArrow", {
    enumerable: true,
    get: function() {
      return _roundedArrow.roundedArrow;
    }
  });
  exports.textEllipsis = void 0;
  var _operationUnit = operationUnit$1;
  var _roundedArrow = roundedArrow$1;
  const textEllipsis2 = {
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis"
  };
  exports.textEllipsis = textEllipsis2;
  const resetComponent2 = (token2) => ({
    boxSizing: "border-box",
    margin: 0,
    padding: 0,
    color: token2.colorText,
    fontSize: token2.fontSize,
    lineHeight: token2.lineHeight,
    listStyle: "none",
    fontFamily: token2.fontFamily
  });
  exports.resetComponent = resetComponent2;
  const resetIcon2 = () => ({
    display: "inline-flex",
    alignItems: "center",
    color: "inherit",
    fontStyle: "normal",
    lineHeight: 0,
    textAlign: "center",
    textTransform: "none",
    verticalAlign: "-0.125em",
    textRendering: "optimizeLegibility",
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "> *": {
      lineHeight: 1
    },
    svg: {
      display: "inline-block"
    }
  });
  exports.resetIcon = resetIcon2;
  const clearFix2 = () => ({
    "&::before": {
      display: "table",
      content: '""'
    },
    "&::after": {
      display: "table",
      clear: "both",
      content: '""'
    }
  });
  exports.clearFix = clearFix2;
  const genLinkStyle2 = (token2) => ({
    a: {
      color: token2.colorLink,
      textDecoration: token2.linkDecoration,
      backgroundColor: "transparent",
      outline: "none",
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "-webkit-text-decoration-skip": "objects",
      "&:hover": {
        color: token2.colorLinkHover
      },
      "&:active": {
        color: token2.colorLinkActive
      },
      [`&:active,
  &:hover`]: {
        textDecoration: token2.linkHoverDecoration,
        outline: 0
      },
      "&:focus": {
        textDecoration: token2.linkFocusDecoration,
        outline: 0
      },
      "&[disabled]": {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      }
    }
  });
  exports.genLinkStyle = genLinkStyle2;
  const genCommonStyle2 = (token2, componentPrefixCls) => {
    const {
      fontFamily,
      fontSize
    } = token2;
    const rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
    return {
      [rootPrefixSelector]: {
        fontFamily,
        fontSize,
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        },
        [rootPrefixSelector]: {
          boxSizing: "border-box",
          "&::before, &::after": {
            boxSizing: "border-box"
          }
        }
      }
    };
  };
  exports.genCommonStyle = genCommonStyle2;
  const genFocusOutline2 = (token2) => ({
    outline: `${token2.lineWidthFocus}px solid ${token2.colorPrimaryBorder}`,
    outlineOffset: 1,
    transition: "outline-offset 0s, outline 0s"
  });
  exports.genFocusOutline = genFocusOutline2;
  const genFocusStyle2 = (token2) => ({
    "&:focus-visible": Object.assign({}, genFocusOutline2(token2))
  });
  exports.genFocusStyle = genFocusStyle2;
})(style$6);
Object.defineProperty(genComponentStyleHook$1, "__esModule", {
  value: true
});
genComponentStyleHook$1.default = genComponentStyleHook;
var _cssinjs$2 = require$$0;
var _react$8 = _global_React;
var _context$1 = context$1;
var _style$8 = style$6;
var _internal$8 = internal;
function genComponentStyleHook(component, styleFn, getDefaultToken) {
  return (prefixCls) => {
    const [theme2, token2, hashId] = (0, _internal$8.useToken)();
    const {
      getPrefixCls,
      iconPrefixCls,
      csp
    } = (0, _react$8.useContext)(_context$1.ConfigContext);
    const rootPrefixCls = getPrefixCls();
    const sharedConfig = {
      theme: theme2,
      token: token2,
      hashId,
      nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce
    };
    (0, _cssinjs$2.useStyleRegister)(Object.assign(Object.assign({}, sharedConfig), {
      path: ["Shared", rootPrefixCls]
    }), () => [{
      "&": (0, _style$8.genLinkStyle)(token2)
    }]);
    return [(0, _cssinjs$2.useStyleRegister)(Object.assign(Object.assign({}, sharedConfig), {
      path: [component, prefixCls, iconPrefixCls]
    }), () => {
      const {
        token: proxyToken,
        flush
      } = (0, _internal$8.statisticToken)(token2);
      const defaultComponentToken = typeof getDefaultToken === "function" ? getDefaultToken(proxyToken) : getDefaultToken;
      const mergedComponentToken = Object.assign(Object.assign({}, defaultComponentToken), token2[component]);
      const componentCls = `.${prefixCls}`;
      const mergedToken = (0, _internal$8.mergeToken)(proxyToken, {
        componentCls,
        prefixCls,
        iconCls: `.${iconPrefixCls}`,
        antCls: `.${rootPrefixCls}`
      }, mergedComponentToken);
      const styleInterpolation = styleFn(mergedToken, {
        hashId,
        prefixCls,
        rootPrefixCls,
        iconPrefixCls,
        overrideComponentToken: token2[component]
      });
      flush(component, mergedComponentToken);
      return [(0, _style$8.genCommonStyle)(token2, prefixCls), styleInterpolation];
    }), hashId];
  };
}
var statistic$1 = {};
Object.defineProperty(statistic$1, "__esModule", {
  value: true
});
statistic$1._statistic_build_ = void 0;
statistic$1.default = statisticToken;
statistic$1.merge = merge2;
statistic$1.statistic = void 0;
const enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
let recording = true;
function merge2() {
  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
    objs[_key] = arguments[_key];
  }
  if (!enableStatistic) {
    return Object.assign.apply(Object, [{}].concat(objs));
  }
  recording = false;
  const ret = {};
  objs.forEach((obj) => {
    const keys2 = Object.keys(obj);
    keys2.forEach((key) => {
      Object.defineProperty(ret, key, {
        configurable: true,
        enumerable: true,
        get: () => obj[key]
      });
    });
  });
  recording = true;
  return ret;
}
const statistic = {};
statistic$1.statistic = statistic;
const _statistic_build_ = {};
statistic$1._statistic_build_ = _statistic_build_;
function noop() {
}
function statisticToken(token2) {
  let tokenKeys2;
  let proxy = token2;
  let flush = noop;
  if (enableStatistic) {
    tokenKeys2 = /* @__PURE__ */ new Set();
    proxy = new Proxy(token2, {
      get(obj, prop) {
        if (recording) {
          tokenKeys2.add(prop);
        }
        return obj[prop];
      }
    });
    flush = (componentName, componentToken) => {
      statistic[componentName] = {
        global: Array.from(tokenKeys2),
        component: componentToken
      };
    };
  }
  return {
    token: proxy,
    keys: tokenKeys2,
    flush
  };
}
var genPresetColor$1 = {};
Object.defineProperty(genPresetColor$1, "__esModule", {
  value: true
});
genPresetColor$1.default = genPresetColor;
var _interface = _interface$1;
function genPresetColor(token2, genCss) {
  return _interface.PresetColors.reduce((prev2, colorKey) => {
    const lightColor = token2[`${colorKey}1`];
    const lightBorderColor = token2[`${colorKey}3`];
    const darkColor = token2[`${colorKey}6`];
    const textColor = token2[`${colorKey}7`];
    return Object.assign(Object.assign({}, prev2), genCss(colorKey, {
      lightColor,
      lightBorderColor,
      darkColor,
      textColor
    }));
  }, {});
}
(function(exports) {
  var _interopRequireWildcard2 = interopRequireWildcard.exports.default;
  var _interopRequireDefault2 = interopRequireDefault.exports.default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DesignTokenContext = void 0;
  Object.defineProperty(exports, "PresetColors", {
    enumerable: true,
    get: function() {
      return _interface2.PresetColors;
    }
  });
  exports.defaultConfig = void 0;
  Object.defineProperty(exports, "genComponentStyleHook", {
    enumerable: true,
    get: function() {
      return _genComponentStyleHook.default;
    }
  });
  Object.defineProperty(exports, "genPresetColor", {
    enumerable: true,
    get: function() {
      return _genPresetColor.default;
    }
  });
  Object.defineProperty(exports, "mergeToken", {
    enumerable: true,
    get: function() {
      return _statistic.merge;
    }
  });
  Object.defineProperty(exports, "statistic", {
    enumerable: true,
    get: function() {
      return _statistic.statistic;
    }
  });
  Object.defineProperty(exports, "statisticToken", {
    enumerable: true,
    get: function() {
      return _statistic.default;
    }
  });
  Object.defineProperty(exports, "useStyleRegister", {
    enumerable: true,
    get: function() {
      return _cssinjs2.useStyleRegister;
    }
  });
  exports.useToken = useToken2;
  var _cssinjs2 = require$$0;
  var _react2 = _interopRequireDefault2(_global_React);
  var _version2 = _interopRequireDefault2(version$2);
  var _interface2 = _interface$1;
  var _default3 = _interopRequireDefault2(_default$x);
  var _seed2 = _interopRequireDefault2(seed);
  var _alias = _interopRequireDefault2(alias);
  var _genComponentStyleHook = _interopRequireDefault2(genComponentStyleHook$1);
  var _statistic = _interopRequireWildcard2(statistic$1);
  var _genPresetColor = _interopRequireDefault2(genPresetColor$1);
  const defaultTheme2 = (0, _cssinjs2.createTheme)(_default3.default);
  const defaultConfig2 = {
    token: _seed2.default,
    hashed: true
  };
  exports.defaultConfig = defaultConfig2;
  const DesignTokenContext2 = /* @__PURE__ */ _react2.default.createContext(defaultConfig2);
  exports.DesignTokenContext = DesignTokenContext2;
  function useToken2() {
    const {
      token: rootDesignToken,
      hashed,
      theme: theme2,
      components
    } = _react2.default.useContext(DesignTokenContext2);
    const salt = `${_version2.default}-${hashed || ""}`;
    const mergedTheme = theme2 || defaultTheme2;
    const [token2, hashId] = (0, _cssinjs2.useCacheToken)(mergedTheme, [_seed2.default, rootDesignToken], {
      salt,
      override: Object.assign({
        override: rootDesignToken
      }, components),
      formatToken: _alias.default
    });
    return [mergedTheme, token2, hashed ? hashId : ""];
  }
})(internal);
var cssVariables = {};
var canUseDom$3 = {};
Object.defineProperty(canUseDom$3, "__esModule", {
  value: true
});
canUseDom$3.default = canUseDom$2;
function canUseDom$2() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var dynamicCSS$1 = {};
var contains$3 = {};
Object.defineProperty(contains$3, "__esModule", {
  value: true
});
contains$3.default = contains$2;
function contains$2(root2, n2) {
  if (!root2) {
    return false;
  }
  if (root2.contains) {
    return root2.contains(n2);
  }
  var node2 = n2;
  while (node2) {
    if (node2 === root2) {
      return true;
    }
    node2 = node2.parentNode;
  }
  return false;
}
var _interopRequireDefault$u = interopRequireDefault.exports.default;
Object.defineProperty(dynamicCSS$1, "__esModule", {
  value: true
});
dynamicCSS$1.clearContainerCache = clearContainerCache;
dynamicCSS$1.injectCSS = injectCSS$1;
dynamicCSS$1.removeCSS = removeCSS$1;
dynamicCSS$1.updateCSS = updateCSS$1;
var _canUseDom$2 = _interopRequireDefault$u(canUseDom$3);
var _contains$1 = _interopRequireDefault$u(contains$3);
var APPEND_ORDER$1 = "data-rc-order";
var MARK_KEY$1 = "rc-util-key";
var containerCache$1 = /* @__PURE__ */ new Map();
function getMark$1() {
  var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark2 = _ref2.mark;
  if (mark2) {
    return mark2.startsWith("data-") ? mark2 : "data-".concat(mark2);
  }
  return MARK_KEY$1;
}
function getContainer$1(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function getOrder$1(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles$1(container) {
  return Array.from((containerCache$1.get(container) || container).children).filter(function(node2) {
    return node2.tagName === "STYLE";
  });
}
function injectCSS$1(css2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!(0, _canUseDom$2.default)()) {
    return null;
  }
  var csp = option.csp, prepend = option.prepend;
  var styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER$1, getOrder$1(prepend));
  if (csp !== null && csp !== void 0 && csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css2;
  var container = getContainer$1(option);
  var firstChild = container.firstChild;
  if (prepend) {
    if (prepend === "queue") {
      var existStyle = findStyles$1(container).filter(function(node2) {
        return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER$1));
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode$1(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer$1(option);
  return findStyles$1(container).find(function(node2) {
    return node2.getAttribute(getMark$1(option)) === key;
  });
}
function removeCSS$1(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var existNode = findExistNode$1(key, option);
  if (existNode) {
    var container = getContainer$1(option);
    container.removeChild(existNode);
  }
}
function syncRealContainer$1(container, option) {
  var cachedRealContainer = containerCache$1.get(container);
  if (!cachedRealContainer || !(0, _contains$1.default)(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS$1("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache$1.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function clearContainerCache() {
  containerCache$1.clear();
}
function updateCSS$1(css2, key) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer$1(option);
  syncRealContainer$1(container, option);
  var existNode = findExistNode$1(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  var newNode = injectCSS$1(css2, option);
  newNode.setAttribute(getMark$1(option), key);
  return newNode;
}
var _interopRequireDefault$t = interopRequireDefault.exports.default;
Object.defineProperty(cssVariables, "__esModule", {
  value: true
});
cssVariables.getStyle = getStyle;
cssVariables.registerTheme = registerTheme;
var _colors$1 = require$$3$1;
var _tinycolor = require$$2$1;
var _canUseDom$1 = _interopRequireDefault$t(canUseDom$3);
var _dynamicCSS$1 = dynamicCSS$1;
_interopRequireDefault$t(warning$5);
const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
function getStyle(globalPrefixCls2, theme2) {
  const variables = {};
  const formatColor = (color2, updater) => {
    let clone2 = color2.clone();
    clone2 = (updater === null || updater === void 0 ? void 0 : updater(clone2)) || clone2;
    return clone2.toRgbString();
  };
  const fillColor = (colorVal, type4) => {
    const baseColor = new _tinycolor.TinyColor(colorVal);
    const colorPalettes = (0, _colors$1.generate)(baseColor.toRgbString());
    variables[`${type4}-color`] = formatColor(baseColor);
    variables[`${type4}-color-disabled`] = colorPalettes[1];
    variables[`${type4}-color-hover`] = colorPalettes[4];
    variables[`${type4}-color-active`] = colorPalettes[6];
    variables[`${type4}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString();
    variables[`${type4}-color-deprecated-bg`] = colorPalettes[0];
    variables[`${type4}-color-deprecated-border`] = colorPalettes[2];
  };
  if (theme2.primaryColor) {
    fillColor(theme2.primaryColor, "primary");
    const primaryColor = new _tinycolor.TinyColor(theme2.primaryColor);
    const primaryColors = (0, _colors$1.generate)(primaryColor.toRgbString());
    primaryColors.forEach((color2, index2) => {
      variables[`primary-${index2 + 1}`] = color2;
    });
    variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2) => c2.lighten(35));
    variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2) => c2.lighten(20));
    variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2) => c2.tint(20));
    variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2) => c2.tint(50));
    variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.12));
    const primaryActiveColor = new _tinycolor.TinyColor(primaryColors[0]);
    variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.3));
    variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2) => c2.darken(2));
  }
  if (theme2.successColor) {
    fillColor(theme2.successColor, "success");
  }
  if (theme2.warningColor) {
    fillColor(theme2.warningColor, "warning");
  }
  if (theme2.errorColor) {
    fillColor(theme2.errorColor, "error");
  }
  if (theme2.infoColor) {
    fillColor(theme2.infoColor, "info");
  }
  const cssList = Object.keys(variables).map((key) => `--${globalPrefixCls2}-${key}: ${variables[key]};`);
  return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
}
function registerTheme(globalPrefixCls2, theme2) {
  const style2 = getStyle(globalPrefixCls2, theme2);
  if ((0, _canUseDom$1.default)()) {
    (0, _dynamicCSS$1.updateCSS)(style2, `${dynamicStyleMark}-dynamic-theme`);
  }
}
var DisabledContext$1 = {};
var _interopRequireWildcard$h = interopRequireWildcard.exports.default;
Object.defineProperty(DisabledContext$1, "__esModule", {
  value: true
});
DisabledContext$1.default = DisabledContext$1.DisabledContextProvider = void 0;
var React$e = _interopRequireWildcard$h(_global_React);
const DisabledContext = /* @__PURE__ */ React$e.createContext(false);
const DisabledContextProvider = (_ref2) => {
  let {
    children,
    disabled
  } = _ref2;
  const originDisabled = React$e.useContext(DisabledContext);
  return /* @__PURE__ */ React$e.createElement(DisabledContext.Provider, {
    value: disabled !== null && disabled !== void 0 ? disabled : originDisabled
  }, children);
};
DisabledContext$1.DisabledContextProvider = DisabledContextProvider;
var _default$r = DisabledContext;
DisabledContext$1.default = _default$r;
var useConfig$1 = {};
var SizeContext$1 = {};
var _interopRequireWildcard$g = interopRequireWildcard.exports.default;
Object.defineProperty(SizeContext$1, "__esModule", {
  value: true
});
SizeContext$1.default = SizeContext$1.SizeContextProvider = void 0;
var React$d = _interopRequireWildcard$g(_global_React);
const SizeContext = /* @__PURE__ */ React$d.createContext(void 0);
const SizeContextProvider = (_ref2) => {
  let {
    children,
    size
  } = _ref2;
  const originSize = React$d.useContext(SizeContext);
  return /* @__PURE__ */ React$d.createElement(SizeContext.Provider, {
    value: size || originSize
  }, children);
};
SizeContext$1.SizeContextProvider = SizeContextProvider;
var _default$q = SizeContext;
SizeContext$1.default = _default$q;
var _interopRequireDefault$s = interopRequireDefault.exports.default;
Object.defineProperty(useConfig$1, "__esModule", {
  value: true
});
useConfig$1.default = void 0;
var _react$7 = _global_React;
var _DisabledContext$2 = _interopRequireDefault$s(DisabledContext$1);
var _SizeContext$3 = _interopRequireDefault$s(SizeContext$1);
function useConfig() {
  const componentDisabled = (0, _react$7.useContext)(_DisabledContext$2.default);
  const componentSize = (0, _react$7.useContext)(_SizeContext$3.default);
  return {
    componentDisabled,
    componentSize
  };
}
var _default$p = useConfig;
useConfig$1.default = _default$p;
var useTheme$1 = {};
var isEqual$1 = {};
var _interopRequireDefault$r = interopRequireDefault.exports.default;
Object.defineProperty(isEqual$1, "__esModule", {
  value: true
});
isEqual$1.default = void 0;
var _typeof2$3 = _interopRequireDefault$r(require$$1);
var _warning$1 = _interopRequireDefault$r(warning$4);
function isEqual(obj1, obj2) {
  var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var refSet = /* @__PURE__ */ new Set();
  function deepEqual(a, b2) {
    var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    var circular = refSet.has(a);
    (0, _warning$1.default)(!circular, "Warning: There may be circular references");
    if (circular) {
      return false;
    }
    if (a === b2) {
      return true;
    }
    if (shallow && level > 1) {
      return false;
    }
    refSet.add(a);
    var newLevel = level + 1;
    if (Array.isArray(a)) {
      if (!Array.isArray(b2) || a.length !== b2.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!deepEqual(a[i], b2[i], newLevel)) {
          return false;
        }
      }
      return true;
    }
    if (a && b2 && (0, _typeof2$3.default)(a) === "object" && (0, _typeof2$3.default)(b2) === "object") {
      var keys2 = Object.keys(a);
      if (keys2.length !== Object.keys(b2).length) {
        return false;
      }
      return keys2.every(function(key) {
        return deepEqual(a[key], b2[key], newLevel);
      });
    }
    return false;
  }
  return deepEqual(obj1, obj2);
}
var _default$o = isEqual;
isEqual$1.default = _default$o;
var _interopRequireDefault$q = interopRequireDefault.exports.default;
Object.defineProperty(useTheme$1, "__esModule", {
  value: true
});
useTheme$1.default = useTheme;
var _useMemo$1 = _interopRequireDefault$q(useMemo$1);
var _isEqual = _interopRequireDefault$q(isEqual$1);
var _internal$7 = internal;
function useTheme(theme2, parentTheme) {
  const themeConfig = theme2 || {};
  const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? _internal$7.defaultConfig : parentTheme;
  const mergedTheme = (0, _useMemo$1.default)(() => {
    if (!theme2) {
      return parentTheme;
    }
    const mergedComponents = Object.assign({}, parentThemeConfig.components);
    Object.keys(theme2.components || {}).forEach((componentName) => {
      mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme2.components[componentName]);
    });
    return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
      token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
      components: mergedComponents
    });
  }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index2) => {
    const nextTheme = next2[index2];
    return !(0, _isEqual.default)(prevTheme, nextTheme, true);
  }));
  return mergedTheme;
}
var style$5 = {};
Object.defineProperty(style$5, "__esModule", {
  value: true
});
style$5.default = void 0;
var _cssinjs$1 = require$$0;
var _style$7 = style$6;
var _internal$6 = internal;
const useStyle = (iconPrefixCls, csp) => {
  const [theme2, token2] = (0, _internal$6.useToken)();
  return (0, _cssinjs$1.useStyleRegister)({
    theme: theme2,
    token: token2,
    hashId: "",
    path: ["ant-design-icons", iconPrefixCls],
    nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce
  }, () => [{
    [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, (0, _style$7.resetIcon)()), {
      [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
        display: "block"
      }
    })
  }]);
};
var _default$n = useStyle;
style$5.default = _default$n;
(function(exports) {
  var _interopRequireWildcard2 = interopRequireWildcard.exports.default;
  var _interopRequireDefault2 = interopRequireDefault.exports.default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "ConfigConsumer", {
    enumerable: true,
    get: function() {
      return _context22.ConfigConsumer;
    }
  });
  Object.defineProperty(exports, "ConfigContext", {
    enumerable: true,
    get: function() {
      return _context22.ConfigContext;
    }
  });
  exports.default = exports.configConsumerProps = void 0;
  Object.defineProperty(exports, "defaultIconPrefixCls", {
    enumerable: true,
    get: function() {
      return _context22.defaultIconPrefixCls;
    }
  });
  exports.warnContext = exports.globalConfig = exports.defaultPrefixCls = void 0;
  var _cssinjs2 = require$$0;
  var _Context2 = _interopRequireDefault2(Context);
  var _rcFieldForm2 = require$$2$2;
  var _valueUtil = valueUtil;
  var _useMemo2 = _interopRequireDefault2(useMemo$1);
  var React2 = _interopRequireWildcard2(_global_React);
  var _locale = _interopRequireWildcard2(locale$4);
  var _context2 = _interopRequireDefault2(context$2);
  var _en_US5 = _interopRequireDefault2(en_US$5);
  var _internal2 = internal;
  var _seed2 = _interopRequireDefault2(seed);
  _interopRequireDefault2(warning$5);
  var _context22 = context$1;
  var _cssVariables = cssVariables;
  var _DisabledContext2 = DisabledContext$1;
  var _useConfig = _interopRequireDefault2(useConfig$1);
  var _useTheme = _interopRequireDefault2(useTheme$1);
  var _SizeContext2 = _interopRequireWildcard2(SizeContext$1);
  var _style2 = _interopRequireDefault2(style$5);
  var __rest2 = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t2[p2[i]] = s2[p2[i]];
      }
    return t2;
  };
  const warnContext = null;
  exports.warnContext = warnContext;
  const configConsumerProps = ["getTargetContainer", "getPopupContainer", "rootPrefixCls", "getPrefixCls", "renderEmpty", "csp", "autoInsertSpaceInButton", "locale", "pageHeader"];
  exports.configConsumerProps = configConsumerProps;
  const PASSED_PROPS2 = ["getTargetContainer", "getPopupContainer", "renderEmpty", "pageHeader", "input", "pagination", "form", "select"];
  const defaultPrefixCls2 = "ant";
  exports.defaultPrefixCls = defaultPrefixCls2;
  let globalPrefixCls2;
  let globalIconPrefixCls2;
  function getGlobalPrefixCls2() {
    return globalPrefixCls2 || defaultPrefixCls2;
  }
  function getGlobalIconPrefixCls2() {
    return globalIconPrefixCls2 || _context22.defaultIconPrefixCls;
  }
  const setGlobalConfig2 = (_ref2) => {
    let {
      prefixCls,
      iconPrefixCls,
      theme: theme2
    } = _ref2;
    if (prefixCls !== void 0) {
      globalPrefixCls2 = prefixCls;
    }
    if (iconPrefixCls !== void 0) {
      globalIconPrefixCls2 = iconPrefixCls;
    }
    if (theme2) {
      (0, _cssVariables.registerTheme)(getGlobalPrefixCls2(), theme2);
    }
  };
  const globalConfig2 = () => ({
    getPrefixCls: (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls)
        return customizePrefixCls;
      return suffixCls ? `${getGlobalPrefixCls2()}-${suffixCls}` : getGlobalPrefixCls2();
    },
    getIconPrefixCls: getGlobalIconPrefixCls2,
    getRootPrefixCls: () => {
      if (globalPrefixCls2) {
        return globalPrefixCls2;
      }
      return getGlobalPrefixCls2();
    }
  });
  exports.globalConfig = globalConfig2;
  const ProviderChildren2 = (props) => {
    const {
      children,
      csp: customCsp,
      autoInsertSpaceInButton,
      form,
      locale: locale2,
      componentSize,
      direction,
      space: space2,
      virtual,
      dropdownMatchSelectWidth,
      legacyLocale,
      parentContext,
      iconPrefixCls: customIconPrefixCls,
      theme: theme2,
      componentDisabled
    } = props;
    const getPrefixCls = React2.useCallback((suffixCls, customizePrefixCls) => {
      const {
        prefixCls
      } = props;
      if (customizePrefixCls)
        return customizePrefixCls;
      const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
      return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
    }, [parentContext.getPrefixCls, props.prefixCls]);
    const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || _context22.defaultIconPrefixCls;
    const shouldWrapSSR = iconPrefixCls !== parentContext.iconPrefixCls;
    const csp = customCsp || parentContext.csp;
    const wrapSSR = (0, _style2.default)(iconPrefixCls, csp);
    const mergedTheme = (0, _useTheme.default)(theme2, parentContext.theme);
    const baseConfig = {
      csp,
      autoInsertSpaceInButton,
      locale: locale2 || legacyLocale,
      direction,
      space: space2,
      virtual,
      dropdownMatchSelectWidth,
      getPrefixCls,
      iconPrefixCls,
      theme: mergedTheme
    };
    const config = Object.assign({}, parentContext);
    Object.keys(baseConfig).forEach((key) => {
      if (baseConfig[key] !== void 0) {
        config[key] = baseConfig[key];
      }
    });
    PASSED_PROPS2.forEach((propName) => {
      const propValue = props[propName];
      if (propValue) {
        config[propName] = propValue;
      }
    });
    const memoedConfig = (0, _useMemo2.default)(() => config, config, (prevConfig, currentConfig) => {
      const prevKeys = Object.keys(prevConfig);
      const currentKeys = Object.keys(currentConfig);
      return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
    });
    const memoIconContextValue = React2.useMemo(() => ({
      prefixCls: iconPrefixCls,
      csp
    }), [iconPrefixCls, csp]);
    let childNode = shouldWrapSSR ? wrapSSR(children) : children;
    const validateMessages = React2.useMemo(() => {
      var _a2, _b, _c;
      return (0, _valueUtil.setValues)({}, ((_a2 = _en_US5.default.Form) === null || _a2 === void 0 ? void 0 : _a2.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, (form === null || form === void 0 ? void 0 : form.validateMessages) || {});
    }, [memoedConfig, form === null || form === void 0 ? void 0 : form.validateMessages]);
    if (Object.keys(validateMessages).length > 0) {
      childNode = /* @__PURE__ */ React2.createElement(_rcFieldForm2.FormProvider, {
        validateMessages
      }, children);
    }
    if (locale2) {
      childNode = /* @__PURE__ */ React2.createElement(_locale.default, {
        locale: locale2,
        _ANT_MARK__: _locale.ANT_MARK
      }, childNode);
    }
    if (iconPrefixCls || csp) {
      childNode = /* @__PURE__ */ React2.createElement(_Context2.default.Provider, {
        value: memoIconContextValue
      }, childNode);
    }
    if (componentSize) {
      childNode = /* @__PURE__ */ React2.createElement(_SizeContext2.SizeContextProvider, {
        size: componentSize
      }, childNode);
    }
    const memoTheme = React2.useMemo(() => {
      const _a2 = mergedTheme || {}, {
        algorithm,
        token: token2
      } = _a2, rest = __rest2(_a2, ["algorithm", "token"]);
      const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? (0, _cssinjs2.createTheme)(algorithm) : void 0;
      return Object.assign(Object.assign({}, rest), {
        theme: themeObj,
        token: Object.assign(Object.assign({}, _seed2.default), token2)
      });
    }, [mergedTheme]);
    if (theme2) {
      childNode = /* @__PURE__ */ React2.createElement(_internal2.DesignTokenContext.Provider, {
        value: memoTheme
      }, childNode);
    }
    if (componentDisabled !== void 0) {
      childNode = /* @__PURE__ */ React2.createElement(_DisabledContext2.DisabledContextProvider, {
        disabled: componentDisabled
      }, childNode);
    }
    return /* @__PURE__ */ React2.createElement(_context22.ConfigContext.Provider, {
      value: memoedConfig
    }, childNode);
  };
  const ConfigProvider2 = (props) => {
    const context2 = React2.useContext(_context22.ConfigContext);
    const antLocale = React2.useContext(_context2.default);
    return /* @__PURE__ */ React2.createElement(ProviderChildren2, Object.assign({
      parentContext: context2,
      legacyLocale: antLocale
    }, props));
  };
  ConfigProvider2.ConfigContext = _context22.ConfigContext;
  ConfigProvider2.SizeContext = _SizeContext2.default;
  ConfigProvider2.config = setGlobalConfig2;
  ConfigProvider2.useConfig = _useConfig.default;
  Object.defineProperty(ConfigProvider2, "SizeContext", {
    get: () => {
      return _SizeContext2.default;
    }
  });
  var _default3 = ConfigProvider2;
  exports.default = _default3;
})(configProvider);
var reactNode = {};
var _interopRequireWildcard$f = interopRequireWildcard.exports.default;
Object.defineProperty(reactNode, "__esModule", {
  value: true
});
reactNode.cloneElement = cloneElement;
reactNode.isFragment = isFragment;
reactNode.isValidElement = void 0;
reactNode.replaceElement = replaceElement;
var React$c = _interopRequireWildcard$f(_global_React);
const {
  isValidElement
} = React$c;
reactNode.isValidElement = isValidElement;
function isFragment(child) {
  return child && isValidElement(child) && child.type === React$c.Fragment;
}
function replaceElement(element2, replacement, props) {
  if (!isValidElement(element2)) {
    return replacement;
  }
  return /* @__PURE__ */ React$c.cloneElement(element2, typeof props === "function" ? props(element2.props || {}) : props);
}
function cloneElement(element2, props) {
  return replaceElement(element2, element2, props);
}
var style$4 = {};
Object.defineProperty(style$4, "__esModule", {
  value: true
});
style$4.default = void 0;
var _cssinjs = require$$0;
var _internal$5 = internal;
var _style$6 = style$6;
const antSpinMove = new _cssinjs.Keyframes("antSpinMove", {
  to: {
    opacity: 1
  }
});
const antRotate = new _cssinjs.Keyframes("antRotate", {
  to: {
    transform: "rotate(405deg)"
  }
});
const genSpinStyle = (token2) => ({
  [`${token2.componentCls}`]: Object.assign(Object.assign({}, (0, _style$6.resetComponent)(token2)), {
    position: "absolute",
    display: "none",
    color: token2.colorPrimary,
    textAlign: "center",
    verticalAlign: "middle",
    opacity: 0,
    transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
    "&-spinning": {
      position: "static",
      display: "inline-block",
      opacity: 1
    },
    "&-nested-loading": {
      position: "relative",
      [`> div > ${token2.componentCls}`]: {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        zIndex: 4,
        display: "block",
        width: "100%",
        height: "100%",
        maxHeight: token2.contentHeight,
        [`${token2.componentCls}-dot`]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: "50%",
          margin: -token2.spinDotSize / 2
        },
        [`${token2.componentCls}-text`]: {
          position: "absolute",
          top: "50%",
          width: "100%",
          paddingTop: (token2.spinDotSize - token2.fontSize) / 2 + 2,
          textShadow: `0 1px 2px ${token2.colorBgContainer}`
        },
        [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
          marginTop: -(token2.spinDotSize / 2) - 10
        },
        "&-sm": {
          [`${token2.componentCls}-dot`]: {
            margin: -token2.spinDotSizeSM / 2
          },
          [`${token2.componentCls}-text`]: {
            paddingTop: (token2.spinDotSizeSM - token2.fontSize) / 2 + 2
          },
          [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
            marginTop: -(token2.spinDotSizeSM / 2) - 10
          }
        },
        "&-lg": {
          [`${token2.componentCls}-dot`]: {
            margin: -(token2.spinDotSizeLG / 2)
          },
          [`${token2.componentCls}-text`]: {
            paddingTop: (token2.spinDotSizeLG - token2.fontSize) / 2 + 2
          },
          [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
            marginTop: -(token2.spinDotSizeLG / 2) - 10
          }
        }
      },
      [`${token2.componentCls}-container`]: {
        position: "relative",
        transition: `opacity ${token2.motionDurationSlow}`,
        "&::after": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          height: "100%",
          background: token2.colorBgContainer,
          opacity: 0,
          transition: `all ${token2.motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        }
      },
      [`${token2.componentCls}-blur`]: {
        clear: "both",
        opacity: 0.5,
        userSelect: "none",
        pointerEvents: "none",
        [`&::after`]: {
          opacity: 0.4,
          pointerEvents: "auto"
        }
      }
    },
    [`&-tip`]: {
      color: token2.spinDotDefault
    },
    [`${token2.componentCls}-dot`]: {
      position: "relative",
      display: "inline-block",
      fontSize: token2.spinDotSize,
      width: "1em",
      height: "1em",
      "&-item": {
        position: "absolute",
        display: "block",
        width: (token2.spinDotSize - token2.marginXXS / 2) / 2,
        height: (token2.spinDotSize - token2.marginXXS / 2) / 2,
        backgroundColor: token2.colorPrimary,
        borderRadius: "100%",
        transform: "scale(0.75)",
        transformOrigin: "50% 50%",
        opacity: 0.3,
        animationName: antSpinMove,
        animationDuration: "1s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear",
        animationDirection: "alternate",
        "&:nth-child(1)": {
          top: 0,
          insetInlineStart: 0
        },
        "&:nth-child(2)": {
          top: 0,
          insetInlineEnd: 0,
          animationDelay: "0.4s"
        },
        "&:nth-child(3)": {
          insetInlineEnd: 0,
          bottom: 0,
          animationDelay: "0.8s"
        },
        "&:nth-child(4)": {
          bottom: 0,
          insetInlineStart: 0,
          animationDelay: "1.2s"
        }
      },
      "&-spin": {
        transform: "rotate(45deg)",
        animationName: antRotate,
        animationDuration: "1.2s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear"
      }
    },
    [`&-sm ${token2.componentCls}-dot`]: {
      fontSize: token2.spinDotSizeSM,
      i: {
        width: (token2.spinDotSizeSM - token2.marginXXS / 2) / 2,
        height: (token2.spinDotSizeSM - token2.marginXXS / 2) / 2
      }
    },
    [`&-lg ${token2.componentCls}-dot`]: {
      fontSize: token2.spinDotSizeLG,
      i: {
        width: (token2.spinDotSizeLG - token2.marginXXS) / 2,
        height: (token2.spinDotSizeLG - token2.marginXXS) / 2
      }
    },
    [`&${token2.componentCls}-show-text ${token2.componentCls}-text`]: {
      display: "block"
    }
  })
});
var _default$m = (0, _internal$5.genComponentStyleHook)("Spin", (token2) => {
  const spinToken = (0, _internal$5.mergeToken)(token2, {
    spinDotDefault: token2.colorTextDescription,
    spinDotSize: token2.controlHeightLG / 2,
    spinDotSizeSM: token2.controlHeightLG * 0.35,
    spinDotSizeLG: token2.controlHeight
  });
  return [genSpinStyle(spinToken)];
}, {
  contentHeight: 400
});
style$4.default = _default$m;
var _interopRequireWildcard$e = interopRequireWildcard.exports.default;
var _interopRequireDefault$p = interopRequireDefault.exports.default;
Object.defineProperty(spin, "__esModule", {
  value: true
});
var default_1$1 = spin.default = void 0;
var _classnames$9 = _interopRequireDefault$p(classnames.exports);
var _throttleDebounce = cjs;
var _omit$2 = _interopRequireDefault$p(omit$1);
var React$b = _interopRequireWildcard$e(_global_React);
var _configProvider$6 = configProvider;
var _reactNode$3 = reactNode;
var _index = _interopRequireDefault$p(style$4);
var __rest$5 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
let defaultIndicator = null;
function renderIndicator(prefixCls, props) {
  const {
    indicator
  } = props;
  const dotClassName = `${prefixCls}-dot`;
  if (indicator === null) {
    return null;
  }
  if ((0, _reactNode$3.isValidElement)(indicator)) {
    return (0, _reactNode$3.cloneElement)(indicator, {
      className: (0, _classnames$9.default)(indicator.props.className, dotClassName)
    });
  }
  if ((0, _reactNode$3.isValidElement)(defaultIndicator)) {
    return (0, _reactNode$3.cloneElement)(defaultIndicator, {
      className: (0, _classnames$9.default)(defaultIndicator.props.className, dotClassName)
    });
  }
  return /* @__PURE__ */ React$b.createElement("span", {
    className: (0, _classnames$9.default)(dotClassName, `${prefixCls}-dot-spin`)
  }, /* @__PURE__ */ React$b.createElement("i", {
    className: `${prefixCls}-dot-item`
  }), /* @__PURE__ */ React$b.createElement("i", {
    className: `${prefixCls}-dot-item`
  }), /* @__PURE__ */ React$b.createElement("i", {
    className: `${prefixCls}-dot-item`
  }), /* @__PURE__ */ React$b.createElement("i", {
    className: `${prefixCls}-dot-item`
  }));
}
function shouldDelay(spinning, delay) {
  return !!spinning && !!delay && !isNaN(Number(delay));
}
const Spin = (props) => {
  const {
    spinPrefixCls: prefixCls,
    spinning: customSpinning = true,
    delay = 0,
    className,
    rootClassName,
    size = "default",
    tip,
    wrapperClassName,
    style: style2,
    children,
    hashId
  } = props, restProps = __rest$5(props, ["spinPrefixCls", "spinning", "delay", "className", "rootClassName", "size", "tip", "wrapperClassName", "style", "children", "hashId"]);
  const [spinning, setSpinning] = React$b.useState(() => customSpinning && !shouldDelay(customSpinning, delay));
  React$b.useEffect(() => {
    if (customSpinning) {
      const showSpinning = (0, _throttleDebounce.debounce)(delay, () => {
        setSpinning(true);
      });
      showSpinning();
      return () => {
        var _a2;
        (_a2 = showSpinning === null || showSpinning === void 0 ? void 0 : showSpinning.cancel) === null || _a2 === void 0 ? void 0 : _a2.call(showSpinning);
      };
    }
    setSpinning(false);
  }, [delay, customSpinning]);
  const isNestedPattern = React$b.useMemo(() => typeof children !== "undefined", [children]);
  const {
    direction
  } = React$b.useContext(_configProvider$6.ConfigContext);
  const spinClassName = (0, _classnames$9.default)(prefixCls, {
    [`${prefixCls}-sm`]: size === "small",
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-spinning`]: spinning,
    [`${prefixCls}-show-text`]: !!tip,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId);
  const containerClassName = (0, _classnames$9.default)(`${prefixCls}-container`, {
    [`${prefixCls}-blur`]: spinning
  });
  const divProps = (0, _omit$2.default)(restProps, ["indicator", "prefixCls"]);
  const spinElement = /* @__PURE__ */ React$b.createElement("div", Object.assign({}, divProps, {
    style: style2,
    className: spinClassName,
    "aria-live": "polite",
    "aria-busy": spinning
  }), renderIndicator(prefixCls, props), tip ? /* @__PURE__ */ React$b.createElement("div", {
    className: `${prefixCls}-text`
  }, tip) : null);
  if (isNestedPattern) {
    return /* @__PURE__ */ React$b.createElement("div", Object.assign({}, divProps, {
      className: (0, _classnames$9.default)(`${prefixCls}-nested-loading`, wrapperClassName, hashId)
    }), spinning && /* @__PURE__ */ React$b.createElement("div", {
      key: "loading"
    }, spinElement), /* @__PURE__ */ React$b.createElement("div", {
      className: containerClassName,
      key: "container"
    }, children));
  }
  return spinElement;
};
const SpinFC = (props) => {
  const {
    prefixCls: customizePrefixCls
  } = props;
  const {
    getPrefixCls
  } = React$b.useContext(_configProvider$6.ConfigContext);
  const spinPrefixCls = getPrefixCls("spin", customizePrefixCls);
  const [wrapSSR, hashId] = (0, _index.default)(spinPrefixCls);
  const spinClassProps = Object.assign(Object.assign({}, props), {
    spinPrefixCls,
    hashId
  });
  return wrapSSR(/* @__PURE__ */ React$b.createElement(Spin, Object.assign({}, spinClassProps)));
};
SpinFC.setDefaultIndicator = (indicator) => {
  defaultIndicator = indicator;
};
var _default$l = SpinFC;
default_1$1 = spin.default = _default$l;
const SizeValues = {
  sm: 24,
  md: 35,
  lg: 50
};
const LoadingIcon$2 = ({ size = "sm" }) => /* @__PURE__ */ React.createElement(Icon$4, {
  icon: "loading",
  style: { fontSize: SizeValues[size] },
  spin: true
});
const Loading = ({ className, height, width, size }) => /* @__PURE__ */ React.createElement("div", {
  className,
  style: {
    height: height + "px",
    width: width + "px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    background: "transparent"
  }
}, /* @__PURE__ */ React.createElement(default_1$1, {
  indicator: /* @__PURE__ */ React.createElement(LoadingIcon$2, {
    size
  })
}));
const { TabPane } = Tabs;
const PluginDetailPage = ({
  plugin,
  isLoggedIn,
  handleClickLike,
  onExtPluginInstall,
  onToggleModal,
  onBack
}) => {
  const t2 = useT();
  const {
    id,
    name: pluginName,
    version: version2,
    publisher,
    like,
    liked,
    description,
    readme,
    images,
    downloads,
    hasUpdate,
    updatedAt: updatedDate,
    installed
  } = plugin != null ? plugin : {};
  const date4 = React.useMemo(() => {
    if (!updatedDate)
      return void 0;
    const d2 = new Date(updatedDate);
    if (isNaN(d2.getTime()))
      return void 0;
    return d2;
  }, [updatedDate]);
  const config = getConfig();
  return /* @__PURE__ */ React.createElement(Wrapper$3, null, /* @__PURE__ */ React.createElement(InnerWrapper, null, /* @__PURE__ */ React.createElement(Breadcrumb$1, {
    style: { marginBottom: "20px" }
  }, /* @__PURE__ */ React.createElement(Breadcrumb$1.Item, null, /* @__PURE__ */ React.createElement(StyledLink, {
    style: { cursor: "pointer" },
    onClick: (e2) => {
      e2.preventDefault();
      onBack == null ? void 0 : onBack();
    }
  }, t2("Top"))), /* @__PURE__ */ React.createElement(Breadcrumb$1.Item, null, pluginName)), plugin ? /* @__PURE__ */ React.createElement(Row$1, {
    wrap: false
  }, /* @__PURE__ */ React.createElement(Col$1, {
    flex: 3,
    style: { maxWidth: "736px" }
  }, /* @__PURE__ */ React.createElement(Carousel$1, {
    autoplay: true
  }, images && images.length > 0 ? images == null ? void 0 : images.map((image2, idx) => /* @__PURE__ */ React.createElement(Image$1, {
    key: id + "-" + idx,
    src: image2,
    fallback: NoPluginCover,
    wrapperStyle: {
      height: "414px",
      display: "flex",
      alignItems: "center"
    },
    preview: false
  })) : /* @__PURE__ */ React.createElement(Image$1, {
    key: id,
    width: "100%",
    height: "auto",
    style: { minHeight: "200px" },
    src: NoPluginCover,
    fallback: "data:image/png;base64,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",
    preview: false
  })), /* @__PURE__ */ React.createElement(PluginDocs, null, /* @__PURE__ */ React.createElement(Tabs, {
    defaultActiveKey: "1"
  }, /* @__PURE__ */ React.createElement(TabPane, {
    tab: t2("README"),
    key: "1"
  }, /* @__PURE__ */ React.createElement(Markdown, null, readme))))), /* @__PURE__ */ React.createElement(Col$1, {
    flex: 2,
    style: {
      padding: "0 24px",
      maxWidth: "400px"
    }
  }, /* @__PURE__ */ React.createElement(Title$1, null, pluginName), /* @__PURE__ */ React.createElement(LikesDownloaded, {
    justify: "end"
  }, /* @__PURE__ */ React.createElement(Space$1, null, /* @__PURE__ */ React.createElement(Col$1, null, /* @__PURE__ */ React.createElement(StyledIcon$1, {
    icon: "heartOutlined"
  }), like), /* @__PURE__ */ React.createElement(Col$1, null, /* @__PURE__ */ React.createElement(StyledIcon$1, {
    icon: "arrowDown"
  }), downloads))), /* @__PURE__ */ React.createElement(Divider$1, {
    style: { margin: "24px 0" }
  }), /* @__PURE__ */ React.createElement(ActionButtons, {
    justify: "space-between",
    wrap: false
  }, /* @__PURE__ */ React.createElement(Col$1, {
    flex: "none",
    style: { marginRight: "12px" }
  }, /* @__PURE__ */ React.createElement(Button$2, {
    type: "primary",
    size: "large",
    ghost: true,
    disabled: !isLoggedIn,
    onClick: () => handleClickLike(!!liked)
  }, liked ? /* @__PURE__ */ React.createElement(Icon$4, {
    icon: "heartFilled",
    style: { color: "#B02838" }
  }) : /* @__PURE__ */ React.createElement(Icon$4, {
    icon: "heartOutlined"
  }))), /* @__PURE__ */ React.createElement(Col$1, {
    flex: "auto"
  }, /* @__PURE__ */ React.createElement(InstallButton, {
    type: "primary",
    size: "large",
    block: true,
    onClick: () => onExtPluginInstall ? onExtPluginInstall(`${id}~${version2}`) : onToggleModal == null ? void 0 : onToggleModal(true),
    disabled: !isLoggedIn || installed && !hasUpdate
  }, /* @__PURE__ */ React.createElement(Icon$4, {
    icon: "download"
  }), hasUpdate ? t2("Update Plugin") : installed ? t2("Already installed") : onExtPluginInstall ? t2("Install") : t2("Open Plugin in your project")))), /* @__PURE__ */ React.createElement(Description, null, /* @__PURE__ */ React.createElement(Col$1, {
    style: { paddingBottom: "8px" }
  }, t2("Description")), /* @__PURE__ */ React.createElement(Col$1, null, description)), /* @__PURE__ */ React.createElement(PluginInfo, {
    align: "middle",
    justify: "space-between"
  }, /* @__PURE__ */ React.createElement(Col$1, null, t2("Developer")), /* @__PURE__ */ React.createElement(Col$1, null, publisher)), /* @__PURE__ */ React.createElement(PluginInfo, {
    align: "middle",
    justify: "space-between"
  }, /* @__PURE__ */ React.createElement(Col$1, null, t2("Version")), /* @__PURE__ */ React.createElement(Col$1, null, "v", version2)), /* @__PURE__ */ React.createElement(PluginInfo, {
    align: "middle",
    justify: "space-between"
  }, /* @__PURE__ */ React.createElement(Col$1, null, t2("Updated Date")), /* @__PURE__ */ React.createElement(Col$1, null, date4 ? `${date4.getFullYear()}/${date4.getMonth() + 1}/${date4.getDate()}` : "")), /* @__PURE__ */ React.createElement(ReportButton, {
    type: "link",
    size: "middle",
    danger: true,
    href: config == null ? void 0 : config.reportUrl,
    target: "_blank"
  }, /* @__PURE__ */ React.createElement(Row$1, {
    align: "bottom",
    justify: "space-between",
    wrap: false
  }, /* @__PURE__ */ React.createElement(Col$1, null, t2("Report this plugin")), /* @__PURE__ */ React.createElement(Col$1, {
    span: 4
  }, /* @__PURE__ */ React.createElement(Icon$4, {
    icon: "exclamation"
  })))))) : /* @__PURE__ */ React.createElement(Loading, {
    height: 400,
    size: "lg"
  })));
};
const Wrapper$3 = styled.div`
  background: ${({ theme: theme2 }) => theme2.main.background};
  &&,
  h1 {
    color: ${({ theme: theme2 }) => theme2.main.text};
  }
`;
const InnerWrapper = styled.div`
  max-width: 1200px;
  margin: 0 auto;
  padding-top: 24px;
  padding-bottom: 48px;
  min-height: 400px;
  width: 100%;
  background: transparent;

  .ant-breadcrumb-separator,
  .ant-breadcrumb-link,
  .ant-breadcrumb li a {
    color: ${({ theme: theme2 }) => theme2.main.text};
    user-select: none;
  }
  .ant-breadcrumb li a {
    :hover {
      color: ${({ theme: theme2 }) => theme2.main.weakText};
    }
  }
`;
const StyledLink = styled.a`
  text-decoration: none;
`;
const PluginDocs = styled.div`
  * {
    color: ${({ theme: theme2 }) => theme2.main.text};
  }
`;
const Title$1 = styled.h1`
  font-size: 28px;
  font-weight: bold;
`;
const LikesDownloaded = styled(Row$1)`
  color: ${({ theme: theme2 }) => theme2.main.weakText};
`;
const ActionButtons = styled(Row$1)``;
const InstallButton = styled(Button$2)`
  .ant-btn-block {
    background: transparent;
  }
`;
const ReportButton = styled(Button$2)`
  padding: 0;
  margintop: 12;
`;
const Description = styled.div`
  margin: 24px 0;
  font-size: 16px;
`;
const PluginInfo = styled(Row$1)`
  margin-top: 12px;
  font-size: 16px;
`;
const StyledIcon$1 = styled(Icon$4)`
  margin-right: 2px;
`;
const { Option: Option2 } = Select$1;
const ModalContent = ({
  visible,
  workspaces,
  onCancel,
  onOpenPluginInReearth
}) => {
  var _a2;
  const t2 = useT();
  const [workspaceId, selectWorkspace] = React.useState("");
  const [projectId, selectProject] = React.useState("");
  const workspaceOptions = workspaces == null ? void 0 : workspaces.map((ws) => /* @__PURE__ */ React.createElement(Option2, {
    key: ws.id,
    value: ws.id
  }, ws.name));
  const handleCancel = React.useCallback(() => {
    selectWorkspace("");
    selectProject("");
    onCancel();
  }, [onCancel]);
  return /* @__PURE__ */ React.createElement(Modal$1, {
    title: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Row$1, {
      justify: "center",
      style: { margin: "24px 0" }
    }, t2("Choose one project to open this plugin")), /* @__PURE__ */ React.createElement(Row$1, {
      gutter: 20,
      align: "middle"
    }, /* @__PURE__ */ React.createElement(Col$1, null, t2("Workspace"), ":"), /* @__PURE__ */ React.createElement(Col$1, null, /* @__PURE__ */ React.createElement(Select$1, {
      loading: !workspaceOptions,
      value: workspaceId,
      style: { width: 250 },
      onChange: selectWorkspace
    }, workspaceOptions)))),
    width: "756px",
    open: visible,
    onCancel: handleCancel,
    okText: t2("Choose"),
    cancelText: t2("Cancel"),
    okButtonProps: { disabled: !workspaceId || !projectId },
    bodyStyle: { padding: "20px 32px", maxHeight: "582px", overflow: "scroll" },
    onOk: () => onOpenPluginInReearth == null ? void 0 : onOpenPluginInReearth(workspaceId, projectId)
  }, (workspaces == null ? void 0 : workspaces.length) ? workspaceId && /* @__PURE__ */ React.createElement(List2, {
    dataSource: workspaceId ? (_a2 = workspaces.find((ws) => ws.id === workspaceId)) == null ? void 0 : _a2.projects.map((prj) => {
      return {
        id: prj.id,
        name: prj.name
      };
    }) : [],
    renderItem: (prj) => /* @__PURE__ */ React.createElement(ListItem, {
      selected: prj.id === projectId,
      onClick: () => selectProject == null ? void 0 : selectProject(prj.id)
    }, prj.name)
  }) : /* @__PURE__ */ React.createElement(Loading, {
    height: 100
  }));
};
const ListItem = styled(List2.Item)`
  margin: 0 12px 10px 12px;
  cursor: pointer;
  background: ${({ selected }) => selected ? "#1677ff" : "#F0F0F0"};
  ${({ selected }) => selected && "color: white;"}
  box-shadow: 0px 2px 8px rgba(0, 0, 0, 0.15);
  padding: 12px 20px;

  :hover {
    background: #1677ff;
    color: white;
  }
`;
var useHooks$1 = (pluginId, installedPlugins) => {
  var _a2;
  const config = getConfig();
  const auth = useAuth();
  const { data: data2, refetch } = usePluginQuery({
    variables: {
      id: pluginId
    }
  });
  const currentPlugin = ((_a2 = data2 == null ? void 0 : data2.node) == null ? void 0 : _a2.__typename) === "Plugin" && data2.node;
  const [likePlugin] = useLikePluginMutation({ variables: { id: pluginId } });
  const [unlikePlugin] = useUnlikePluginMutation({
    variables: { id: pluginId }
  });
  const onLike = React.useCallback(
    async (id) => {
      await likePlugin({
        variables: {
          id
        }
      });
      await refetch();
    },
    [likePlugin, refetch]
  );
  const onUnlike = React.useCallback(
    async (id) => {
      await unlikePlugin({
        variables: {
          id
        }
      });
      await refetch();
    },
    [unlikePlugin, refetch]
  );
  const plugin = React.useMemo(() => {
    var _a3, _b, _c;
    if (!currentPlugin)
      return void 0;
    const installedPlugin = installedPlugins == null ? void 0 : installedPlugins.find((ip) => ip.id === currentPlugin.id);
    return currentPlugin ? {
      id: currentPlugin.id,
      name: currentPlugin.name,
      cover: currentPlugin.images[0],
      publisher: currentPlugin.publisher.displayName || currentPlugin.publisher.name,
      like: currentPlugin.like,
      images: currentPlugin.images,
      description: currentPlugin.description || "",
      readme: currentPlugin.readme,
      liked: currentPlugin.liked,
      version: (_a3 = currentPlugin.latestVersion) == null ? void 0 : _a3.version,
      downloads: currentPlugin.downloads,
      updatedAt: currentPlugin.updatedAt,
      hasUpdate: !!(((_b = currentPlugin.latestVersion) == null ? void 0 : _b.version) && (installedPlugin == null ? void 0 : installedPlugin.version) && ((_c = currentPlugin.latestVersion) == null ? void 0 : _c.version) > (installedPlugin == null ? void 0 : installedPlugin.version)),
      installed: installedPlugins && installedPlugins.findIndex(
        (p2) => {
          var _a4;
          return p2.id === currentPlugin.id && p2.version === ((_a4 = currentPlugin.latestVersion) == null ? void 0 : _a4.version);
        }
      ) >= 0
    } : void 0;
  }, [currentPlugin, installedPlugins]);
  const [modalVisible, onToggleModal] = React.useState(false);
  const [workspaces, setWorkspaces] = React.useState([]);
  React.useEffect(() => {
    const config2 = getConfig();
    if (!modalVisible || !config2)
      return;
    const base2 = config2.reearthApi;
    (async () => {
      const token2 = await auth.getAccessToken();
      const data22 = await fetch(base2 + "/graphql", {
        method: "POST",
        body: JSON.stringify({
          query: `query { me { teams { id, name, projects(first:100) { nodes { id, name } } } } }`
        }),
        headers: {
          Authorization: `Bearer ${token2}`,
          "Content-Type": "application/json"
        }
      }).then((r2) => r2.json());
      if (!data22.data)
        return;
      const ws = data22.data.me.teams.map((t2) => ({
        ...t2,
        projects: t2.projects.nodes
      }));
      setWorkspaces(ws);
    })();
  }, [auth, modalVisible]);
  const handleOpenPluginInReearth = React.useCallback(
    (_workspaceId, projectId) => {
      var _a3;
      location.href = ((_a3 = config == null ? void 0 : config.reearthWeb) != null ? _a3 : "") + `/settings/projects/${projectId}/plugins?pluginId=${pluginId}`;
    },
    [config == null ? void 0 : config.reearthWeb, pluginId]
  );
  return {
    plugin,
    workspaces,
    modalVisible,
    onLike,
    onUnlike,
    onToggleModal,
    handleOpenPluginInReearth
  };
};
const PluginDetail = ({
  pluginId,
  accessToken,
  installedPlugins,
  onPluginInstall: onExtPluginInstall,
  onBack
}) => {
  const { isAuthenticated } = useAuth(accessToken);
  const {
    plugin,
    workspaces,
    modalVisible,
    onLike,
    onUnlike,
    onToggleModal,
    handleOpenPluginInReearth
  } = useHooks$1(pluginId ? pluginId : "", installedPlugins);
  const handleClickLike = React.useCallback(
    (isLiked) => {
      if (!pluginId)
        return;
      isLiked ? onUnlike(pluginId) : onLike(pluginId);
    },
    [onLike, onUnlike, pluginId]
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(PluginDetailPage, {
    isLoggedIn: isAuthenticated,
    plugin,
    handleClickLike,
    onExtPluginInstall,
    onToggleModal,
    onBack
  }), /* @__PURE__ */ React.createElement(ModalContent, {
    visible: modalVisible != null ? modalVisible : false,
    workspaces,
    onCancel: () => onToggleModal == null ? void 0 : onToggleModal(false),
    onOpenPluginInReearth: handleOpenPluginInReearth
  }));
};
var HeaderBanner = "data:image/png;base64,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";
const TitleBar = () => {
  const t2 = useT();
  return /* @__PURE__ */ React.createElement(Wrapper$2, null, /* @__PURE__ */ React.createElement(Contents, null, /* @__PURE__ */ React.createElement(Title, null, t2("Re:Earth Marketplace")), /* @__PURE__ */ React.createElement(Desc, null, t2("Make Re:Earth the way you want it"))));
};
const Wrapper$2 = styled.section`
  width: 100%;
  height: 159px;
  background: url(${HeaderBanner}) center center;
  background-size: cover;
  background-repeat: no-repeat;
  color: #fff;
  margin-bottom: 48px;
`;
const Contents = styled.div`
  max-width: 1200px;
  margin: 0 auto;
`;
const Title = styled.h1`
  padding: 48px 0 10px;
  color: #fff;
`;
const Desc = styled.p``;
const { Meta } = Card$1;
const PluginsListCard = ({
  name,
  publisher,
  cover,
  likedCount,
  personallyLiked,
  downloadCount,
  loading,
  onClick
}) => {
  const t2 = useT();
  return /* @__PURE__ */ React.createElement(StyledCard, {
    loading,
    cover: /* @__PURE__ */ React.createElement(StyledImage, {
      alt: t2("alt-plugin-cover-image"),
      src: cover ? cover : NoPluginCover,
      style: { borderRadius: "4px" },
      preview: false,
      fallback: "data:image/png;base64,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"
    }),
    size: "small",
    bordered: false,
    onClick,
    bodyStyle: { padding: "0" }
  }, /* @__PURE__ */ React.createElement(Row$1, {
    justify: "space-between",
    align: "top"
  }, /* @__PURE__ */ React.createElement(AuthorName, null, publisher), /* @__PURE__ */ React.createElement(Space$1, {
    size: "small"
  }, /* @__PURE__ */ React.createElement(LikedRow, {
    align: "middle",
    personallyLiked
  }, /* @__PURE__ */ React.createElement(StyledIcon, {
    icon: "heartOutlined"
  }), /* @__PURE__ */ React.createElement("span", null, likedCount)), /* @__PURE__ */ React.createElement(Row$1, {
    align: "middle"
  }, /* @__PURE__ */ React.createElement(StyledIcon, {
    icon: "arrowDown"
  }), /* @__PURE__ */ React.createElement(LikedNum, null, downloadCount)))), /* @__PURE__ */ React.createElement(StyledMeta, {
    title: name
  }));
};
const StyledCard = styled(Card$1)`
  background: ${({ theme: theme2 }) => theme2.main.background};
  color: ${({ theme: theme2 }) => theme2.main.text};
  width: 260px;
  padding: 6px;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.3s;

  :hover {
    box-shadow: 0px 3px 8px ${({ theme: theme2 }) => theme2.main.shadow};
  }
`;
const StyledImage = styled(Image$1)`
  height: 170px;
  object-fit: cover;
  max-height: 170px;
`;
const AuthorName = styled.p`
  color: ${({ theme: theme2 }) => theme2.main.text};
`;
const LikedNum = styled.span`
  color: ${({ theme: theme2 }) => theme2.main.text};
`;
const LikedRow = styled(Row$1, { shouldForwardProp: (propName) => propName !== "personallyLiked" })`
  color: ${({ theme: theme2, personallyLiked }) => personallyLiked ? "#B02838" : theme2.main.text};
`;
const StyledMeta = styled(Meta)`
  * {
    color: ${({ theme: theme2 }) => theme2.main.text};
  }
`;
const StyledIcon = styled(Icon$4)`
  margin-right: 2px;
`;
const PluginsList = ({ plugins: plugins2, loading, onPluginSelect }) => {
  return /* @__PURE__ */ React.createElement(Space$1, {
    size: [30, 18],
    wrap: true
  }, plugins2 ? plugins2.map((plugin) => {
    return /* @__PURE__ */ React.createElement(PluginsListCard, {
      key: plugin.id,
      name: plugin.name,
      publisher: plugin.publisher,
      cover: plugin.cover,
      likedCount: plugin.like,
      personallyLiked: plugin.liked,
      downloadCount: plugin.downloads,
      loading,
      onClick: () => onPluginSelect == null ? void 0 : onPluginSelect(plugin.id)
    });
  }) : null);
};
var Search$2 = {};
var SearchOutlined$4 = { exports: {} };
var SearchOutlined$3 = {};
var SearchOutlined$2 = {};
Object.defineProperty(SearchOutlined$2, "__esModule", { value: true });
var SearchOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
SearchOutlined$2.default = SearchOutlined$1;
var AntdIcon = {};
var require$$3 = /* @__PURE__ */ getAugmentedNamespace(slicedToArray);
var require$$4$1 = /* @__PURE__ */ getAugmentedNamespace(defineProperty$2);
var require$$5 = /* @__PURE__ */ getAugmentedNamespace(objectWithoutProperties);
var IconBase$1 = {};
var utils$1 = {};
var warning$2 = {};
Object.defineProperty(warning$2, "__esModule", {
  value: true
});
warning$2.call = call;
warning$2.default = void 0;
warning$2.note = note;
warning$2.noteOnce = noteOnce;
warning$2.resetWarned = resetWarned;
warning$2.warning = warning$1;
warning$2.warningOnce = warningOnce;
var warned = {};
function warning$1(valid2, message) {
}
function note(valid2, message) {
}
function resetWarned() {
  warned = {};
}
function call(method4, valid2, message) {
  if (!valid2 && !warned[message]) {
    method4(false, message);
    warned[message] = true;
  }
}
function warningOnce(valid2, message) {
  call(warning$1, valid2, message);
}
function noteOnce(valid2, message) {
  call(note, valid2, message);
}
var _default$k = warningOnce;
warning$2.default = _default$k;
var dynamicCSS = {};
var canUseDom$1 = {};
Object.defineProperty(canUseDom$1, "__esModule", {
  value: true
});
canUseDom$1.default = canUseDom;
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var contains$1 = {};
Object.defineProperty(contains$1, "__esModule", {
  value: true
});
contains$1.default = contains;
function contains(root2, n2) {
  if (!root2) {
    return false;
  }
  if (root2.contains) {
    return root2.contains(n2);
  }
  var node2 = n2;
  while (node2) {
    if (node2 === root2) {
      return true;
    }
    node2 = node2.parentNode;
  }
  return false;
}
var _interopRequireDefault$o = interopRequireDefault.exports.default;
Object.defineProperty(dynamicCSS, "__esModule", {
  value: true
});
dynamicCSS.injectCSS = injectCSS;
dynamicCSS.removeCSS = removeCSS;
dynamicCSS.updateCSS = updateCSS;
var _canUseDom = _interopRequireDefault$o(canUseDom$1);
var _contains = _interopRequireDefault$o(contains$1);
var APPEND_ORDER = "data-rc-order";
var MARK_KEY = "rc-util-key";
var containerCache = /* @__PURE__ */ new Map();
function getMark() {
  var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark2 = _ref2.mark;
  if (mark2) {
    return mark2.startsWith("data-") ? mark2 : "data-".concat(mark2);
  }
  return MARK_KEY;
}
function getContainer(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function getOrder(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles(container) {
  return Array.from((containerCache.get(container) || container).children).filter(function(node2) {
    return node2.tagName === "STYLE";
  });
}
function injectCSS(css2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!(0, _canUseDom.default)()) {
    return null;
  }
  var csp = option.csp, prepend = option.prepend;
  var styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
  if (csp === null || csp === void 0 ? void 0 : csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css2;
  var container = getContainer(option);
  var firstChild = container.firstChild;
  if (prepend) {
    if (prepend === "queue") {
      var existStyle = findStyles(container).filter(function(node2) {
        return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER));
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer(option);
  return findStyles(container).find(function(node2) {
    return node2.getAttribute(getMark(option)) === key;
  });
}
function removeCSS(key) {
  var _existNode$parentNode;
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var existNode = findExistNode(key, option);
  existNode === null || existNode === void 0 ? void 0 : (_existNode$parentNode = existNode.parentNode) === null || _existNode$parentNode === void 0 ? void 0 : _existNode$parentNode.removeChild(existNode);
}
function syncRealContainer(container, option) {
  var cachedRealContainer = containerCache.get(container);
  if (!cachedRealContainer || !(0, _contains.default)(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache.set(container, parentNode);
    parentNode.removeChild(placeholderStyle);
  }
}
function updateCSS(css2, key) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer(option);
  syncRealContainer(container, option);
  var existNode = findExistNode(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if (((_option$csp = option.csp) === null || _option$csp === void 0 ? void 0 : _option$csp.nonce) && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  var newNode = injectCSS(css2, option);
  newNode.setAttribute(getMark(option), key);
  return newNode;
}
var _interopRequireDefault$n = interopRequireDefault.exports;
var _typeof3 = require$$1;
Object.defineProperty(utils$1, "__esModule", {
  value: true
});
utils$1.generate = generate;
utils$1.getSecondaryColor = getSecondaryColor;
utils$1.iconStyles = void 0;
utils$1.isIconDefinition = isIconDefinition;
utils$1.normalizeAttrs = normalizeAttrs;
utils$1.normalizeTwoToneColors = normalizeTwoToneColors;
utils$1.useInsertStyles = utils$1.svgBaseProps = void 0;
utils$1.warning = warning2;
var _objectSpread2$6 = _interopRequireDefault$n(objectSpread2.exports);
var _typeof2$2 = _interopRequireDefault$n(require$$1);
var _colors = require$$3$1;
var _react$6 = _interopRequireWildcard$d(_global_React);
var _warning = _interopRequireDefault$n(warning$2);
var _dynamicCSS = dynamicCSS;
var _Context$1 = _interopRequireDefault$n(Context);
function _getRequireWildcardCache$4(nodeInterop) {
  if (typeof WeakMap !== "function")
    return null;
  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache$4 = function _getRequireWildcardCache2(nodeInterop2) {
    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard$d(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") {
    return { default: obj };
  }
  var cache2 = _getRequireWildcardCache$4(nodeInterop);
  if (cache2 && cache2.has(obj)) {
    return cache2.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache2) {
    cache2.set(obj, newObj);
  }
  return newObj;
}
function warning2(valid2, message) {
  (0, _warning.default)(valid2, "[@ant-design/icons] ".concat(message));
}
function isIconDefinition(target) {
  return (0, _typeof2$2.default)(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && ((0, _typeof2$2.default)(target.icon) === "object" || typeof target.icon === "function");
}
function normalizeAttrs() {
  var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(attrs).reduce(function(acc, key) {
    var val = attrs[key];
    switch (key) {
      case "class":
        acc.className = val;
        delete acc.class;
        break;
      default:
        acc[key] = val;
    }
    return acc;
  }, {});
}
function generate(node2, key, rootProps) {
  if (!rootProps) {
    return /* @__PURE__ */ _react$6.default.createElement(node2.tag, (0, _objectSpread2$6.default)({
      key
    }, normalizeAttrs(node2.attrs)), (node2.children || []).map(function(child, index2) {
      return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
    }));
  }
  return /* @__PURE__ */ _react$6.default.createElement(node2.tag, (0, _objectSpread2$6.default)((0, _objectSpread2$6.default)({
    key
  }, normalizeAttrs(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
    return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
  }));
}
function getSecondaryColor(primaryColor) {
  return (0, _colors.generate)(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }
  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var svgBaseProps = {
  width: "1em",
  height: "1em",
  fill: "currentColor",
  "aria-hidden": "true",
  focusable: "false"
};
utils$1.svgBaseProps = svgBaseProps;
var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
utils$1.iconStyles = iconStyles;
var useInsertStyles3 = function useInsertStyles4() {
  var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles;
  var _useContext = (0, _react$6.useContext)(_Context$1.default), csp = _useContext.csp, prefixCls = _useContext.prefixCls;
  var mergedStyleStr = styleStr;
  if (prefixCls) {
    mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
  }
  (0, _react$6.useEffect)(function() {
    (0, _dynamicCSS.updateCSS)(mergedStyleStr, "@ant-design-icons", {
      prepend: true,
      csp
    });
  }, []);
};
utils$1.useInsertStyles = useInsertStyles3;
var _interopRequireDefault$m = interopRequireDefault.exports;
Object.defineProperty(IconBase$1, "__esModule", {
  value: true
});
IconBase$1.default = void 0;
var _objectWithoutProperties2$1 = _interopRequireDefault$m(require$$5);
var _objectSpread2$5 = _interopRequireDefault$m(objectSpread2.exports);
var _utils$3 = utils$1;
var _excluded$1 = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
var twoToneColorPalette = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: false
};
function setTwoToneColors(_ref2) {
  var primaryColor = _ref2.primaryColor, secondaryColor = _ref2.secondaryColor;
  twoToneColorPalette.primaryColor = primaryColor;
  twoToneColorPalette.secondaryColor = secondaryColor || (0, _utils$3.getSecondaryColor)(primaryColor);
  twoToneColorPalette.calculated = !!secondaryColor;
}
function getTwoToneColors() {
  return (0, _objectSpread2$5.default)({}, twoToneColorPalette);
}
var IconBase3 = function IconBase4(props) {
  var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = (0, _objectWithoutProperties2$1.default)(props, _excluded$1);
  var colors2 = twoToneColorPalette;
  if (primaryColor) {
    colors2 = {
      primaryColor,
      secondaryColor: secondaryColor || (0, _utils$3.getSecondaryColor)(primaryColor)
    };
  }
  (0, _utils$3.useInsertStyles)();
  (0, _utils$3.warning)((0, _utils$3.isIconDefinition)(icon), "icon should be icon definiton, but got ".concat(icon));
  if (!(0, _utils$3.isIconDefinition)(icon)) {
    return null;
  }
  var target = icon;
  if (target && typeof target.icon === "function") {
    target = (0, _objectSpread2$5.default)((0, _objectSpread2$5.default)({}, target), {}, {
      icon: target.icon(colors2.primaryColor, colors2.secondaryColor)
    });
  }
  return (0, _utils$3.generate)(target.icon, "svg-".concat(target.name), (0, _objectSpread2$5.default)({
    className,
    onClick,
    style: style2,
    "data-icon": target.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, restProps));
};
IconBase3.displayName = "IconReact";
IconBase3.getTwoToneColors = getTwoToneColors;
IconBase3.setTwoToneColors = setTwoToneColors;
var _default$j = IconBase3;
IconBase$1.default = _default$j;
var twoTonePrimaryColor = {};
var _interopRequireDefault$l = interopRequireDefault.exports;
Object.defineProperty(twoTonePrimaryColor, "__esModule", {
  value: true
});
twoTonePrimaryColor.getTwoToneColor = getTwoToneColor;
twoTonePrimaryColor.setTwoToneColor = setTwoToneColor;
var _slicedToArray2$1 = _interopRequireDefault$l(require$$3);
var _IconBase$1 = _interopRequireDefault$l(IconBase$1);
var _utils$2 = utils$1;
function setTwoToneColor(twoToneColor) {
  var _normalizeTwoToneColo = (0, _utils$2.normalizeTwoToneColors)(twoToneColor), _normalizeTwoToneColo2 = (0, _slicedToArray2$1.default)(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return _IconBase$1.default.setTwoToneColors({
    primaryColor,
    secondaryColor
  });
}
function getTwoToneColor() {
  var colors2 = _IconBase$1.default.getTwoToneColors();
  if (!colors2.calculated) {
    return colors2.primaryColor;
  }
  return [colors2.primaryColor, colors2.secondaryColor];
}
var _interopRequireDefault$k = interopRequireDefault.exports;
var _typeof$3 = require$$1;
Object.defineProperty(AntdIcon, "__esModule", {
  value: true
});
AntdIcon.default = void 0;
var _objectSpread2$4 = _interopRequireDefault$k(objectSpread2.exports);
var _slicedToArray2 = _interopRequireDefault$k(require$$3);
var _defineProperty2 = _interopRequireDefault$k(require$$4$1);
var _objectWithoutProperties2 = _interopRequireDefault$k(require$$5);
var React$a = _interopRequireWildcard$c(_global_React);
var _classnames$8 = _interopRequireDefault$k(classnames.exports);
var _Context = _interopRequireDefault$k(Context);
var _IconBase = _interopRequireDefault$k(IconBase$1);
var _twoTonePrimaryColor = twoTonePrimaryColor;
var _utils$1 = utils$1;
var _excluded = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
function _getRequireWildcardCache$3(nodeInterop) {
  if (typeof WeakMap !== "function")
    return null;
  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache$3 = function _getRequireWildcardCache2(nodeInterop2) {
    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard$c(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof$3(obj) !== "object" && typeof obj !== "function") {
    return { default: obj };
  }
  var cache2 = _getRequireWildcardCache$3(nodeInterop);
  if (cache2 && cache2.has(obj)) {
    return cache2.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache2) {
    cache2.set(obj, newObj);
  }
  return newObj;
}
(0, _twoTonePrimaryColor.setTwoToneColor)("#1890ff");
var Icon = /* @__PURE__ */ React$a.forwardRef(function(props, ref2) {
  var _classNames;
  var className = props.className, icon = props.icon, spin2 = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = (0, _objectWithoutProperties2.default)(props, _excluded);
  var _React$useContext = React$a.useContext(_Context.default), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
  var classString = (0, _classnames$8.default)(rootClassName, prefixCls, (_classNames = {}, (0, _defineProperty2.default)(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), (0, _defineProperty2.default)(_classNames, "".concat(prefixCls, "-spin"), !!spin2 || icon.name === "loading"), _classNames), className);
  var iconTabIndex = tabIndex;
  if (iconTabIndex === void 0 && onClick) {
    iconTabIndex = -1;
  }
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : void 0;
  var _normalizeTwoToneColo = (0, _utils$1.normalizeTwoToneColors)(twoToneColor), _normalizeTwoToneColo2 = (0, _slicedToArray2.default)(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return /* @__PURE__ */ React$a.createElement("span", (0, _objectSpread2$4.default)((0, _objectSpread2$4.default)({
    role: "img",
    "aria-label": icon.name
  }, restProps), {}, {
    ref: ref2,
    tabIndex: iconTabIndex,
    onClick,
    className: classString
  }), /* @__PURE__ */ React$a.createElement(_IconBase.default, {
    icon,
    primaryColor,
    secondaryColor,
    style: svgStyle
  }));
});
Icon.displayName = "AntdIcon";
Icon.getTwoToneColor = _twoTonePrimaryColor.getTwoToneColor;
Icon.setTwoToneColor = _twoTonePrimaryColor.setTwoToneColor;
var _default$i = Icon;
AntdIcon.default = _default$i;
var _interopRequireDefault$j = interopRequireDefault.exports;
var _typeof$2 = require$$1;
Object.defineProperty(SearchOutlined$3, "__esModule", {
  value: true
});
SearchOutlined$3.default = void 0;
var _objectSpread2$3 = _interopRequireDefault$j(objectSpread2.exports);
var React$9 = _interopRequireWildcard$b(_global_React);
var _SearchOutlined$1 = _interopRequireDefault$j(SearchOutlined$2);
var _AntdIcon$2 = _interopRequireDefault$j(AntdIcon);
function _getRequireWildcardCache$2(nodeInterop) {
  if (typeof WeakMap !== "function")
    return null;
  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache$2 = function _getRequireWildcardCache2(nodeInterop2) {
    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard$b(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof$2(obj) !== "object" && typeof obj !== "function") {
    return { default: obj };
  }
  var cache2 = _getRequireWildcardCache$2(nodeInterop);
  if (cache2 && cache2.has(obj)) {
    return cache2.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache2) {
    cache2.set(obj, newObj);
  }
  return newObj;
}
var SearchOutlined2 = function SearchOutlined3(props, ref2) {
  return /* @__PURE__ */ React$9.createElement(_AntdIcon$2.default, (0, _objectSpread2$3.default)((0, _objectSpread2$3.default)({}, props), {}, {
    ref: ref2,
    icon: _SearchOutlined$1.default
  }));
};
SearchOutlined2.displayName = "SearchOutlined";
var _default$h = /* @__PURE__ */ React$9.forwardRef(SearchOutlined2);
SearchOutlined$3.default = _default$h;
(function(module2, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _SearchOutlined2 = _interopRequireDefault2(SearchOutlined$3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _default3 = _SearchOutlined2;
  exports.default = _default3;
  module2.exports = _default3;
})(SearchOutlined$4, SearchOutlined$4.exports);
var ref = {};
var _interopRequireDefault$i = interopRequireDefault.exports.default;
Object.defineProperty(ref, "__esModule", {
  value: true
});
ref.composeRef = composeRef;
ref.fillRef = fillRef;
ref.supportRef = supportRef;
ref.useComposeRef = useComposeRef;
var _typeof2$1 = _interopRequireDefault$i(require$$1);
var _reactIs$1 = reactIs$2.exports;
var _useMemo = _interopRequireDefault$i(useMemo$1);
function fillRef(ref2, node2) {
  if (typeof ref2 === "function") {
    ref2(node2);
  } else if ((0, _typeof2$1.default)(ref2) === "object" && ref2 && "current" in ref2) {
    ref2.current = node2;
  }
}
function composeRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function(ref2) {
    return ref2;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function(node2) {
    refs.forEach(function(ref2) {
      fillRef(ref2, node2);
    });
  };
}
function useComposeRef() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }
  return (0, _useMemo.default)(function() {
    return composeRef.apply(void 0, refs);
  }, refs, function(prev2, next2) {
    return prev2.length === next2.length && prev2.every(function(ref2, i) {
      return ref2 === next2[i];
    });
  });
}
function supportRef(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type4 = (0, _reactIs$1.isMemo)(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  if (typeof type4 === "function" && !((_type$prototype = type4.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
    return false;
  }
  if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
    return false;
  }
  return true;
}
var button$1 = {};
var button = {};
var Compact$1 = {};
var toArray$1 = {};
var _interopRequireDefault$h = interopRequireDefault.exports.default;
Object.defineProperty(toArray$1, "__esModule", {
  value: true
});
toArray$1.default = toArray;
var _react$5 = _interopRequireDefault$h(_global_React);
var _reactIs = reactIs$2.exports;
function toArray(children) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var ret = [];
  _react$5.default.Children.forEach(children, function(child) {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray(child));
    } else if ((0, _reactIs.isFragment)(child) && child.props) {
      ret = ret.concat(toArray(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}
var style$3 = {};
var compact = {};
Object.defineProperty(compact, "__esModule", {
  value: true
});
compact.default = void 0;
const genSpaceCompactStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-block": {
        display: "flex",
        width: "100%"
      },
      "&-vertical": {
        flexDirection: "column"
      }
    }
  };
};
var _default$g = genSpaceCompactStyle;
compact.default = _default$g;
var _interopRequireDefault$g = interopRequireDefault.exports.default;
Object.defineProperty(style$3, "__esModule", {
  value: true
});
style$3.default = void 0;
var _internal$4 = internal;
var _compact = _interopRequireDefault$g(compact);
const genSpaceStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-align": {
        flexDirection: "column",
        "&-center": {
          alignItems: "center"
        },
        "&-start": {
          alignItems: "flex-start"
        },
        "&-end": {
          alignItems: "flex-end"
        },
        "&-baseline": {
          alignItems: "baseline"
        }
      },
      [`${componentCls}-item`]: {
        "&:empty": {
          display: "none"
        }
      }
    }
  };
};
var _default$f = (0, _internal$4.genComponentStyleHook)("Space", (token2) => [genSpaceStyle(token2), (0, _compact.default)(token2)]);
style$3.default = _default$f;
var _interopRequireWildcard$a = interopRequireWildcard.exports.default;
var _interopRequireDefault$f = interopRequireDefault.exports.default;
Object.defineProperty(Compact$1, "__esModule", {
  value: true
});
Compact$1.useCompactItemContext = Compact$1.default = Compact$1.SpaceCompactItemContext = Compact$1.NoCompactStyle = void 0;
var _classnames$7 = _interopRequireDefault$f(classnames.exports);
var _toArray = _interopRequireDefault$f(toArray$1);
var React$8 = _interopRequireWildcard$a(_global_React);
var _configProvider$5 = configProvider;
var _style$5 = _interopRequireDefault$f(style$3);
var __rest$4 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const SpaceCompactItemContext = /* @__PURE__ */ React$8.createContext(null);
Compact$1.SpaceCompactItemContext = SpaceCompactItemContext;
const useCompactItemContext = (prefixCls, direction) => {
  const compactItemContext = React$8.useContext(SpaceCompactItemContext);
  const compactItemClassnames = React$8.useMemo(() => {
    if (!compactItemContext)
      return "";
    const {
      compactDirection,
      isFirstItem,
      isLastItem
    } = compactItemContext;
    const separator = compactDirection === "vertical" ? "-vertical-" : "-";
    return (0, _classnames$7.default)({
      [`${prefixCls}-compact${separator}item`]: true,
      [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
      [`${prefixCls}-compact${separator}last-item`]: isLastItem,
      [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
    });
  }, [prefixCls, direction, compactItemContext]);
  return {
    compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
    compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
    compactItemClassnames
  };
};
Compact$1.useCompactItemContext = useCompactItemContext;
const NoCompactStyle = (_ref2) => {
  let {
    children
  } = _ref2;
  return /* @__PURE__ */ React$8.createElement(SpaceCompactItemContext.Provider, {
    value: null
  }, children);
};
Compact$1.NoCompactStyle = NoCompactStyle;
const CompactItem = (_a2) => {
  var {
    children
  } = _a2, otherProps = __rest$4(_a2, ["children"]);
  return /* @__PURE__ */ React$8.createElement(SpaceCompactItemContext.Provider, {
    value: otherProps
  }, children);
};
const Compact = (props) => {
  const {
    getPrefixCls,
    direction: directionConfig
  } = React$8.useContext(_configProvider$5.ConfigContext);
  const {
    size = "middle",
    direction,
    block: block2,
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children
  } = props, restProps = __rest$4(props, ["size", "direction", "block", "prefixCls", "className", "rootClassName", "children"]);
  const prefixCls = getPrefixCls("space-compact", customizePrefixCls);
  const [wrapSSR, hashId] = (0, _style$5.default)(prefixCls);
  const clx = (0, _classnames$7.default)(prefixCls, hashId, {
    [`${prefixCls}-rtl`]: directionConfig === "rtl",
    [`${prefixCls}-block`]: block2,
    [`${prefixCls}-vertical`]: direction === "vertical"
  }, className, rootClassName);
  const compactItemContext = React$8.useContext(SpaceCompactItemContext);
  const childNodes = (0, _toArray.default)(children);
  const nodes = React$8.useMemo(() => childNodes.map((child, i) => {
    const key = child && child.key || `${prefixCls}-item-${i}`;
    return /* @__PURE__ */ React$8.createElement(CompactItem, {
      key,
      compactSize: size,
      compactDirection: direction,
      isFirstItem: i === 0 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isFirstItem)),
      isLastItem: i === childNodes.length - 1 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isLastItem))
    }, child);
  }), [size, childNodes, compactItemContext]);
  if (childNodes.length === 0) {
    return null;
  }
  return wrapSSR(/* @__PURE__ */ React$8.createElement("div", Object.assign({
    className: clx
  }, restProps), nodes));
};
var _default$e = Compact;
Compact$1.default = _default$e;
var wave = {};
var isVisible = {};
Object.defineProperty(isVisible, "__esModule", {
  value: true
});
isVisible.default = void 0;
var _default$d = function _default(element2) {
  if (!element2) {
    return false;
  }
  if (element2 instanceof Element) {
    if (element2.offsetParent) {
      return true;
    }
    if (element2.getBBox) {
      var _getBBox = element2.getBBox(), width = _getBBox.width, height = _getBBox.height;
      if (width || height) {
        return true;
      }
    }
    if (element2.getBoundingClientRect) {
      var _element$getBoundingC = element2.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
      if (_width || _height) {
        return true;
      }
    }
  }
  return false;
};
isVisible.default = _default$d;
var style$2 = {};
Object.defineProperty(style$2, "__esModule", {
  value: true
});
style$2.default = void 0;
var _internal$3 = internal;
const genWaveStyle = (token2) => {
  const {
    componentCls,
    colorPrimary
  } = token2;
  return {
    [componentCls]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${colorPrimary})`,
      boxShadow: `0 0 0 0 currentcolor`,
      opacity: 0.2,
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: `0 0 0 6px currentcolor`,
          opacity: 0
        }
      }
    }
  };
};
var _default$c = (0, _internal$3.genComponentStyleHook)("Wave", (token2) => [genWaveStyle(token2)]);
style$2.default = _default$c;
var useWave$1 = {};
var WaveEffect$1 = {};
var require$$2 = /* @__PURE__ */ getAugmentedNamespace(es$1);
var raf$1 = {};
Object.defineProperty(raf$1, "__esModule", {
  value: true
});
raf$1.default = void 0;
var raf8 = function raf9(callback) {
  return +setTimeout(callback, 16);
};
var caf8 = function caf9(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf8 = function raf10(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf8 = function caf10(handle2) {
    return window.cancelAnimationFrame(handle2);
  };
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id) {
  rafIds.delete(id);
}
var wrapperRaf3 = function wrapperRaf4(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID += 1;
  var id = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id);
      callback();
    } else {
      var realId = raf8(function() {
        callRef(leftTimes - 1);
      });
      rafIds.set(id, realId);
    }
  }
  callRef(times);
  return id;
};
wrapperRaf3.cancel = function(id) {
  var realId = rafIds.get(id);
  cleanup(realId);
  return caf8(realId);
};
var _default$b = wrapperRaf3;
raf$1.default = _default$b;
var render$1 = {};
var regeneratorRuntime = { exports: {} };
(function(module2) {
  var _typeof4 = _typeof$4.exports["default"];
  function _regeneratorRuntime3() {
    module2.exports = _regeneratorRuntime3 = function _regeneratorRuntime4() {
      return exports;
    }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    var exports = {}, Op = Object.prototype, hasOwn2 = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function define2(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap2(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context2 = new Context2(tryLocsList || []);
      return generator._invoke = function(innerFn2, self3, context3) {
        var state = "suspendedStart";
        return function(method4, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method4)
              throw arg;
            return doneResult();
          }
          for (context3.method = method4, context3.arg = arg; ; ) {
            var delegate = context3.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context3);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context3.method)
              context3.sent = context3._sent = context3.arg;
            else if ("throw" === context3.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context3.arg;
              context3.dispatchException(context3.arg);
            } else
              "return" === context3.method && context3.abrupt("return", context3.arg);
            state = "executing";
            var record = tryCatch(innerFn2, self3, context3);
            if ("normal" === record.type) {
              if (state = context3.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return {
                value: record.arg,
                done: context3.done
              };
            }
            "throw" === record.type && (state = "completed", context3.method = "throw", context3.arg = record.arg);
          }
        };
      }(innerFn, self2, context2), generator;
    }
    function tryCatch(fn2, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn2.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap2;
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn2.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype2) {
      ["next", "throw", "return"].forEach(function(method4) {
        define(prototype2, method4, function(arg) {
          return this._invoke(method4, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method4, arg, resolve, reject) {
        var record = tryCatch(generator[method4], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg, value = result.value;
          return value && "object" == _typeof4(value) && hasOwn2.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
            invoke("next", value2, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function(error3) {
            return invoke("throw", error3, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      this._invoke = function(method4, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method4, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      };
    }
    function maybeInvokeDelegate(delegate, context2) {
      var method4 = delegate.iterator[context2.method];
      if (void 0 === method4) {
        if (context2.delegate = null, "throw" === context2.method) {
          if (delegate.iterator["return"] && (context2.method = "return", context2.arg = void 0, maybeInvokeDelegate(delegate, context2), "throw" === context2.method))
            return ContinueSentinel;
          context2.method = "throw", context2.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method4, delegate.iterator, context2.arg);
      if ("throw" === record.type)
        return context2.method = "throw", context2.arg = record.arg, context2.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context2[delegate.resultName] = info.value, context2.next = delegate.nextLoc, "return" !== context2.method && (context2.method = "next", context2.arg = void 0), context2.delegate = null, ContinueSentinel) : info : (context2.method = "throw", context2.arg = new TypeError("iterator result is not an object"), context2.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context2(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod)
          return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next)
          return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1, next2 = function next3() {
            for (; ++i < iterable.length; ) {
              if (hasOwn2.call(iterable, i))
                return next3.value = iterable[i], next3.done = false, next3;
            }
            return next3.value = void 0, next3.done = true, next3;
          };
          return next2.next = next2;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: void 0,
        done: true
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function(genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function(arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap2(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
      return this;
    }), define(Gp, "toString", function() {
      return "[object Generator]";
    }), exports.keys = function(object4) {
      var keys2 = [];
      for (var key in object4) {
        keys2.push(key);
      }
      return keys2.reverse(), function next2() {
        for (; keys2.length; ) {
          var key2 = keys2.pop();
          if (key2 in object4)
            return next2.value = key2, next2.done = false, next2;
        }
        return next2.done = true, next2;
      };
    }, exports.values = values, Context2.prototype = {
      constructor: Context2,
      reset: function reset(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
          for (var name in this) {
            "t" === name.charAt(0) && hasOwn2.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
          }
      },
      stop: function stop() {
        this.done = true;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type)
          throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done)
          throw exception;
        var context2 = this;
        function handle2(loc, caught) {
          return record.type = "throw", record.arg = exception, context2.next = loc, caught && (context2.method = "next", context2.arg = void 0), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i], record = entry.completion;
          if ("root" === entry.tryLoc)
            return handle2("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn2.call(entry, "catchLoc"), hasFinally = hasOwn2.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc)
                return handle2(entry.catchLoc, true);
              if (this.prev < entry.finallyLoc)
                return handle2(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc)
                return handle2(entry.catchLoc, true);
            } else {
              if (!hasFinally)
                throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc)
                return handle2(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(type4, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn2.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type4 || "continue" === type4) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type4, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if ("throw" === record.type)
          throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc)
            return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
      }
    }, exports;
  }
  module2.exports = _regeneratorRuntime3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(regeneratorRuntime);
var asyncToGenerator = { exports: {} };
(function(module2) {
  function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error3) {
      reject(error3);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator3(fn2) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn2.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  module2.exports = _asyncToGenerator3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(asyncToGenerator);
const _global_ReactDOM = ReactDOM;
var _interopRequireWildcard$9 = interopRequireWildcard.exports.default;
var _interopRequireDefault$e = interopRequireDefault.exports.default;
Object.defineProperty(render$1, "__esModule", {
  value: true
});
render$1._r = _r;
render$1._u = _u;
render$1.render = render;
render$1.unmount = unmount;
var _regeneratorRuntime2 = _interopRequireDefault$e(regeneratorRuntime.exports);
var _asyncToGenerator2 = _interopRequireDefault$e(asyncToGenerator.exports);
var _typeof2 = _interopRequireDefault$e(require$$1);
var _objectSpread2$2 = _interopRequireDefault$e(objectSpread2.exports);
var ReactDOM$1 = _interopRequireWildcard$9(_global_ReactDOM);
var fullClone = (0, _objectSpread2$2.default)({}, ReactDOM$1);
var version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
var createRoot;
try {
  var mainVersion = Number((version || "").split(".")[0]);
  if (mainVersion >= 18) {
    createRoot = fullClone.createRoot;
  }
} catch (e2) {
}
function toggleWarning(skip) {
  var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && (0, _typeof2.default)(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
  }
}
var MARK = "__rc_react_root__";
function modernRender(node2, container) {
  toggleWarning(true);
  var root2 = container[MARK] || createRoot(container);
  toggleWarning(false);
  root2.render(node2);
  container[MARK] = root2;
}
function legacyRender(node2, container) {
  reactRender(node2, container);
}
function _r(node2, container) {
}
function render(node2, container) {
  if (createRoot) {
    modernRender(node2, container);
    return;
  }
  legacyRender(node2, container);
}
function modernUnmount(_x) {
  return _modernUnmount.apply(this, arguments);
}
function _modernUnmount() {
  _modernUnmount = (0, _asyncToGenerator2.default)(/* @__PURE__ */ (0, _regeneratorRuntime2.default)().mark(function _callee(container) {
    return (0, _regeneratorRuntime2.default)().wrap(function _callee$(_context2) {
      while (1)
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", Promise.resolve().then(function() {
              var _container$MARK;
              (_container$MARK = container[MARK]) === null || _container$MARK === void 0 ? void 0 : _container$MARK.unmount();
              delete container[MARK];
            }));
          case 1:
          case "end":
            return _context2.stop();
        }
    }, _callee);
  }));
  return _modernUnmount.apply(this, arguments);
}
function legacyUnmount(container) {
  unmountComponentAtNode(container);
}
function _u(container) {
}
function unmount(_x2) {
  return _unmount.apply(this, arguments);
}
function _unmount() {
  _unmount = (0, _asyncToGenerator2.default)(/* @__PURE__ */ (0, _regeneratorRuntime2.default)().mark(function _callee2(container) {
    return (0, _regeneratorRuntime2.default)().wrap(function _callee2$(_context2) {
      while (1)
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(createRoot !== void 0)) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return", modernUnmount(container));
          case 2:
            legacyUnmount(container);
          case 3:
          case "end":
            return _context2.stop();
        }
    }, _callee2);
  }));
  return _unmount.apply(this, arguments);
}
var util = {};
Object.defineProperty(util, "__esModule", {
  value: true
});
util.getTargetWaveColor = getTargetWaveColor;
util.isNotGrey = isNotGrey;
util.isValidWaveColor = isValidWaveColor;
function isNotGrey(color2) {
  const match2 = (color2 || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  if (match2 && match2[1] && match2[2] && match2[3]) {
    return !(match2[1] === match2[2] && match2[2] === match2[3]);
  }
  return true;
}
function isValidWaveColor(color2) {
  return color2 && color2 !== "#fff" && color2 !== "#ffffff" && color2 !== "rgb(255, 255, 255)" && color2 !== "rgba(255, 255, 255, 1)" && isNotGrey(color2) && !/rgba\((?:\d*, ){3}0\)/.test(color2) && color2 !== "transparent";
}
function getTargetWaveColor(node2) {
  const {
    borderTopColor,
    borderColor,
    backgroundColor
  } = getComputedStyle(node2);
  if (isValidWaveColor(borderTopColor)) {
    return borderTopColor;
  }
  if (isValidWaveColor(borderColor)) {
    return borderColor;
  }
  if (isValidWaveColor(backgroundColor)) {
    return backgroundColor;
  }
  return null;
}
var _interopRequireDefault$d = interopRequireDefault.exports.default;
var _interopRequireWildcard$8 = interopRequireWildcard.exports.default;
Object.defineProperty(WaveEffect$1, "__esModule", {
  value: true
});
WaveEffect$1.default = showWaveEffect;
var React$7 = _interopRequireWildcard$8(_global_React);
var _rcMotion$1 = _interopRequireDefault$d(require$$2);
var _raf = _interopRequireDefault$d(raf$1);
var _render = render$1;
var _classnames$6 = _interopRequireDefault$d(classnames.exports);
var _util = util;
function validateNum(value) {
  return Number.isNaN(value) ? 0 : value;
}
const WaveEffect = (props) => {
  const {
    className,
    target
  } = props;
  const divRef = React$7.useRef(null);
  const [color2, setWaveColor] = React$7.useState(null);
  const [borderRadius, setBorderRadius] = React$7.useState([]);
  const [left, setLeft] = React$7.useState(0);
  const [top, setTop] = React$7.useState(0);
  const [width, setWidth] = React$7.useState(0);
  const [height, setHeight] = React$7.useState(0);
  const [enabled, setEnabled] = React$7.useState(false);
  const waveStyle = {
    left,
    top,
    width,
    height,
    borderRadius: borderRadius.map((radius) => `${radius}px`).join(" ")
  };
  if (color2) {
    waveStyle["--wave-color"] = color2;
  }
  function syncPos() {
    const nodeStyle = getComputedStyle(target);
    setWaveColor((0, _util.getTargetWaveColor)(target));
    const isStatic = nodeStyle.position === "static";
    const {
      borderLeftWidth,
      borderTopWidth
    } = nodeStyle;
    setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
    setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
    setWidth(target.offsetWidth);
    setHeight(target.offsetHeight);
    const {
      borderTopLeftRadius,
      borderTopRightRadius,
      borderBottomLeftRadius,
      borderBottomRightRadius
    } = nodeStyle;
    setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius) => validateNum(parseFloat(radius))));
  }
  React$7.useEffect(() => {
    if (target) {
      const id = (0, _raf.default)(() => {
        syncPos();
        setEnabled(true);
      });
      let resizeObserver2;
      if (typeof ResizeObserver !== "undefined") {
        resizeObserver2 = new ResizeObserver(syncPos);
        resizeObserver2.observe(target);
      }
      return () => {
        _raf.default.cancel(id);
        resizeObserver2 === null || resizeObserver2 === void 0 ? void 0 : resizeObserver2.disconnect();
      };
    }
  }, []);
  if (!enabled) {
    return null;
  }
  return /* @__PURE__ */ React$7.createElement(_rcMotion$1.default, {
    visible: true,
    motionAppear: true,
    motionName: "wave-motion",
    motionDeadline: 5e3,
    onAppearEnd: (_24, event) => {
      var _a2;
      if (event.deadline || event.propertyName === "opacity") {
        const holder = (_a2 = divRef.current) === null || _a2 === void 0 ? void 0 : _a2.parentElement;
        (0, _render.unmount)(holder).then(() => {
          var _a3;
          (_a3 = holder.parentElement) === null || _a3 === void 0 ? void 0 : _a3.removeChild(holder);
        });
      }
      return false;
    }
  }, (_ref2) => {
    let {
      className: motionClassName
    } = _ref2;
    return /* @__PURE__ */ React$7.createElement("div", {
      ref: divRef,
      className: (0, _classnames$6.default)(className, motionClassName),
      style: waveStyle
    });
  });
};
function showWaveEffect(node2, className) {
  const holder = document.createElement("div");
  holder.style.position = "absolute";
  holder.style.left = `0px`;
  holder.style.top = `0px`;
  node2 === null || node2 === void 0 ? void 0 : node2.insertBefore(holder, node2 === null || node2 === void 0 ? void 0 : node2.firstChild);
  (0, _render.render)(/* @__PURE__ */ React$7.createElement(WaveEffect, {
    target: node2,
    className
  }), holder);
}
var _interopRequireDefault$c = interopRequireDefault.exports.default;
Object.defineProperty(useWave$1, "__esModule", {
  value: true
});
useWave$1.default = useWave;
var _WaveEffect = _interopRequireDefault$c(WaveEffect$1);
function useWave(nodeRef, className) {
  function showWave() {
    const node2 = nodeRef.current;
    (0, _WaveEffect.default)(node2, className);
  }
  return showWave;
}
var _interopRequireWildcard$7 = interopRequireWildcard.exports.default;
var _interopRequireDefault$b = interopRequireDefault.exports.default;
Object.defineProperty(wave, "__esModule", {
  value: true
});
wave.default = void 0;
var _classnames$5 = _interopRequireDefault$b(classnames.exports);
var _ref$2 = ref;
var _isVisible = _interopRequireDefault$b(isVisible);
var _react$4 = _interopRequireWildcard$7(_global_React);
var _configProvider$4 = configProvider;
var _reactNode$2 = reactNode;
var _style$4 = _interopRequireDefault$b(style$2);
var _useWave = _interopRequireDefault$b(useWave$1);
const Wave = (props) => {
  const {
    children,
    disabled
  } = props;
  const {
    getPrefixCls
  } = (0, _react$4.useContext)(_configProvider$4.ConfigContext);
  const containerRef = (0, _react$4.useRef)(null);
  const prefixCls = getPrefixCls("wave");
  const [, hashId] = (0, _style$4.default)(prefixCls);
  const showWave = (0, _useWave.default)(containerRef, (0, _classnames$5.default)(prefixCls, hashId));
  _react$4.default.useEffect(() => {
    const node2 = containerRef.current;
    if (!node2 || node2.nodeType !== 1 || disabled) {
      return;
    }
    const onClick = (e2) => {
      if (e2.target.tagName === "INPUT" || !(0, _isVisible.default)(e2.target) || !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
        return;
      }
      showWave();
    };
    node2.addEventListener("click", onClick, true);
    return () => {
      node2.removeEventListener("click", onClick, true);
    };
  }, [disabled]);
  if (!/* @__PURE__ */ _react$4.default.isValidElement(children)) {
    return children !== null && children !== void 0 ? children : null;
  }
  const ref2 = (0, _ref$2.supportRef)(children) ? (0, _ref$2.composeRef)(children.ref, containerRef) : containerRef;
  return (0, _reactNode$2.cloneElement)(children, {
    ref: ref2
  });
};
var _default$a = Wave;
wave.default = _default$a;
var buttonGroup = {};
var _interopRequireWildcard$6 = interopRequireWildcard.exports.default;
var _interopRequireDefault$a = interopRequireDefault.exports.default;
Object.defineProperty(buttonGroup, "__esModule", {
  value: true
});
buttonGroup.default = buttonGroup.GroupSizeContext = void 0;
var _classnames$4 = _interopRequireDefault$a(classnames.exports);
var React$6 = _interopRequireWildcard$6(_global_React);
var _configProvider$3 = configProvider;
var _internal$2 = internal;
_interopRequireDefault$a(warning$5);
var __rest$3 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const GroupSizeContext = /* @__PURE__ */ React$6.createContext(void 0);
buttonGroup.GroupSizeContext = GroupSizeContext;
const ButtonGroup = (props) => {
  const {
    getPrefixCls,
    direction
  } = React$6.useContext(_configProvider$3.ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    size,
    className
  } = props, others = __rest$3(props, ["prefixCls", "size", "className"]);
  const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
  const [, , hashId] = (0, _internal$2.useToken)();
  let sizeCls = "";
  switch (size) {
    case "large":
      sizeCls = "lg";
      break;
    case "small":
      sizeCls = "sm";
      break;
  }
  const classes = (0, _classnames$4.default)(prefixCls, {
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, hashId);
  return /* @__PURE__ */ React$6.createElement(GroupSizeContext.Provider, {
    value: size
  }, /* @__PURE__ */ React$6.createElement("div", Object.assign({}, others, {
    className: classes
  })));
};
var _default$9 = ButtonGroup;
buttonGroup.default = _default$9;
var buttonHelpers = {};
var _interopRequireDefault$9 = interopRequireDefault.exports.default;
Object.defineProperty(buttonHelpers, "__esModule", {
  value: true
});
buttonHelpers.isString = isString;
buttonHelpers.isTwoCNChar = void 0;
buttonHelpers.isUnBorderedButtonType = isUnBorderedButtonType;
buttonHelpers.spaceChildren = spaceChildren;
var _react$3 = _interopRequireDefault$9(_global_React);
var _reactNode$1 = reactNode;
const rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
buttonHelpers.isTwoCNChar = isTwoCNChar;
function isString(str) {
  return typeof str === "string";
}
function isUnBorderedButtonType(type4) {
  return type4 === "text" || type4 === "link";
}
function splitCNCharsBySpace(child, needInserted) {
  if (child === null || child === void 0) {
    return;
  }
  const SPACE = needInserted ? " " : "";
  if (typeof child !== "string" && typeof child !== "number" && isString(child.type) && isTwoCNChar(child.props.children)) {
    return (0, _reactNode$1.cloneElement)(child, {
      children: child.props.children.split("").join(SPACE)
    });
  }
  if (typeof child === "string") {
    return isTwoCNChar(child) ? /* @__PURE__ */ _react$3.default.createElement("span", null, child.split("").join(SPACE)) : /* @__PURE__ */ _react$3.default.createElement("span", null, child);
  }
  if ((0, _reactNode$1.isFragment)(child)) {
    return /* @__PURE__ */ _react$3.default.createElement("span", null, child);
  }
  return child;
}
function spaceChildren(children, needInserted) {
  let isPrevChildPure = false;
  const childList = [];
  _react$3.default.Children.forEach(children, (child) => {
    const type4 = typeof child;
    const isCurrentChildPure = type4 === "string" || type4 === "number";
    if (isPrevChildPure && isCurrentChildPure) {
      const lastIndex = childList.length - 1;
      const lastChild = childList[lastIndex];
      childList[lastIndex] = `${lastChild}${child}`;
    } else {
      childList.push(child);
    }
    isPrevChildPure = isCurrentChildPure;
  });
  return _react$3.default.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted));
}
var LoadingIcon$1 = {};
var LoadingOutlined$4 = { exports: {} };
var LoadingOutlined$3 = {};
var LoadingOutlined$2 = {};
Object.defineProperty(LoadingOutlined$2, "__esModule", { value: true });
var LoadingOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
LoadingOutlined$2.default = LoadingOutlined$1;
var _interopRequireDefault$8 = interopRequireDefault.exports;
var _typeof$1 = require$$1;
Object.defineProperty(LoadingOutlined$3, "__esModule", {
  value: true
});
LoadingOutlined$3.default = void 0;
var _objectSpread2$1 = _interopRequireDefault$8(objectSpread2.exports);
var React$5 = _interopRequireWildcard$5(_global_React);
var _LoadingOutlined$1 = _interopRequireDefault$8(LoadingOutlined$2);
var _AntdIcon$1 = _interopRequireDefault$8(AntdIcon);
function _getRequireWildcardCache$1(nodeInterop) {
  if (typeof WeakMap !== "function")
    return null;
  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache$1 = function _getRequireWildcardCache2(nodeInterop2) {
    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard$5(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof$1(obj) !== "object" && typeof obj !== "function") {
    return { default: obj };
  }
  var cache2 = _getRequireWildcardCache$1(nodeInterop);
  if (cache2 && cache2.has(obj)) {
    return cache2.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache2) {
    cache2.set(obj, newObj);
  }
  return newObj;
}
var LoadingOutlined3 = function LoadingOutlined4(props, ref2) {
  return /* @__PURE__ */ React$5.createElement(_AntdIcon$1.default, (0, _objectSpread2$1.default)((0, _objectSpread2$1.default)({}, props), {}, {
    ref: ref2,
    icon: _LoadingOutlined$1.default
  }));
};
LoadingOutlined3.displayName = "LoadingOutlined";
var _default$8 = /* @__PURE__ */ React$5.forwardRef(LoadingOutlined3);
LoadingOutlined$3.default = _default$8;
(function(module2, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _LoadingOutlined2 = _interopRequireDefault2(LoadingOutlined$3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _default3 = _LoadingOutlined2;
  exports.default = _default3;
  module2.exports = _default3;
})(LoadingOutlined$4, LoadingOutlined$4.exports);
var _interopRequireDefault$7 = interopRequireDefault.exports.default;
Object.defineProperty(LoadingIcon$1, "__esModule", {
  value: true
});
LoadingIcon$1.default = void 0;
var _LoadingOutlined = _interopRequireDefault$7(LoadingOutlined$4.exports);
var _rcMotion = _interopRequireDefault$7(require$$2);
var _react$2 = _interopRequireDefault$7(_global_React);
const getCollapsedWidth = () => ({
  width: 0,
  opacity: 0,
  transform: "scale(0)"
});
const getRealWidth = (node2) => ({
  width: node2.scrollWidth,
  opacity: 1,
  transform: "scale(1)"
});
const LoadingIcon = (_ref2) => {
  let {
    prefixCls,
    loading,
    existIcon
  } = _ref2;
  const visible = !!loading;
  if (existIcon) {
    return /* @__PURE__ */ _react$2.default.createElement("span", {
      className: `${prefixCls}-loading-icon`
    }, /* @__PURE__ */ _react$2.default.createElement(_LoadingOutlined.default, null));
  }
  return /* @__PURE__ */ _react$2.default.createElement(_rcMotion.default, {
    visible,
    motionName: `${prefixCls}-loading-icon-motion`,
    removeOnLeave: true,
    onAppearStart: getCollapsedWidth,
    onAppearActive: getRealWidth,
    onEnterStart: getCollapsedWidth,
    onEnterActive: getRealWidth,
    onLeaveStart: getRealWidth,
    onLeaveActive: getCollapsedWidth
  }, (_ref22, ref2) => {
    let {
      className,
      style: style2
    } = _ref22;
    return /* @__PURE__ */ _react$2.default.createElement("span", {
      className: `${prefixCls}-loading-icon`,
      style: style2,
      ref: ref2
    }, /* @__PURE__ */ _react$2.default.createElement(_LoadingOutlined.default, {
      className
    }));
  });
};
var _default$7 = LoadingIcon;
LoadingIcon$1.default = _default$7;
var style$1 = {};
var group = {};
Object.defineProperty(group, "__esModule", {
  value: true
});
group.default = void 0;
const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
  [`> span, > ${buttonTypeCls}`]: {
    "&:not(:last-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: borderColor
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: borderColor
        }
      }
    }
  }
});
const genGroupStyle$1 = (token2) => {
  const {
    componentCls,
    fontSize,
    lineWidth,
    colorPrimaryHover,
    colorErrorHover
  } = token2;
  return {
    [`${componentCls}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        [`> span, > ${componentCls}`]: {
          "&:not(:last-child)": {
            [`&, & > ${componentCls}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: -lineWidth,
            [`&, & > ${componentCls}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [componentCls]: {
          position: "relative",
          zIndex: 1,
          [`&:hover,
          &:focus,
          &:active`]: {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${componentCls}-icon-only`]: {
          fontSize
        }
      },
      genButtonBorderStyle(`${componentCls}-primary`, colorPrimaryHover),
      genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
    ]
  };
};
var _default$6 = genGroupStyle$1;
group.default = _default$6;
var compactItem = {};
Object.defineProperty(compactItem, "__esModule", {
  value: true
});
compactItem.genCompactItemStyle = genCompactItemStyle;
function compactItemBorder(token2, parentCls, options) {
  const {
    focusElCls,
    focus,
    borderElCls
  } = options;
  const childCombinator = borderElCls ? "> *" : "";
  const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
  return {
    [`&-item:not(${parentCls}-last-item)`]: {
      marginInlineEnd: -token2.lineWidth
    },
    "&-item": Object.assign(Object.assign({
      [hoverEffects]: {
        zIndex: 2
      }
    }, focusElCls ? {
      [`&${focusElCls}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${childCombinator}`]: {
        zIndex: 0
      }
    })
  };
}
function compactItemBorderRadius(prefixCls, parentCls, options) {
  const {
    borderElCls
  } = options;
  const childCombinator = borderElCls ? `> ${borderElCls}` : "";
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
      borderRadius: 0
    },
    [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function genCompactItemStyle(token2) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: true
  };
  const {
    componentCls
  } = token2;
  const compactCls = `${componentCls}-compact`;
  return {
    [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token2, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
  };
}
var compactItemVertical = {};
Object.defineProperty(compactItemVertical, "__esModule", {
  value: true
});
compactItemVertical.genCompactItemVerticalStyle = genCompactItemVerticalStyle;
function compactItemVerticalBorder(token2, parentCls) {
  return {
    [`&-item:not(${parentCls}-last-item)`]: {
      marginBottom: -token2.lineWidth
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function compactItemBorderVerticalRadius(prefixCls, parentCls) {
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function genCompactItemVerticalStyle(token2) {
  const compactCls = `${token2.componentCls}-compact-vertical`;
  return {
    [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
  };
}
var _interopRequireDefault$6 = interopRequireDefault.exports.default;
Object.defineProperty(style$1, "__esModule", {
  value: true
});
style$1.default = void 0;
var _internal$1 = internal;
var _group = _interopRequireDefault$6(group);
var _style$3 = style$6;
var _compactItem$1 = compactItem;
var _compactItemVertical = compactItemVertical;
const genSharedButtonStyle = (token2) => {
  const {
    componentCls,
    iconCls
  } = token2;
  return {
    [componentCls]: {
      outline: "none",
      position: "relative",
      display: "inline-block",
      fontWeight: 400,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      backgroundColor: "transparent",
      border: `${token2.lineWidth}px ${token2.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      lineHeight: token2.lineHeight,
      color: token2.colorText,
      "> span": {
        display: "inline-block"
      },
      [`> ${iconCls} + span, > span + ${iconCls}`]: {
        marginInlineStart: token2.marginXS
      },
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": Object.assign({}, (0, _style$3.genFocusStyle)(token2)),
      [`&-icon-only${componentCls}-compact-item`]: {
        flex: "none"
      },
      [`&-compact-item${componentCls}-primary`]: {
        [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
          position: "relative",
          "&:before": {
            position: "absolute",
            top: -token2.lineWidth,
            insetInlineStart: -token2.lineWidth,
            display: "inline-block",
            width: token2.lineWidth,
            height: `calc(100% + ${token2.lineWidth * 2}px)`,
            backgroundColor: token2.colorPrimaryHover,
            content: '""'
          }
        }
      },
      "&-compact-vertical-item": {
        [`&${componentCls}-primary`]: {
          [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: -token2.lineWidth,
              insetInlineStart: -token2.lineWidth,
              display: "inline-block",
              width: `calc(100% + ${token2.lineWidth * 2}px)`,
              height: token2.lineWidth,
              backgroundColor: token2.colorPrimaryHover,
              content: '""'
            }
          }
        }
      }
    }
  };
};
const genHoverActiveButtonStyle = (hoverStyle, activeStyle) => ({
  "&:not(:disabled)": {
    "&:hover": hoverStyle,
    "&:active": activeStyle
  }
});
const genCircleButtonStyle = (token2) => ({
  minWidth: token2.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
});
const genRoundButtonStyle = (token2) => ({
  borderRadius: token2.controlHeight,
  paddingInlineStart: token2.controlHeight / 2,
  paddingInlineEnd: token2.controlHeight / 2
});
const genDisabledStyle$1 = (token2) => ({
  cursor: "not-allowed",
  borderColor: token2.colorBorder,
  color: token2.colorTextDisabled,
  backgroundColor: token2.colorBgContainerDisabled,
  boxShadow: "none"
});
const genGhostButtonStyle = (btnCls, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
  [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
    color: textColor || void 0,
    backgroundColor: "transparent",
    borderColor: borderColor || void 0,
    boxShadow: "none"
  }, genHoverActiveButtonStyle(Object.assign({
    backgroundColor: "transparent"
  }, hoverStyle), Object.assign({
    backgroundColor: "transparent"
  }, activeStyle))), {
    "&:disabled": {
      cursor: "not-allowed",
      color: textColorDisabled || void 0,
      borderColor: borderColorDisabled || void 0
    }
  })
});
const genSolidDisabledButtonStyle = (token2) => ({
  "&:disabled": Object.assign({}, genDisabledStyle$1(token2))
});
const genSolidButtonStyle = (token2) => Object.assign({}, genSolidDisabledButtonStyle(token2));
const genPureDisabledButtonStyle = (token2) => ({
  "&:disabled": {
    cursor: "not-allowed",
    color: token2.colorTextDisabled
  }
});
const genDefaultButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
  backgroundColor: token2.colorBgContainer,
  borderColor: token2.colorBorder,
  boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`
}), genHoverActiveButtonStyle({
  color: token2.colorPrimaryHover,
  borderColor: token2.colorPrimaryHover
}, {
  color: token2.colorPrimaryActive,
  borderColor: token2.colorPrimaryActive
})), genGhostButtonStyle(token2.componentCls, token2.colorBgContainer, token2.colorBgContainer, token2.colorTextDisabled, token2.colorBorder)), {
  [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    color: token2.colorError,
    borderColor: token2.colorError
  }, genHoverActiveButtonStyle({
    color: token2.colorErrorHover,
    borderColor: token2.colorErrorBorderHover
  }, {
    color: token2.colorErrorActive,
    borderColor: token2.colorErrorActive
  })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder)), genSolidDisabledButtonStyle(token2))
});
const genPrimaryButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
  color: token2.colorTextLightSolid,
  backgroundColor: token2.colorPrimary,
  boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`
}), genHoverActiveButtonStyle({
  color: token2.colorTextLightSolid,
  backgroundColor: token2.colorPrimaryHover
}, {
  color: token2.colorTextLightSolid,
  backgroundColor: token2.colorPrimaryActive
})), genGhostButtonStyle(token2.componentCls, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
  color: token2.colorPrimaryHover,
  borderColor: token2.colorPrimaryHover
}, {
  color: token2.colorPrimaryActive,
  borderColor: token2.colorPrimaryActive
})), {
  [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    backgroundColor: token2.colorError,
    boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`
  }, genHoverActiveButtonStyle({
    backgroundColor: token2.colorErrorHover
  }, {
    backgroundColor: token2.colorErrorActive
  })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
    color: token2.colorErrorHover,
    borderColor: token2.colorErrorHover
  }, {
    color: token2.colorErrorActive,
    borderColor: token2.colorErrorActive
  })), genSolidDisabledButtonStyle(token2))
});
const genDashedButtonStyle = (token2) => Object.assign(Object.assign({}, genDefaultButtonStyle(token2)), {
  borderStyle: "dashed"
});
const genLinkButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({
  color: token2.colorLink
}, genHoverActiveButtonStyle({
  color: token2.colorLinkHover
}, {
  color: token2.colorLinkActive
})), genPureDisabledButtonStyle(token2)), {
  [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: token2.colorError
  }, genHoverActiveButtonStyle({
    color: token2.colorErrorHover
  }, {
    color: token2.colorErrorActive
  })), genPureDisabledButtonStyle(token2))
});
const genTextButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({}, genHoverActiveButtonStyle({
  color: token2.colorText,
  backgroundColor: token2.colorBgTextHover
}, {
  color: token2.colorText,
  backgroundColor: token2.colorBgTextActive
})), genPureDisabledButtonStyle(token2)), {
  [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: token2.colorError
  }, genPureDisabledButtonStyle(token2)), genHoverActiveButtonStyle({
    color: token2.colorErrorHover,
    backgroundColor: token2.colorErrorBg
  }, {
    color: token2.colorErrorHover,
    backgroundColor: token2.colorErrorBg
  }))
});
const genDisabledButtonStyle = (token2) => Object.assign(Object.assign({}, genDisabledStyle$1(token2)), {
  [`&${token2.componentCls}:hover`]: Object.assign({}, genDisabledStyle$1(token2))
});
const genTypeButtonStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-default`]: genDefaultButtonStyle(token2),
    [`${componentCls}-primary`]: genPrimaryButtonStyle(token2),
    [`${componentCls}-dashed`]: genDashedButtonStyle(token2),
    [`${componentCls}-link`]: genLinkButtonStyle(token2),
    [`${componentCls}-text`]: genTextButtonStyle(token2),
    [`${componentCls}-disabled`]: genDisabledButtonStyle(token2)
  };
};
const genSizeButtonStyle = function(token2) {
  let sizePrefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const {
    componentCls,
    iconCls,
    controlHeight,
    fontSize,
    lineHeight,
    lineWidth,
    borderRadius,
    buttonPaddingHorizontal
  } = token2;
  const paddingVertical = Math.max(0, (controlHeight - fontSize * lineHeight) / 2 - lineWidth);
  const paddingHorizontal = buttonPaddingHorizontal - lineWidth;
  const iconOnlyCls = `${componentCls}-icon-only`;
  return [
    {
      [`${componentCls}${sizePrefixCls}`]: {
        fontSize,
        height: controlHeight,
        padding: `${paddingVertical}px ${paddingHorizontal}px`,
        borderRadius,
        [`&${iconOnlyCls}`]: {
          width: controlHeight,
          paddingInlineStart: 0,
          paddingInlineEnd: 0,
          [`&${componentCls}-round`]: {
            width: "auto"
          },
          "> span": {
            transform: "scale(1.143)"
          }
        },
        [`&${componentCls}-loading`]: {
          opacity: token2.opacityLoading,
          cursor: "default"
        },
        [`${componentCls}-loading-icon`]: {
          transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
        },
        [`&:not(${iconOnlyCls}) ${componentCls}-loading-icon > ${iconCls}`]: {
          marginInlineEnd: token2.marginXS
        }
      }
    },
    {
      [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle(token2)
    },
    {
      [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle(token2)
    }
  ];
};
const genSizeBaseButtonStyle = (token2) => genSizeButtonStyle(token2);
const genSizeSmallButtonStyle = (token2) => {
  const smallToken = (0, _internal$1.mergeToken)(token2, {
    controlHeight: token2.controlHeightSM,
    padding: token2.paddingXS,
    buttonPaddingHorizontal: 8,
    borderRadius: token2.borderRadiusSM
  });
  return genSizeButtonStyle(smallToken, `${token2.componentCls}-sm`);
};
const genSizeLargeButtonStyle = (token2) => {
  const largeToken = (0, _internal$1.mergeToken)(token2, {
    controlHeight: token2.controlHeightLG,
    fontSize: token2.fontSizeLG,
    borderRadius: token2.borderRadiusLG
  });
  return genSizeButtonStyle(largeToken, `${token2.componentCls}-lg`);
};
const genBlockButtonStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      [`&${componentCls}-block`]: {
        width: "100%"
      }
    }
  };
};
var _default$5 = (0, _internal$1.genComponentStyleHook)("Button", (token2) => {
  const {
    controlTmpOutline,
    paddingContentHorizontal
  } = token2;
  const buttonToken = (0, _internal$1.mergeToken)(token2, {
    colorOutlineDefault: controlTmpOutline,
    buttonPaddingHorizontal: paddingContentHorizontal
  });
  return [
    genSharedButtonStyle(buttonToken),
    genSizeSmallButtonStyle(buttonToken),
    genSizeBaseButtonStyle(buttonToken),
    genSizeLargeButtonStyle(buttonToken),
    genBlockButtonStyle(buttonToken),
    genTypeButtonStyle(buttonToken),
    (0, _group.default)(buttonToken),
    (0, _compactItem$1.genCompactItemStyle)(token2),
    (0, _compactItemVertical.genCompactItemVerticalStyle)(token2)
  ];
});
style$1.default = _default$5;
var _interopRequireWildcard$4 = interopRequireWildcard.exports.default;
var _interopRequireDefault$5 = interopRequireDefault.exports.default;
Object.defineProperty(button, "__esModule", {
  value: true
});
button.convertLegacyProps = convertLegacyProps;
button.default = void 0;
var _classnames$3 = _interopRequireDefault$5(classnames.exports);
var _omit$1 = _interopRequireDefault$5(omit$1);
var React$4 = _interopRequireWildcard$4(_global_React);
var _configProvider$2 = configProvider;
var _DisabledContext$1 = _interopRequireDefault$5(DisabledContext$1);
var _SizeContext$2 = _interopRequireDefault$5(SizeContext$1);
var _Compact$2 = Compact$1;
_interopRequireDefault$5(warning$5);
var _wave = _interopRequireDefault$5(wave);
var _buttonGroup = _interopRequireWildcard$4(buttonGroup);
var _buttonHelpers = buttonHelpers;
var _LoadingIcon = _interopRequireDefault$5(LoadingIcon$1);
var _style$2 = _interopRequireDefault$5(style$1);
var __rest$2 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function convertLegacyProps(type4) {
  if (type4 === "danger") {
    return {
      danger: true
    };
  }
  return {
    type: type4
  };
}
function getLoadingConfig(loading) {
  if (typeof loading === "object" && loading) {
    const delay = loading === null || loading === void 0 ? void 0 : loading.delay;
    const isDelay = !Number.isNaN(delay) && typeof delay === "number";
    return {
      loading: false,
      delay: isDelay ? delay : 0
    };
  }
  return {
    loading: !!loading,
    delay: 0
  };
}
const InternalButton = (props, ref2) => {
  const {
    loading = false,
    prefixCls: customizePrefixCls,
    type: type4 = "default",
    danger,
    shape = "default",
    size: customizeSize,
    disabled: customDisabled,
    className,
    rootClassName,
    children,
    icon,
    ghost = false,
    block: block2 = false,
    htmlType = "button"
  } = props, rest = __rest$2(props, ["loading", "prefixCls", "type", "danger", "shape", "size", "disabled", "className", "rootClassName", "children", "icon", "ghost", "block", "htmlType"]);
  const {
    getPrefixCls,
    autoInsertSpaceInButton,
    direction
  } = React$4.useContext(_configProvider$2.ConfigContext);
  const prefixCls = getPrefixCls("btn", customizePrefixCls);
  const [wrapSSR, hashId] = (0, _style$2.default)(prefixCls);
  const size = React$4.useContext(_SizeContext$2.default);
  const disabled = React$4.useContext(_DisabledContext$1.default);
  const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  const groupSize = React$4.useContext(_buttonGroup.GroupSizeContext);
  const loadingOrDelay = React$4.useMemo(() => getLoadingConfig(loading), [loading]);
  const [innerLoading, setLoading] = React$4.useState(loadingOrDelay.loading);
  const [hasTwoCNChar, setHasTwoCNChar] = React$4.useState(false);
  const buttonRef = ref2 || /* @__PURE__ */ React$4.createRef();
  const isNeedInserted = () => React$4.Children.count(children) === 1 && !icon && !(0, _buttonHelpers.isUnBorderedButtonType)(type4);
  const fixTwoCNChar = () => {
    if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
      return;
    }
    const buttonText = buttonRef.current.textContent;
    if (isNeedInserted() && (0, _buttonHelpers.isTwoCNChar)(buttonText)) {
      if (!hasTwoCNChar) {
        setHasTwoCNChar(true);
      }
    } else if (hasTwoCNChar) {
      setHasTwoCNChar(false);
    }
  };
  React$4.useEffect(() => {
    let delayTimer = null;
    if (loadingOrDelay.delay > 0) {
      delayTimer = window.setTimeout(() => {
        delayTimer = null;
        setLoading(true);
      }, loadingOrDelay.delay);
    } else {
      setLoading(loadingOrDelay.loading);
    }
    function cleanupTimer() {
      if (delayTimer) {
        window.clearTimeout(delayTimer);
        delayTimer = null;
      }
    }
    return cleanupTimer;
  }, [loadingOrDelay]);
  React$4.useEffect(fixTwoCNChar, [buttonRef]);
  const handleClick = (e2) => {
    const {
      onClick
    } = props;
    if (innerLoading || mergedDisabled) {
      e2.preventDefault();
      return;
    }
    onClick === null || onClick === void 0 ? void 0 : onClick(e2);
  };
  const autoInsertSpace = autoInsertSpaceInButton !== false;
  const {
    compactSize,
    compactItemClassnames
  } = (0, _Compact$2.useCompactItemContext)(prefixCls, direction);
  const sizeClassNameMap = {
    large: "lg",
    small: "sm",
    middle: void 0
  };
  const sizeFullname = compactSize || groupSize || customizeSize || size;
  const sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || "" : "";
  const iconType = innerLoading ? "loading" : icon;
  const linkButtonRestProps = (0, _omit$1.default)(rest, ["navigate"]);
  const hrefAndDisabled = linkButtonRestProps.href !== void 0 && mergedDisabled;
  const classes = (0, _classnames$3.default)(prefixCls, hashId, {
    [`${prefixCls}-${shape}`]: shape !== "default" && shape,
    [`${prefixCls}-${type4}`]: type4,
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
    [`${prefixCls}-background-ghost`]: ghost && !(0, _buttonHelpers.isUnBorderedButtonType)(type4),
    [`${prefixCls}-loading`]: innerLoading,
    [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && autoInsertSpace && !innerLoading,
    [`${prefixCls}-block`]: block2,
    [`${prefixCls}-dangerous`]: !!danger,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-disabled`]: hrefAndDisabled
  }, compactItemClassnames, className, rootClassName);
  const iconNode = icon && !innerLoading ? icon : /* @__PURE__ */ React$4.createElement(_LoadingIcon.default, {
    existIcon: !!icon,
    prefixCls,
    loading: !!innerLoading
  });
  const kids = children || children === 0 ? (0, _buttonHelpers.spaceChildren)(children, isNeedInserted() && autoInsertSpace) : null;
  if (linkButtonRestProps.href !== void 0) {
    return wrapSSR(/* @__PURE__ */ React$4.createElement("a", Object.assign({}, linkButtonRestProps, {
      className: classes,
      onClick: handleClick,
      ref: buttonRef
    }), iconNode, kids));
  }
  let buttonNode = /* @__PURE__ */ React$4.createElement("button", Object.assign({}, rest, {
    type: htmlType,
    className: classes,
    onClick: handleClick,
    disabled: mergedDisabled,
    ref: buttonRef
  }), iconNode, kids);
  if (!(0, _buttonHelpers.isUnBorderedButtonType)(type4)) {
    buttonNode = /* @__PURE__ */ React$4.createElement(_wave.default, {
      disabled: !!innerLoading
    }, buttonNode);
  }
  return wrapSSR(buttonNode);
};
const Button = /* @__PURE__ */ React$4.forwardRef(InternalButton);
Button.Group = _buttonGroup.default;
Button.__ANT_BUTTON = true;
var _default$4 = Button;
button.default = _default$4;
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports.default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {};
  exports.default = void 0;
  var _button2 = _interopRequireDefault2(button);
  var _buttonHelpers2 = buttonHelpers;
  Object.keys(_buttonHelpers2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _buttonHelpers2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _buttonHelpers2[key];
      }
    });
  });
  var _default3 = _button2.default;
  exports.default = _default3;
})(button$1);
var Input$1 = {};
var CloseCircleFilled$4 = { exports: {} };
var CloseCircleFilled$3 = {};
var CloseCircleFilled$2 = {};
Object.defineProperty(CloseCircleFilled$2, "__esModule", { value: true });
var CloseCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z" } }] }, "name": "close-circle", "theme": "filled" };
CloseCircleFilled$2.default = CloseCircleFilled$1;
var _interopRequireDefault$4 = interopRequireDefault.exports;
var _typeof = require$$1;
Object.defineProperty(CloseCircleFilled$3, "__esModule", {
  value: true
});
CloseCircleFilled$3.default = void 0;
var _objectSpread2 = _interopRequireDefault$4(objectSpread2.exports);
var React$3 = _interopRequireWildcard$3(_global_React);
var _CloseCircleFilled$1 = _interopRequireDefault$4(CloseCircleFilled$2);
var _AntdIcon = _interopRequireDefault$4(AntdIcon);
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function")
    return null;
  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard$3(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return { default: obj };
  }
  var cache2 = _getRequireWildcardCache(nodeInterop);
  if (cache2 && cache2.has(obj)) {
    return cache2.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache2) {
    cache2.set(obj, newObj);
  }
  return newObj;
}
var CloseCircleFilled2 = function CloseCircleFilled3(props, ref2) {
  return /* @__PURE__ */ React$3.createElement(_AntdIcon.default, (0, _objectSpread2.default)((0, _objectSpread2.default)({}, props), {}, {
    ref: ref2,
    icon: _CloseCircleFilled$1.default
  }));
};
CloseCircleFilled2.displayName = "CloseCircleFilled";
var _default$3 = /* @__PURE__ */ React$3.forwardRef(CloseCircleFilled2);
CloseCircleFilled$3.default = _default$3;
(function(module2, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _CloseCircleFilled2 = _interopRequireDefault2(CloseCircleFilled$3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _default3 = _CloseCircleFilled2;
  exports.default = _default3;
  module2.exports = _default3;
})(CloseCircleFilled$4, CloseCircleFilled$4.exports);
var require$$4 = /* @__PURE__ */ getAugmentedNamespace(es);
var context = {};
var _interopRequireWildcard$2 = interopRequireWildcard.exports.default;
var _interopRequireDefault$3 = interopRequireDefault.exports.default;
Object.defineProperty(context, "__esModule", {
  value: true
});
context.NoStyleItemContext = context.NoFormStyle = context.FormProvider = context.FormItemPrefixContext = context.FormItemInputContext = context.FormContext = void 0;
var _rcFieldForm = require$$2$2;
var _omit = _interopRequireDefault$3(omit$1);
var React$2 = _interopRequireWildcard$2(_global_React);
const FormContext = /* @__PURE__ */ React$2.createContext({
  labelAlign: "right",
  vertical: false,
  itemRef: () => {
  }
});
context.FormContext = FormContext;
const NoStyleItemContext = /* @__PURE__ */ React$2.createContext(null);
context.NoStyleItemContext = NoStyleItemContext;
const FormProvider2 = (props) => {
  const providerProps = (0, _omit.default)(props, ["prefixCls"]);
  return /* @__PURE__ */ React$2.createElement(_rcFieldForm.FormProvider, Object.assign({}, providerProps));
};
context.FormProvider = FormProvider2;
const FormItemPrefixContext = /* @__PURE__ */ React$2.createContext({
  prefixCls: ""
});
context.FormItemPrefixContext = FormItemPrefixContext;
const FormItemInputContext = /* @__PURE__ */ React$2.createContext({});
context.FormItemInputContext = FormItemInputContext;
const NoFormStyle = (_ref2) => {
  let {
    children,
    status,
    override
  } = _ref2;
  const formItemInputContext = (0, React$2.useContext)(FormItemInputContext);
  const newFormItemInputContext = (0, React$2.useMemo)(() => {
    const newContext = Object.assign({}, formItemInputContext);
    if (override) {
      delete newContext.isFormItemInput;
    }
    if (status) {
      delete newContext.status;
      delete newContext.hasFeedback;
      delete newContext.feedbackIcon;
    }
    return newContext;
  }, [status, override, formItemInputContext]);
  return /* @__PURE__ */ React$2.createElement(FormItemInputContext.Provider, {
    value: newFormItemInputContext
  }, children);
};
context.NoFormStyle = NoFormStyle;
var statusUtils = {};
var _interopRequireDefault$2 = interopRequireDefault.exports.default;
Object.defineProperty(statusUtils, "__esModule", {
  value: true
});
statusUtils.getMergedStatus = void 0;
statusUtils.getStatusClassNames = getStatusClassNames;
var _classnames$2 = _interopRequireDefault$2(classnames.exports);
function getStatusClassNames(prefixCls, status, hasFeedback) {
  return (0, _classnames$2.default)({
    [`${prefixCls}-status-success`]: status === "success",
    [`${prefixCls}-status-warning`]: status === "warning",
    [`${prefixCls}-status-error`]: status === "error",
    [`${prefixCls}-status-validating`]: status === "validating",
    [`${prefixCls}-has-feedback`]: hasFeedback
  });
}
const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;
statusUtils.getMergedStatus = getMergedStatus;
var useRemovePasswordTimeout$1 = {};
Object.defineProperty(useRemovePasswordTimeout$1, "__esModule", {
  value: true
});
useRemovePasswordTimeout$1.default = useRemovePasswordTimeout;
var _react$1 = _global_React;
function useRemovePasswordTimeout(inputRef, triggerOnMount) {
  const removePasswordTimeoutRef = (0, _react$1.useRef)([]);
  const removePasswordTimeout = () => {
    removePasswordTimeoutRef.current.push(setTimeout(() => {
      var _a2, _b, _c, _d;
      if (((_a2 = inputRef.current) === null || _a2 === void 0 ? void 0 : _a2.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute("value"))) {
        (_d = inputRef.current) === null || _d === void 0 ? void 0 : _d.input.removeAttribute("value");
      }
    }));
  };
  (0, _react$1.useEffect)(() => {
    if (triggerOnMount) {
      removePasswordTimeout();
    }
    return () => removePasswordTimeoutRef.current.forEach((timer) => {
      if (timer) {
        clearTimeout(timer);
      }
    });
  }, []);
  return removePasswordTimeout;
}
var utils = {};
Object.defineProperty(utils, "__esModule", {
  value: true
});
utils.hasPrefixSuffix = hasPrefixSuffix;
function hasPrefixSuffix(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}
var style = {};
Object.defineProperty(style, "__esModule", {
  value: true
});
style.genStatusStyle = style.genPlaceholderStyle = style.genInputSmallStyle = style.genInputGroupStyle = style.genHoverStyle = style.genDisabledStyle = style.genBasicInputStyle = style.genActiveStyle = style.default = void 0;
style.initInputToken = initInputToken;
var _style$1 = style$6;
var _compactItem = compactItem;
var _internal = internal;
const genPlaceholderStyle = (color2) => ({
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color: color2,
    userSelect: "none"
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
});
style.genPlaceholderStyle = genPlaceholderStyle;
const genHoverStyle = (token2) => ({
  borderColor: token2.inputBorderHoverColor,
  borderInlineEndWidth: token2.lineWidth
});
style.genHoverStyle = genHoverStyle;
const genActiveStyle = (token2) => ({
  borderColor: token2.inputBorderHoverColor,
  boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`,
  borderInlineEndWidth: token2.lineWidth,
  outline: 0
});
style.genActiveStyle = genActiveStyle;
const genDisabledStyle = (token2) => ({
  color: token2.colorTextDisabled,
  backgroundColor: token2.colorBgContainerDisabled,
  borderColor: token2.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "&:hover": Object.assign({}, genHoverStyle((0, _internal.mergeToken)(token2, {
    inputBorderHoverColor: token2.colorBorder
  })))
});
style.genDisabledStyle = genDisabledStyle;
const genInputLargeStyle = (token2) => {
  const {
    inputPaddingVerticalLG,
    fontSizeLG,
    lineHeightLG,
    borderRadiusLG,
    inputPaddingHorizontalLG
  } = token2;
  return {
    padding: `${inputPaddingVerticalLG}px ${inputPaddingHorizontalLG}px`,
    fontSize: fontSizeLG,
    lineHeight: lineHeightLG,
    borderRadius: borderRadiusLG
  };
};
const genInputSmallStyle = (token2) => ({
  padding: `${token2.inputPaddingVerticalSM}px ${token2.controlPaddingHorizontalSM - 1}px`,
  borderRadius: token2.borderRadiusSM
});
style.genInputSmallStyle = genInputSmallStyle;
const genStatusStyle = (token2, parentCls) => {
  const {
    componentCls,
    colorError,
    colorWarning,
    colorErrorOutline,
    colorWarningOutline,
    colorErrorBorderHover,
    colorWarningBorderHover
  } = token2;
  return {
    [`&-status-error:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
      borderColor: colorError,
      "&:hover": {
        borderColor: colorErrorBorderHover
      },
      "&:focus, &-focused": Object.assign({}, genActiveStyle((0, _internal.mergeToken)(token2, {
        inputBorderActiveColor: colorError,
        inputBorderHoverColor: colorError,
        controlOutline: colorErrorOutline
      }))),
      [`${componentCls}-prefix, ${componentCls}-suffix`]: {
        color: colorError
      }
    },
    [`&-status-warning:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
      borderColor: colorWarning,
      "&:hover": {
        borderColor: colorWarningBorderHover
      },
      "&:focus, &-focused": Object.assign({}, genActiveStyle((0, _internal.mergeToken)(token2, {
        inputBorderActiveColor: colorWarning,
        inputBorderHoverColor: colorWarning,
        controlOutline: colorWarningOutline
      }))),
      [`${componentCls}-prefix, ${componentCls}-suffix`]: {
        color: colorWarning
      }
    }
  };
};
style.genStatusStyle = genStatusStyle;
const genBasicInputStyle = (token2) => Object.assign(Object.assign({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${token2.inputPaddingVertical}px ${token2.inputPaddingHorizontal}px`,
  color: token2.colorText,
  fontSize: token2.fontSize,
  lineHeight: token2.lineHeight,
  backgroundColor: token2.colorBgContainer,
  backgroundImage: "none",
  borderWidth: token2.lineWidth,
  borderStyle: token2.lineType,
  borderColor: token2.colorBorder,
  borderRadius: token2.borderRadius,
  transition: `all ${token2.motionDurationMid}`
}, genPlaceholderStyle(token2.colorTextPlaceholder)), {
  "&:hover": Object.assign({}, genHoverStyle(token2)),
  "&:focus, &-focused": Object.assign({}, genActiveStyle(token2)),
  "&-disabled, &[disabled]": Object.assign({}, genDisabledStyle(token2)),
  "&-borderless": {
    "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
      backgroundColor: "transparent",
      border: "none",
      boxShadow: "none"
    }
  },
  "textarea&": {
    maxWidth: "100%",
    height: "auto",
    minHeight: token2.controlHeight,
    lineHeight: token2.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${token2.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  "&-lg": Object.assign({}, genInputLargeStyle(token2)),
  "&-sm": Object.assign({}, genInputSmallStyle(token2)),
  "&-rtl": {
    direction: "rtl"
  },
  "&-textarea-rtl": {
    direction: "rtl"
  }
});
style.genBasicInputStyle = genBasicInputStyle;
const genInputGroupStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    [`&[class*='col-']`]: {
      paddingInlineEnd: token2.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token2)),
    [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token2)),
    [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
      height: token2.controlHeightLG
    },
    [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
      height: token2.controlHeightSM
    },
    [`> ${componentCls}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${componentCls}-group`]: {
      [`&-addon, &-wrap`]: {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${token2.inputPaddingHorizontal}px`,
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.fontSize,
        textAlign: "center",
        backgroundColor: token2.colorFillAlter,
        border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
        borderRadius: token2.borderRadius,
        transition: `all ${token2.motionDurationSlow}`,
        lineHeight: 1,
        [`${antCls}-select`]: {
          margin: `-${token2.inputPaddingVertical + 1}px -${token2.inputPaddingHorizontal}px`,
          [`&${antCls}-select-single:not(${antCls}-select-customize-input)`]: {
            [`${antCls}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${token2.lineWidth}px ${token2.lineType} transparent`,
              boxShadow: "none"
            }
          },
          "&-open, &-focused": {
            [`${antCls}-select-selector`]: {
              color: token2.colorPrimary
            }
          }
        },
        [`${antCls}-cascader-picker`]: {
          margin: `-9px -${token2.inputPaddingHorizontal}px`,
          backgroundColor: "transparent",
          [`${antCls}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    },
    [`${componentCls}`]: {
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${componentCls}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      [`${antCls}-select ${antCls}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}-affix-wrapper`]: {
      [`&:not(:first-child) ${componentCls}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${componentCls}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      [`${antCls}-select ${antCls}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${componentCls}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${componentCls}-search &`]: {
          borderStartStartRadius: token2.borderRadius,
          borderEndStartRadius: token2.borderRadius
        }
      },
      [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${componentCls}-group-compact`]: Object.assign(Object.assign({
      display: "block"
    }, (0, _style$1.clearFix)()), {
      [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: token2.lineWidth,
          "&:hover": {
            zIndex: 1
          },
          "&:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-block",
        float: "none",
        verticalAlign: "top",
        borderRadius: 0
      },
      [`& > ${componentCls}-affix-wrapper`]: {
        display: "inline-flex"
      },
      [`& > ${antCls}-picker-range`]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: -token2.lineWidth,
        borderInlineEndWidth: token2.lineWidth
      },
      [`${componentCls}`]: {
        float: "none"
      },
      [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderRadius: 0,
        "&:hover": {
          zIndex: 1
        },
        "&:focus": {
          zIndex: 1
        }
      },
      [`& > ${antCls}-select-focused`]: {
        zIndex: 1
      },
      [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
        zIndex: 1
      },
      [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
        borderStartStartRadius: token2.borderRadius,
        borderEndStartRadius: token2.borderRadius
      },
      [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderStartEndRadius: token2.borderRadius,
        borderEndEndRadius: token2.borderRadius
      },
      [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
        verticalAlign: "top"
      },
      [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
        marginInlineStart: -token2.lineWidth,
        [`${componentCls}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${componentCls}-group-wrapper:not(:last-child)`]: {
        [`&${componentCls}-search > ${componentCls}-group`]: {
          [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${componentCls}`]: {
            borderStartStartRadius: token2.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: token2.borderRadius
          }
        }
      }
    })
  };
};
style.genInputGroupStyle = genInputGroupStyle;
const genInputStyle = (token2) => {
  const {
    componentCls,
    controlHeightSM,
    lineWidth
  } = token2;
  const FIXED_CHROME_COLOR_HEIGHT = 16;
  const colorSmallPadding = (controlHeightSM - lineWidth * 2 - FIXED_CHROME_COLOR_HEIGHT) / 2;
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, (0, _style$1.resetComponent)(token2)), genBasicInputStyle(token2)), genStatusStyle(token2, componentCls)), {
      '&[type="color"]': {
        height: token2.controlHeight,
        [`&${componentCls}-lg`]: {
          height: token2.controlHeightLG
        },
        [`&${componentCls}-sm`]: {
          height: controlHeightSM,
          paddingTop: colorSmallPadding,
          paddingBottom: colorSmallPadding
        }
      },
      '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
        "-webkit-appearance": "none"
      }
    })
  };
};
const genAllowClearStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-clear-icon`]: {
      margin: 0,
      color: token2.colorTextQuaternary,
      fontSize: token2.fontSizeIcon,
      verticalAlign: -1,
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "&:hover": {
        color: token2.colorTextTertiary
      },
      "&:active": {
        color: token2.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${token2.inputAffixPadding}px`
      }
    }
  };
};
const genAffixStyle = (token2) => {
  const {
    componentCls,
    inputAffixPadding,
    colorTextDescription,
    motionDurationSlow,
    colorIcon,
    colorIconHover,
    iconCls
  } = token2;
  return {
    [`${componentCls}-affix-wrapper`]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
      display: "inline-flex",
      [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: Object.assign(Object.assign({}, genHoverStyle(token2)), {
        zIndex: 1,
        [`${componentCls}-search-with-button &`]: {
          zIndex: 0
        }
      }),
      "&-focused, &:focus": {
        zIndex: 1
      },
      "&-disabled": {
        [`${componentCls}[disabled]`]: {
          background: "transparent"
        }
      },
      [`> input${componentCls}`]: {
        padding: 0,
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${componentCls}`]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: token2.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: colorTextDescription
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: token2.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: inputAffixPadding
        },
        "&-suffix": {
          marginInlineStart: inputAffixPadding
        }
      }
    }), genAllowClearStyle(token2)), {
      [`${iconCls}${componentCls}-password-icon`]: {
        color: colorIcon,
        cursor: "pointer",
        transition: `all ${motionDurationSlow}`,
        "&:hover": {
          color: colorIconHover
        }
      }
    }), genStatusStyle(token2, `${componentCls}-affix-wrapper`))
  };
};
const genGroupStyle = (token2) => {
  const {
    componentCls,
    colorError,
    colorWarning,
    borderRadiusLG,
    borderRadiusSM
  } = token2;
  return {
    [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, (0, _style$1.resetComponent)(token2)), genInputGroupStyle(token2)), {
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": {
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        "&-rtl": {
          direction: "rtl"
        },
        "&-lg": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusLG
          }
        },
        "&-sm": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusSM
          }
        },
        "&-status-error": {
          [`${componentCls}-group-addon`]: {
            color: colorError,
            borderColor: colorError
          }
        },
        "&-status-warning": {
          [`${componentCls}-group-addon`]: {
            color: colorWarning,
            borderColor: colorWarning
          }
        },
        "&-disabled": {
          [`${componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token2))
        }
      }
    })
  };
};
const genSearchInputStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  const searchPrefixCls = `${componentCls}-search`;
  return {
    [searchPrefixCls]: {
      [`${componentCls}`]: {
        "&:hover, &:focus": {
          borderColor: token2.colorPrimaryHover,
          [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
            borderInlineStartColor: token2.colorPrimaryHover
          }
        }
      },
      [`${componentCls}-affix-wrapper`]: {
        borderRadius: 0
      },
      [`${componentCls}-lg`]: {
        lineHeight: token2.lineHeightLG - 2e-4
      },
      [`> ${componentCls}-group`]: {
        [`> ${componentCls}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${searchPrefixCls}-button`]: {
            paddingTop: 0,
            paddingBottom: 0,
            borderStartStartRadius: 0,
            borderStartEndRadius: token2.borderRadius,
            borderEndEndRadius: token2.borderRadius,
            borderEndStartRadius: 0
          },
          [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
            color: token2.colorTextDescription,
            "&:hover": {
              color: token2.colorPrimaryHover
            },
            "&:active": {
              color: token2.colorPrimaryActive
            },
            [`&${antCls}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${searchPrefixCls}-button`]: {
        height: token2.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`&-large ${searchPrefixCls}-button`]: {
        height: token2.controlHeightLG
      },
      [`&-small ${searchPrefixCls}-button`]: {
        height: token2.controlHeightSM
      },
      "&-rtl": {
        direction: "rtl"
      },
      [`&${componentCls}-compact-item`]: {
        [`&:not(${componentCls}-compact-last-item)`]: {
          [`${componentCls}-group-addon`]: {
            [`${componentCls}-search-button`]: {
              marginInlineEnd: -token2.lineWidth,
              borderRadius: 0
            }
          }
        },
        [`&:not(${componentCls}-compact-first-item)`]: {
          [`${componentCls},${componentCls}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
          "&:hover,&:focus,&:active": {
            zIndex: 2
          }
        },
        [`> ${componentCls}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
};
function initInputToken(token2) {
  return (0, _internal.mergeToken)(token2, {
    inputAffixPadding: token2.paddingXXS,
    inputPaddingVertical: Math.max(Math.round((token2.controlHeight - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 3),
    inputPaddingVerticalLG: Math.ceil((token2.controlHeightLG - token2.fontSizeLG * token2.lineHeightLG) / 2 * 10) / 10 - token2.lineWidth,
    inputPaddingVerticalSM: Math.max(Math.round((token2.controlHeightSM - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 0),
    inputPaddingHorizontal: token2.paddingSM - token2.lineWidth,
    inputPaddingHorizontalSM: token2.paddingXS - token2.lineWidth,
    inputPaddingHorizontalLG: token2.controlPaddingHorizontal - token2.lineWidth,
    inputBorderHoverColor: token2.colorPrimaryHover,
    inputBorderActiveColor: token2.colorPrimaryHover
  });
}
const genTextAreaStyle = (token2) => {
  const {
    componentCls,
    paddingLG
  } = token2;
  const textareaPrefixCls = `${componentCls}-textarea`;
  return {
    [textareaPrefixCls]: {
      position: "relative",
      "&-show-count": {
        [`> ${componentCls}`]: {
          height: "100%"
        },
        [`${componentCls}-data-count`]: {
          position: "absolute",
          bottom: -token2.fontSize * token2.lineHeight,
          insetInlineEnd: 0,
          color: token2.colorTextDescription,
          whiteSpace: "nowrap",
          pointerEvents: "none"
        }
      },
      [`&-affix-wrapper${textareaPrefixCls}-has-feedback`]: {
        [`${componentCls}`]: {
          paddingInlineEnd: paddingLG
        }
      },
      [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
        padding: 0,
        [`> textarea${componentCls}`]: {
          fontSize: "inherit",
          border: "none",
          outline: "none",
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        [`${componentCls}-suffix`]: {
          margin: 0,
          "> *:not(:last-child)": {
            marginInline: 0
          },
          [`${componentCls}-clear-icon`]: {
            position: "absolute",
            insetInlineEnd: token2.paddingXS,
            insetBlockStart: token2.paddingXS
          },
          [`${textareaPrefixCls}-suffix`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: token2.inputPaddingHorizontal,
            bottom: 0,
            zIndex: 1,
            display: "inline-flex",
            alignItems: "center",
            margin: "auto",
            pointerEvents: "none"
          }
        }
      }
    }
  };
};
var _default$2 = (0, _internal.genComponentStyleHook)("Input", (token2) => {
  const inputToken = initInputToken(token2);
  return [
    genInputStyle(inputToken),
    genTextAreaStyle(inputToken),
    genAffixStyle(inputToken),
    genGroupStyle(inputToken),
    genSearchInputStyle(inputToken),
    (0, _compactItem.genCompactItemStyle)(inputToken)
  ];
});
style.default = _default$2;
var _interopRequireWildcard$1 = interopRequireWildcard.exports.default;
var _interopRequireDefault$1 = interopRequireDefault.exports.default;
Object.defineProperty(Input$1, "__esModule", {
  value: true
});
Input$1.default = void 0;
Input$1.triggerFocus = triggerFocus;
var _CloseCircleFilled = _interopRequireDefault$1(CloseCircleFilled$4.exports);
var _classnames$1 = _interopRequireDefault$1(classnames.exports);
var _rcInput = _interopRequireDefault$1(require$$4);
var _ref$1 = ref;
var _react = _interopRequireWildcard$1(_global_React);
var _configProvider$1 = configProvider;
var _DisabledContext = _interopRequireDefault$1(DisabledContext$1);
var _SizeContext$1 = _interopRequireDefault$1(SizeContext$1);
var _context = context;
var _Compact$1 = Compact$1;
var _statusUtils = statusUtils;
_interopRequireDefault$1(warning$5);
var _useRemovePasswordTimeout = _interopRequireDefault$1(useRemovePasswordTimeout$1);
var _utils = utils;
var _style = _interopRequireDefault$1(style);
var __rest$1 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function triggerFocus(element2, option) {
  if (!element2) {
    return;
  }
  element2.focus(option);
  const {
    cursor: cursor2
  } = option || {};
  if (cursor2) {
    const len = element2.value.length;
    switch (cursor2) {
      case "start":
        element2.setSelectionRange(0, 0);
        break;
      case "end":
        element2.setSelectionRange(len, len);
        break;
      default:
        element2.setSelectionRange(0, len);
        break;
    }
  }
}
const Input2 = /* @__PURE__ */ (0, _react.forwardRef)((props, ref2) => {
  const {
    prefixCls: customizePrefixCls,
    bordered = true,
    status: customStatus,
    size: customSize,
    disabled: customDisabled,
    onBlur,
    onFocus,
    suffix,
    allowClear,
    addonAfter,
    addonBefore,
    className,
    rootClassName,
    onChange,
    classNames: classes
  } = props, rest = __rest$1(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "rootClassName", "onChange", "classNames"]);
  const {
    getPrefixCls,
    direction,
    input
  } = _react.default.useContext(_configProvider$1.ConfigContext);
  const prefixCls = getPrefixCls("input", customizePrefixCls);
  const inputRef = (0, _react.useRef)(null);
  const [wrapSSR, hashId] = (0, _style.default)(prefixCls);
  const {
    compactSize,
    compactItemClassnames
  } = (0, _Compact$1.useCompactItemContext)(prefixCls, direction);
  const size = _react.default.useContext(_SizeContext$1.default);
  const mergedSize = compactSize || customSize || size;
  const disabled = _react.default.useContext(_DisabledContext.default);
  const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = (0, _react.useContext)(_context.FormItemInputContext);
  const mergedStatus = (0, _statusUtils.getMergedStatus)(contextStatus, customStatus);
  const inputHasPrefixSuffix = (0, _utils.hasPrefixSuffix)(props) || !!hasFeedback;
  const prevHasPrefixSuffix = (0, _react.useRef)(inputHasPrefixSuffix);
  (0, _react.useEffect)(() => {
    if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current)
      ;
    prevHasPrefixSuffix.current = inputHasPrefixSuffix;
  }, [inputHasPrefixSuffix]);
  const removePasswordTimeout = (0, _useRemovePasswordTimeout.default)(inputRef, true);
  const handleBlur = (e2) => {
    removePasswordTimeout();
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
  };
  const handleFocus = (e2) => {
    removePasswordTimeout();
    onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
  };
  const handleChange = (e2) => {
    removePasswordTimeout();
    onChange === null || onChange === void 0 ? void 0 : onChange(e2);
  };
  const suffixNode = (hasFeedback || suffix) && /* @__PURE__ */ _react.default.createElement(_react.default.Fragment, null, suffix, hasFeedback && feedbackIcon);
  let mergedAllowClear;
  if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
    mergedAllowClear = allowClear;
  } else if (allowClear) {
    mergedAllowClear = {
      clearIcon: /* @__PURE__ */ _react.default.createElement(_CloseCircleFilled.default, null)
    };
  }
  return wrapSSR(/* @__PURE__ */ _react.default.createElement(_rcInput.default, Object.assign({
    ref: (0, _ref$1.composeRef)(ref2, inputRef),
    prefixCls,
    autoComplete: input === null || input === void 0 ? void 0 : input.autoComplete
  }, rest, {
    disabled: mergedDisabled,
    onBlur: handleBlur,
    onFocus: handleFocus,
    suffix: suffixNode,
    allowClear: mergedAllowClear,
    className: (0, _classnames$1.default)(className, rootClassName, compactItemClassnames),
    onChange: handleChange,
    addonAfter: addonAfter && /* @__PURE__ */ _react.default.createElement(_Compact$1.NoCompactStyle, null, /* @__PURE__ */ _react.default.createElement(_context.NoFormStyle, {
      override: true,
      status: true
    }, addonAfter)),
    addonBefore: addonBefore && /* @__PURE__ */ _react.default.createElement(_Compact$1.NoCompactStyle, null, /* @__PURE__ */ _react.default.createElement(_context.NoFormStyle, {
      override: true,
      status: true
    }, addonBefore)),
    classNames: Object.assign(Object.assign({}, classes), {
      input: (0, _classnames$1.default)({
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-lg`]: mergedSize === "large",
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-borderless`]: !bordered
      }, !inputHasPrefixSuffix && (0, _statusUtils.getStatusClassNames)(prefixCls, mergedStatus), classes === null || classes === void 0 ? void 0 : classes.input, hashId)
    }),
    classes: {
      affixWrapper: (0, _classnames$1.default)({
        [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-affix-wrapper-borderless`]: !bordered
      }, (0, _statusUtils.getStatusClassNames)(`${prefixCls}-affix-wrapper`, mergedStatus, hasFeedback), hashId),
      wrapper: (0, _classnames$1.default)({
        [`${prefixCls}-group-rtl`]: direction === "rtl"
      }, hashId),
      group: (0, _classnames$1.default)({
        [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-group-wrapper-disabled`]: mergedDisabled
      }, (0, _statusUtils.getStatusClassNames)(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
    }
  })));
});
var _default$1 = Input2;
Input$1.default = _default$1;
var _interopRequireWildcard = interopRequireWildcard.exports.default;
var _interopRequireDefault = interopRequireDefault.exports.default;
Object.defineProperty(Search$2, "__esModule", {
  value: true
});
var default_1 = Search$2.default = void 0;
var _SearchOutlined = _interopRequireDefault(SearchOutlined$4.exports);
var _classnames = _interopRequireDefault(classnames.exports);
var _ref = ref;
var React$1 = _interopRequireWildcard(_global_React);
var _button = _interopRequireDefault(button$1);
var _configProvider = configProvider;
var _SizeContext = _interopRequireDefault(SizeContext$1);
var _Compact = Compact$1;
var _reactNode = reactNode;
var _Input = _interopRequireDefault(Input$1);
var __rest = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const Search$1 = /* @__PURE__ */ React$1.forwardRef((props, ref2) => {
  const {
    prefixCls: customizePrefixCls,
    inputPrefixCls: customizeInputPrefixCls,
    className,
    size: customizeSize,
    suffix,
    enterButton = false,
    addonAfter,
    loading,
    disabled,
    onSearch: customOnSearch,
    onChange: customOnChange,
    onCompositionStart,
    onCompositionEnd
  } = props, restProps = __rest(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]);
  const {
    getPrefixCls,
    direction
  } = React$1.useContext(_configProvider.ConfigContext);
  const contextSize = React$1.useContext(_SizeContext.default);
  const composedRef = React$1.useRef(false);
  const prefixCls = getPrefixCls("input-search", customizePrefixCls);
  const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
  const {
    compactSize
  } = (0, _Compact.useCompactItemContext)(prefixCls, direction);
  const size = compactSize || customizeSize || contextSize;
  const inputRef = React$1.useRef(null);
  const onChange = (e2) => {
    if (e2 && e2.target && e2.type === "click" && customOnSearch) {
      customOnSearch(e2.target.value, e2);
    }
    if (customOnChange) {
      customOnChange(e2);
    }
  };
  const onMouseDown = (e2) => {
    var _a2;
    if (document.activeElement === ((_a2 = inputRef.current) === null || _a2 === void 0 ? void 0 : _a2.input)) {
      e2.preventDefault();
    }
  };
  const onSearch = (e2) => {
    var _a2, _b;
    if (customOnSearch) {
      customOnSearch((_b = (_a2 = inputRef.current) === null || _a2 === void 0 ? void 0 : _a2.input) === null || _b === void 0 ? void 0 : _b.value, e2);
    }
  };
  const onPressEnter = (e2) => {
    if (composedRef.current || loading) {
      return;
    }
    onSearch(e2);
  };
  const searchIcon = typeof enterButton === "boolean" ? /* @__PURE__ */ React$1.createElement(_SearchOutlined.default, null) : null;
  const btnClassName = `${prefixCls}-button`;
  let button2;
  const enterButtonAsElement = enterButton || {};
  const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
  if (isAntdButton || enterButtonAsElement.type === "button") {
    button2 = (0, _reactNode.cloneElement)(enterButtonAsElement, Object.assign({
      onMouseDown,
      onClick: (e2) => {
        var _a2, _b;
        (_b = (_a2 = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a2 === void 0 ? void 0 : _a2.onClick) === null || _b === void 0 ? void 0 : _b.call(_a2, e2);
        onSearch(e2);
      },
      key: "enterButton"
    }, isAntdButton ? {
      className: btnClassName,
      size
    } : {}));
  } else {
    button2 = /* @__PURE__ */ React$1.createElement(_button.default, {
      className: btnClassName,
      type: enterButton ? "primary" : void 0,
      size,
      disabled,
      key: "enterButton",
      onMouseDown,
      onClick: onSearch,
      loading,
      icon: searchIcon
    }, enterButton);
  }
  if (addonAfter) {
    button2 = [button2, (0, _reactNode.cloneElement)(addonAfter, {
      key: "addonAfter"
    })];
  }
  const cls = (0, _classnames.default)(prefixCls, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${size}`]: !!size,
    [`${prefixCls}-with-button`]: !!enterButton
  }, className);
  const handleOnCompositionStart = (e2) => {
    composedRef.current = true;
    onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
  };
  const handleOnCompositionEnd = (e2) => {
    composedRef.current = false;
    onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
  };
  return /* @__PURE__ */ React$1.createElement(_Input.default, Object.assign({
    ref: (0, _ref.composeRef)(inputRef, ref2),
    onPressEnter
  }, restProps, {
    size,
    onCompositionStart: handleOnCompositionStart,
    onCompositionEnd: handleOnCompositionEnd,
    prefixCls: inputPrefixCls,
    addonAfter: button2,
    suffix,
    onChange,
    className: cls,
    disabled
  }));
});
var _default2 = Search$1;
default_1 = Search$2.default = _default2;
var Search = styled(default_1)`
  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }
`;
const SearchArea = ({
  onSearch,
  isLoggedIn,
  isFavSelected,
  handleFavButtonClick
}) => {
  const t2 = useT();
  return /* @__PURE__ */ React.createElement(StyledSpace, {
    size: 16
  }, /* @__PURE__ */ React.createElement(StyledSearch, {
    placeholder: t2("search text"),
    allowClear: true,
    onSearch
  }), isLoggedIn && /* @__PURE__ */ React.createElement(StyledButton, {
    isFavSelected,
    onClick: () => handleFavButtonClick(!isFavSelected)
  }, t2("Liked"), /* @__PURE__ */ React.createElement(Icon$4, {
    icon: "heartOutlined"
  })));
};
const StyledSpace = styled(Space$1)`
  width: 100%;
  padding-bottom: 24px;
`;
const StyledSearch = styled(Search)`
  width: 432px;

  * {
    color: ${({ theme: theme2 }) => theme2.main.weakText};
    background: transparent;
  }

  :hover {
    background: transparent;
  }

  .ant-input-affix-wrapper,
  .ant-input-search-button {
    border: 1px solid ${({ theme: theme2 }) => theme2.main.weakText};
    background: transparent;
  }
`;
const StyledButton = styled(Button$2, {
  shouldForwardProp: (propName) => propName !== "isFavSelected"
})`
  font-weight: bold;
  background: transparent;
  color: ${({ theme: theme2, isFavSelected }) => isFavSelected ? "#1677ff" : theme2.main.weakText};
  border: 1px solid
    ${({ theme: theme2, isFavSelected }) => isFavSelected ? "#1677ff" : theme2.main.weakText};
  border-radius: 8px;

  :hover {
    background: transparent;
  }

  :focus {
    ${({ theme: theme2, isFavSelected }) => !isFavSelected && `border: 1px solid ${theme2.main.weakText};`}
    ${({ theme: theme2, isFavSelected }) => !isFavSelected && `color: ${theme2.main.weakText};`}
    background: transparent;
  }
`;
const TopPageContents = ({
  plugins: plugins2,
  isLoggedIn,
  isFavSelected,
  totalCount,
  page,
  loadingPlugins,
  pageSize,
  onSearch,
  handleFavButtonClick,
  onPluginSelect,
  onPageChange
}) => {
  return /* @__PURE__ */ React.createElement(Wrapper$1, null, /* @__PURE__ */ React.createElement(SearchArea, {
    onSearch,
    isLoggedIn,
    handleFavButtonClick,
    isFavSelected
  }), !loadingPlugins ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(PluginsList, {
    plugins: plugins2,
    onPluginSelect
  }), /* @__PURE__ */ React.createElement(Pagination$1, {
    current: page,
    total: totalCount,
    pageSize,
    onChange: onPageChange
  })) : /* @__PURE__ */ React.createElement(Loading, {
    height: 400
  }));
};
const Wrapper$1 = styled.div`
  max-width: 1200px;
  margin: 0 auto;
  padding-bottom: 72px;
  background: transparent;
`;
const TopPage = ({
  plugins: plugins2,
  showBanner,
  isLoggedIn,
  isFavSelected,
  onSearch,
  handleFavButtonClick,
  onPluginSelect,
  totalCount,
  page,
  onPageChange,
  loadingPlugins,
  pageSize
}) => {
  return /* @__PURE__ */ React.createElement(Wrapper, null, showBanner && /* @__PURE__ */ React.createElement(TitleBar, null), /* @__PURE__ */ React.createElement(TopPageContents, {
    plugins: plugins2,
    onSearch,
    isLoggedIn,
    isFavSelected,
    handleFavButtonClick,
    onPluginSelect,
    totalCount,
    page,
    onPageChange,
    loadingPlugins,
    pageSize
  }));
};
const Wrapper = styled.div`
  background: ${({ theme: theme2 }) => theme2.main.background};
`;
var useHooks = (pageSize, searchText, sort, liked, accessToken) => {
  var _a2;
  const [page, setPage] = React.useState(1);
  const { isAuthenticated } = useAuth(accessToken);
  const gqlCache = useApolloClient().cache;
  const { data: data2, loading: loadingPlugins } = useSearchPluginQuery({
    variables: {
      first: pageSize,
      offset: (page - 1) * pageSize,
      keyword: searchText,
      liked: liked || void 0,
      sort
    }
  });
  const plugins2 = React.useMemo(
    () => data2 == null ? void 0 : data2.plugins.nodes.map(
      (p2) => p2 ? {
        id: p2.id,
        name: p2.name,
        cover: p2.images[0],
        publisher: p2.publisher.displayName || p2.publisher.name,
        like: p2.like,
        liked: p2.liked,
        downloads: p2.downloads
      } : void 0
    ).filter((p2) => !!p2),
    [data2 == null ? void 0 : data2.plugins]
  );
  React.useEffect(() => {
    return () => {
      gqlCache.evict({ fieldName: "plugins" });
    };
  }, [gqlCache]);
  return {
    plugins: plugins2,
    isAuthenticated,
    page,
    totalCount: (_a2 = data2 == null ? void 0 : data2.plugins.totalCount) != null ? _a2 : 0,
    handlePageChange: setPage,
    loadingPlugins
  };
};
const Top = ({ showBanner, accessToken, onPluginSelect }) => {
  const [searchText, updateSearchText] = React.useState("");
  const [isFavSelected, toggleLiked] = React.useState(false);
  const pageSize = 40;
  const { plugins: plugins2, isAuthenticated, totalCount, page, handlePageChange, loadingPlugins } = useHooks(
    pageSize,
    searchText,
    void 0,
    isFavSelected,
    accessToken
  );
  const handleSearch = React.useCallback(
    (text2) => {
      updateSearchText(text2);
      handlePageChange(1);
    },
    [updateSearchText, handlePageChange]
  );
  const handleFavButtonClick = React.useCallback(
    (isFaved) => {
      toggleLiked(isFaved);
      handlePageChange(1);
    },
    [toggleLiked, handlePageChange]
  );
  return /* @__PURE__ */ React.createElement(TopPage, {
    plugins: plugins2,
    showBanner,
    onSearch: handleSearch,
    isLoggedIn: isAuthenticated,
    handleFavButtonClick,
    isFavSelected,
    onPluginSelect,
    totalCount,
    page,
    onPageChange: handlePageChange,
    loadingPlugins,
    pageSize
  });
};
function LibraryExtension({
  theme: theme2,
  lang,
  accessToken,
  installedPlugins,
  onInstall,
  onNotificationChange
}) {
  const t2 = useT();
  const handleInstall = React.useCallback(
    (id) => {
      onInstall == null ? void 0 : onInstall(id);
      onNotificationChange == null ? void 0 : onNotificationChange("success", t2("Your plugin was successfully updated!"), t2("Success"));
    },
    [t2, onInstall, onNotificationChange]
  );
  const [pluginId, setPluginId] = React.useState();
  React.useLayoutEffect(() => {
    const params = new URLSearchParams(location.search);
    const pluginId2 = params.get("pluginId");
    if (pluginId2) {
      setPluginId(pluginId2);
    }
  }, []);
  const handlePluginSelect = React.useCallback((pluginId2) => {
    setPluginId(pluginId2);
  }, []);
  const handleBack = React.useCallback(() => {
    setPluginId("");
  }, []);
  return /* @__PURE__ */ React.createElement(SharedProviders, {
    accessToken,
    lang,
    theme: theme2
  }, /* @__PURE__ */ React.createElement(CoreWrapper, null, pluginId && /* @__PURE__ */ React.createElement(PluginDetail, {
    pluginId,
    accessToken,
    installedPlugins,
    onPluginInstall: handleInstall,
    onBack: handleBack
  }), !pluginId && /* @__PURE__ */ React.createElement(Top, {
    accessToken,
    onPluginSelect: handlePluginSelect
  })));
}
var extension = [
  {
    type: "plugin-library",
    id: "marketplace-library",
    component: LibraryExtension
  },
  {
    type: "plugin-installed",
    id: "marketplace-installed",
    component: PluginInstalledList
  }
];
export { extension as default };
